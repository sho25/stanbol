begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|core
operator|.
name|scope
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Dictionary
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Activate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Component
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Deactivate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Property
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|PropertyOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Reference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|ReferenceCardinality
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|ReferencePolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|ReferenceStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Service
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|owl
operator|.
name|OWLOntologyManagerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|stanboltools
operator|.
name|offline
operator|.
name|OfflineMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|ontonet
operator|.
name|api
operator|.
name|ONManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|servicesapi
operator|.
name|OfflineConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|servicesapi
operator|.
name|OntologyNetworkConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|servicesapi
operator|.
name|collector
operator|.
name|DuplicateIDException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|servicesapi
operator|.
name|collector
operator|.
name|MissingOntologyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|servicesapi
operator|.
name|collector
operator|.
name|UnmodifiableOntologyCollectorException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|servicesapi
operator|.
name|io
operator|.
name|OntologyInputSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|servicesapi
operator|.
name|io
operator|.
name|StoredOntologySource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|servicesapi
operator|.
name|ontology
operator|.
name|Multiplexer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|servicesapi
operator|.
name|ontology
operator|.
name|OntologyProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|servicesapi
operator|.
name|scope
operator|.
name|NoSuchScopeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|servicesapi
operator|.
name|scope
operator|.
name|OntologySpace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|servicesapi
operator|.
name|scope
operator|.
name|PersistentCollectorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|servicesapi
operator|.
name|scope
operator|.
name|Scope
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|servicesapi
operator|.
name|scope
operator|.
name|ScopeManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|servicesapi
operator|.
name|scope
operator|.
name|ScopeRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|servicesapi
operator|.
name|util
operator|.
name|OntologyNetworkConfigurationUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|sources
operator|.
name|owlapi
operator|.
name|BlankOntologySource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|sources
operator|.
name|owlapi
operator|.
name|RootOntologyIRISource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|service
operator|.
name|component
operator|.
name|ComponentContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|io
operator|.
name|FileDocumentSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|io
operator|.
name|IRIDocumentSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|io
operator|.
name|OWLOntologyDocumentSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|io
operator|.
name|StreamDocumentSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|IRI
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLOntology
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLOntologyCreationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLOntologyID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLOntologyManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * The running context of a Stanbol Ontology Network Manager instance. From this object it is possible to  * obtain factories, indices, registries and what have you.  *   * @see ScopeManager  *   */
end_comment

begin_class
annotation|@
name|Component
argument_list|(
name|immediate
operator|=
literal|true
argument_list|,
name|metatype
operator|=
literal|true
argument_list|)
annotation|@
name|Service
argument_list|(
block|{
name|ScopeRegistry
operator|.
name|class
block|,
name|ScopeManager
operator|.
name|class
block|,
name|ONManager
operator|.
name|class
block|}
argument_list|)
specifier|public
class|class
name|ScopeManagerImpl
extends|extends
name|ScopeRegistryImpl
implements|implements
name|ONManager
block|{
specifier|public
specifier|static
specifier|final
name|String
name|_CONFIG_ONTOLOGY_PATH_DEFAULT
init|=
literal|""
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|_CONNECTIVITY_POLICY_DEFAULT
init|=
literal|"TIGHT"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|_ID_SCOPE_REGISTRY_DEFAULT
init|=
literal|"ontology"
decl_stmt|;
comment|/**      * The singleton instance of {@link ScopeManagerImpl}.      */
specifier|private
specifier|static
name|ScopeManagerImpl
name|me
init|=
literal|null
decl_stmt|;
comment|/**      * Returns the instance of {@link ScopeManagerImpl} that was activated most recently. It can be used for      * referencing this component from an object that is not an OSGi component (for instance, if making it a      * component would introduce an activation cycle).      *       * @return the singleton instance of {@link ScopeManagerImpl}.      */
specifier|public
specifier|static
name|ScopeManagerImpl
name|get
parameter_list|()
block|{
return|return
name|me
return|;
block|}
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|ScopeManager
operator|.
name|CONFIG_ONTOLOGY_PATH
argument_list|,
name|value
operator|=
name|_CONFIG_ONTOLOGY_PATH_DEFAULT
argument_list|)
specifier|private
name|String
name|configPath
decl_stmt|;
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|ScopeManager
operator|.
name|CONNECTIVITY_POLICY
argument_list|,
name|options
operator|=
block|{
annotation|@
name|PropertyOption
argument_list|(
name|value
operator|=
literal|'%'
operator|+
name|ScopeManager
operator|.
name|CONNECTIVITY_POLICY
operator|+
literal|".option.tight"
argument_list|,
name|name
operator|=
literal|"TIGHT"
argument_list|)
block|,
annotation|@
name|PropertyOption
argument_list|(
name|value
operator|=
literal|'%'
operator|+
name|ScopeManager
operator|.
name|CONNECTIVITY_POLICY
operator|+
literal|".option.loose"
argument_list|,
name|name
operator|=
literal|"LOOSE"
argument_list|)
block|}
argument_list|,
name|value
operator|=
name|_CONNECTIVITY_POLICY_DEFAULT
argument_list|)
specifier|private
name|String
name|connectivityPolicyString
decl_stmt|;
annotation|@
name|Reference
specifier|private
name|PersistentCollectorFactory
name|factory
decl_stmt|;
specifier|private
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|getClass
argument_list|()
argument_list|)
decl_stmt|;
annotation|@
name|Reference
specifier|private
name|OfflineConfiguration
name|offline
decl_stmt|;
comment|/**      * The {@link OfflineMode} is used by Stanbol to indicate that no external service should be referenced.      * For this engine that means it is necessary to check if the used {@link ReferencedSite} can operate      * offline or not.      *       * @see #enableOfflineMode(OfflineMode)      * @see #disableOfflineMode(OfflineMode)      */
annotation|@
name|Reference
argument_list|(
name|cardinality
operator|=
name|ReferenceCardinality
operator|.
name|OPTIONAL_UNARY
argument_list|,
name|policy
operator|=
name|ReferencePolicy
operator|.
name|DYNAMIC
argument_list|,
name|bind
operator|=
literal|"enableOfflineMode"
argument_list|,
name|unbind
operator|=
literal|"disableOfflineMode"
argument_list|,
name|strategy
operator|=
name|ReferenceStrategy
operator|.
name|EVENT
argument_list|)
specifier|private
name|OfflineMode
name|offlineMode
decl_stmt|;
annotation|@
name|Reference
specifier|private
name|OntologyProvider
argument_list|<
name|?
argument_list|>
name|ontologyProvider
decl_stmt|;
specifier|private
name|IRI
name|ontonetNS
init|=
literal|null
decl_stmt|;
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|ScopeManager
operator|.
name|ID_SCOPE_REGISTRY
argument_list|,
name|value
operator|=
name|_ID_SCOPE_REGISTRY_DEFAULT
argument_list|)
specifier|private
name|String
name|scopeRegistryId
decl_stmt|;
comment|/*      * The identifiers (not yet parsed as IRIs) of the ontology scopes that should be activated.      */
specifier|private
name|String
index|[]
name|toActivate
init|=
operator|new
name|String
index|[]
block|{}
decl_stmt|;
comment|/**      * This default constructor is<b>only</b> intended to be used by the OSGI environment with Service      * Component Runtime support.      *<p>      * DO NOT USE to manually create instances - the ONManagerImpl instances do need to be configured! YOU      * NEED TO USE      * {@link #ONManagerImpl(OntologyProvider, OfflineConfiguration, PersistentCollectorFactory, Dictionary)}      * or its overloads, to parse the configuration and then initialise the rule store if running outside an      * OSGI environment.      */
specifier|public
name|ScopeManagerImpl
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
comment|// All bindings are deferred to the activator
block|}
comment|/**      * Used to instantiate an ONManagerImpl outside of an OSGi environment.      *       * @param ontologyProvider      *            the ontology provider that will be used for storing ontologies.      * @param offline      *            the offline configuration      * @param spaceFactory      *            the factory implementation to be used for creating ontology spaces      * @param configuration      *            the configuration of this ONManagerImpl      */
specifier|public
name|ScopeManagerImpl
parameter_list|(
name|OntologyProvider
argument_list|<
name|?
argument_list|>
name|ontologyProvider
parameter_list|,
name|OfflineConfiguration
name|offline
parameter_list|,
name|PersistentCollectorFactory
name|factory
parameter_list|,
name|Dictionary
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|configuration
parameter_list|)
block|{
name|this
argument_list|()
expr_stmt|;
name|this
operator|.
name|ontologyProvider
operator|=
name|ontologyProvider
expr_stmt|;
name|this
operator|.
name|factory
operator|=
name|factory
expr_stmt|;
name|this
operator|.
name|offline
operator|=
name|offline
expr_stmt|;
try|try
block|{
name|activate
argument_list|(
name|configuration
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Unable to access servlet context."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Used to configure an instance within an OSGi container.      *       * @throws IOException      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Activate
specifier|protected
name|void
name|activate
parameter_list|(
name|ComponentContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|log
operator|.
name|info
argument_list|(
literal|"in "
operator|+
name|ScopeManagerImpl
operator|.
name|class
operator|+
literal|" activate with context "
operator|+
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"No valid"
operator|+
name|ComponentContext
operator|.
name|class
operator|+
literal|" parsed in activate!"
argument_list|)
throw|;
block|}
name|activate
argument_list|(
operator|(
name|Dictionary
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
operator|)
name|context
operator|.
name|getProperties
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Called within both OSGi and non-OSGi environments.      *       * @param configuration      * @throws IOException      */
specifier|protected
name|void
name|activate
parameter_list|(
name|Dictionary
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|configuration
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|before
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|me
operator|=
name|this
expr_stmt|;
comment|// Assign singleton instance
comment|// Parse configuration
if|if
condition|(
name|offline
operator|!=
literal|null
condition|)
name|ontonetNS
operator|=
name|offline
operator|.
name|getDefaultOntologyNetworkNamespace
argument_list|()
expr_stmt|;
name|scopeRegistryId
operator|=
operator|(
name|String
operator|)
name|configuration
operator|.
name|get
argument_list|(
name|ScopeManager
operator|.
name|ID_SCOPE_REGISTRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|scopeRegistryId
operator|==
literal|null
condition|)
name|scopeRegistryId
operator|=
name|_ID_SCOPE_REGISTRY_DEFAULT
expr_stmt|;
name|configPath
operator|=
operator|(
name|String
operator|)
name|configuration
operator|.
name|get
argument_list|(
name|ScopeManager
operator|.
name|CONFIG_ONTOLOGY_PATH
argument_list|)
expr_stmt|;
if|if
condition|(
name|configPath
operator|==
literal|null
condition|)
name|configPath
operator|=
name|_CONFIG_ONTOLOGY_PATH_DEFAULT
expr_stmt|;
comment|// Bind components, starting with the local directories.
name|List
argument_list|<
name|String
argument_list|>
name|dirs
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
for|for
control|(
name|IRI
name|iri
range|:
name|offline
operator|.
name|getOntologySourceLocations
argument_list|()
control|)
name|dirs
operator|.
name|add
argument_list|(
name|iri
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|ex
parameter_list|)
block|{
comment|// Ok, go empty
block|}
name|bindResources
argument_list|()
expr_stmt|;
comment|// String tfile = (String) configuration.get(CONFIG_FILE_PATH);
comment|// if (tfile != null) this.configPath = tfile;
comment|// String tns = (String) configuration.get(KRES_NAMESPACE);
comment|// if (tns != null) this.kresNs = tns;
comment|// configPath = (String) configuration.get(CONFIG_FILE_PATH);
comment|// If there is no configuration file, just start with an empty scope set
name|Object
name|connectivityPolicy
init|=
name|configuration
operator|.
name|get
argument_list|(
name|ScopeManager
operator|.
name|CONNECTIVITY_POLICY
argument_list|)
decl_stmt|;
if|if
condition|(
name|connectivityPolicy
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|connectivityPolicyString
operator|=
name|_CONNECTIVITY_POLICY_DEFAULT
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|connectivityPolicyString
operator|=
name|connectivityPolicy
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
name|String
name|configPath
init|=
name|getOntologyNetworkConfigurationPath
argument_list|()
decl_stmt|;
if|if
condition|(
name|configPath
operator|!=
literal|null
operator|&&
operator|!
name|configPath
operator|.
name|trim
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|OWLOntology
name|oConf
init|=
literal|null
decl_stmt|;
name|OWLOntologyManager
name|tempMgr
init|=
name|OWLOntologyManagerFactory
operator|.
name|createOWLOntologyManager
argument_list|(
name|offline
operator|.
name|getOntologySourceLocations
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|IRI
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|OWLOntologyDocumentSource
name|oConfSrc
init|=
literal|null
decl_stmt|;
try|try
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Try to load the configuration ontology from a local bundle relative path"
argument_list|)
expr_stmt|;
name|InputStream
name|is
init|=
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getResourceAsStream
argument_list|(
name|configPath
argument_list|)
decl_stmt|;
name|oConfSrc
operator|=
operator|new
name|StreamDocumentSource
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e1
parameter_list|)
block|{
try|try
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Cannot load from a local bundle relative path"
argument_list|,
name|e1
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Try to load the configuration ontology resolving the given IRI"
argument_list|)
expr_stmt|;
name|IRI
name|iri
init|=
name|IRI
operator|.
name|create
argument_list|(
name|configPath
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|iri
operator|.
name|isAbsolute
argument_list|()
condition|)
throw|throw
operator|new
name|Exception
argument_list|(
literal|"IRI seems to be not absolute! value was: "
operator|+
name|iri
operator|.
name|toQuotedString
argument_list|()
argument_list|)
throw|;
name|oConfSrc
operator|=
operator|new
name|IRIDocumentSource
argument_list|(
name|iri
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
try|try
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Cannot load from the web"
argument_list|,
name|e1
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Try to load the configuration ontology as full local file path"
argument_list|)
expr_stmt|;
name|oConfSrc
operator|=
operator|new
name|FileDocumentSource
argument_list|(
operator|new
name|File
argument_list|(
name|configPath
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e2
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Cannot load the configuration ontology from parameter value: "
operator|+
name|configPath
argument_list|,
name|e2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|oConfSrc
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"No ONM configuration file found at path "
operator|+
name|configPath
operator|+
literal|". Starting with blank scope set."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|oConf
operator|=
name|tempMgr
operator|.
name|loadOntologyFromOntologyDocument
argument_list|(
name|oConfSrc
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OWLOntologyCreationException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Cannot create the configuration ontology"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Create and populate the scopes from the config ontology.
name|bootstrapOntologyNetwork
argument_list|(
name|oConf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// No ontology supplied. Access the local graph
name|rebuildScopes
argument_list|()
expr_stmt|;
block|}
name|log
operator|.
name|debug
argument_list|(
name|ScopeManager
operator|.
name|class
operator|+
literal|" activated. Time : {} ms."
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|before
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|bindResources
parameter_list|()
block|{
comment|// if (ontologySpaceFactory == null) {
comment|// if (ontologyProvider.getStore() instanceof TcProvider) ontologySpaceFactory = new
comment|// ClerezzaOntologySpaceFactory(
comment|// (OntologyProvider<TcProvider>) ontologyProvider, new Hashtable<String,Object>());
comment|// }
name|IRI
name|iri
init|=
name|IRI
operator|.
name|create
argument_list|(
name|ontonetNS
operator|+
name|scopeRegistryId
operator|+
literal|"/"
argument_list|)
decl_stmt|;
name|factory
operator|.
name|setDefaultNamespace
argument_list|(
name|iri
argument_list|)
expr_stmt|;
comment|// Add listeners
comment|// if (ontologyProvider instanceof ScopeEventListener) factory
comment|// .addScopeEventListener((ScopeEventListener) ontologyProvider);
name|Multiplexer
name|multiplexer
init|=
name|ontologyProvider
operator|.
name|getOntologyNetworkDescriptor
argument_list|()
decl_stmt|;
name|this
operator|.
name|addScopeRegistrationListener
argument_list|(
name|multiplexer
argument_list|)
expr_stmt|;
name|factory
operator|.
name|addScopeEventListener
argument_list|(
name|multiplexer
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|bootstrapOntologyNetwork
parameter_list|(
name|OWLOntology
name|configOntology
parameter_list|)
block|{
if|if
condition|(
name|configOntology
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Ontology Network Manager starting with empty scope set."
argument_list|)
expr_stmt|;
return|return;
block|}
try|try
block|{
comment|/**              * We create and register the scopes before activating              */
for|for
control|(
name|String
name|scopeId
range|:
name|OntologyNetworkConfigurationUtils
operator|.
name|getScopes
argument_list|(
name|configOntology
argument_list|)
control|)
block|{
name|String
index|[]
name|cores
init|=
name|OntologyNetworkConfigurationUtils
operator|.
name|getCoreOntologies
argument_list|(
name|configOntology
argument_list|,
name|scopeId
argument_list|)
decl_stmt|;
name|String
index|[]
name|customs
init|=
name|OntologyNetworkConfigurationUtils
operator|.
name|getCustomOntologies
argument_list|(
name|configOntology
argument_list|,
name|scopeId
argument_list|)
decl_stmt|;
comment|// "Be a man. Use printf"
name|log
operator|.
name|debug
argument_list|(
literal|"Detected scope \"{}\""
argument_list|,
name|scopeId
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|cores
control|)
name|log
operator|.
name|debug
argument_list|(
literal|"\tDetected core ontology {}"
argument_list|,
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|customs
control|)
name|log
operator|.
name|debug
argument_list|(
literal|"\tDetected custom ontology {}"
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|// Create the scope
name|log
operator|.
name|debug
argument_list|(
literal|"Rebuilding scope \"{}\""
argument_list|,
name|scopeId
argument_list|)
expr_stmt|;
name|Scope
name|sc
init|=
literal|null
decl_stmt|;
name|sc
operator|=
comment|/* factory. */
name|createOntologyScope
argument_list|(
name|scopeId
argument_list|,
operator|new
name|BlankOntologySource
argument_list|()
argument_list|)
expr_stmt|;
comment|// Populate the core space
if|if
condition|(
name|cores
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|OntologySpace
name|corespc
init|=
name|sc
operator|.
name|getCoreSpace
argument_list|()
decl_stmt|;
name|corespc
operator|.
name|tearDown
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cores
operator|.
name|length
condition|;
name|i
operator|++
control|)
try|try
block|{
name|corespc
operator|.
name|addOntology
argument_list|(
operator|new
name|RootOntologyIRISource
argument_list|(
name|IRI
operator|.
name|create
argument_list|(
name|cores
index|[
name|i
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Failed to import ontology "
operator|+
name|cores
index|[
name|i
index|]
argument_list|,
name|ex
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|sc
operator|.
name|setUp
argument_list|()
expr_stmt|;
name|registerScope
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|.
name|getCustomSpace
argument_list|()
operator|.
name|tearDown
argument_list|()
expr_stmt|;
for|for
control|(
name|String
name|locationIri
range|:
name|customs
control|)
block|{
try|try
block|{
name|OntologyInputSource
argument_list|<
name|?
argument_list|>
name|src
init|=
operator|new
name|RootOntologyIRISource
argument_list|(
name|IRI
operator|.
name|create
argument_list|(
name|locationIri
argument_list|)
argument_list|)
decl_stmt|;
name|sc
operator|.
name|getCustomSpace
argument_list|()
operator|.
name|addOntology
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Added ontology from location {}"
argument_list|,
name|locationIri
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnmodifiableOntologyCollectorException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"An error occurred while trying to add the ontology from location: "
operator|+
name|locationIri
argument_list|,
name|e
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|sc
operator|.
name|getCustomSpace
argument_list|()
operator|.
name|setUp
argument_list|()
expr_stmt|;
block|}
comment|/**              * Try to get activation policies              */
name|toActivate
operator|=
name|OntologyNetworkConfigurationUtils
operator|.
name|getScopesToActivate
argument_list|(
name|configOntology
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|scopeID
range|:
name|toActivate
control|)
block|{
try|try
block|{
name|scopeID
operator|=
name|scopeID
operator|.
name|trim
argument_list|()
expr_stmt|;
name|setScopeActive
argument_list|(
name|scopeID
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Ontology scope "
operator|+
name|scopeID
operator|+
literal|" activated."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchScopeException
name|ex
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Tried to activate unavailable scope "
operator|+
name|scopeID
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Exception caught while activating scope "
operator|+
name|scopeID
operator|+
literal|" . Skipping."
argument_list|,
name|ex
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Invalid ONM configuration file found. "
operator|+
literal|"Starting with blank scope set."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|configureScope
parameter_list|(
name|Scope
name|scope
parameter_list|)
throws|throws
name|DuplicateIDException
block|{
if|if
condition|(
name|scope
operator|.
name|getCustomSpace
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|OntologySpace
operator|.
name|ConnectivityPolicy
name|policy
decl_stmt|;
try|try
block|{
name|policy
operator|=
name|OntologySpace
operator|.
name|ConnectivityPolicy
operator|.
name|valueOf
argument_list|(
name|connectivityPolicyString
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"The value {}"
argument_list|,
name|connectivityPolicyString
argument_list|)
expr_stmt|;
name|log
operator|.
name|warn
argument_list|(
literal|" -- configured as default ConnectivityPolicy does not match any value of the Enumeration!"
argument_list|)
expr_stmt|;
name|log
operator|.
name|warn
argument_list|(
literal|" -- Setting the default policy as defined by the {}."
argument_list|,
name|OntologySpace
operator|.
name|ConnectivityPolicy
operator|.
name|class
argument_list|)
expr_stmt|;
name|policy
operator|=
name|OntologySpace
operator|.
name|ConnectivityPolicy
operator|.
name|valueOf
argument_list|(
name|_CONNECTIVITY_POLICY_DEFAULT
argument_list|)
expr_stmt|;
block|}
name|scope
operator|.
name|getCustomSpace
argument_list|()
operator|.
name|setConnectivityPolicy
argument_list|(
name|policy
argument_list|)
expr_stmt|;
block|}
comment|// Commented out: for the time being we try not to propagate additions to scopes.
comment|// if (ontologyProvider instanceof OntologyCollectorListener) scope
comment|// .addOntologyCollectorListener((OntologyCollectorListener) ontologyProvider);
comment|// fireScopeCreated(scope);
name|this
operator|.
name|registerScope
argument_list|(
name|scope
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Scope
name|createOntologyScope
parameter_list|(
name|String
name|scopeID
parameter_list|,
name|OntologyInputSource
argument_list|<
name|?
argument_list|>
modifier|...
name|coreOntologies
parameter_list|)
throws|throws
name|DuplicateIDException
block|{
name|Scope
name|sc
init|=
name|factory
operator|.
name|createOntologyScope
argument_list|(
name|scopeID
argument_list|,
name|coreOntologies
argument_list|)
decl_stmt|;
name|configureScope
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|sc
return|;
block|}
comment|/**      * Deactivation of the ONManagerImpl resets all its resources.      */
annotation|@
name|Deactivate
specifier|protected
name|void
name|deactivate
parameter_list|(
name|ComponentContext
name|context
parameter_list|)
block|{
name|ontonetNS
operator|=
literal|null
expr_stmt|;
name|configPath
operator|=
literal|null
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"in "
operator|+
name|ScopeManagerImpl
operator|.
name|class
operator|+
literal|" deactivate with context "
operator|+
name|context
argument_list|)
expr_stmt|;
block|}
comment|/**      * Called by the ConfigurationAdmin to unbind the {@link #offlineMode} if the service becomes unavailable      *       * @param mode      */
specifier|protected
specifier|final
name|void
name|disableOfflineMode
parameter_list|(
name|OfflineMode
name|mode
parameter_list|)
block|{
name|this
operator|.
name|offlineMode
operator|=
literal|null
expr_stmt|;
block|}
comment|/**      * Called by the ConfigurationAdmin to bind the {@link #offlineMode} if the service becomes available      *       * @param mode      */
specifier|protected
specifier|final
name|void
name|enableOfflineMode
parameter_list|(
name|OfflineMode
name|mode
parameter_list|)
block|{
name|this
operator|.
name|offlineMode
operator|=
name|mode
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|OfflineConfiguration
name|getOfflineConfiguration
parameter_list|()
block|{
return|return
name|offline
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getOntologyNetworkConfigurationPath
parameter_list|()
block|{
return|return
name|configPath
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getOntologyNetworkNamespace
parameter_list|()
block|{
return|return
name|ontonetNS
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Returns the ontology space factory that was created along with the manager context.      *       * @return the ontology space factory      */
annotation|@
name|Override
specifier|public
name|PersistentCollectorFactory
name|getPersistentCollectorFactory
parameter_list|()
block|{
return|return
name|factory
return|;
block|}
annotation|@
name|Override
specifier|public
name|ScopeRegistry
name|getScopeRegistry
parameter_list|()
block|{
return|return
name|this
return|;
block|}
comment|/**      * Returns<code>true</code> only if Stanbol operates in {@link OfflineMode}.      *       * @return the offline state      */
specifier|protected
specifier|final
name|boolean
name|isOfflineMode
parameter_list|()
block|{
return|return
name|offlineMode
operator|!=
literal|null
return|;
block|}
specifier|private
name|void
name|rebuildScopes
parameter_list|()
block|{
name|OntologyNetworkConfiguration
name|struct
init|=
name|ontologyProvider
operator|.
name|getOntologyNetworkConfiguration
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|scopeId
range|:
name|struct
operator|.
name|getScopeIDs
argument_list|()
control|)
block|{
name|long
name|before
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Rebuilding scope with ID \"{}\"."
argument_list|,
name|scopeId
argument_list|)
expr_stmt|;
name|Collection
argument_list|<
name|OWLOntologyID
argument_list|>
name|coreOnts
init|=
name|struct
operator|.
name|getCoreOntologyKeysForScope
argument_list|(
name|scopeId
argument_list|)
decl_stmt|;
name|OntologyInputSource
argument_list|<
name|?
argument_list|>
index|[]
name|srcs
init|=
operator|new
name|OntologyInputSource
argument_list|<
name|?
argument_list|>
index|[
name|coreOnts
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|OWLOntologyID
name|coreOnt
range|:
name|coreOnts
control|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Core ontology key : {}"
argument_list|,
name|coreOnts
argument_list|)
expr_stmt|;
name|srcs
index|[
name|i
operator|++
index|]
operator|=
operator|new
name|StoredOntologySource
argument_list|(
name|coreOnt
argument_list|)
expr_stmt|;
block|}
name|Scope
name|scope
decl_stmt|;
try|try
block|{
name|scope
operator|=
name|createOntologyScope
argument_list|(
name|scopeId
argument_list|,
name|srcs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DuplicateIDException
name|e
parameter_list|)
block|{
name|String
name|dupe
init|=
name|e
operator|.
name|getDuplicateID
argument_list|()
decl_stmt|;
name|log
operator|.
name|warn
argument_list|(
literal|"Scope \"{}\" already exists and will be reused."
argument_list|,
name|dupe
argument_list|)
expr_stmt|;
name|scope
operator|=
name|getScope
argument_list|(
name|dupe
argument_list|)
expr_stmt|;
block|}
name|OntologySpace
name|custom
init|=
name|scope
operator|.
name|getCustomSpace
argument_list|()
decl_stmt|;
comment|// Register even if some ontologies were to fail to be restored afterwards.
name|scopeMap
operator|.
name|put
argument_list|(
name|scopeId
argument_list|,
name|scope
argument_list|)
expr_stmt|;
for|for
control|(
name|OWLOntologyID
name|key
range|:
name|struct
operator|.
name|getCustomOntologyKeysForScope
argument_list|(
name|scopeId
argument_list|)
control|)
try|try
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Custom ontology key : {}"
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|custom
operator|.
name|addOntology
argument_list|(
operator|new
name|StoredOntologySource
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MissingOntologyException
name|ex
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Could not find an ontology with public key {} to be managed by scope \"{}\". Proceeding to next ontology."
argument_list|,
name|key
argument_list|,
name|scopeId
argument_list|)
expr_stmt|;
continue|continue;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Exception caught while trying to add ontology with public key "
operator|+
name|key
operator|+
literal|" to rebuilt scope \""
operator|+
name|scopeId
operator|+
literal|"\". proceeding to next ontology"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Scope \"{}\" rebuilt in {} ms."
argument_list|,
name|scopeId
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|before
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|registerScope
parameter_list|(
name|Scope
name|scope
parameter_list|)
throws|throws
name|DuplicateIDException
block|{
if|if
condition|(
name|scope
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"scope cannot be null."
argument_list|)
throw|;
name|String
name|id
init|=
name|scope
operator|.
name|getID
argument_list|()
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|containsScope
argument_list|(
name|id
argument_list|)
condition|)
throw|throw
operator|new
name|DuplicateIDException
argument_list|(
name|id
argument_list|,
literal|"Scope registry already contains ontology scope with ID "
operator|+
name|id
argument_list|)
throw|;
comment|// if (this.containsScope(id)) {
comment|// if (scope != getScope(id)) {
comment|// log.warn("Overriding different scope with same ID {}", id);
comment|// super.registerScope(scope);
comment|// } else log.warn("Ignoring unnecessary call to already registered scope {}", id);
comment|// } else
name|super
operator|.
name|registerScope
argument_list|(
name|scope
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setOntologyNetworkNamespace
parameter_list|(
name|String
name|namespace
parameter_list|)
block|{
if|if
condition|(
name|namespace
operator|==
literal|null
operator|||
name|namespace
operator|.
name|isEmpty
argument_list|()
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"namespace must be a non-null and non-empty string."
argument_list|)
throw|;
if|if
condition|(
operator|!
name|namespace
operator|.
name|endsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"OntoNet namespaces must be slash URIs, adding '/'."
argument_list|)
expr_stmt|;
name|namespace
operator|+=
literal|"/"
expr_stmt|;
block|}
name|this
operator|.
name|ontonetNS
operator|=
name|IRI
operator|.
name|create
argument_list|(
name|namespace
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

