begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|registry
operator|.
name|impl
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Dictionary
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|access
operator|.
name|TcManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|serializedform
operator|.
name|Parser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Activate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Component
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Deactivate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Property
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|PropertyOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Reference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Service
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|ontonet
operator|.
name|api
operator|.
name|OfflineConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|ontonet
operator|.
name|api
operator|.
name|ontology
operator|.
name|OntologyProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|ontonet
operator|.
name|impl
operator|.
name|clerezza
operator|.
name|ClerezzaOntologyProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|registry
operator|.
name|api
operator|.
name|RegistryContentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|registry
operator|.
name|api
operator|.
name|RegistryContentListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|registry
operator|.
name|api
operator|.
name|RegistryItemFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|registry
operator|.
name|api
operator|.
name|RegistryManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|registry
operator|.
name|api
operator|.
name|model
operator|.
name|CachingPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|registry
operator|.
name|api
operator|.
name|model
operator|.
name|Library
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|registry
operator|.
name|api
operator|.
name|model
operator|.
name|Registry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|registry
operator|.
name|api
operator|.
name|model
operator|.
name|RegistryItem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|registry
operator|.
name|api
operator|.
name|model
operator|.
name|RegistryItem
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|registry
operator|.
name|api
operator|.
name|model
operator|.
name|RegistryOntology
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|registry
operator|.
name|impl
operator|.
name|util
operator|.
name|RegistryUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|registry
operator|.
name|xd
operator|.
name|vocabulary
operator|.
name|CODOVocabulary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|owl
operator|.
name|OWLOntologyManagerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|service
operator|.
name|component
operator|.
name|ComponentContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|apibinding
operator|.
name|OWLManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|IRI
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLAxiom
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLAxiomVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLClass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLClassAssertionAxiom
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLClassExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLDataFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLIndividual
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLNamedIndividual
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLObjectProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLObjectPropertyAssertionAxiom
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLObjectPropertyExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLOntology
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLOntologyAlreadyExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLOntologyCreationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLOntologyManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|util
operator|.
name|OWLAxiomVisitorAdapter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Default implementation of the registry manager, that listens to requests on its referenced resources and  * issues loading requests accordingly.  *   * @author alexdma  */
end_comment

begin_class
annotation|@
name|Component
argument_list|(
name|immediate
operator|=
literal|true
argument_list|,
name|metatype
operator|=
literal|true
argument_list|)
annotation|@
name|Service
argument_list|(
name|RegistryManager
operator|.
name|class
argument_list|)
specifier|public
class|class
name|RegistryManagerImpl
implements|implements
name|RegistryManager
implements|,
name|RegistryContentListener
block|{
specifier|private
specifier|static
specifier|final
name|CachingPolicy
name|_CACHING_POLICY_DEFAULT
init|=
name|CachingPolicy
operator|.
name|CENTRALISED
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|boolean
name|_LAZY_LOADING_DEFAULT
init|=
literal|true
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|OWLClass
name|cRegistryLibrary
decl_stmt|,
name|cOntology
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|OWLObjectProperty
name|hasPart
decl_stmt|,
name|hasOntology
decl_stmt|,
name|isPartOf
decl_stmt|,
name|isOntologyOf
decl_stmt|;
static|static
block|{
name|OWLDataFactory
name|factory
init|=
name|OWLManager
operator|.
name|getOWLDataFactory
argument_list|()
decl_stmt|;
name|cOntology
operator|=
name|factory
operator|.
name|getOWLClass
argument_list|(
name|IRI
operator|.
name|create
argument_list|(
name|CODOVocabulary
operator|.
name|CODK_Ontology
argument_list|)
argument_list|)
expr_stmt|;
name|cRegistryLibrary
operator|=
name|factory
operator|.
name|getOWLClass
argument_list|(
name|IRI
operator|.
name|create
argument_list|(
name|CODOVocabulary
operator|.
name|CODD_OntologyLibrary
argument_list|)
argument_list|)
expr_stmt|;
name|isPartOf
operator|=
name|factory
operator|.
name|getOWLObjectProperty
argument_list|(
name|IRI
operator|.
name|create
argument_list|(
name|CODOVocabulary
operator|.
name|PARTOF_IsPartOf
argument_list|)
argument_list|)
expr_stmt|;
name|isOntologyOf
operator|=
name|factory
operator|.
name|getOWLObjectProperty
argument_list|(
name|IRI
operator|.
name|create
argument_list|(
name|CODOVocabulary
operator|.
name|ODPM_IsOntologyOf
argument_list|)
argument_list|)
expr_stmt|;
name|hasPart
operator|=
name|factory
operator|.
name|getOWLObjectProperty
argument_list|(
name|IRI
operator|.
name|create
argument_list|(
name|CODOVocabulary
operator|.
name|PARTOF_HasPart
argument_list|)
argument_list|)
expr_stmt|;
name|hasOntology
operator|=
name|factory
operator|.
name|getOWLObjectProperty
argument_list|(
name|IRI
operator|.
name|create
argument_list|(
name|CODOVocabulary
operator|.
name|ODPM_HasOntology
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Reference
specifier|private
name|OntologyProvider
argument_list|<
name|?
argument_list|>
name|cache
decl_stmt|;
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|RegistryManager
operator|.
name|CACHING_POLICY
argument_list|,
name|options
operator|=
block|{
annotation|@
name|PropertyOption
argument_list|(
name|value
operator|=
literal|'%'
operator|+
name|RegistryManager
operator|.
name|CACHING_POLICY
operator|+
literal|".option.distributed"
argument_list|,
name|name
operator|=
literal|"DISTRIBUTED"
argument_list|)
block|,
annotation|@
name|PropertyOption
argument_list|(
name|value
operator|=
literal|'%'
operator|+
name|RegistryManager
operator|.
name|CACHING_POLICY
operator|+
literal|".option.centralised"
argument_list|,
name|name
operator|=
literal|"CENTRALISED"
argument_list|)
block|}
argument_list|,
name|value
operator|=
literal|"CENTRALISED"
argument_list|)
specifier|private
name|String
name|cachingPolicyString
decl_stmt|;
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|RegistryManager
operator|.
name|LAZY_LOADING
argument_list|,
name|boolValue
operator|=
name|_LAZY_LOADING_DEFAULT
argument_list|)
specifier|private
name|boolean
name|lazyLoading
init|=
name|_LAZY_LOADING_DEFAULT
decl_stmt|;
comment|/* Maps registries to libraries */
specifier|private
name|Map
argument_list|<
name|IRI
argument_list|,
name|Set
argument_list|<
name|IRI
argument_list|>
argument_list|>
name|libraryIndex
init|=
operator|new
name|HashMap
argument_list|<
name|IRI
argument_list|,
name|Set
argument_list|<
name|IRI
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|RegistryManager
operator|.
name|REGISTRY_LOCATIONS
argument_list|,
name|cardinality
operator|=
literal|1000
argument_list|,
name|value
operator|=
block|{
literal|"http://www.ontologydesignpatterns.org/registry/iksnetwork-standalone.owl"
block|}
argument_list|)
specifier|private
name|String
index|[]
name|locations
decl_stmt|;
specifier|private
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|getClass
argument_list|()
argument_list|)
decl_stmt|;
annotation|@
name|Reference
specifier|private
name|OfflineConfiguration
name|offline
decl_stmt|;
comment|/* Maps libraries to ontologies */
specifier|private
name|Map
argument_list|<
name|IRI
argument_list|,
name|Set
argument_list|<
name|IRI
argument_list|>
argument_list|>
name|ontologyIndex
init|=
operator|new
name|HashMap
argument_list|<
name|IRI
argument_list|,
name|Set
argument_list|<
name|IRI
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|IRI
argument_list|,
name|RegistryItem
argument_list|>
name|population
init|=
operator|new
name|TreeMap
argument_list|<
name|IRI
argument_list|,
name|RegistryItem
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|Set
argument_list|<
name|IRI
argument_list|>
name|registries
init|=
operator|new
name|HashSet
argument_list|<
name|IRI
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|RegistryItemFactory
name|riFactory
decl_stmt|;
comment|/**      * This default constructor is<b>only</b> intended to be used by the OSGI environment with Service      * Component Runtime support.      *<p>      * DO NOT USE to manually create instances - the RegistryManagerImpl instances do need to be configured!      * YOU NEED TO USE {@link #RegistryManagerImpl(Dictionary)} or its overloads, to parse the configuration      * and then initialise the rule store if running outside an OSGI environment.      */
specifier|public
name|RegistryManagerImpl
parameter_list|()
block|{}
comment|/**      * To be invoked by non-OSGi environments.      *       * @param the      *            configuration registry manager-specific configuration      */
specifier|public
name|RegistryManagerImpl
parameter_list|(
name|OfflineConfiguration
name|offline
parameter_list|,
name|OntologyProvider
argument_list|<
name|?
argument_list|>
name|cache
parameter_list|,
name|Dictionary
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|configuration
parameter_list|)
block|{
name|this
argument_list|()
expr_stmt|;
name|this
operator|.
name|offline
operator|=
name|offline
expr_stmt|;
name|this
operator|.
name|cache
operator|=
name|cache
expr_stmt|;
name|activate
argument_list|(
name|configuration
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Activate
specifier|protected
name|void
name|activate
parameter_list|(
name|ComponentContext
name|context
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"in {} activate with context {}"
argument_list|,
name|getClass
argument_list|()
argument_list|,
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"No valid"
operator|+
name|ComponentContext
operator|.
name|class
operator|+
literal|" parsed in activate!"
argument_list|)
throw|;
block|}
name|activate
argument_list|(
operator|(
name|Dictionary
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
operator|)
name|context
operator|.
name|getProperties
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|activate
parameter_list|(
name|Dictionary
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|configuration
parameter_list|)
block|{
comment|// Parse configuration.
try|try
block|{
name|lazyLoading
operator|=
call|(
name|Boolean
call|)
argument_list|(
name|configuration
operator|.
name|get
argument_list|(
name|RegistryManager
operator|.
name|LAZY_LOADING
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|lazyLoading
operator|=
name|_LAZY_LOADING_DEFAULT
expr_stmt|;
block|}
name|Object
name|obj
init|=
name|configuration
operator|.
name|get
argument_list|(
name|RegistryManager
operator|.
name|REGISTRY_LOCATIONS
argument_list|)
decl_stmt|;
if|if
condition|(
name|obj
operator|instanceof
name|String
index|[]
condition|)
name|locations
operator|=
operator|(
name|String
index|[]
operator|)
name|obj
expr_stmt|;
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|String
condition|)
name|locations
operator|=
operator|new
name|String
index|[]
block|{
operator|(
name|String
operator|)
name|obj
block|}
expr_stmt|;
if|if
condition|(
name|locations
operator|==
literal|null
condition|)
name|locations
operator|=
operator|new
name|String
index|[]
block|{
literal|"http://www.ontologydesignpatterns.org/registry/iksnetwork-standalone.owl"
block|}
expr_stmt|;
name|Object
name|cachingPolicy
init|=
name|configuration
operator|.
name|get
argument_list|(
name|RegistryManager
operator|.
name|CACHING_POLICY
argument_list|)
decl_stmt|;
if|if
condition|(
name|cachingPolicy
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|cachingPolicyString
operator|=
name|_CACHING_POLICY_DEFAULT
operator|.
name|name
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|cachingPolicyString
operator|=
name|cachingPolicy
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
specifier|final
name|IRI
index|[]
name|offlineResources
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|offline
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|IRI
argument_list|>
name|paths
init|=
name|offline
operator|.
name|getOntologySourceLocations
argument_list|()
decl_stmt|;
if|if
condition|(
name|paths
operator|!=
literal|null
condition|)
name|offlineResources
operator|=
name|paths
operator|.
name|toArray
argument_list|(
operator|new
name|IRI
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// There are no offline paths.
else|else
name|offlineResources
operator|=
operator|new
name|IRI
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|// There's no offline configuration at all.
else|else
name|offlineResources
operator|=
operator|new
name|IRI
index|[
literal|0
index|]
expr_stmt|;
comment|// Used only for creating the registry model, do not use for caching.
name|OWLOntologyManager
name|mgr
init|=
name|OWLOntologyManagerFactory
operator|.
name|createOWLOntologyManager
argument_list|(
name|offlineResources
argument_list|)
decl_stmt|;
comment|// Load registries
name|Set
argument_list|<
name|OWLOntology
argument_list|>
name|regOnts
init|=
operator|new
name|HashSet
argument_list|<
name|OWLOntology
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|loc
range|:
name|locations
control|)
block|{
try|try
block|{
name|regOnts
operator|.
name|add
argument_list|(
name|mgr
operator|.
name|loadOntology
argument_list|(
name|IRI
operator|.
name|create
argument_list|(
name|loc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OWLOntologyAlreadyExistsException
name|e
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Skipping cached ontology {}."
argument_list|,
name|e
operator|.
name|getOntologyID
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
catch|catch
parameter_list|(
name|OWLOntologyCreationException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Failed to load ontology "
operator|+
name|loc
operator|+
literal|" - Skipping..."
argument_list|,
name|e
argument_list|)
expr_stmt|;
continue|continue;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Invalid registry configuration "
operator|+
name|loc
operator|+
literal|" - Skipping..."
argument_list|,
name|e
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|// Create and set the cache.
if|if
condition|(
name|cachingPolicyString
operator|.
name|equals
argument_list|(
name|CachingPolicy
operator|.
name|CENTRALISED
operator|.
name|name
argument_list|()
argument_list|)
condition|)
block|{
comment|// this.cache = OWLOntologyManagerFactory.createOWLOntologyManager(offlineResources);
if|if
condition|(
name|cache
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Caching policy is set as Centralised, but no ontology provider is supplied. Will use new in-memory tcProvider."
argument_list|)
expr_stmt|;
name|cache
operator|=
operator|new
name|ClerezzaOntologyProvider
argument_list|(
name|TcManager
operator|.
name|getInstance
argument_list|()
argument_list|,
name|offline
argument_list|,
name|Parser
operator|.
name|getInstance
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// else sta bene cosi'
block|}
elseif|else
if|if
condition|(
name|cachingPolicyString
operator|.
name|equals
argument_list|(
name|CachingPolicy
operator|.
name|DISTRIBUTED
operator|.
name|name
argument_list|()
argument_list|)
condition|)
block|{
name|this
operator|.
name|cache
operator|=
literal|null
expr_stmt|;
block|}
name|riFactory
operator|=
operator|new
name|RegistryItemFactoryImpl
argument_list|(
name|cache
argument_list|)
expr_stmt|;
comment|// Build the model.
name|createModel
argument_list|(
name|regOnts
argument_list|)
expr_stmt|;
comment|// Set the cache on libraries.
name|Set
argument_list|<
name|RegistryItem
argument_list|>
name|visited
init|=
operator|new
name|HashSet
argument_list|<
name|RegistryItem
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Registry
name|reg
range|:
name|getRegistries
argument_list|()
control|)
for|for
control|(
name|RegistryItem
name|child
range|:
name|reg
operator|.
name|getChildren
argument_list|()
control|)
if|if
condition|(
operator|!
name|visited
operator|.
name|contains
argument_list|(
name|child
argument_list|)
condition|)
block|{
if|if
condition|(
name|child
operator|instanceof
name|Library
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|cache
operator|!=
literal|null
condition|)
operator|(
operator|(
name|Library
operator|)
name|child
operator|)
operator|.
name|setCache
argument_list|(
name|this
operator|.
name|cache
argument_list|)
expr_stmt|;
else|else
operator|(
operator|(
name|Library
operator|)
name|child
operator|)
operator|.
name|setCache
argument_list|(
operator|new
name|ClerezzaOntologyProvider
argument_list|(
name|TcManager
operator|.
name|getInstance
argument_list|()
argument_list|,
name|offline
argument_list|,
name|Parser
operator|.
name|getInstance
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|visited
operator|.
name|add
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isLazyLoading
argument_list|()
condition|)
block|{
comment|// Nothing to do about it at the moment.
block|}
else|else
block|{
name|loadEager
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|addRegistry
parameter_list|(
name|Registry
name|registry
parameter_list|)
block|{
comment|// TODO: automatically set the cache if unset or non conform to the caching policy.
try|try
block|{
name|population
operator|.
name|put
argument_list|(
name|registry
operator|.
name|getIRI
argument_list|()
argument_list|,
name|registry
argument_list|)
expr_stmt|;
name|registries
operator|.
name|add
argument_list|(
name|registry
operator|.
name|getIRI
argument_list|()
argument_list|)
expr_stmt|;
name|updateLocations
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Failed to add ontology registry."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|clearRegistries
parameter_list|()
block|{
for|for
control|(
name|IRI
name|id
range|:
name|registries
control|)
if|if
condition|(
name|registries
operator|.
name|remove
argument_list|(
name|id
argument_list|)
condition|)
name|population
operator|.
name|remove
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|updateLocations
argument_list|()
expr_stmt|;
block|}
comment|/**      * @deprecated with each library having its own cache, load balancing is no longer necessary      * @return      */
specifier|protected
name|Registry
name|computeBestCandidate
parameter_list|(
name|Library
name|lib
parameter_list|)
block|{
name|Map
argument_list|<
name|IRI
argument_list|,
name|Float
argument_list|>
name|loadFactors
init|=
name|computeLoadFactors
argument_list|()
decl_stmt|;
name|IRI
name|current
init|=
literal|null
decl_stmt|;
name|float
name|lowest
init|=
literal|1.0f
decl_stmt|;
for|for
control|(
name|RegistryItem
name|item
range|:
name|lib
operator|.
name|getParents
argument_list|()
control|)
block|{
name|IRI
name|iri
init|=
name|item
operator|.
name|getIRI
argument_list|()
decl_stmt|;
if|if
condition|(
name|loadFactors
operator|.
name|containsKey
argument_list|(
name|iri
argument_list|)
condition|)
block|{
name|float
name|f
init|=
name|loadFactors
operator|.
name|get
argument_list|(
name|iri
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|<
name|lowest
condition|)
block|{
name|lowest
operator|=
name|f
expr_stmt|;
name|current
operator|=
name|iri
expr_stmt|;
block|}
block|}
block|}
return|return
call|(
name|Registry
call|)
argument_list|(
name|population
operator|.
name|get
argument_list|(
name|current
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * @deprecated with each library having its own cache, load balancing is no longer necessary      * @return      */
specifier|protected
name|Map
argument_list|<
name|IRI
argument_list|,
name|Float
argument_list|>
name|computeLoadFactors
parameter_list|()
block|{
name|Map
argument_list|<
name|IRI
argument_list|,
name|Float
argument_list|>
name|loadFactors
init|=
operator|new
name|HashMap
argument_list|<
name|IRI
argument_list|,
name|Float
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Registry
name|r
range|:
name|getRegistries
argument_list|()
control|)
block|{
name|int
name|tot
init|=
literal|0
decl_stmt|,
name|num
init|=
literal|0
decl_stmt|;
name|RegistryItem
index|[]
name|children
init|=
name|r
operator|.
name|getChildren
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|children
index|[
name|i
index|]
operator|instanceof
name|Library
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|Library
operator|)
name|children
index|[
name|i
index|]
operator|)
operator|.
name|isLoaded
argument_list|()
condition|)
name|num
operator|++
expr_stmt|;
name|tot
operator|++
expr_stmt|;
block|}
block|}
name|loadFactors
operator|.
name|put
argument_list|(
name|r
operator|.
name|getIRI
argument_list|()
argument_list|,
operator|(
name|float
operator|)
name|num
operator|/
operator|(
name|float
operator|)
name|tot
argument_list|)
expr_stmt|;
block|}
return|return
name|loadFactors
return|;
block|}
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|Registry
argument_list|>
name|createModel
parameter_list|(
name|Set
argument_list|<
name|OWLOntology
argument_list|>
name|registryOntologies
parameter_list|)
block|{
name|Set
argument_list|<
name|Registry
argument_list|>
name|results
init|=
operator|new
name|HashSet
argument_list|<
name|Registry
argument_list|>
argument_list|()
decl_stmt|;
comment|// Reset population
name|population
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Build the transitive imports closure of the union.
name|Set
argument_list|<
name|OWLOntology
argument_list|>
name|closure
init|=
operator|new
name|HashSet
argument_list|<
name|OWLOntology
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|OWLOntology
name|rego
range|:
name|registryOntologies
control|)
name|closure
operator|.
name|addAll
argument_list|(
name|rego
operator|.
name|getOWLOntologyManager
argument_list|()
operator|.
name|getImportsClosure
argument_list|(
name|rego
argument_list|)
argument_list|)
expr_stmt|;
comment|/*          * For each value in this map, index 0 is the score of the library class, while 1 is the score of the          * ontology class.          */
specifier|final
name|Map
argument_list|<
name|IRI
argument_list|,
name|int
index|[]
argument_list|>
name|candidateTypes
init|=
operator|new
name|HashMap
argument_list|<
name|IRI
argument_list|,
name|int
index|[]
argument_list|>
argument_list|()
decl_stmt|;
comment|/*          * Scans class assertions and object property values and tries to determine the type of each          * individual it finds.          */
name|OWLAxiomVisitor
name|scanner
init|=
operator|new
name|OWLAxiomVisitorAdapter
argument_list|()
block|{
comment|/*              * For a given identifier, returns the array of integers whose value determine the likelihood if              * the corresponding entity being a library or an ontology. If no such array exists, it is              * created.              */
specifier|private
name|int
index|[]
name|checkScores
parameter_list|(
name|IRI
name|key
parameter_list|)
block|{
name|int
index|[]
name|scores
decl_stmt|;
if|if
condition|(
name|candidateTypes
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
condition|)
name|scores
operator|=
name|candidateTypes
operator|.
name|get
argument_list|(
name|key
argument_list|)
expr_stmt|;
else|else
block|{
name|scores
operator|=
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|0
block|}
expr_stmt|;
name|candidateTypes
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|scores
argument_list|)
expr_stmt|;
block|}
return|return
name|scores
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|OWLClassAssertionAxiom
name|axiom
parameter_list|)
block|{
name|OWLIndividual
name|ind
init|=
name|axiom
operator|.
name|getIndividual
argument_list|()
decl_stmt|;
comment|// Do not accept anonymous registry items.
if|if
condition|(
name|ind
operator|.
name|isAnonymous
argument_list|()
condition|)
return|return;
name|IRI
name|iri
init|=
name|ind
operator|.
name|asOWLNamedIndividual
argument_list|()
operator|.
name|getIRI
argument_list|()
decl_stmt|;
name|int
index|[]
name|scores
init|=
name|checkScores
argument_list|(
name|iri
argument_list|)
decl_stmt|;
name|OWLClassExpression
name|type
init|=
name|axiom
operator|.
name|getClassExpression
argument_list|()
decl_stmt|;
comment|// If the type is stated to be a library, increase its library score.
if|if
condition|(
name|cRegistryLibrary
operator|.
name|equals
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|scores
index|[
literal|0
index|]
operator|++
expr_stmt|;
block|}
elseif|else
comment|// If the type is stated to be an ontology, increase its ontology score.
if|if
condition|(
name|cOntology
operator|.
name|equals
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|scores
index|[
literal|1
index|]
operator|++
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|OWLObjectPropertyAssertionAxiom
name|axiom
parameter_list|)
block|{
name|OWLObjectPropertyExpression
name|prop
init|=
name|axiom
operator|.
name|getProperty
argument_list|()
decl_stmt|;
if|if
condition|(
name|hasOntology
operator|.
name|equals
argument_list|(
name|prop
argument_list|)
condition|)
block|{
name|IRI
name|iri
decl_stmt|;
comment|// The axiom subject gets a +1 in its library score.
name|OWLIndividual
name|ind
init|=
name|axiom
operator|.
name|getSubject
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ind
operator|.
name|isAnonymous
argument_list|()
condition|)
block|{
name|iri
operator|=
name|ind
operator|.
name|asOWLNamedIndividual
argument_list|()
operator|.
name|getIRI
argument_list|()
expr_stmt|;
name|checkScores
argument_list|(
name|iri
argument_list|)
index|[
literal|0
index|]
operator|++
expr_stmt|;
block|}
comment|// The axiom object gets a +1 in its ontology score.
name|ind
operator|=
name|axiom
operator|.
name|getObject
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ind
operator|.
name|isAnonymous
argument_list|()
condition|)
block|{
name|iri
operator|=
name|ind
operator|.
name|asOWLNamedIndividual
argument_list|()
operator|.
name|getIRI
argument_list|()
expr_stmt|;
name|checkScores
argument_list|(
name|iri
argument_list|)
index|[
literal|1
index|]
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|isOntologyOf
operator|.
name|equals
argument_list|(
name|prop
argument_list|)
condition|)
block|{
name|IRI
name|iri
decl_stmt|;
comment|// The axiom subject gets a +1 in its ontology score.
name|OWLIndividual
name|ind
init|=
name|axiom
operator|.
name|getSubject
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ind
operator|.
name|isAnonymous
argument_list|()
condition|)
block|{
name|iri
operator|=
name|ind
operator|.
name|asOWLNamedIndividual
argument_list|()
operator|.
name|getIRI
argument_list|()
expr_stmt|;
name|checkScores
argument_list|(
name|iri
argument_list|)
index|[
literal|1
index|]
operator|++
expr_stmt|;
block|}
comment|// The axiom object gets a +1 in its library score.
name|ind
operator|=
name|axiom
operator|.
name|getObject
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ind
operator|.
name|isAnonymous
argument_list|()
condition|)
block|{
name|iri
operator|=
name|ind
operator|.
name|asOWLNamedIndividual
argument_list|()
operator|.
name|getIRI
argument_list|()
expr_stmt|;
name|checkScores
argument_list|(
name|iri
argument_list|)
index|[
literal|0
index|]
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
decl_stmt|;
comment|// First pass to determine the types.
for|for
control|(
name|OWLOntology
name|o
range|:
name|closure
control|)
for|for
control|(
name|OWLAxiom
name|ax
range|:
name|o
operator|.
name|getAxioms
argument_list|()
control|)
name|ax
operator|.
name|accept
argument_list|(
name|scanner
argument_list|)
expr_stmt|;
comment|// Then populate on the registry
name|OWLDataFactory
name|df
init|=
name|OWLManager
operator|.
name|getOWLDataFactory
argument_list|()
decl_stmt|;
for|for
control|(
name|IRI
name|iri
range|:
name|candidateTypes
operator|.
name|keySet
argument_list|()
control|)
block|{
name|int
index|[]
name|scores
init|=
name|candidateTypes
operator|.
name|get
argument_list|(
name|iri
argument_list|)
decl_stmt|;
if|if
condition|(
name|scores
operator|!=
literal|null
operator|&&
operator|(
name|scores
index|[
literal|0
index|]
operator|>
literal|0
operator|||
name|scores
index|[
literal|1
index|]
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|scores
index|[
literal|0
index|]
operator|>
literal|0
operator|&&
name|scores
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|population
operator|.
name|put
argument_list|(
name|iri
argument_list|,
name|riFactory
operator|.
name|createLibrary
argument_list|(
name|df
operator|.
name|getOWLNamedIndividual
argument_list|(
name|iri
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|scores
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|scores
index|[
literal|1
index|]
operator|>
literal|0
condition|)
name|population
operator|.
name|put
argument_list|(
name|iri
argument_list|,
name|riFactory
operator|.
name|createRegistryOntology
argument_list|(
name|df
operator|.
name|getOWLNamedIndividual
argument_list|(
name|iri
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// else log.warn("Unable to determine type for registry item {}", iri);
block|}
for|for
control|(
name|OWLOntology
name|oReg
range|:
name|registryOntologies
control|)
block|{
try|try
block|{
name|results
operator|.
name|add
argument_list|(
name|populateRegistry
argument_list|(
name|oReg
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RegistryContentException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"An error occurred while populating an ontology registry."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|results
return|;
block|}
annotation|@
name|Deactivate
specifier|protected
name|void
name|deactivate
parameter_list|(
name|ComponentContext
name|context
parameter_list|)
block|{
name|lazyLoading
operator|=
name|_LAZY_LOADING_DEFAULT
expr_stmt|;
name|locations
operator|=
literal|null
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"in {} deactivate with context {}"
argument_list|,
name|getClass
argument_list|()
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|CachingPolicy
name|getCachingPolicy
parameter_list|()
block|{
try|try
block|{
return|return
name|CachingPolicy
operator|.
name|valueOf
argument_list|(
name|cachingPolicyString
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"The value \""
operator|+
name|cachingPolicyString
operator|+
literal|"\" configured as default CachingPolicy does not match any value of the Enumeration! "
operator|+
literal|"Return the default policy as defined by the "
operator|+
name|CachingPolicy
operator|.
name|class
operator|+
literal|"."
argument_list|)
expr_stmt|;
return|return
name|_CACHING_POLICY_DEFAULT
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|Library
argument_list|>
name|getLibraries
parameter_list|()
block|{
name|Set
argument_list|<
name|Library
argument_list|>
name|results
init|=
operator|new
name|HashSet
argument_list|<
name|Library
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|IRI
name|key
range|:
name|population
operator|.
name|keySet
argument_list|()
control|)
block|{
name|RegistryItem
name|item
init|=
name|population
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|item
operator|instanceof
name|Library
condition|)
name|results
operator|.
name|add
argument_list|(
operator|(
name|Library
operator|)
name|item
argument_list|)
expr_stmt|;
block|}
return|return
name|results
return|;
block|}
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|Library
argument_list|>
name|getLibraries
parameter_list|(
name|IRI
name|ontologyID
parameter_list|)
block|{
name|Set
argument_list|<
name|Library
argument_list|>
name|results
init|=
operator|new
name|HashSet
argument_list|<
name|Library
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|RegistryItem
name|item
range|:
name|population
operator|.
name|get
argument_list|(
name|ontologyID
argument_list|)
operator|.
name|getParents
argument_list|()
control|)
if|if
condition|(
name|item
operator|instanceof
name|Library
condition|)
name|results
operator|.
name|add
argument_list|(
operator|(
name|Library
operator|)
name|item
argument_list|)
expr_stmt|;
return|return
name|results
return|;
block|}
annotation|@
name|Override
specifier|public
name|Library
name|getLibrary
parameter_list|(
name|IRI
name|id
parameter_list|)
block|{
name|RegistryItem
name|item
init|=
name|population
operator|.
name|get
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|item
operator|!=
literal|null
operator|&&
name|item
operator|instanceof
name|Library
condition|)
return|return
operator|(
name|Library
operator|)
name|item
return|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|OfflineConfiguration
name|getOfflineConfiguration
parameter_list|()
block|{
return|return
name|offline
return|;
block|}
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|Registry
argument_list|>
name|getRegistries
parameter_list|()
block|{
name|Set
argument_list|<
name|Registry
argument_list|>
name|results
init|=
operator|new
name|HashSet
argument_list|<
name|Registry
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|IRI
name|key
range|:
name|population
operator|.
name|keySet
argument_list|()
control|)
block|{
name|RegistryItem
name|item
init|=
name|population
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|item
operator|instanceof
name|Registry
condition|)
name|results
operator|.
name|add
argument_list|(
operator|(
name|Registry
operator|)
name|item
argument_list|)
expr_stmt|;
block|}
return|return
name|results
return|;
block|}
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|Registry
argument_list|>
name|getRegistries
parameter_list|(
name|IRI
name|libraryID
parameter_list|)
block|{
name|Set
argument_list|<
name|Registry
argument_list|>
name|results
init|=
operator|new
name|HashSet
argument_list|<
name|Registry
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
for|for
control|(
name|RegistryItem
name|item
range|:
name|population
operator|.
name|get
argument_list|(
name|libraryID
argument_list|)
operator|.
name|getParents
argument_list|()
control|)
if|if
condition|(
name|item
operator|instanceof
name|Registry
condition|)
name|results
operator|.
name|add
argument_list|(
operator|(
name|Registry
operator|)
name|item
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|ex
parameter_list|)
block|{
return|return
name|results
return|;
block|}
return|return
name|results
return|;
block|}
annotation|@
name|Override
specifier|public
name|Registry
name|getRegistry
parameter_list|(
name|IRI
name|id
parameter_list|)
block|{
name|RegistryItem
name|item
init|=
name|population
operator|.
name|get
argument_list|(
name|id
argument_list|)
decl_stmt|;
return|return
name|item
operator|!=
literal|null
operator|&&
name|item
operator|instanceof
name|Registry
condition|?
operator|(
name|Registry
operator|)
name|item
else|:
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isLazyLoading
parameter_list|()
block|{
return|return
name|lazyLoading
return|;
block|}
specifier|private
name|void
name|loadEager
parameter_list|()
block|{
for|for
control|(
name|RegistryItem
name|item
range|:
name|population
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|item
operator|instanceof
name|Library
operator|&&
operator|!
operator|(
operator|(
name|Library
operator|)
name|item
operator|)
operator|.
name|isLoaded
argument_list|()
condition|)
block|{
comment|// TODO: implement ontology request targets.
if|if
condition|(
name|CachingPolicy
operator|.
name|CENTRALISED
operator|.
name|equals
argument_list|(
name|getCachingPolicy
argument_list|()
argument_list|)
operator|&&
name|this
operator|.
name|cache
operator|!=
literal|null
condition|)
block|{
operator|(
operator|(
name|Library
operator|)
name|item
operator|)
operator|.
name|loadOntologies
argument_list|(
name|this
operator|.
name|cache
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CachingPolicy
operator|.
name|DISTRIBUTED
operator|.
name|equals
argument_list|(
name|getCachingPolicy
argument_list|()
argument_list|)
condition|)
block|{
name|Library
name|lib
init|=
operator|(
name|Library
operator|)
name|item
decl_stmt|;
name|lib
operator|.
name|loadOntologies
argument_list|(
name|lib
operator|.
name|getCache
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Tried to load ontology resource {} using a null cache."
argument_list|,
name|item
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|protected
name|Library
name|populateLibrary
parameter_list|(
name|OWLNamedIndividual
name|ind
parameter_list|,
name|Set
argument_list|<
name|OWLOntology
argument_list|>
name|registries
parameter_list|)
throws|throws
name|RegistryContentException
block|{
name|IRI
name|id
init|=
name|ind
operator|.
name|getIRI
argument_list|()
decl_stmt|;
name|RegistryItem
name|lib
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|population
operator|.
name|containsKey
argument_list|(
name|id
argument_list|)
condition|)
block|{
comment|// We are not allowing multityping either.
name|lib
operator|=
name|population
operator|.
name|get
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|lib
operator|instanceof
name|Library
operator|)
condition|)
throw|throw
operator|new
name|RegistryContentException
argument_list|(
literal|"Inconsistent multityping: for item "
operator|+
name|id
operator|+
literal|" : {"
operator|+
name|Library
operator|.
name|class
operator|+
literal|", "
operator|+
name|lib
operator|.
name|getClass
argument_list|()
operator|+
literal|"}"
argument_list|)
throw|;
block|}
else|else
block|{
name|lib
operator|=
name|riFactory
operator|.
name|createLibrary
argument_list|(
name|ind
operator|.
name|asOWLNamedIndividual
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|population
operator|.
name|put
argument_list|(
name|lib
operator|.
name|getIRI
argument_list|()
argument_list|,
name|lib
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Invalid identifier for library item "
operator|+
name|lib
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|// EXIT nodes.
name|Set
argument_list|<
name|OWLIndividual
argument_list|>
name|ronts
init|=
operator|new
name|HashSet
argument_list|<
name|OWLIndividual
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|OWLOntology
name|o
range|:
name|registries
control|)
name|ronts
operator|.
name|addAll
argument_list|(
name|ind
operator|.
name|getObjectPropertyValues
argument_list|(
name|hasOntology
argument_list|,
name|o
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|OWLIndividual
name|iont
range|:
name|ronts
control|)
block|{
if|if
condition|(
name|iont
operator|.
name|isNamed
argument_list|()
condition|)
name|lib
operator|.
name|addChild
argument_list|(
name|populateOntology
argument_list|(
name|iont
operator|.
name|asOWLNamedIndividual
argument_list|()
argument_list|,
name|registries
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|Library
operator|)
name|lib
return|;
block|}
specifier|protected
name|RegistryOntology
name|populateOntology
parameter_list|(
name|OWLNamedIndividual
name|ind
parameter_list|,
name|Set
argument_list|<
name|OWLOntology
argument_list|>
name|registries
parameter_list|)
throws|throws
name|RegistryContentException
block|{
name|IRI
name|id
init|=
name|ind
operator|.
name|getIRI
argument_list|()
decl_stmt|;
name|RegistryItem
name|ront
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|population
operator|.
name|containsKey
argument_list|(
name|id
argument_list|)
condition|)
block|{
comment|// We are not allowing multityping either.
name|ront
operator|=
name|population
operator|.
name|get
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ront
operator|instanceof
name|RegistryOntology
operator|)
condition|)
throw|throw
operator|new
name|RegistryContentException
argument_list|(
literal|"Inconsistent multityping: for item "
operator|+
name|id
operator|+
literal|" : {"
operator|+
name|RegistryOntology
operator|.
name|class
operator|+
literal|", "
operator|+
name|ront
operator|.
name|getClass
argument_list|()
operator|+
literal|"}"
argument_list|)
throw|;
block|}
else|else
block|{
name|ront
operator|=
name|riFactory
operator|.
name|createRegistryOntology
argument_list|(
name|ind
argument_list|)
expr_stmt|;
try|try
block|{
name|population
operator|.
name|put
argument_list|(
name|ront
operator|.
name|getIRI
argument_list|()
argument_list|,
name|ront
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Invalid identifier for library item "
operator|+
name|ront
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|// EXIT nodes.
name|Set
argument_list|<
name|OWLIndividual
argument_list|>
name|libs
init|=
operator|new
name|HashSet
argument_list|<
name|OWLIndividual
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|OWLOntology
name|o
range|:
name|registries
control|)
name|libs
operator|.
name|addAll
argument_list|(
name|ind
operator|.
name|getObjectPropertyValues
argument_list|(
name|isOntologyOf
argument_list|,
name|o
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|OWLIndividual
name|ilib
range|:
name|libs
control|)
block|{
if|if
condition|(
name|ilib
operator|.
name|isNamed
argument_list|()
condition|)
name|ront
operator|.
name|addParent
argument_list|(
name|populateLibrary
argument_list|(
name|ilib
operator|.
name|asOWLNamedIndividual
argument_list|()
argument_list|,
name|registries
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|RegistryOntology
operator|)
name|ront
return|;
block|}
specifier|protected
name|Registry
name|populateRegistry
parameter_list|(
name|OWLOntology
name|registry
parameter_list|)
throws|throws
name|RegistryContentException
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Populating registry content from ontology {}"
argument_list|,
name|registry
argument_list|)
expr_stmt|;
name|Registry
name|reg
init|=
name|riFactory
operator|.
name|createRegistry
argument_list|(
name|registry
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|OWLOntology
argument_list|>
name|closure
init|=
name|registry
operator|.
name|getOWLOntologyManager
argument_list|()
operator|.
name|getImportsClosure
argument_list|(
name|registry
argument_list|)
decl_stmt|;
comment|// Just scan all individuals. Recurse in case the registry imports more registries.
for|for
control|(
name|OWLIndividual
name|ind
range|:
name|registry
operator|.
name|getIndividualsInSignature
argument_list|(
literal|true
argument_list|)
control|)
block|{
comment|// We do not allow anonymous registry items.
if|if
condition|(
name|ind
operator|.
name|isAnonymous
argument_list|()
condition|)
continue|continue;
name|RegistryItem
name|item
init|=
literal|null
decl_stmt|;
comment|// IRI id = ind.asOWLNamedIndividual().getIRI();
name|Type
name|t
init|=
name|RegistryUtils
operator|.
name|getType
argument_list|(
name|ind
argument_list|,
name|closure
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Undetermined type for registry ontology individual {}"
argument_list|,
name|ind
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|LIBRARY
case|:
name|log
operator|.
name|debug
argument_list|(
literal|"Found library for individual {}"
argument_list|,
name|ind
argument_list|)
expr_stmt|;
comment|// Create the library and attach to parent and children
name|item
operator|=
name|populateLibrary
argument_list|(
name|ind
operator|.
name|asOWLNamedIndividual
argument_list|()
argument_list|,
name|closure
argument_list|)
expr_stmt|;
name|reg
operator|.
name|addChild
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|item
operator|.
name|addRegistryContentListener
argument_list|(
name|this
argument_list|)
expr_stmt|;
break|break;
case|case
name|ONTOLOGY
case|:
name|log
operator|.
name|debug
argument_list|(
literal|"Found ontology for individual {}"
argument_list|,
name|ind
argument_list|)
expr_stmt|;
comment|// Create the ontology and attach to parent
name|item
operator|=
name|populateOntology
argument_list|(
name|ind
operator|.
name|asOWLNamedIndividual
argument_list|()
argument_list|,
name|closure
argument_list|)
expr_stmt|;
name|item
operator|.
name|addRegistryContentListener
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// We don't know where to attach it within this method.
break|break;
default|default:
break|break;
block|}
block|}
try|try
block|{
name|reg
operator|.
name|addRegistryContentListener
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Registry {} added."
argument_list|,
name|reg
operator|.
name|getIRI
argument_list|()
argument_list|)
expr_stmt|;
name|population
operator|.
name|put
argument_list|(
name|reg
operator|.
name|getIRI
argument_list|()
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Invalid identifier for library item "
operator|+
name|reg
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|reg
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|registryContentRequested
parameter_list|(
name|RegistryItem
name|requestTarget
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"In {} registry content was requested on {}."
argument_list|,
name|getClass
argument_list|()
argument_list|,
name|requestTarget
argument_list|)
expr_stmt|;
comment|// TODO: implement ontology request targets.
if|if
condition|(
name|CachingPolicy
operator|.
name|CENTRALISED
operator|.
name|equals
argument_list|(
name|getCachingPolicy
argument_list|()
argument_list|)
operator|&&
name|this
operator|.
name|cache
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|requestTarget
operator|instanceof
name|Library
operator|&&
operator|!
operator|(
operator|(
name|Library
operator|)
name|requestTarget
operator|)
operator|.
name|isLoaded
argument_list|()
condition|)
operator|(
operator|(
name|Library
operator|)
name|requestTarget
operator|)
operator|.
name|loadOntologies
argument_list|(
name|this
operator|.
name|cache
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CachingPolicy
operator|.
name|DISTRIBUTED
operator|.
name|equals
argument_list|(
name|getCachingPolicy
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|requestTarget
operator|instanceof
name|Library
operator|&&
operator|!
operator|(
operator|(
name|Library
operator|)
name|requestTarget
operator|)
operator|.
name|isLoaded
argument_list|()
condition|)
block|{
name|Library
name|lib
init|=
operator|(
name|Library
operator|)
name|requestTarget
decl_stmt|;
name|lib
operator|.
name|loadOntologies
argument_list|(
name|lib
operator|.
name|getCache
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Tried to load ontology resource {} using a null cache."
argument_list|,
name|requestTarget
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeRegistry
parameter_list|(
name|IRI
name|registryId
parameter_list|)
block|{
comment|// TODO: automatically remove ontologies from the cache if centralised.
name|registries
operator|.
name|remove
argument_list|(
name|registryId
argument_list|)
expr_stmt|;
name|updateLocations
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setLazyLoading
parameter_list|(
name|boolean
name|lazy
parameter_list|)
block|{
comment|// Warning: do not use in constructor!
name|this
operator|.
name|lazyLoading
operator|=
name|lazy
expr_stmt|;
if|if
condition|(
operator|!
name|lazy
condition|)
name|loadEager
argument_list|()
expr_stmt|;
block|}
specifier|protected
specifier|synchronized
name|void
name|updateLocations
parameter_list|()
block|{
name|Set
argument_list|<
name|IRI
argument_list|>
name|locations
init|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|registries
argument_list|)
decl_stmt|;
name|this
operator|.
name|locations
operator|=
name|locations
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

