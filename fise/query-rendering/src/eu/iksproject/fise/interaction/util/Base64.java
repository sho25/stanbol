begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
package|package
name|eu
operator|.
name|iksproject
operator|.
name|fise
operator|.
name|interaction
operator|.
name|util
package|;
end_package

begin_comment
comment|/**  *<p>Encodes and decodes to and from Base64 notation.</p>  *<p>Homepage:<a href="http://iharder.net/base64">http://iharder.net/base64</a>.</p>  *   *<p>Example:</p>  *   *<code>String encoded = Base64.encode( myByteArray );</code>  *<br />  *<code>byte[] myByteArray = Base64.decode( encoded );</code>  *  *<p>The<tt>options</tt> parameter, which appears in a few places, is used to pass   * several pieces of information to the encoder. In the "higher level" methods such as   * encodeBytes( bytes, options ) the options parameter can be used to indicate such   * things as first gzipping the bytes before encoding them, not inserting linefeeds,  * and encoding using the URL-safe and Ordered dialects.</p>  *  *<p>Note, according to<a href="http://www.faqs.org/rfcs/rfc3548.html">RFC3548</a>,  * Section 2.1, implementations should not add line feeds unless explicitly told  * to do so. I've got Base64 set to this behavior now, although earlier versions  * broke lines by default.</p>  *  *<p>The constants defined in Base64 can be OR-ed together to combine options, so you   * might make a call like this:</p>  *  *<code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>  *<p>to compress the data before encoding it and then making the output have newline characters.</p>  *<p>Also...</p>  *<code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>  *  *  *  *<p>  * Change Log:  *</p>  *<ul>  *<li>v2.3.4 - Fixed bug when working with gzipped streams whereby flushing  *   the Base64.OutputStream closed the Base64 encoding (by padding with equals  *   signs) too soon. Also added an option to suppress the automatic decoding  *   of gzipped streams. Also added experimental support for specifying a  *   class loader when using the  *   {@link #decodeToObject(java.lang.String, int, java.lang.ClassLoader)}  *   method.</li>  *<li>v2.3.3 - Changed default char encoding to US-ASCII which reduces the internal Java  *   footprint with its CharEncoders and so forth. Fixed some javadocs that were  *   inconsistent. Removed imports and specified things like java.io.IOException  *   explicitly inline.</li>  *<li>v2.3.2 - Reduced memory footprint! Finally refined the "guessing" of how big the  *   final encoded data will be so that the code doesn't have to create two output  *   arrays: an oversized initial one and then a final, exact-sized one. Big win  *   when using the {@link #encodeBytesToBytes(byte[])} family of methods (and not  *   using the gzip options which uses a different mechanism with streams and stuff).</li>  *<li>v2.3.1 - Added {@link #encodeBytesToBytes(byte[], int, int, int)} and some  *   similar helper methods to be more efficient with memory by not returning a  *   String but just a byte array.</li>  *<li>v2.3 -<strong>This is not a drop-in replacement!</strong> This is two years of comments  *   and bug fixes queued up and finally executed. Thanks to everyone who sent  *   me stuff, and I'm sorry I wasn't able to distribute your fixes to everyone else.  *   Much bad coding was cleaned up including throwing exceptions where necessary   *   instead of returning null values or something similar. Here are some changes  *   that may affect you:  *<ul>  *<li><em>Does not break lines, by default.</em> This is to keep in compliance with  *<a href="http://www.faqs.org/rfcs/rfc3548.html">RFC3548</a>.</li>  *<li><em>Throws exceptions instead of returning null values.</em> Because some operations  *      (especially those that may permit the GZIP option) use IO streams, there  *      is a possiblity of an java.io.IOException being thrown. After some discussion and  *      thought, I've changed the behavior of the methods to throw java.io.IOExceptions  *      rather than return null if ever there's an error. I think this is more  *      appropriate, though it will require some changes to your code. Sorry,  *      it should have been done this way to begin with.</li>  *<li><em>Removed all references to System.out, System.err, and the like.</em>  *      Shame on me. All I can say is sorry they were ever there.</li>  *<li><em>Throws NullPointerExceptions and IllegalArgumentExceptions</em> as needed  *      such as when passed arrays are null or offsets are invalid.</li>  *<li>Cleaned up as much javadoc as I could to avoid any javadoc warnings.  *      This was especially annoying before for people who were thorough in their  *      own projects and then had gobs of javadoc warnings on this file.</li>  *</ul>  *<li>v2.2.1 - Fixed bug using URL_SAFE and ORDERED encodings. Fixed bug  *   when using very small files (~< 40 bytes).</li>  *<li>v2.2 - Added some helper methods for encoding/decoding directly from  *   one file to the next. Also added a main() method to support command line  *   encoding/decoding from one file to the next. Also added these Base64 dialects:  *<ol>  *<li>The default is RFC3548 format.</li>  *<li>Calling Base64.setFormat(Base64.BASE64_FORMAT.URLSAFE_FORMAT) generates  *   URL and file name friendly format as described in Section 4 of RFC3548.  *   http://www.faqs.org/rfcs/rfc3548.html</li>  *<li>Calling Base64.setFormat(Base64.BASE64_FORMAT.ORDERED_FORMAT) generates  *   URL and file name friendly format that preserves lexical ordering as described  *   in http://www.faqs.org/qa/rfcc-1940.html</li>  *</ol>  *   Special thanks to Jim Kellerman at<a href="http://www.powerset.com/">http://www.powerset.com/</a>  *   for contributing the new Base64 dialects.  *</li>  *   *<li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added  *   some convenience methods for reading and writing to and from files.</li>  *<li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems  *   with other encodings (like EBCDIC).</li>  *<li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the  *   encoded data was a single byte.</li>  *<li>v2.0 - I got rid of methods that used booleans to set options.   *   Now everything is more consolidated and cleaner. The code now detects  *   when data that's being decoded is gzip-compressed and will decompress it  *   automatically. Generally things are cleaner. You'll probably have to  *   change some method calls that you were making to support the new  *   options format (<tt>int</tt>s that you "OR" together).</li>  *<li>v1.5.1 - Fixed bug when decompressing and decoding to a               *   byte[] using<tt>decode( String s, boolean gzipCompressed )</tt>.        *   Added the ability to "suspend" encoding in the Output Stream so          *   you can turn on and off the encoding if you need to embed base64         *   data in an otherwise "normal" stream (like an XML file).</li>    *<li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.  *      This helps when using GZIP streams.  *      Added the ability to GZip-compress objects before encoding them.</li>  *<li>v1.4 - Added helper methods to read/write files.</li>  *<li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>  *<li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream  *      where last buffer being read, if not completely full, was not returned.</li>  *<li>v1.3.4 - Fixed when "improperly padded stream" error was thrown at the wrong time.</li>  *<li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>  *</ul>  *  *<p>  * I am placing this code in the Public Domain. Do with it as you will.  * This software comes with no guarantees or warranties but with  * plenty of well-wishing instead!  * Please visit<a href="http://iharder.net/base64">http://iharder.net/base64</a>  * periodically to check for updates or to contribute improvements.  *</p>  *  * @author Robert Harder  * @author rob@iharder.net  * @version 2.3.3  */
end_comment

begin_class
specifier|public
class|class
name|Base64
block|{
comment|/* ********  P U B L I C   F I E L D S  ******** */
comment|/** No options specified. Value is zero. */
specifier|public
specifier|final
specifier|static
name|int
name|NO_OPTIONS
init|=
literal|0
decl_stmt|;
comment|/** Specify encoding in first bit. Value is one. */
specifier|public
specifier|final
specifier|static
name|int
name|ENCODE
init|=
literal|1
decl_stmt|;
comment|/** Specify decoding in first bit. Value is zero. */
specifier|public
specifier|final
specifier|static
name|int
name|DECODE
init|=
literal|0
decl_stmt|;
comment|/** Specify that data should be gzip-compressed in second bit. Value is two. */
specifier|public
specifier|final
specifier|static
name|int
name|GZIP
init|=
literal|2
decl_stmt|;
comment|/** Specify that gzipped data should<em>not</em> be automatically gunzipped. */
specifier|public
specifier|final
specifier|static
name|int
name|DONT_GUNZIP
init|=
literal|4
decl_stmt|;
comment|/** Do break lines when encoding. Value is 8. */
specifier|public
specifier|final
specifier|static
name|int
name|DO_BREAK_LINES
init|=
literal|8
decl_stmt|;
comment|/**       * Encode using Base64-like encoding that is URL- and Filename-safe as described      * in Section 4 of RFC3548:       *<a href="http://www.faqs.org/rfcs/rfc3548.html">http://www.faqs.org/rfcs/rfc3548.html</a>.      * It is important to note that data encoded this way is<em>not</em> officially valid Base64,       * or at the very least should not be called Base64 without also specifying that is      * was encoded using the URL- and Filename-safe dialect.      */
specifier|public
specifier|final
specifier|static
name|int
name|URL_SAFE
init|=
literal|16
decl_stmt|;
comment|/**       * Encode using the special "ordered" dialect of Base64 described here:       *<a href="http://www.faqs.org/qa/rfcc-1940.html">http://www.faqs.org/qa/rfcc-1940.html</a>.       */
specifier|public
specifier|final
specifier|static
name|int
name|ORDERED
init|=
literal|32
decl_stmt|;
comment|/* ********  P R I V A T E   F I E L D S  ******** */
comment|/** Maximum line length (76) of Base64 output. */
specifier|private
specifier|final
specifier|static
name|int
name|MAX_LINE_LENGTH
init|=
literal|76
decl_stmt|;
comment|/** The equals sign (=) as a byte. */
specifier|private
specifier|final
specifier|static
name|byte
name|EQUALS_SIGN
init|=
operator|(
name|byte
operator|)
literal|'='
decl_stmt|;
comment|/** The new line character (\n) as a byte. */
specifier|private
specifier|final
specifier|static
name|byte
name|NEW_LINE
init|=
operator|(
name|byte
operator|)
literal|'\n'
decl_stmt|;
comment|/** Preferred encoding. */
specifier|private
specifier|final
specifier|static
name|String
name|PREFERRED_ENCODING
init|=
literal|"US-ASCII"
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|byte
name|WHITE_SPACE_ENC
init|=
operator|-
literal|5
decl_stmt|;
comment|// Indicates white space in encoding
specifier|private
specifier|final
specifier|static
name|byte
name|EQUALS_SIGN_ENC
init|=
operator|-
literal|1
decl_stmt|;
comment|// Indicates equals sign in encoding
comment|/* ********  S T A N D A R D   B A S E 6 4   A L P H A B E T  ******** */
comment|/** The 64 valid Base64 values. */
comment|/* Host platform me be something funny like EBCDIC, so we hardcode these values. */
specifier|private
specifier|final
specifier|static
name|byte
index|[]
name|_STANDARD_ALPHABET
init|=
block|{
operator|(
name|byte
operator|)
literal|'A'
block|,
operator|(
name|byte
operator|)
literal|'B'
block|,
operator|(
name|byte
operator|)
literal|'C'
block|,
operator|(
name|byte
operator|)
literal|'D'
block|,
operator|(
name|byte
operator|)
literal|'E'
block|,
operator|(
name|byte
operator|)
literal|'F'
block|,
operator|(
name|byte
operator|)
literal|'G'
block|,
operator|(
name|byte
operator|)
literal|'H'
block|,
operator|(
name|byte
operator|)
literal|'I'
block|,
operator|(
name|byte
operator|)
literal|'J'
block|,
operator|(
name|byte
operator|)
literal|'K'
block|,
operator|(
name|byte
operator|)
literal|'L'
block|,
operator|(
name|byte
operator|)
literal|'M'
block|,
operator|(
name|byte
operator|)
literal|'N'
block|,
operator|(
name|byte
operator|)
literal|'O'
block|,
operator|(
name|byte
operator|)
literal|'P'
block|,
operator|(
name|byte
operator|)
literal|'Q'
block|,
operator|(
name|byte
operator|)
literal|'R'
block|,
operator|(
name|byte
operator|)
literal|'S'
block|,
operator|(
name|byte
operator|)
literal|'T'
block|,
operator|(
name|byte
operator|)
literal|'U'
block|,
operator|(
name|byte
operator|)
literal|'V'
block|,
operator|(
name|byte
operator|)
literal|'W'
block|,
operator|(
name|byte
operator|)
literal|'X'
block|,
operator|(
name|byte
operator|)
literal|'Y'
block|,
operator|(
name|byte
operator|)
literal|'Z'
block|,
operator|(
name|byte
operator|)
literal|'a'
block|,
operator|(
name|byte
operator|)
literal|'b'
block|,
operator|(
name|byte
operator|)
literal|'c'
block|,
operator|(
name|byte
operator|)
literal|'d'
block|,
operator|(
name|byte
operator|)
literal|'e'
block|,
operator|(
name|byte
operator|)
literal|'f'
block|,
operator|(
name|byte
operator|)
literal|'g'
block|,
operator|(
name|byte
operator|)
literal|'h'
block|,
operator|(
name|byte
operator|)
literal|'i'
block|,
operator|(
name|byte
operator|)
literal|'j'
block|,
operator|(
name|byte
operator|)
literal|'k'
block|,
operator|(
name|byte
operator|)
literal|'l'
block|,
operator|(
name|byte
operator|)
literal|'m'
block|,
operator|(
name|byte
operator|)
literal|'n'
block|,
operator|(
name|byte
operator|)
literal|'o'
block|,
operator|(
name|byte
operator|)
literal|'p'
block|,
operator|(
name|byte
operator|)
literal|'q'
block|,
operator|(
name|byte
operator|)
literal|'r'
block|,
operator|(
name|byte
operator|)
literal|'s'
block|,
operator|(
name|byte
operator|)
literal|'t'
block|,
operator|(
name|byte
operator|)
literal|'u'
block|,
operator|(
name|byte
operator|)
literal|'v'
block|,
operator|(
name|byte
operator|)
literal|'w'
block|,
operator|(
name|byte
operator|)
literal|'x'
block|,
operator|(
name|byte
operator|)
literal|'y'
block|,
operator|(
name|byte
operator|)
literal|'z'
block|,
operator|(
name|byte
operator|)
literal|'0'
block|,
operator|(
name|byte
operator|)
literal|'1'
block|,
operator|(
name|byte
operator|)
literal|'2'
block|,
operator|(
name|byte
operator|)
literal|'3'
block|,
operator|(
name|byte
operator|)
literal|'4'
block|,
operator|(
name|byte
operator|)
literal|'5'
block|,
operator|(
name|byte
operator|)
literal|'6'
block|,
operator|(
name|byte
operator|)
literal|'7'
block|,
operator|(
name|byte
operator|)
literal|'8'
block|,
operator|(
name|byte
operator|)
literal|'9'
block|,
operator|(
name|byte
operator|)
literal|'+'
block|,
operator|(
name|byte
operator|)
literal|'/'
block|}
decl_stmt|;
comment|/**       * Translates a Base64 value to either its 6-bit reconstruction value      * or a negative number indicating some other meaning.      **/
specifier|private
specifier|final
specifier|static
name|byte
index|[]
name|_STANDARD_DECODABET
init|=
block|{
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
comment|// Decimal  0 -  8
operator|-
literal|5
block|,
operator|-
literal|5
block|,
comment|// Whitespace: Tab and Linefeed
operator|-
literal|9
block|,
operator|-
literal|9
block|,
comment|// Decimal 11 - 12
operator|-
literal|5
block|,
comment|// Whitespace: Carriage Return
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
comment|// Decimal 14 - 26
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
comment|// Decimal 27 - 31
operator|-
literal|5
block|,
comment|// Whitespace: Space
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
comment|// Decimal 33 - 42
literal|62
block|,
comment|// Plus sign at decimal 43
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
comment|// Decimal 44 - 46
literal|63
block|,
comment|// Slash at decimal 47
literal|52
block|,
literal|53
block|,
literal|54
block|,
literal|55
block|,
literal|56
block|,
literal|57
block|,
literal|58
block|,
literal|59
block|,
literal|60
block|,
literal|61
block|,
comment|// Numbers zero through nine
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
comment|// Decimal 58 - 60
operator|-
literal|1
block|,
comment|// Equals sign at decimal 61
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
comment|// Decimal 62 - 64
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
comment|// Letters 'A' through 'N'
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
comment|// Letters 'O' through 'Z'
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
comment|// Decimal 91 - 96
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
comment|// Letters 'a' through 'm'
literal|39
block|,
literal|40
block|,
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|48
block|,
literal|49
block|,
literal|50
block|,
literal|51
block|,
comment|// Letters 'n' through 'z'
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
comment|// Decimal 123 - 126
comment|/*,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 127 - 139         -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152         -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165         -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178         -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191         -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204         -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217         -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230         -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243         -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 */
block|}
decl_stmt|;
comment|/* ********  U R L   S A F E   B A S E 6 4   A L P H A B E T  ******** */
comment|/**      * Used in the URL- and Filename-safe dialect described in Section 4 of RFC3548:       *<a href="http://www.faqs.org/rfcs/rfc3548.html">http://www.faqs.org/rfcs/rfc3548.html</a>.      * Notice that the last two bytes become "hyphen" and "underscore" instead of "plus" and "slash."      */
specifier|private
specifier|final
specifier|static
name|byte
index|[]
name|_URL_SAFE_ALPHABET
init|=
block|{
operator|(
name|byte
operator|)
literal|'A'
block|,
operator|(
name|byte
operator|)
literal|'B'
block|,
operator|(
name|byte
operator|)
literal|'C'
block|,
operator|(
name|byte
operator|)
literal|'D'
block|,
operator|(
name|byte
operator|)
literal|'E'
block|,
operator|(
name|byte
operator|)
literal|'F'
block|,
operator|(
name|byte
operator|)
literal|'G'
block|,
operator|(
name|byte
operator|)
literal|'H'
block|,
operator|(
name|byte
operator|)
literal|'I'
block|,
operator|(
name|byte
operator|)
literal|'J'
block|,
operator|(
name|byte
operator|)
literal|'K'
block|,
operator|(
name|byte
operator|)
literal|'L'
block|,
operator|(
name|byte
operator|)
literal|'M'
block|,
operator|(
name|byte
operator|)
literal|'N'
block|,
operator|(
name|byte
operator|)
literal|'O'
block|,
operator|(
name|byte
operator|)
literal|'P'
block|,
operator|(
name|byte
operator|)
literal|'Q'
block|,
operator|(
name|byte
operator|)
literal|'R'
block|,
operator|(
name|byte
operator|)
literal|'S'
block|,
operator|(
name|byte
operator|)
literal|'T'
block|,
operator|(
name|byte
operator|)
literal|'U'
block|,
operator|(
name|byte
operator|)
literal|'V'
block|,
operator|(
name|byte
operator|)
literal|'W'
block|,
operator|(
name|byte
operator|)
literal|'X'
block|,
operator|(
name|byte
operator|)
literal|'Y'
block|,
operator|(
name|byte
operator|)
literal|'Z'
block|,
operator|(
name|byte
operator|)
literal|'a'
block|,
operator|(
name|byte
operator|)
literal|'b'
block|,
operator|(
name|byte
operator|)
literal|'c'
block|,
operator|(
name|byte
operator|)
literal|'d'
block|,
operator|(
name|byte
operator|)
literal|'e'
block|,
operator|(
name|byte
operator|)
literal|'f'
block|,
operator|(
name|byte
operator|)
literal|'g'
block|,
operator|(
name|byte
operator|)
literal|'h'
block|,
operator|(
name|byte
operator|)
literal|'i'
block|,
operator|(
name|byte
operator|)
literal|'j'
block|,
operator|(
name|byte
operator|)
literal|'k'
block|,
operator|(
name|byte
operator|)
literal|'l'
block|,
operator|(
name|byte
operator|)
literal|'m'
block|,
operator|(
name|byte
operator|)
literal|'n'
block|,
operator|(
name|byte
operator|)
literal|'o'
block|,
operator|(
name|byte
operator|)
literal|'p'
block|,
operator|(
name|byte
operator|)
literal|'q'
block|,
operator|(
name|byte
operator|)
literal|'r'
block|,
operator|(
name|byte
operator|)
literal|'s'
block|,
operator|(
name|byte
operator|)
literal|'t'
block|,
operator|(
name|byte
operator|)
literal|'u'
block|,
operator|(
name|byte
operator|)
literal|'v'
block|,
operator|(
name|byte
operator|)
literal|'w'
block|,
operator|(
name|byte
operator|)
literal|'x'
block|,
operator|(
name|byte
operator|)
literal|'y'
block|,
operator|(
name|byte
operator|)
literal|'z'
block|,
operator|(
name|byte
operator|)
literal|'0'
block|,
operator|(
name|byte
operator|)
literal|'1'
block|,
operator|(
name|byte
operator|)
literal|'2'
block|,
operator|(
name|byte
operator|)
literal|'3'
block|,
operator|(
name|byte
operator|)
literal|'4'
block|,
operator|(
name|byte
operator|)
literal|'5'
block|,
operator|(
name|byte
operator|)
literal|'6'
block|,
operator|(
name|byte
operator|)
literal|'7'
block|,
operator|(
name|byte
operator|)
literal|'8'
block|,
operator|(
name|byte
operator|)
literal|'9'
block|,
operator|(
name|byte
operator|)
literal|'-'
block|,
operator|(
name|byte
operator|)
literal|'_'
block|}
decl_stmt|;
comment|/**      * Used in decoding URL- and Filename-safe dialects of Base64.      */
specifier|private
specifier|final
specifier|static
name|byte
index|[]
name|_URL_SAFE_DECODABET
init|=
block|{
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
comment|// Decimal  0 -  8
operator|-
literal|5
block|,
operator|-
literal|5
block|,
comment|// Whitespace: Tab and Linefeed
operator|-
literal|9
block|,
operator|-
literal|9
block|,
comment|// Decimal 11 - 12
operator|-
literal|5
block|,
comment|// Whitespace: Carriage Return
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
comment|// Decimal 14 - 26
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
comment|// Decimal 27 - 31
operator|-
literal|5
block|,
comment|// Whitespace: Space
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
comment|// Decimal 33 - 42
operator|-
literal|9
block|,
comment|// Plus sign at decimal 43
operator|-
literal|9
block|,
comment|// Decimal 44
literal|62
block|,
comment|// Minus sign at decimal 45
operator|-
literal|9
block|,
comment|// Decimal 46
operator|-
literal|9
block|,
comment|// Slash at decimal 47
literal|52
block|,
literal|53
block|,
literal|54
block|,
literal|55
block|,
literal|56
block|,
literal|57
block|,
literal|58
block|,
literal|59
block|,
literal|60
block|,
literal|61
block|,
comment|// Numbers zero through nine
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
comment|// Decimal 58 - 60
operator|-
literal|1
block|,
comment|// Equals sign at decimal 61
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
comment|// Decimal 62 - 64
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
comment|// Letters 'A' through 'N'
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
comment|// Letters 'O' through 'Z'
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
comment|// Decimal 91 - 94
literal|63
block|,
comment|// Underscore at decimal 95
operator|-
literal|9
block|,
comment|// Decimal 96
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
comment|// Letters 'a' through 'm'
literal|39
block|,
literal|40
block|,
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|48
block|,
literal|49
block|,
literal|50
block|,
literal|51
block|,
comment|// Letters 'n' through 'z'
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
comment|// Decimal 123 - 126
comment|/*,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 127 - 139       -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152       -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165       -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178       -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191       -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204       -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217       -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230       -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243       -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 */
block|}
decl_stmt|;
comment|/* ********  O R D E R E D   B A S E 6 4   A L P H A B E T  ******** */
comment|/**      * I don't get the point of this technique, but someone requested it,      * and it is described here:      *<a href="http://www.faqs.org/qa/rfcc-1940.html">http://www.faqs.org/qa/rfcc-1940.html</a>.      */
specifier|private
specifier|final
specifier|static
name|byte
index|[]
name|_ORDERED_ALPHABET
init|=
block|{
operator|(
name|byte
operator|)
literal|'-'
block|,
operator|(
name|byte
operator|)
literal|'0'
block|,
operator|(
name|byte
operator|)
literal|'1'
block|,
operator|(
name|byte
operator|)
literal|'2'
block|,
operator|(
name|byte
operator|)
literal|'3'
block|,
operator|(
name|byte
operator|)
literal|'4'
block|,
operator|(
name|byte
operator|)
literal|'5'
block|,
operator|(
name|byte
operator|)
literal|'6'
block|,
operator|(
name|byte
operator|)
literal|'7'
block|,
operator|(
name|byte
operator|)
literal|'8'
block|,
operator|(
name|byte
operator|)
literal|'9'
block|,
operator|(
name|byte
operator|)
literal|'A'
block|,
operator|(
name|byte
operator|)
literal|'B'
block|,
operator|(
name|byte
operator|)
literal|'C'
block|,
operator|(
name|byte
operator|)
literal|'D'
block|,
operator|(
name|byte
operator|)
literal|'E'
block|,
operator|(
name|byte
operator|)
literal|'F'
block|,
operator|(
name|byte
operator|)
literal|'G'
block|,
operator|(
name|byte
operator|)
literal|'H'
block|,
operator|(
name|byte
operator|)
literal|'I'
block|,
operator|(
name|byte
operator|)
literal|'J'
block|,
operator|(
name|byte
operator|)
literal|'K'
block|,
operator|(
name|byte
operator|)
literal|'L'
block|,
operator|(
name|byte
operator|)
literal|'M'
block|,
operator|(
name|byte
operator|)
literal|'N'
block|,
operator|(
name|byte
operator|)
literal|'O'
block|,
operator|(
name|byte
operator|)
literal|'P'
block|,
operator|(
name|byte
operator|)
literal|'Q'
block|,
operator|(
name|byte
operator|)
literal|'R'
block|,
operator|(
name|byte
operator|)
literal|'S'
block|,
operator|(
name|byte
operator|)
literal|'T'
block|,
operator|(
name|byte
operator|)
literal|'U'
block|,
operator|(
name|byte
operator|)
literal|'V'
block|,
operator|(
name|byte
operator|)
literal|'W'
block|,
operator|(
name|byte
operator|)
literal|'X'
block|,
operator|(
name|byte
operator|)
literal|'Y'
block|,
operator|(
name|byte
operator|)
literal|'Z'
block|,
operator|(
name|byte
operator|)
literal|'_'
block|,
operator|(
name|byte
operator|)
literal|'a'
block|,
operator|(
name|byte
operator|)
literal|'b'
block|,
operator|(
name|byte
operator|)
literal|'c'
block|,
operator|(
name|byte
operator|)
literal|'d'
block|,
operator|(
name|byte
operator|)
literal|'e'
block|,
operator|(
name|byte
operator|)
literal|'f'
block|,
operator|(
name|byte
operator|)
literal|'g'
block|,
operator|(
name|byte
operator|)
literal|'h'
block|,
operator|(
name|byte
operator|)
literal|'i'
block|,
operator|(
name|byte
operator|)
literal|'j'
block|,
operator|(
name|byte
operator|)
literal|'k'
block|,
operator|(
name|byte
operator|)
literal|'l'
block|,
operator|(
name|byte
operator|)
literal|'m'
block|,
operator|(
name|byte
operator|)
literal|'n'
block|,
operator|(
name|byte
operator|)
literal|'o'
block|,
operator|(
name|byte
operator|)
literal|'p'
block|,
operator|(
name|byte
operator|)
literal|'q'
block|,
operator|(
name|byte
operator|)
literal|'r'
block|,
operator|(
name|byte
operator|)
literal|'s'
block|,
operator|(
name|byte
operator|)
literal|'t'
block|,
operator|(
name|byte
operator|)
literal|'u'
block|,
operator|(
name|byte
operator|)
literal|'v'
block|,
operator|(
name|byte
operator|)
literal|'w'
block|,
operator|(
name|byte
operator|)
literal|'x'
block|,
operator|(
name|byte
operator|)
literal|'y'
block|,
operator|(
name|byte
operator|)
literal|'z'
block|}
decl_stmt|;
comment|/**      * Used in decoding the "ordered" dialect of Base64.      */
specifier|private
specifier|final
specifier|static
name|byte
index|[]
name|_ORDERED_DECODABET
init|=
block|{
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
comment|// Decimal  0 -  8
operator|-
literal|5
block|,
operator|-
literal|5
block|,
comment|// Whitespace: Tab and Linefeed
operator|-
literal|9
block|,
operator|-
literal|9
block|,
comment|// Decimal 11 - 12
operator|-
literal|5
block|,
comment|// Whitespace: Carriage Return
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
comment|// Decimal 14 - 26
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
comment|// Decimal 27 - 31
operator|-
literal|5
block|,
comment|// Whitespace: Space
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
comment|// Decimal 33 - 42
operator|-
literal|9
block|,
comment|// Plus sign at decimal 43
operator|-
literal|9
block|,
comment|// Decimal 44
literal|0
block|,
comment|// Minus sign at decimal 45
operator|-
literal|9
block|,
comment|// Decimal 46
operator|-
literal|9
block|,
comment|// Slash at decimal 47
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
comment|// Numbers zero through nine
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
comment|// Decimal 58 - 60
operator|-
literal|1
block|,
comment|// Equals sign at decimal 61
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
comment|// Decimal 62 - 64
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
comment|// Letters 'A' through 'M'
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
comment|// Letters 'N' through 'Z'
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
comment|// Decimal 91 - 94
literal|37
block|,
comment|// Underscore at decimal 95
operator|-
literal|9
block|,
comment|// Decimal 96
literal|38
block|,
literal|39
block|,
literal|40
block|,
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|48
block|,
literal|49
block|,
literal|50
block|,
comment|// Letters 'a' through 'm'
literal|51
block|,
literal|52
block|,
literal|53
block|,
literal|54
block|,
literal|55
block|,
literal|56
block|,
literal|57
block|,
literal|58
block|,
literal|59
block|,
literal|60
block|,
literal|61
block|,
literal|62
block|,
literal|63
block|,
comment|// Letters 'n' through 'z'
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|9
comment|// Decimal 123 - 126
comment|/*,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 127 - 139         -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152         -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165         -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178         -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191         -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204         -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217         -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230         -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243         -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 */
block|}
decl_stmt|;
comment|/* ********  D E T E R M I N E   W H I C H   A L H A B E T  ******** */
comment|/**      * Returns one of the _SOMETHING_ALPHABET byte arrays depending on      * the options specified.      * It's possible, though silly, to specify ORDERED<b>and</b> URLSAFE      * in which case one of them will be picked, though there is      * no guarantee as to which one will be picked.      */
specifier|private
specifier|final
specifier|static
name|byte
index|[]
name|getAlphabet
parameter_list|(
name|int
name|options
parameter_list|)
block|{
if|if
condition|(
operator|(
name|options
operator|&
name|URL_SAFE
operator|)
operator|==
name|URL_SAFE
condition|)
block|{
return|return
name|_URL_SAFE_ALPHABET
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|options
operator|&
name|ORDERED
operator|)
operator|==
name|ORDERED
condition|)
block|{
return|return
name|_ORDERED_ALPHABET
return|;
block|}
else|else
block|{
return|return
name|_STANDARD_ALPHABET
return|;
block|}
block|}
comment|// end getAlphabet
comment|/**      * Returns one of the _SOMETHING_DECODABET byte arrays depending on      * the options specified.      * It's possible, though silly, to specify ORDERED and URL_SAFE      * in which case one of them will be picked, though there is      * no guarantee as to which one will be picked.      */
specifier|private
specifier|final
specifier|static
name|byte
index|[]
name|getDecodabet
parameter_list|(
name|int
name|options
parameter_list|)
block|{
if|if
condition|(
operator|(
name|options
operator|&
name|URL_SAFE
operator|)
operator|==
name|URL_SAFE
condition|)
block|{
return|return
name|_URL_SAFE_DECODABET
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|options
operator|&
name|ORDERED
operator|)
operator|==
name|ORDERED
condition|)
block|{
return|return
name|_ORDERED_DECODABET
return|;
block|}
else|else
block|{
return|return
name|_STANDARD_DECODABET
return|;
block|}
block|}
comment|// end getAlphabet
comment|/** Defeats instantiation. */
specifier|private
name|Base64
parameter_list|()
block|{}
comment|/* ********  E N C O D I N G   M E T H O D S  ******** */
comment|/**      * Encodes up to the first three bytes of array<var>threeBytes</var>      * and returns a four-byte array in Base64 notation.      * The actual number of significant bytes in your array is      * given by<var>numSigBytes</var>.      * The array<var>threeBytes</var> needs only be as big as      *<var>numSigBytes</var>.      * Code can reuse a byte array by passing a four-byte array as<var>b4</var>.      *      * @param b4 A reusable byte array to reduce array instantiation      * @param threeBytes the array to convert      * @param numSigBytes the number of significant bytes in your array      * @return four byte array in Base64 notation.      * @since 1.5.1      */
specifier|private
specifier|static
name|byte
index|[]
name|encode3to4
parameter_list|(
name|byte
index|[]
name|b4
parameter_list|,
name|byte
index|[]
name|threeBytes
parameter_list|,
name|int
name|numSigBytes
parameter_list|,
name|int
name|options
parameter_list|)
block|{
name|encode3to4
argument_list|(
name|threeBytes
argument_list|,
literal|0
argument_list|,
name|numSigBytes
argument_list|,
name|b4
argument_list|,
literal|0
argument_list|,
name|options
argument_list|)
expr_stmt|;
return|return
name|b4
return|;
block|}
comment|// end encode3to4
comment|/**      *<p>Encodes up to three bytes of the array<var>source</var>      * and writes the resulting four Base64 bytes to<var>destination</var>.      * The source and destination arrays can be manipulated      * anywhere along their length by specifying       *<var>srcOffset</var> and<var>destOffset</var>.      * This method does not check to make sure your arrays      * are large enough to accomodate<var>srcOffset</var> + 3 for      * the<var>source</var> array or<var>destOffset</var> + 4 for      * the<var>destination</var> array.      * The actual number of significant bytes in your array is      * given by<var>numSigBytes</var>.</p> 	 *<p>This is the lowest level of the encoding methods with 	 * all possible parameters.</p>      *      * @param source the array to convert      * @param srcOffset the index where conversion begins      * @param numSigBytes the number of significant bytes in your array      * @param destination the array to hold the conversion      * @param destOffset the index where output will be put      * @return the<var>destination</var> array      * @since 1.3      */
specifier|private
specifier|static
name|byte
index|[]
name|encode3to4
parameter_list|(
name|byte
index|[]
name|source
parameter_list|,
name|int
name|srcOffset
parameter_list|,
name|int
name|numSigBytes
parameter_list|,
name|byte
index|[]
name|destination
parameter_list|,
name|int
name|destOffset
parameter_list|,
name|int
name|options
parameter_list|)
block|{
name|byte
index|[]
name|ALPHABET
init|=
name|getAlphabet
argument_list|(
name|options
argument_list|)
decl_stmt|;
comment|//           1         2         3
comment|// 01234567890123456789012345678901 Bit position
comment|// --------000000001111111122222222 Array position from threeBytes
comment|// --------|    ||    ||    ||    | Six bit groups to index ALPHABET
comment|//>>18>>12>> 6>> 0  Right shift necessary
comment|//                0x3f  0x3f  0x3f  Additional AND
comment|// Create buffer with zero-padding if there are only one or two
comment|// significant bytes passed in the array.
comment|// We have to shift left 24 in order to flush out the 1's that appear
comment|// when Java treats a value as negative that is cast from a byte to an int.
name|int
name|inBuff
init|=
operator|(
name|numSigBytes
operator|>
literal|0
condition|?
operator|(
operator|(
name|source
index|[
name|srcOffset
index|]
operator|<<
literal|24
operator|)
operator|>>>
literal|8
operator|)
else|:
literal|0
operator|)
operator||
operator|(
name|numSigBytes
operator|>
literal|1
condition|?
operator|(
operator|(
name|source
index|[
name|srcOffset
operator|+
literal|1
index|]
operator|<<
literal|24
operator|)
operator|>>>
literal|16
operator|)
else|:
literal|0
operator|)
operator||
operator|(
name|numSigBytes
operator|>
literal|2
condition|?
operator|(
operator|(
name|source
index|[
name|srcOffset
operator|+
literal|2
index|]
operator|<<
literal|24
operator|)
operator|>>>
literal|24
operator|)
else|:
literal|0
operator|)
decl_stmt|;
switch|switch
condition|(
name|numSigBytes
condition|)
block|{
case|case
literal|3
case|:
name|destination
index|[
name|destOffset
index|]
operator|=
name|ALPHABET
index|[
operator|(
name|inBuff
operator|>>>
literal|18
operator|)
index|]
expr_stmt|;
name|destination
index|[
name|destOffset
operator|+
literal|1
index|]
operator|=
name|ALPHABET
index|[
operator|(
name|inBuff
operator|>>>
literal|12
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
name|destination
index|[
name|destOffset
operator|+
literal|2
index|]
operator|=
name|ALPHABET
index|[
operator|(
name|inBuff
operator|>>>
literal|6
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
name|destination
index|[
name|destOffset
operator|+
literal|3
index|]
operator|=
name|ALPHABET
index|[
operator|(
name|inBuff
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
return|return
name|destination
return|;
case|case
literal|2
case|:
name|destination
index|[
name|destOffset
index|]
operator|=
name|ALPHABET
index|[
operator|(
name|inBuff
operator|>>>
literal|18
operator|)
index|]
expr_stmt|;
name|destination
index|[
name|destOffset
operator|+
literal|1
index|]
operator|=
name|ALPHABET
index|[
operator|(
name|inBuff
operator|>>>
literal|12
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
name|destination
index|[
name|destOffset
operator|+
literal|2
index|]
operator|=
name|ALPHABET
index|[
operator|(
name|inBuff
operator|>>>
literal|6
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
name|destination
index|[
name|destOffset
operator|+
literal|3
index|]
operator|=
name|EQUALS_SIGN
expr_stmt|;
return|return
name|destination
return|;
case|case
literal|1
case|:
name|destination
index|[
name|destOffset
index|]
operator|=
name|ALPHABET
index|[
operator|(
name|inBuff
operator|>>>
literal|18
operator|)
index|]
expr_stmt|;
name|destination
index|[
name|destOffset
operator|+
literal|1
index|]
operator|=
name|ALPHABET
index|[
operator|(
name|inBuff
operator|>>>
literal|12
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
name|destination
index|[
name|destOffset
operator|+
literal|2
index|]
operator|=
name|EQUALS_SIGN
expr_stmt|;
name|destination
index|[
name|destOffset
operator|+
literal|3
index|]
operator|=
name|EQUALS_SIGN
expr_stmt|;
return|return
name|destination
return|;
default|default:
return|return
name|destination
return|;
block|}
comment|// end switch
block|}
comment|// end encode3to4
comment|/**      * Performs Base64 encoding on the<code>raw</code> ByteBuffer,      * writing it to the<code>encoded</code> ByteBuffer.      * This is an experimental feature. Currently it does not      * pass along any options (such as {@link #DO_BREAK_LINES}      * or {@link #GZIP}.      *      * @param raw input buffer      * @param encoded output buffer      * @since 2.3      */
specifier|public
specifier|static
name|void
name|encode
parameter_list|(
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
name|raw
parameter_list|,
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
name|encoded
parameter_list|)
block|{
name|byte
index|[]
name|raw3
init|=
operator|new
name|byte
index|[
literal|3
index|]
decl_stmt|;
name|byte
index|[]
name|enc4
init|=
operator|new
name|byte
index|[
literal|4
index|]
decl_stmt|;
while|while
condition|(
name|raw
operator|.
name|hasRemaining
argument_list|()
condition|)
block|{
name|int
name|rem
init|=
name|Math
operator|.
name|min
argument_list|(
literal|3
argument_list|,
name|raw
operator|.
name|remaining
argument_list|()
argument_list|)
decl_stmt|;
name|raw
operator|.
name|get
argument_list|(
name|raw3
argument_list|,
literal|0
argument_list|,
name|rem
argument_list|)
expr_stmt|;
name|Base64
operator|.
name|encode3to4
argument_list|(
name|enc4
argument_list|,
name|raw3
argument_list|,
name|rem
argument_list|,
name|Base64
operator|.
name|NO_OPTIONS
argument_list|)
expr_stmt|;
name|encoded
operator|.
name|put
argument_list|(
name|enc4
argument_list|)
expr_stmt|;
block|}
comment|// end input remaining
block|}
comment|/**      * Performs Base64 encoding on the<code>raw</code> ByteBuffer,      * writing it to the<code>encoded</code> CharBuffer.      * This is an experimental feature. Currently it does not      * pass along any options (such as {@link #DO_BREAK_LINES}      * or {@link #GZIP}.      *      * @param raw input buffer      * @param encoded output buffer      * @since 2.3      */
specifier|public
specifier|static
name|void
name|encode
parameter_list|(
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
name|raw
parameter_list|,
name|java
operator|.
name|nio
operator|.
name|CharBuffer
name|encoded
parameter_list|)
block|{
name|byte
index|[]
name|raw3
init|=
operator|new
name|byte
index|[
literal|3
index|]
decl_stmt|;
name|byte
index|[]
name|enc4
init|=
operator|new
name|byte
index|[
literal|4
index|]
decl_stmt|;
while|while
condition|(
name|raw
operator|.
name|hasRemaining
argument_list|()
condition|)
block|{
name|int
name|rem
init|=
name|Math
operator|.
name|min
argument_list|(
literal|3
argument_list|,
name|raw
operator|.
name|remaining
argument_list|()
argument_list|)
decl_stmt|;
name|raw
operator|.
name|get
argument_list|(
name|raw3
argument_list|,
literal|0
argument_list|,
name|rem
argument_list|)
expr_stmt|;
name|Base64
operator|.
name|encode3to4
argument_list|(
name|enc4
argument_list|,
name|raw3
argument_list|,
name|rem
argument_list|,
name|Base64
operator|.
name|NO_OPTIONS
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|encoded
operator|.
name|put
argument_list|(
call|(
name|char
call|)
argument_list|(
name|enc4
index|[
name|i
index|]
operator|&
literal|0xFF
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// end input remaining
block|}
comment|/**      * Serializes an object and returns the Base64-encoded      * version of that serialized object.        *        *<p>As of v 2.3, if the object      * cannot be serialized or there is another error,      * the method will throw an java.io.IOException.<b>This is new to v2.3!</b>      * In earlier versions, it just returned a null value, but      * in retrospect that's a pretty poor way to handle it.</p>      *       * The object is not GZip-compressed before being encoded.      *      * @param serializableObject The object to encode      * @return The Base64-encoded object      * @throws java.io.IOException if there is an error      * @throws NullPointerException if serializedObject is null      * @since 1.4      */
specifier|public
specifier|static
name|String
name|encodeObject
parameter_list|(
name|java
operator|.
name|io
operator|.
name|Serializable
name|serializableObject
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
block|{
return|return
name|encodeObject
argument_list|(
name|serializableObject
argument_list|,
name|NO_OPTIONS
argument_list|)
return|;
block|}
comment|// end encodeObject
comment|/**      * Serializes an object and returns the Base64-encoded      * version of that serialized object.      *        *<p>As of v 2.3, if the object      * cannot be serialized or there is another error,      * the method will throw an java.io.IOException.<b>This is new to v2.3!</b>      * In earlier versions, it just returned a null value, but      * in retrospect that's a pretty poor way to handle it.</p>      *       * The object is not GZip-compressed before being encoded.      *<p>      * Example options:<pre>      *   GZIP: gzip-compresses object before encoding it.      *   DO_BREAK_LINES: break lines at 76 characters      *</pre>      *<p>      * Example:<code>encodeObject( myObj, Base64.GZIP )</code> or      *<p>      * Example:<code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>      *      * @param serializableObject The object to encode      * @param options Specified options      * @return The Base64-encoded object      * @see Base64#GZIP      * @see Base64#DO_BREAK_LINES      * @throws java.io.IOException if there is an error      * @since 2.0      */
specifier|public
specifier|static
name|String
name|encodeObject
parameter_list|(
name|java
operator|.
name|io
operator|.
name|Serializable
name|serializableObject
parameter_list|,
name|int
name|options
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
block|{
if|if
condition|(
name|serializableObject
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"Cannot serialize a null object."
argument_list|)
throw|;
block|}
comment|// end if: null
comment|// Streams
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
name|baos
init|=
literal|null
decl_stmt|;
name|java
operator|.
name|io
operator|.
name|OutputStream
name|b64os
init|=
literal|null
decl_stmt|;
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|GZIPOutputStream
name|gzos
init|=
literal|null
decl_stmt|;
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
name|oos
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream
name|baos
operator|=
operator|new
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
argument_list|()
expr_stmt|;
name|b64os
operator|=
operator|new
name|Base64
operator|.
name|OutputStream
argument_list|(
name|baos
argument_list|,
name|ENCODE
operator||
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|GZIP
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// Gzip
name|gzos
operator|=
operator|new
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|GZIPOutputStream
argument_list|(
name|b64os
argument_list|)
expr_stmt|;
name|oos
operator|=
operator|new
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
argument_list|(
name|gzos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Not gzipped
name|oos
operator|=
operator|new
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
argument_list|(
name|b64os
argument_list|)
expr_stmt|;
block|}
name|oos
operator|.
name|writeObject
argument_list|(
name|serializableObject
argument_list|)
expr_stmt|;
block|}
comment|// end try
catch|catch
parameter_list|(
name|java
operator|.
name|io
operator|.
name|IOException
name|e
parameter_list|)
block|{
comment|// Catch it and then throw it immediately so that
comment|// the finally{} block is called for cleanup.
throw|throw
name|e
throw|;
block|}
comment|// end catch
finally|finally
block|{
try|try
block|{
name|oos
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{}
try|try
block|{
name|gzos
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{}
try|try
block|{
name|b64os
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{}
try|try
block|{
name|baos
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{}
block|}
comment|// end finally
comment|// Return value according to relevant encoding.
try|try
block|{
return|return
operator|new
name|String
argument_list|(
name|baos
operator|.
name|toByteArray
argument_list|()
argument_list|,
name|PREFERRED_ENCODING
argument_list|)
return|;
block|}
comment|// end try
catch|catch
parameter_list|(
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
name|uue
parameter_list|)
block|{
comment|// Fall back to some Java default
return|return
operator|new
name|String
argument_list|(
name|baos
operator|.
name|toByteArray
argument_list|()
argument_list|)
return|;
block|}
comment|// end catch
block|}
comment|// end encode
comment|/**      * Encodes a byte array into Base64 notation.      * Does not GZip-compress data.      *        * @param source The data to convert      * @return The data in Base64-encoded form      * @throws NullPointerException if source array is null      * @since 1.4      */
specifier|public
specifier|static
name|String
name|encodeBytes
parameter_list|(
name|byte
index|[]
name|source
parameter_list|)
block|{
comment|// Since we're not going to have the GZIP encoding turned on,
comment|// we're not going to have an java.io.IOException thrown, so
comment|// we should not force the user to have to catch it.
name|String
name|encoded
init|=
literal|null
decl_stmt|;
try|try
block|{
name|encoded
operator|=
name|encodeBytes
argument_list|(
name|source
argument_list|,
literal|0
argument_list|,
name|source
operator|.
name|length
argument_list|,
name|NO_OPTIONS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|io
operator|.
name|IOException
name|ex
parameter_list|)
block|{
assert|assert
literal|false
operator|:
name|ex
operator|.
name|getMessage
argument_list|()
assert|;
block|}
comment|// end catch
assert|assert
name|encoded
operator|!=
literal|null
assert|;
return|return
name|encoded
return|;
block|}
comment|// end encodeBytes
comment|/**      * Encodes a byte array into Base64 notation.      *<p>      * Example options:<pre>      *   GZIP: gzip-compresses object before encoding it.      *   DO_BREAK_LINES: break lines at 76 characters      *<i>Note: Technically, this makes your encoding non-compliant.</i>      *</pre>      *<p>      * Example:<code>encodeBytes( myData, Base64.GZIP )</code> or      *<p>      * Example:<code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>      *      *        *<p>As of v 2.3, if there is an error with the GZIP stream,      * the method will throw an java.io.IOException.<b>This is new to v2.3!</b>      * In earlier versions, it just returned a null value, but      * in retrospect that's a pretty poor way to handle it.</p>      *       *      * @param source The data to convert      * @param options Specified options      * @return The Base64-encoded data as a String      * @see Base64#GZIP      * @see Base64#DO_BREAK_LINES      * @throws java.io.IOException if there is an error      * @throws NullPointerException if source array is null      * @since 2.0      */
specifier|public
specifier|static
name|String
name|encodeBytes
parameter_list|(
name|byte
index|[]
name|source
parameter_list|,
name|int
name|options
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
block|{
return|return
name|encodeBytes
argument_list|(
name|source
argument_list|,
literal|0
argument_list|,
name|source
operator|.
name|length
argument_list|,
name|options
argument_list|)
return|;
block|}
comment|// end encodeBytes
comment|/**      * Encodes a byte array into Base64 notation.      * Does not GZip-compress data.      *        *<p>As of v 2.3, if there is an error,      * the method will throw an java.io.IOException.<b>This is new to v2.3!</b>      * In earlier versions, it just returned a null value, but      * in retrospect that's a pretty poor way to handle it.</p>      *       *      * @param source The data to convert      * @param off Offset in array where conversion should begin      * @param len Length of data to convert      * @return The Base64-encoded data as a String      * @throws NullPointerException if source array is null      * @throws IllegalArgumentException if source array, offset, or length are invalid      * @since 1.4      */
specifier|public
specifier|static
name|String
name|encodeBytes
parameter_list|(
name|byte
index|[]
name|source
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
block|{
comment|// Since we're not going to have the GZIP encoding turned on,
comment|// we're not going to have an java.io.IOException thrown, so
comment|// we should not force the user to have to catch it.
name|String
name|encoded
init|=
literal|null
decl_stmt|;
try|try
block|{
name|encoded
operator|=
name|encodeBytes
argument_list|(
name|source
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|NO_OPTIONS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|io
operator|.
name|IOException
name|ex
parameter_list|)
block|{
assert|assert
literal|false
operator|:
name|ex
operator|.
name|getMessage
argument_list|()
assert|;
block|}
comment|// end catch
assert|assert
name|encoded
operator|!=
literal|null
assert|;
return|return
name|encoded
return|;
block|}
comment|// end encodeBytes
comment|/**      * Encodes a byte array into Base64 notation.      *<p>      * Example options:<pre>      *   GZIP: gzip-compresses object before encoding it.      *   DO_BREAK_LINES: break lines at 76 characters      *<i>Note: Technically, this makes your encoding non-compliant.</i>      *</pre>      *<p>      * Example:<code>encodeBytes( myData, Base64.GZIP )</code> or      *<p>      * Example:<code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>      *      *        *<p>As of v 2.3, if there is an error with the GZIP stream,      * the method will throw an java.io.IOException.<b>This is new to v2.3!</b>      * In earlier versions, it just returned a null value, but      * in retrospect that's a pretty poor way to handle it.</p>      *       *      * @param source The data to convert      * @param off Offset in array where conversion should begin      * @param len Length of data to convert      * @param options Specified options      * @return The Base64-encoded data as a String      * @see Base64#GZIP      * @see Base64#DO_BREAK_LINES      * @throws java.io.IOException if there is an error      * @throws NullPointerException if source array is null      * @throws IllegalArgumentException if source array, offset, or length are invalid      * @since 2.0      */
specifier|public
specifier|static
name|String
name|encodeBytes
parameter_list|(
name|byte
index|[]
name|source
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|options
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
block|{
name|byte
index|[]
name|encoded
init|=
name|encodeBytesToBytes
argument_list|(
name|source
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|options
argument_list|)
decl_stmt|;
comment|// Return value according to relevant encoding.
try|try
block|{
return|return
operator|new
name|String
argument_list|(
name|encoded
argument_list|,
name|PREFERRED_ENCODING
argument_list|)
return|;
block|}
comment|// end try
catch|catch
parameter_list|(
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
name|uue
parameter_list|)
block|{
return|return
operator|new
name|String
argument_list|(
name|encoded
argument_list|)
return|;
block|}
comment|// end catch
block|}
comment|// end encodeBytes
comment|/**      * Similar to {@link #encodeBytes(byte[])} but returns      * a byte array instead of instantiating a String. This is more efficient      * if you're working with I/O streams and have large data sets to encode.      *      *      * @param source The data to convert      * @return The Base64-encoded data as a byte[] (of ASCII characters)      * @throws NullPointerException if source array is null      * @since 2.3.1      */
specifier|public
specifier|static
name|byte
index|[]
name|encodeBytesToBytes
parameter_list|(
name|byte
index|[]
name|source
parameter_list|)
block|{
name|byte
index|[]
name|encoded
init|=
literal|null
decl_stmt|;
try|try
block|{
name|encoded
operator|=
name|encodeBytesToBytes
argument_list|(
name|source
argument_list|,
literal|0
argument_list|,
name|source
operator|.
name|length
argument_list|,
name|Base64
operator|.
name|NO_OPTIONS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|io
operator|.
name|IOException
name|ex
parameter_list|)
block|{
assert|assert
literal|false
operator|:
literal|"IOExceptions only come from GZipping, which is turned off: "
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
assert|;
block|}
return|return
name|encoded
return|;
block|}
comment|/**      * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns      * a byte array instead of instantiating a String. This is more efficient      * if you're working with I/O streams and have large data sets to encode.      *      *      * @param source The data to convert      * @param off Offset in array where conversion should begin      * @param len Length of data to convert      * @param options Specified options      * @return The Base64-encoded data as a String      * @see Base64#GZIP      * @see Base64#DO_BREAK_LINES      * @throws java.io.IOException if there is an error      * @throws NullPointerException if source array is null      * @throws IllegalArgumentException if source array, offset, or length are invalid      * @since 2.3.1      */
specifier|public
specifier|static
name|byte
index|[]
name|encodeBytesToBytes
parameter_list|(
name|byte
index|[]
name|source
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|options
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
block|{
if|if
condition|(
name|source
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"Cannot serialize a null array."
argument_list|)
throw|;
block|}
comment|// end if: null
if|if
condition|(
name|off
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot have negative offset: "
operator|+
name|off
argument_list|)
throw|;
block|}
comment|// end if: off< 0
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot have length offset: "
operator|+
name|len
argument_list|)
throw|;
block|}
comment|// end if: len< 0
if|if
condition|(
name|off
operator|+
name|len
operator|>
name|source
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Cannot have offset of %d and length of %d with array of length %d"
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|source
operator|.
name|length
argument_list|)
argument_list|)
throw|;
block|}
comment|// end if: off< 0
comment|// Compress?
if|if
condition|(
operator|(
name|options
operator|&
name|GZIP
operator|)
operator|!=
literal|0
condition|)
block|{
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
name|baos
init|=
literal|null
decl_stmt|;
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|GZIPOutputStream
name|gzos
init|=
literal|null
decl_stmt|;
name|Base64
operator|.
name|OutputStream
name|b64os
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// GZip -> Base64 -> ByteArray
name|baos
operator|=
operator|new
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
argument_list|()
expr_stmt|;
name|b64os
operator|=
operator|new
name|Base64
operator|.
name|OutputStream
argument_list|(
name|baos
argument_list|,
name|ENCODE
operator||
name|options
argument_list|)
expr_stmt|;
name|gzos
operator|=
operator|new
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|GZIPOutputStream
argument_list|(
name|b64os
argument_list|)
expr_stmt|;
name|gzos
operator|.
name|write
argument_list|(
name|source
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|gzos
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// end try
catch|catch
parameter_list|(
name|java
operator|.
name|io
operator|.
name|IOException
name|e
parameter_list|)
block|{
comment|// Catch it and then throw it immediately so that
comment|// the finally{} block is called for cleanup.
throw|throw
name|e
throw|;
block|}
comment|// end catch
finally|finally
block|{
try|try
block|{
name|gzos
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{}
try|try
block|{
name|b64os
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{}
try|try
block|{
name|baos
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{}
block|}
comment|// end finally
return|return
name|baos
operator|.
name|toByteArray
argument_list|()
return|;
block|}
comment|// end if: compress
comment|// Else, don't compress. Better not to use streams at all then.
else|else
block|{
name|boolean
name|breakLines
init|=
operator|(
name|options
operator|&
name|DO_BREAK_LINES
operator|)
operator|>
literal|0
decl_stmt|;
comment|//int    len43   = len * 4 / 3;
comment|//byte[] outBuff = new byte[   ( len43 )                      // Main 4:3
comment|//                           + ( (len % 3)> 0 ? 4 : 0 )      // Account for padding
comment|//                           + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines
comment|// Try to determine more precisely how big the array needs to be.
comment|// If we get it right, we don't have to do an array copy, and
comment|// we save a bunch of memory.
name|int
name|encLen
init|=
operator|(
name|len
operator|/
literal|3
operator|)
operator|*
literal|4
operator|+
operator|(
name|len
operator|%
literal|3
operator|>
literal|0
condition|?
literal|4
else|:
literal|0
operator|)
decl_stmt|;
comment|// Bytes needed for actual encoding
if|if
condition|(
name|breakLines
condition|)
block|{
name|encLen
operator|+=
name|encLen
operator|/
name|MAX_LINE_LENGTH
expr_stmt|;
comment|// Plus extra newline characters
block|}
name|byte
index|[]
name|outBuff
init|=
operator|new
name|byte
index|[
name|encLen
index|]
decl_stmt|;
name|int
name|d
init|=
literal|0
decl_stmt|;
name|int
name|e
init|=
literal|0
decl_stmt|;
name|int
name|len2
init|=
name|len
operator|-
literal|2
decl_stmt|;
name|int
name|lineLength
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|d
operator|<
name|len2
condition|;
name|d
operator|+=
literal|3
operator|,
name|e
operator|+=
literal|4
control|)
block|{
name|encode3to4
argument_list|(
name|source
argument_list|,
name|d
operator|+
name|off
argument_list|,
literal|3
argument_list|,
name|outBuff
argument_list|,
name|e
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|lineLength
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|breakLines
operator|&&
name|lineLength
operator|>=
name|MAX_LINE_LENGTH
condition|)
block|{
name|outBuff
index|[
name|e
operator|+
literal|4
index|]
operator|=
name|NEW_LINE
expr_stmt|;
name|e
operator|++
expr_stmt|;
name|lineLength
operator|=
literal|0
expr_stmt|;
block|}
comment|// end if: end of line
block|}
comment|// en dfor: each piece of array
if|if
condition|(
name|d
operator|<
name|len
condition|)
block|{
name|encode3to4
argument_list|(
name|source
argument_list|,
name|d
operator|+
name|off
argument_list|,
name|len
operator|-
name|d
argument_list|,
name|outBuff
argument_list|,
name|e
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|e
operator|+=
literal|4
expr_stmt|;
block|}
comment|// end if: some padding needed
comment|// Only resize array if we didn't guess it right.
if|if
condition|(
name|e
operator|<
name|outBuff
operator|.
name|length
operator|-
literal|1
condition|)
block|{
name|byte
index|[]
name|finalOut
init|=
operator|new
name|byte
index|[
name|e
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|outBuff
argument_list|,
literal|0
argument_list|,
name|finalOut
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//System.err.println("Having to resize array from " + outBuff.length + " to " + e );
return|return
name|finalOut
return|;
block|}
else|else
block|{
comment|//System.err.println("No need to resize array.");
return|return
name|outBuff
return|;
block|}
block|}
comment|// end else: don't compress
block|}
comment|// end encodeBytesToBytes
comment|/* ********  D E C O D I N G   M E T H O D S  ******** */
comment|/**      * Decodes four bytes from array<var>source</var>      * and writes the resulting bytes (up to three of them)      * to<var>destination</var>.      * The source and destination arrays can be manipulated      * anywhere along their length by specifying       *<var>srcOffset</var> and<var>destOffset</var>.      * This method does not check to make sure your arrays      * are large enough to accomodate<var>srcOffset</var> + 4 for      * the<var>source</var> array or<var>destOffset</var> + 3 for      * the<var>destination</var> array.      * This method returns the actual number of bytes that       * were converted from the Base64 encoding. 	 *<p>This is the lowest level of the decoding methods with 	 * all possible parameters.</p>      *       *      * @param source the array to convert      * @param srcOffset the index where conversion begins      * @param destination the array to hold the conversion      * @param destOffset the index where output will be put 	 * @param options alphabet type is pulled from this (standard, url-safe, ordered)      * @return the number of decoded bytes converted      * @throws NullPointerException if source or destination arrays are null      * @throws IllegalArgumentException if srcOffset or destOffset are invalid      *         or there is not enough room in the array.      * @since 1.3      */
specifier|private
specifier|static
name|int
name|decode4to3
parameter_list|(
name|byte
index|[]
name|source
parameter_list|,
name|int
name|srcOffset
parameter_list|,
name|byte
index|[]
name|destination
parameter_list|,
name|int
name|destOffset
parameter_list|,
name|int
name|options
parameter_list|)
block|{
comment|// Lots of error checking and exception throwing
if|if
condition|(
name|source
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"Source array was null."
argument_list|)
throw|;
block|}
comment|// end if
if|if
condition|(
name|destination
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"Destination array was null."
argument_list|)
throw|;
block|}
comment|// end if
if|if
condition|(
name|srcOffset
operator|<
literal|0
operator|||
name|srcOffset
operator|+
literal|3
operator|>=
name|source
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Source array with length %d cannot have offset of %d and still process four bytes."
argument_list|,
name|source
operator|.
name|length
argument_list|,
name|srcOffset
argument_list|)
argument_list|)
throw|;
block|}
comment|// end if
if|if
condition|(
name|destOffset
operator|<
literal|0
operator|||
name|destOffset
operator|+
literal|2
operator|>=
name|destination
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Destination array with length %d cannot have offset of %d and still store three bytes."
argument_list|,
name|destination
operator|.
name|length
argument_list|,
name|destOffset
argument_list|)
argument_list|)
throw|;
block|}
comment|// end if
name|byte
index|[]
name|DECODABET
init|=
name|getDecodabet
argument_list|(
name|options
argument_list|)
decl_stmt|;
comment|// Example: Dk==
if|if
condition|(
name|source
index|[
name|srcOffset
operator|+
literal|2
index|]
operator|==
name|EQUALS_SIGN
condition|)
block|{
comment|// Two ways to do the same thing. Don't know which way I like best.
comment|//int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ]<< 24 )>>>  6 )
comment|//              | ( ( DECODABET[ source[ srcOffset + 1] ]<< 24 )>>> 12 );
name|int
name|outBuff
init|=
operator|(
operator|(
name|DECODABET
index|[
name|source
index|[
name|srcOffset
index|]
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|18
operator|)
operator||
operator|(
operator|(
name|DECODABET
index|[
name|source
index|[
name|srcOffset
operator|+
literal|1
index|]
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|12
operator|)
decl_stmt|;
name|destination
index|[
name|destOffset
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|outBuff
operator|>>>
literal|16
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|// Example: DkL=
elseif|else
if|if
condition|(
name|source
index|[
name|srcOffset
operator|+
literal|3
index|]
operator|==
name|EQUALS_SIGN
condition|)
block|{
comment|// Two ways to do the same thing. Don't know which way I like best.
comment|//int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ]<< 24 )>>>  6 )
comment|//              | ( ( DECODABET[ source[ srcOffset + 1 ] ]<< 24 )>>> 12 )
comment|//              | ( ( DECODABET[ source[ srcOffset + 2 ] ]<< 24 )>>> 18 );
name|int
name|outBuff
init|=
operator|(
operator|(
name|DECODABET
index|[
name|source
index|[
name|srcOffset
index|]
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|18
operator|)
operator||
operator|(
operator|(
name|DECODABET
index|[
name|source
index|[
name|srcOffset
operator|+
literal|1
index|]
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|12
operator|)
operator||
operator|(
operator|(
name|DECODABET
index|[
name|source
index|[
name|srcOffset
operator|+
literal|2
index|]
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|6
operator|)
decl_stmt|;
name|destination
index|[
name|destOffset
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|outBuff
operator|>>>
literal|16
argument_list|)
expr_stmt|;
name|destination
index|[
name|destOffset
operator|+
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|outBuff
operator|>>>
literal|8
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
comment|// Example: DkLE
else|else
block|{
comment|// Two ways to do the same thing. Don't know which way I like best.
comment|//int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ]<< 24 )>>>  6 )
comment|//              | ( ( DECODABET[ source[ srcOffset + 1 ] ]<< 24 )>>> 12 )
comment|//              | ( ( DECODABET[ source[ srcOffset + 2 ] ]<< 24 )>>> 18 )
comment|//              | ( ( DECODABET[ source[ srcOffset + 3 ] ]<< 24 )>>> 24 );
name|int
name|outBuff
init|=
operator|(
operator|(
name|DECODABET
index|[
name|source
index|[
name|srcOffset
index|]
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|18
operator|)
operator||
operator|(
operator|(
name|DECODABET
index|[
name|source
index|[
name|srcOffset
operator|+
literal|1
index|]
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|12
operator|)
operator||
operator|(
operator|(
name|DECODABET
index|[
name|source
index|[
name|srcOffset
operator|+
literal|2
index|]
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
operator|(
name|DECODABET
index|[
name|source
index|[
name|srcOffset
operator|+
literal|3
index|]
index|]
operator|&
literal|0xFF
operator|)
operator|)
decl_stmt|;
name|destination
index|[
name|destOffset
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|outBuff
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|destination
index|[
name|destOffset
operator|+
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|outBuff
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|destination
index|[
name|destOffset
operator|+
literal|2
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|outBuff
argument_list|)
expr_stmt|;
return|return
literal|3
return|;
block|}
block|}
comment|// end decodeToBytes
comment|/**      * Low-level access to decoding ASCII characters in      * the form of a byte array.<strong>Ignores GUNZIP option, if      * it's set.</strong> This is not generally a recommended method,      * although it is used internally as part of the decoding process.      * Special case: if len = 0, an empty array is returned. Still,      * if you need more speed and reduced memory footprint (and aren't      * gzipping), consider this method.      *      * @param source The Base64 encoded data      * @return decoded data      * @since 2.3.1      */
specifier|public
specifier|static
name|byte
index|[]
name|decode
parameter_list|(
name|byte
index|[]
name|source
parameter_list|)
block|{
name|byte
index|[]
name|decoded
init|=
literal|null
decl_stmt|;
try|try
block|{
name|decoded
operator|=
name|decode
argument_list|(
name|source
argument_list|,
literal|0
argument_list|,
name|source
operator|.
name|length
argument_list|,
name|Base64
operator|.
name|NO_OPTIONS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|io
operator|.
name|IOException
name|ex
parameter_list|)
block|{
assert|assert
literal|false
operator|:
literal|"IOExceptions only come from GZipping, which is turned off: "
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
assert|;
block|}
return|return
name|decoded
return|;
block|}
comment|/**      * Low-level access to decoding ASCII characters in      * the form of a byte array.<strong>Ignores GUNZIP option, if      * it's set.</strong> This is not generally a recommended method,      * although it is used internally as part of the decoding process.      * Special case: if len = 0, an empty array is returned. Still,      * if you need more speed and reduced memory footprint (and aren't      * gzipping), consider this method.      *      * @param source The Base64 encoded data      * @param off    The offset of where to begin decoding      * @param len    The length of characters to decode      * @param options Can specify options such as alphabet type to use      * @return decoded data      * @throws java.io.IOException If bogus characters exist in source data      * @since 1.3      */
specifier|public
specifier|static
name|byte
index|[]
name|decode
parameter_list|(
name|byte
index|[]
name|source
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|options
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
block|{
comment|// Lots of error checking and exception throwing
if|if
condition|(
name|source
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"Cannot decode null source array."
argument_list|)
throw|;
block|}
comment|// end if
if|if
condition|(
name|off
argument_list|<
literal|0
operator|||
name|off
operator|+
name|len
argument_list|>
name|source
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Source array with length %d cannot have offset of %d and process %d bytes."
argument_list|,
name|source
operator|.
name|length
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
argument_list|)
throw|;
block|}
comment|// end if
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
return|return
operator|new
name|byte
index|[
literal|0
index|]
return|;
block|}
elseif|else
if|if
condition|(
name|len
operator|<
literal|4
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Base64-encoded string must have at least four characters, but length specified was "
operator|+
name|len
argument_list|)
throw|;
block|}
comment|// end if
name|byte
index|[]
name|DECODABET
init|=
name|getDecodabet
argument_list|(
name|options
argument_list|)
decl_stmt|;
name|int
name|len34
init|=
name|len
operator|*
literal|3
operator|/
literal|4
decl_stmt|;
comment|// Estimate on array size
name|byte
index|[]
name|outBuff
init|=
operator|new
name|byte
index|[
name|len34
index|]
decl_stmt|;
comment|// Upper limit on size of output
name|int
name|outBuffPosn
init|=
literal|0
decl_stmt|;
comment|// Keep track of where we're writing
name|byte
index|[]
name|b4
init|=
operator|new
name|byte
index|[
literal|4
index|]
decl_stmt|;
comment|// Four byte buffer from source, eliminating white space
name|int
name|b4Posn
init|=
literal|0
decl_stmt|;
comment|// Keep track of four byte input buffer
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|// Source array counter
name|byte
name|sbiCrop
init|=
literal|0
decl_stmt|;
comment|// Low seven bits (ASCII) of input
name|byte
name|sbiDecode
init|=
literal|0
decl_stmt|;
comment|// Special value from DECODABET
for|for
control|(
name|i
operator|=
name|off
init|;
name|i
operator|<
name|off
operator|+
name|len
condition|;
name|i
operator|++
control|)
block|{
comment|// Loop through source
name|sbiCrop
operator|=
call|(
name|byte
call|)
argument_list|(
name|source
index|[
name|i
index|]
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
comment|// Only the low seven bits
name|sbiDecode
operator|=
name|DECODABET
index|[
name|sbiCrop
index|]
expr_stmt|;
comment|// Special value
comment|// White space, Equals sign, or legit Base64 character
comment|// Note the values such as -5 and -9 in the
comment|// DECODABETs at the top of the file.
if|if
condition|(
name|sbiDecode
operator|>=
name|WHITE_SPACE_ENC
condition|)
block|{
if|if
condition|(
name|sbiDecode
operator|>=
name|EQUALS_SIGN_ENC
condition|)
block|{
name|b4
index|[
name|b4Posn
operator|++
index|]
operator|=
name|sbiCrop
expr_stmt|;
comment|// Save non-whitespace
if|if
condition|(
name|b4Posn
operator|>
literal|3
condition|)
block|{
comment|// Time to decode?
name|outBuffPosn
operator|+=
name|decode4to3
argument_list|(
name|b4
argument_list|,
literal|0
argument_list|,
name|outBuff
argument_list|,
name|outBuffPosn
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|b4Posn
operator|=
literal|0
expr_stmt|;
comment|// If that was the equals sign, break out of 'for' loop
if|if
condition|(
name|sbiCrop
operator|==
name|EQUALS_SIGN
condition|)
block|{
break|break;
block|}
comment|// end if: equals sign
block|}
comment|// end if: quartet built
block|}
comment|// end if: equals sign or better
block|}
comment|// end if: white space, equals sign or better
else|else
block|{
comment|// There's a bad input character in the Base64 stream.
throw|throw
operator|new
name|java
operator|.
name|io
operator|.
name|IOException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Bad Base64 input character '%c' in array position %d"
argument_list|,
name|source
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
argument_list|)
throw|;
block|}
comment|// end else:
block|}
comment|// each input character
name|byte
index|[]
name|out
init|=
operator|new
name|byte
index|[
name|outBuffPosn
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|outBuff
argument_list|,
literal|0
argument_list|,
name|out
argument_list|,
literal|0
argument_list|,
name|outBuffPosn
argument_list|)
expr_stmt|;
return|return
name|out
return|;
block|}
comment|// end decode
comment|/**      * Decodes data from Base64 notation, automatically      * detecting gzip-compressed data and decompressing it.      *      * @param s the string to decode      * @return the decoded data      * @throws java.io.IOException If there is a problem      * @since 1.4      */
specifier|public
specifier|static
name|byte
index|[]
name|decode
parameter_list|(
name|String
name|s
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
block|{
return|return
name|decode
argument_list|(
name|s
argument_list|,
name|NO_OPTIONS
argument_list|)
return|;
block|}
comment|/**      * Decodes data from Base64 notation, automatically      * detecting gzip-compressed data and decompressing it.      *      * @param s the string to decode      * @param options encode options such as URL_SAFE      * @return the decoded data      * @throws java.io.IOException if there is an error      * @throws NullPointerException if<tt>s</tt> is null      * @since 1.4      */
specifier|public
specifier|static
name|byte
index|[]
name|decode
parameter_list|(
name|String
name|s
parameter_list|,
name|int
name|options
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
block|{
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"Input string was null."
argument_list|)
throw|;
block|}
comment|// end if
name|byte
index|[]
name|bytes
decl_stmt|;
try|try
block|{
name|bytes
operator|=
name|s
operator|.
name|getBytes
argument_list|(
name|PREFERRED_ENCODING
argument_list|)
expr_stmt|;
block|}
comment|// end try
catch|catch
parameter_list|(
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
name|uee
parameter_list|)
block|{
name|bytes
operator|=
name|s
operator|.
name|getBytes
argument_list|()
expr_stmt|;
block|}
comment|// end catch
comment|//</change>
comment|// Decode
name|bytes
operator|=
name|decode
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|bytes
operator|.
name|length
argument_list|,
name|options
argument_list|)
expr_stmt|;
comment|// Check to see if it's gzip-compressed
comment|// GZIP Magic Two-Byte Number: 0x8b1f (35615)
name|boolean
name|dontGunzip
init|=
operator|(
name|options
operator|&
name|DONT_GUNZIP
operator|)
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|bytes
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bytes
operator|.
name|length
operator|>=
literal|4
operator|)
operator|&&
operator|(
operator|!
name|dontGunzip
operator|)
condition|)
block|{
name|int
name|head
init|=
operator|(
operator|(
name|int
operator|)
name|bytes
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|(
name|bytes
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|&
literal|0xff00
operator|)
decl_stmt|;
if|if
condition|(
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|GZIPInputStream
operator|.
name|GZIP_MAGIC
operator|==
name|head
condition|)
block|{
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
name|bais
init|=
literal|null
decl_stmt|;
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|GZIPInputStream
name|gzis
init|=
literal|null
decl_stmt|;
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
name|baos
init|=
literal|null
decl_stmt|;
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
literal|2048
index|]
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
try|try
block|{
name|baos
operator|=
operator|new
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
argument_list|()
expr_stmt|;
name|bais
operator|=
operator|new
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
name|gzis
operator|=
operator|new
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|GZIPInputStream
argument_list|(
name|bais
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|length
operator|=
name|gzis
operator|.
name|read
argument_list|(
name|buffer
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|baos
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
comment|// end while: reading input
comment|// No error? Get new bytes.
name|bytes
operator|=
name|baos
operator|.
name|toByteArray
argument_list|()
expr_stmt|;
block|}
comment|// end try
catch|catch
parameter_list|(
name|java
operator|.
name|io
operator|.
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
comment|// Just return originally-decoded bytes
block|}
comment|// end catch
finally|finally
block|{
try|try
block|{
name|baos
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{}
try|try
block|{
name|gzis
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{}
try|try
block|{
name|bais
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{}
block|}
comment|// end finally
block|}
comment|// end if: gzipped
block|}
comment|// end if: bytes.length>= 2
return|return
name|bytes
return|;
block|}
comment|// end decode
comment|/**      * Attempts to decode Base64 data and deserialize a Java      * Object within. Returns<tt>null</tt> if there was an error.      *      * @param encodedObject The Base64 data to decode      * @return The decoded and deserialized object      * @throws NullPointerException if encodedObject is null      * @throws java.io.IOException if there is a general error      * @throws ClassNotFoundException if the decoded object is of a      *         class that cannot be found by the JVM      * @since 1.5      */
specifier|public
specifier|static
name|Object
name|decodeToObject
parameter_list|(
name|String
name|encodedObject
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
throws|,
name|java
operator|.
name|lang
operator|.
name|ClassNotFoundException
block|{
return|return
name|decodeToObject
argument_list|(
name|encodedObject
argument_list|,
name|NO_OPTIONS
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Attempts to decode Base64 data and deserialize a Java      * Object within. Returns<tt>null</tt> if there was an error.      * If<tt>loader</tt> is not null, it will be the class loader      * used when deserializing.      *      * @param encodedObject The Base64 data to decode      * @param options Various parameters related to decoding      * @param loader Optional class loader to use in deserializing classes.      * @return The decoded and deserialized object      * @throws NullPointerException if encodedObject is null      * @throws java.io.IOException if there is a general error      * @throws ClassNotFoundException if the decoded object is of a       *         class that cannot be found by the JVM      * @since 2.3.4      */
specifier|public
specifier|static
name|Object
name|decodeToObject
parameter_list|(
name|String
name|encodedObject
parameter_list|,
name|int
name|options
parameter_list|,
specifier|final
name|ClassLoader
name|loader
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
throws|,
name|java
operator|.
name|lang
operator|.
name|ClassNotFoundException
block|{
comment|// Decode and gunzip if necessary
name|byte
index|[]
name|objBytes
init|=
name|decode
argument_list|(
name|encodedObject
argument_list|,
name|options
argument_list|)
decl_stmt|;
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
name|bais
init|=
literal|null
decl_stmt|;
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
name|ois
init|=
literal|null
decl_stmt|;
name|Object
name|obj
init|=
literal|null
decl_stmt|;
try|try
block|{
name|bais
operator|=
operator|new
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
argument_list|(
name|objBytes
argument_list|)
expr_stmt|;
comment|// If no custom class loader is provided, use Java's builtin OIS.
if|if
condition|(
name|loader
operator|==
literal|null
condition|)
block|{
name|ois
operator|=
operator|new
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
argument_list|(
name|bais
argument_list|)
expr_stmt|;
block|}
comment|// end if: no loader provided
comment|// Else make a customized object input stream that uses
comment|// the provided class loader.
else|else
block|{
name|ois
operator|=
operator|new
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
argument_list|(
name|bais
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|Class
argument_list|<
name|?
argument_list|>
name|resolveClass
parameter_list|(
name|java
operator|.
name|io
operator|.
name|ObjectStreamClass
name|streamClass
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|Class
name|c
init|=
name|Class
operator|.
name|forName
argument_list|(
name|streamClass
operator|.
name|getName
argument_list|()
argument_list|,
literal|false
argument_list|,
name|loader
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|null
condition|)
block|{
return|return
name|super
operator|.
name|resolveClass
argument_list|(
name|streamClass
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|c
return|;
comment|// Class loader knows of this class.
block|}
comment|// end else: not null
block|}
comment|// end resolveClass
block|}
expr_stmt|;
comment|// end ois
block|}
comment|// end else: no custom class loader
name|obj
operator|=
name|ois
operator|.
name|readObject
argument_list|()
expr_stmt|;
block|}
comment|// end try
catch|catch
parameter_list|(
name|java
operator|.
name|io
operator|.
name|IOException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
comment|// Catch and throw in order to execute finally{}
block|}
comment|// end catch
catch|catch
parameter_list|(
name|java
operator|.
name|lang
operator|.
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
comment|// Catch and throw in order to execute finally{}
block|}
comment|// end catch
finally|finally
block|{
try|try
block|{
name|bais
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{}
try|try
block|{
name|ois
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{}
block|}
comment|// end finally
return|return
name|obj
return|;
block|}
comment|// end decodeObject
comment|/**      * Convenience method for encoding data to a file.      *      *<p>As of v 2.3, if there is a error,      * the method will throw an java.io.IOException.<b>This is new to v2.3!</b>      * In earlier versions, it just returned false, but      * in retrospect that's a pretty poor way to handle it.</p>      *       * @param dataToEncode byte array of data to encode in base64 form      * @param filename Filename for saving encoded data      * @throws java.io.IOException if there is an error      * @throws NullPointerException if dataToEncode is null      * @since 2.1      */
specifier|public
specifier|static
name|void
name|encodeToFile
parameter_list|(
name|byte
index|[]
name|dataToEncode
parameter_list|,
name|String
name|filename
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
block|{
if|if
condition|(
name|dataToEncode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"Data to encode was null."
argument_list|)
throw|;
block|}
comment|// end iff
name|Base64
operator|.
name|OutputStream
name|bos
init|=
literal|null
decl_stmt|;
try|try
block|{
name|bos
operator|=
operator|new
name|Base64
operator|.
name|OutputStream
argument_list|(
operator|new
name|java
operator|.
name|io
operator|.
name|FileOutputStream
argument_list|(
name|filename
argument_list|)
argument_list|,
name|Base64
operator|.
name|ENCODE
argument_list|)
expr_stmt|;
name|bos
operator|.
name|write
argument_list|(
name|dataToEncode
argument_list|)
expr_stmt|;
block|}
comment|// end try
catch|catch
parameter_list|(
name|java
operator|.
name|io
operator|.
name|IOException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
comment|// Catch and throw to execute finally{} block
block|}
comment|// end catch: java.io.IOException
finally|finally
block|{
try|try
block|{
name|bos
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{}
block|}
comment|// end finally
block|}
comment|// end encodeToFile
comment|/**      * Convenience method for decoding data to a file.      *      *<p>As of v 2.3, if there is a error,      * the method will throw an java.io.IOException.<b>This is new to v2.3!</b>      * In earlier versions, it just returned false, but      * in retrospect that's a pretty poor way to handle it.</p>      *       * @param dataToDecode Base64-encoded data as a string      * @param filename Filename for saving decoded data      * @throws java.io.IOException if there is an error      * @since 2.1      */
specifier|public
specifier|static
name|void
name|decodeToFile
parameter_list|(
name|String
name|dataToDecode
parameter_list|,
name|String
name|filename
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
block|{
name|Base64
operator|.
name|OutputStream
name|bos
init|=
literal|null
decl_stmt|;
try|try
block|{
name|bos
operator|=
operator|new
name|Base64
operator|.
name|OutputStream
argument_list|(
operator|new
name|java
operator|.
name|io
operator|.
name|FileOutputStream
argument_list|(
name|filename
argument_list|)
argument_list|,
name|Base64
operator|.
name|DECODE
argument_list|)
expr_stmt|;
name|bos
operator|.
name|write
argument_list|(
name|dataToDecode
operator|.
name|getBytes
argument_list|(
name|PREFERRED_ENCODING
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// end try
catch|catch
parameter_list|(
name|java
operator|.
name|io
operator|.
name|IOException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
comment|// Catch and throw to execute finally{} block
block|}
comment|// end catch: java.io.IOException
finally|finally
block|{
try|try
block|{
name|bos
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{}
block|}
comment|// end finally
block|}
comment|// end decodeToFile
comment|/**      * Convenience method for reading a base64-encoded      * file and decoding it.      *      *<p>As of v 2.3, if there is a error,      * the method will throw an java.io.IOException.<b>This is new to v2.3!</b>      * In earlier versions, it just returned false, but      * in retrospect that's a pretty poor way to handle it.</p>      *       * @param filename Filename for reading encoded data      * @return decoded byte array      * @throws java.io.IOException if there is an error      * @since 2.1      */
specifier|public
specifier|static
name|byte
index|[]
name|decodeFromFile
parameter_list|(
name|String
name|filename
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
block|{
name|byte
index|[]
name|decodedData
init|=
literal|null
decl_stmt|;
name|Base64
operator|.
name|InputStream
name|bis
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// Set up some useful variables
name|java
operator|.
name|io
operator|.
name|File
name|file
init|=
operator|new
name|java
operator|.
name|io
operator|.
name|File
argument_list|(
name|filename
argument_list|)
decl_stmt|;
name|byte
index|[]
name|buffer
init|=
literal|null
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
name|int
name|numBytes
init|=
literal|0
decl_stmt|;
comment|// Check for size of file
if|if
condition|(
name|file
operator|.
name|length
argument_list|()
operator|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|java
operator|.
name|io
operator|.
name|IOException
argument_list|(
literal|"File is too big for this convenience method ("
operator|+
name|file
operator|.
name|length
argument_list|()
operator|+
literal|" bytes)."
argument_list|)
throw|;
block|}
comment|// end if: file too big for int index
name|buffer
operator|=
operator|new
name|byte
index|[
operator|(
name|int
operator|)
name|file
operator|.
name|length
argument_list|()
index|]
expr_stmt|;
comment|// Open a stream
name|bis
operator|=
operator|new
name|Base64
operator|.
name|InputStream
argument_list|(
operator|new
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
argument_list|(
operator|new
name|java
operator|.
name|io
operator|.
name|FileInputStream
argument_list|(
name|file
argument_list|)
argument_list|)
argument_list|,
name|Base64
operator|.
name|DECODE
argument_list|)
expr_stmt|;
comment|// Read until done
while|while
condition|(
operator|(
name|numBytes
operator|=
name|bis
operator|.
name|read
argument_list|(
name|buffer
argument_list|,
name|length
argument_list|,
literal|4096
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|length
operator|+=
name|numBytes
expr_stmt|;
block|}
comment|// end while
comment|// Save in a variable to return
name|decodedData
operator|=
operator|new
name|byte
index|[
name|length
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|decodedData
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
comment|// end try
catch|catch
parameter_list|(
name|java
operator|.
name|io
operator|.
name|IOException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
comment|// Catch and release to execute finally{}
block|}
comment|// end catch: java.io.IOException
finally|finally
block|{
try|try
block|{
name|bis
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{}
block|}
comment|// end finally
return|return
name|decodedData
return|;
block|}
comment|// end decodeFromFile
comment|/**      * Convenience method for reading a binary file      * and base64-encoding it.      *      *<p>As of v 2.3, if there is a error,      * the method will throw an java.io.IOException.<b>This is new to v2.3!</b>      * In earlier versions, it just returned false, but      * in retrospect that's a pretty poor way to handle it.</p>      *       * @param filename Filename for reading binary data      * @return base64-encoded string      * @throws java.io.IOException if there is an error      * @since 2.1      */
specifier|public
specifier|static
name|String
name|encodeFromFile
parameter_list|(
name|String
name|filename
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
block|{
name|String
name|encodedData
init|=
literal|null
decl_stmt|;
name|Base64
operator|.
name|InputStream
name|bis
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// Set up some useful variables
name|java
operator|.
name|io
operator|.
name|File
name|file
init|=
operator|new
name|java
operator|.
name|io
operator|.
name|File
argument_list|(
name|filename
argument_list|)
decl_stmt|;
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
name|Math
operator|.
name|max
argument_list|(
call|(
name|int
call|)
argument_list|(
name|file
operator|.
name|length
argument_list|()
operator|*
literal|1.4
argument_list|)
argument_list|,
literal|40
argument_list|)
index|]
decl_stmt|;
comment|// Need max() for math on small files (v2.2.1)
name|int
name|length
init|=
literal|0
decl_stmt|;
name|int
name|numBytes
init|=
literal|0
decl_stmt|;
comment|// Open a stream
name|bis
operator|=
operator|new
name|Base64
operator|.
name|InputStream
argument_list|(
operator|new
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
argument_list|(
operator|new
name|java
operator|.
name|io
operator|.
name|FileInputStream
argument_list|(
name|file
argument_list|)
argument_list|)
argument_list|,
name|Base64
operator|.
name|ENCODE
argument_list|)
expr_stmt|;
comment|// Read until done
while|while
condition|(
operator|(
name|numBytes
operator|=
name|bis
operator|.
name|read
argument_list|(
name|buffer
argument_list|,
name|length
argument_list|,
literal|4096
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|length
operator|+=
name|numBytes
expr_stmt|;
block|}
comment|// end while
comment|// Save in a variable to return
name|encodedData
operator|=
operator|new
name|String
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|length
argument_list|,
name|Base64
operator|.
name|PREFERRED_ENCODING
argument_list|)
expr_stmt|;
block|}
comment|// end try
catch|catch
parameter_list|(
name|java
operator|.
name|io
operator|.
name|IOException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
comment|// Catch and release to execute finally{}
block|}
comment|// end catch: java.io.IOException
finally|finally
block|{
try|try
block|{
name|bis
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{}
block|}
comment|// end finally
return|return
name|encodedData
return|;
block|}
comment|// end encodeFromFile
comment|/**      * Reads<tt>infile</tt> and encodes it to<tt>outfile</tt>.      *      * @param infile Input file      * @param outfile Output file      * @throws java.io.IOException if there is an error      * @since 2.2      */
specifier|public
specifier|static
name|void
name|encodeFileToFile
parameter_list|(
name|String
name|infile
parameter_list|,
name|String
name|outfile
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
block|{
name|String
name|encoded
init|=
name|Base64
operator|.
name|encodeFromFile
argument_list|(
name|infile
argument_list|)
decl_stmt|;
name|java
operator|.
name|io
operator|.
name|OutputStream
name|out
init|=
literal|null
decl_stmt|;
try|try
block|{
name|out
operator|=
operator|new
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
argument_list|(
operator|new
name|java
operator|.
name|io
operator|.
name|FileOutputStream
argument_list|(
name|outfile
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|encoded
operator|.
name|getBytes
argument_list|(
literal|"US-ASCII"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Strict, 7-bit output.
block|}
comment|// end try
catch|catch
parameter_list|(
name|java
operator|.
name|io
operator|.
name|IOException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
comment|// Catch and release to execute finally{}
block|}
comment|// end catch
finally|finally
block|{
try|try
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{}
block|}
comment|// end finally
block|}
comment|// end encodeFileToFile
comment|/**      * Reads<tt>infile</tt> and decodes it to<tt>outfile</tt>.      *      * @param infile Input file      * @param outfile Output file      * @throws java.io.IOException if there is an error      * @since 2.2      */
specifier|public
specifier|static
name|void
name|decodeFileToFile
parameter_list|(
name|String
name|infile
parameter_list|,
name|String
name|outfile
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
block|{
name|byte
index|[]
name|decoded
init|=
name|Base64
operator|.
name|decodeFromFile
argument_list|(
name|infile
argument_list|)
decl_stmt|;
name|java
operator|.
name|io
operator|.
name|OutputStream
name|out
init|=
literal|null
decl_stmt|;
try|try
block|{
name|out
operator|=
operator|new
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
argument_list|(
operator|new
name|java
operator|.
name|io
operator|.
name|FileOutputStream
argument_list|(
name|outfile
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|decoded
argument_list|)
expr_stmt|;
block|}
comment|// end try
catch|catch
parameter_list|(
name|java
operator|.
name|io
operator|.
name|IOException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
comment|// Catch and release to execute finally{}
block|}
comment|// end catch
finally|finally
block|{
try|try
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{}
block|}
comment|// end finally
block|}
comment|// end decodeFileToFile
comment|/* ********  I N N E R   C L A S S   I N P U T S T R E A M  ******** */
comment|/**      * A {@link Base64.InputStream} will read data from another      *<tt>java.io.InputStream</tt>, given in the constructor,      * and encode/decode to/from Base64 notation on the fly.      *      * @see Base64      * @since 1.3      */
specifier|public
specifier|static
class|class
name|InputStream
extends|extends
name|java
operator|.
name|io
operator|.
name|FilterInputStream
block|{
specifier|private
name|boolean
name|encode
decl_stmt|;
comment|// Encoding or decoding
specifier|private
name|int
name|position
decl_stmt|;
comment|// Current position in the buffer
specifier|private
name|byte
index|[]
name|buffer
decl_stmt|;
comment|// Small buffer holding converted data
specifier|private
name|int
name|bufferLength
decl_stmt|;
comment|// Length of buffer (3 or 4)
specifier|private
name|int
name|numSigBytes
decl_stmt|;
comment|// Number of meaningful bytes in the buffer
specifier|private
name|int
name|lineLength
decl_stmt|;
specifier|private
name|boolean
name|breakLines
decl_stmt|;
comment|// Break lines at less than 80 characters
specifier|private
name|int
name|options
decl_stmt|;
comment|// Record options used to create the stream.
specifier|private
name|byte
index|[]
name|decodabet
decl_stmt|;
comment|// Local copies to avoid extra method calls
comment|/**          * Constructs a {@link Base64.InputStream} in DECODE mode.          *          * @param in the<tt>java.io.InputStream</tt> from which to read data.          * @since 1.3          */
specifier|public
name|InputStream
parameter_list|(
name|java
operator|.
name|io
operator|.
name|InputStream
name|in
parameter_list|)
block|{
name|this
argument_list|(
name|in
argument_list|,
name|DECODE
argument_list|)
expr_stmt|;
block|}
comment|// end constructor
comment|/**          * Constructs a {@link Base64.InputStream} in          * either ENCODE or DECODE mode.          *<p>          * Valid options:<pre>          *   ENCODE or DECODE: Encode or Decode as data is read.          *   DO_BREAK_LINES: break lines at 76 characters          *     (only meaningful when encoding)</i>          *</pre>          *<p>          * Example:<code>new Base64.InputStream( in, Base64.DECODE )</code>          *          *          * @param in the<tt>java.io.InputStream</tt> from which to read data.          * @param options Specified options          * @see Base64#ENCODE          * @see Base64#DECODE          * @see Base64#DO_BREAK_LINES          * @since 2.0          */
specifier|public
name|InputStream
parameter_list|(
name|java
operator|.
name|io
operator|.
name|InputStream
name|in
parameter_list|,
name|int
name|options
parameter_list|)
block|{
name|super
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|this
operator|.
name|options
operator|=
name|options
expr_stmt|;
comment|// Record for later
name|this
operator|.
name|breakLines
operator|=
operator|(
name|options
operator|&
name|DO_BREAK_LINES
operator|)
operator|>
literal|0
expr_stmt|;
name|this
operator|.
name|encode
operator|=
operator|(
name|options
operator|&
name|ENCODE
operator|)
operator|>
literal|0
expr_stmt|;
name|this
operator|.
name|bufferLength
operator|=
name|encode
condition|?
literal|4
else|:
literal|3
expr_stmt|;
name|this
operator|.
name|buffer
operator|=
operator|new
name|byte
index|[
name|bufferLength
index|]
expr_stmt|;
name|this
operator|.
name|position
operator|=
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|lineLength
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|decodabet
operator|=
name|getDecodabet
argument_list|(
name|options
argument_list|)
expr_stmt|;
block|}
comment|// end constructor
comment|/**          * Reads enough of the input stream to convert          * to/from Base64 and returns the next byte.          *          * @return next byte          * @since 1.3          */
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
block|{
comment|// Do we need to get data?
if|if
condition|(
name|position
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|encode
condition|)
block|{
name|byte
index|[]
name|b3
init|=
operator|new
name|byte
index|[
literal|3
index|]
decl_stmt|;
name|int
name|numBinaryBytes
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|int
name|b
init|=
name|in
operator|.
name|read
argument_list|()
decl_stmt|;
comment|// If end of stream, b is -1.
if|if
condition|(
name|b
operator|>=
literal|0
condition|)
block|{
name|b3
index|[
name|i
index|]
operator|=
operator|(
name|byte
operator|)
name|b
expr_stmt|;
name|numBinaryBytes
operator|++
expr_stmt|;
block|}
else|else
block|{
break|break;
comment|// out of for loop
block|}
comment|// end else: end of stream
block|}
comment|// end for: each needed input byte
if|if
condition|(
name|numBinaryBytes
operator|>
literal|0
condition|)
block|{
name|encode3to4
argument_list|(
name|b3
argument_list|,
literal|0
argument_list|,
name|numBinaryBytes
argument_list|,
name|buffer
argument_list|,
literal|0
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|position
operator|=
literal|0
expr_stmt|;
name|numSigBytes
operator|=
literal|4
expr_stmt|;
block|}
comment|// end if: got data
else|else
block|{
return|return
operator|-
literal|1
return|;
comment|// Must be end of stream
block|}
comment|// end else
block|}
comment|// end if: encoding
comment|// Else decoding
else|else
block|{
name|byte
index|[]
name|b4
init|=
operator|new
name|byte
index|[
literal|4
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
comment|// Read four "meaningful" bytes:
name|int
name|b
init|=
literal|0
decl_stmt|;
do|do
block|{
name|b
operator|=
name|in
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|b
operator|>=
literal|0
operator|&&
name|decodabet
index|[
name|b
operator|&
literal|0x7f
index|]
operator|<=
name|WHITE_SPACE_ENC
condition|)
do|;
if|if
condition|(
name|b
operator|<
literal|0
condition|)
block|{
break|break;
comment|// Reads a -1 if end of stream
block|}
comment|// end if: end of stream
name|b4
index|[
name|i
index|]
operator|=
operator|(
name|byte
operator|)
name|b
expr_stmt|;
block|}
comment|// end for: each needed input byte
if|if
condition|(
name|i
operator|==
literal|4
condition|)
block|{
name|numSigBytes
operator|=
name|decode4to3
argument_list|(
name|b4
argument_list|,
literal|0
argument_list|,
name|buffer
argument_list|,
literal|0
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|position
operator|=
literal|0
expr_stmt|;
block|}
comment|// end if: got four characters
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
comment|// end else if: also padded correctly
else|else
block|{
comment|// Must have broken out from above.
throw|throw
operator|new
name|java
operator|.
name|io
operator|.
name|IOException
argument_list|(
literal|"Improperly padded Base64 input."
argument_list|)
throw|;
block|}
comment|// end
block|}
comment|// end else: decode
block|}
comment|// end else: get data
comment|// Got data?
if|if
condition|(
name|position
operator|>=
literal|0
condition|)
block|{
comment|// End of relevant data?
if|if
condition|(
comment|/*!encode&&*/
name|position
operator|>=
name|numSigBytes
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
comment|// end if: got data
if|if
condition|(
name|encode
operator|&&
name|breakLines
operator|&&
name|lineLength
operator|>=
name|MAX_LINE_LENGTH
condition|)
block|{
name|lineLength
operator|=
literal|0
expr_stmt|;
return|return
literal|'\n'
return|;
block|}
comment|// end if
else|else
block|{
name|lineLength
operator|++
expr_stmt|;
comment|// This isn't important when decoding
comment|// but throwing an extra "if" seems
comment|// just as wasteful.
name|int
name|b
init|=
name|buffer
index|[
name|position
operator|++
index|]
decl_stmt|;
if|if
condition|(
name|position
operator|>=
name|bufferLength
condition|)
block|{
name|position
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|// end if: end
return|return
name|b
operator|&
literal|0xFF
return|;
comment|// This is how you "cast" a byte that's
comment|// intended to be unsigned.
block|}
comment|// end else
block|}
comment|// end if: position>= 0
comment|// Else error
else|else
block|{
throw|throw
operator|new
name|java
operator|.
name|io
operator|.
name|IOException
argument_list|(
literal|"Error in Base64 code reading stream."
argument_list|)
throw|;
block|}
comment|// end else
block|}
comment|// end read
comment|/**          * Calls {@link #read()} repeatedly until the end of stream          * is reached or<var>len</var> bytes are read.          * Returns number of bytes read into array or -1 if          * end of stream is encountered.          *          * @param dest array to hold values          * @param off offset for array          * @param len max number of bytes to read into array          * @return bytes read into array or -1 if end of stream is encountered.          * @since 1.3          */
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|(
name|byte
index|[]
name|dest
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
block|{
name|int
name|i
decl_stmt|;
name|int
name|b
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|=
name|read
argument_list|()
expr_stmt|;
if|if
condition|(
name|b
operator|>=
literal|0
condition|)
block|{
name|dest
index|[
name|off
operator|+
name|i
index|]
operator|=
operator|(
name|byte
operator|)
name|b
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
break|break;
comment|// Out of 'for' loop
block|}
comment|// Out of 'for' loop
block|}
comment|// end for: each byte read
return|return
name|i
return|;
block|}
comment|// end read
block|}
comment|// end inner class InputStream
comment|/* ********  I N N E R   C L A S S   O U T P U T S T R E A M  ******** */
comment|/**      * A {@link Base64.OutputStream} will write data to another      *<tt>java.io.OutputStream</tt>, given in the constructor,      * and encode/decode to/from Base64 notation on the fly.      *      * @see Base64      * @since 1.3      */
specifier|public
specifier|static
class|class
name|OutputStream
extends|extends
name|java
operator|.
name|io
operator|.
name|FilterOutputStream
block|{
specifier|private
name|boolean
name|encode
decl_stmt|;
specifier|private
name|int
name|position
decl_stmt|;
specifier|private
name|byte
index|[]
name|buffer
decl_stmt|;
specifier|private
name|int
name|bufferLength
decl_stmt|;
specifier|private
name|int
name|lineLength
decl_stmt|;
specifier|private
name|boolean
name|breakLines
decl_stmt|;
specifier|private
name|byte
index|[]
name|b4
decl_stmt|;
comment|// Scratch used in a few places
specifier|private
name|boolean
name|suspendEncoding
decl_stmt|;
specifier|private
name|int
name|options
decl_stmt|;
comment|// Record for later
specifier|private
name|byte
index|[]
name|decodabet
decl_stmt|;
comment|// Local copies to avoid extra method calls
comment|/**          * Constructs a {@link Base64.OutputStream} in ENCODE mode.          *          * @param out the<tt>java.io.OutputStream</tt> to which data will be written.          * @since 1.3          */
specifier|public
name|OutputStream
parameter_list|(
name|java
operator|.
name|io
operator|.
name|OutputStream
name|out
parameter_list|)
block|{
name|this
argument_list|(
name|out
argument_list|,
name|ENCODE
argument_list|)
expr_stmt|;
block|}
comment|// end constructor
comment|/**          * Constructs a {@link Base64.OutputStream} in          * either ENCODE or DECODE mode.          *<p>          * Valid options:<pre>          *   ENCODE or DECODE: Encode or Decode as data is read.          *   DO_BREAK_LINES: don't break lines at 76 characters          *     (only meaningful when encoding)</i>          *</pre>          *<p>          * Example:<code>new Base64.OutputStream( out, Base64.ENCODE )</code>          *          * @param out the<tt>java.io.OutputStream</tt> to which data will be written.          * @param options Specified options.          * @see Base64#ENCODE          * @see Base64#DECODE          * @see Base64#DO_BREAK_LINES          * @since 1.3          */
specifier|public
name|OutputStream
parameter_list|(
name|java
operator|.
name|io
operator|.
name|OutputStream
name|out
parameter_list|,
name|int
name|options
parameter_list|)
block|{
name|super
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|this
operator|.
name|breakLines
operator|=
operator|(
name|options
operator|&
name|DO_BREAK_LINES
operator|)
operator|!=
literal|0
expr_stmt|;
name|this
operator|.
name|encode
operator|=
operator|(
name|options
operator|&
name|ENCODE
operator|)
operator|!=
literal|0
expr_stmt|;
name|this
operator|.
name|bufferLength
operator|=
name|encode
condition|?
literal|3
else|:
literal|4
expr_stmt|;
name|this
operator|.
name|buffer
operator|=
operator|new
name|byte
index|[
name|bufferLength
index|]
expr_stmt|;
name|this
operator|.
name|position
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|lineLength
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|suspendEncoding
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|b4
operator|=
operator|new
name|byte
index|[
literal|4
index|]
expr_stmt|;
name|this
operator|.
name|options
operator|=
name|options
expr_stmt|;
name|this
operator|.
name|decodabet
operator|=
name|getDecodabet
argument_list|(
name|options
argument_list|)
expr_stmt|;
block|}
comment|// end constructor
comment|/**          * Writes the byte to the output stream after          * converting to/from Base64 notation.          * When encoding, bytes are buffered three          * at a time before the output stream actually          * gets a write() call.          * When decoding, bytes are buffered four          * at a time.          *          * @param theByte the byte to write          * @since 1.3          */
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|int
name|theByte
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
block|{
comment|// Encoding suspended?
if|if
condition|(
name|suspendEncoding
condition|)
block|{
name|this
operator|.
name|out
operator|.
name|write
argument_list|(
name|theByte
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// end if: supsended
comment|// Encode?
if|if
condition|(
name|encode
condition|)
block|{
name|buffer
index|[
name|position
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|theByte
expr_stmt|;
if|if
condition|(
name|position
operator|>=
name|bufferLength
condition|)
block|{
comment|// Enough to encode.
name|this
operator|.
name|out
operator|.
name|write
argument_list|(
name|encode3to4
argument_list|(
name|b4
argument_list|,
name|buffer
argument_list|,
name|bufferLength
argument_list|,
name|options
argument_list|)
argument_list|)
expr_stmt|;
name|lineLength
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|breakLines
operator|&&
name|lineLength
operator|>=
name|MAX_LINE_LENGTH
condition|)
block|{
name|this
operator|.
name|out
operator|.
name|write
argument_list|(
name|NEW_LINE
argument_list|)
expr_stmt|;
name|lineLength
operator|=
literal|0
expr_stmt|;
block|}
comment|// end if: end of line
name|position
operator|=
literal|0
expr_stmt|;
block|}
comment|// end if: enough to output
block|}
comment|// end if: encoding
comment|// Else, Decoding
else|else
block|{
comment|// Meaningful Base64 character?
if|if
condition|(
name|decodabet
index|[
name|theByte
operator|&
literal|0x7f
index|]
operator|>
name|WHITE_SPACE_ENC
condition|)
block|{
name|buffer
index|[
name|position
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|theByte
expr_stmt|;
if|if
condition|(
name|position
operator|>=
name|bufferLength
condition|)
block|{
comment|// Enough to output.
name|int
name|len
init|=
name|Base64
operator|.
name|decode4to3
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|b4
argument_list|,
literal|0
argument_list|,
name|options
argument_list|)
decl_stmt|;
name|out
operator|.
name|write
argument_list|(
name|b4
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|position
operator|=
literal|0
expr_stmt|;
block|}
comment|// end if: enough to output
block|}
comment|// end if: meaningful base64 character
elseif|else
if|if
condition|(
name|decodabet
index|[
name|theByte
operator|&
literal|0x7f
index|]
operator|!=
name|WHITE_SPACE_ENC
condition|)
block|{
throw|throw
operator|new
name|java
operator|.
name|io
operator|.
name|IOException
argument_list|(
literal|"Invalid character in Base64 data."
argument_list|)
throw|;
block|}
comment|// end else: not white space either
block|}
comment|// end else: decoding
block|}
comment|// end write
comment|/**          * Calls {@link #write(int)} repeatedly until<var>len</var>           * bytes are written.          *          * @param theBytes array from which to read bytes          * @param off offset for array          * @param len max number of bytes to read into array          * @since 1.3          */
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|byte
index|[]
name|theBytes
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
block|{
comment|// Encoding suspended?
if|if
condition|(
name|suspendEncoding
condition|)
block|{
name|this
operator|.
name|out
operator|.
name|write
argument_list|(
name|theBytes
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// end if: supsended
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|write
argument_list|(
name|theBytes
index|[
name|off
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|// end for: each byte written
block|}
comment|// end write
comment|/**          * Method added by PHIL. [Thanks, PHIL. -Rob]          * This pads the buffer without closing the stream.          * @throws java.io.IOException  if there's an error.          */
specifier|public
name|void
name|flushBase64
parameter_list|()
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
block|{
if|if
condition|(
name|position
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|encode
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|encode3to4
argument_list|(
name|b4
argument_list|,
name|buffer
argument_list|,
name|position
argument_list|,
name|options
argument_list|)
argument_list|)
expr_stmt|;
name|position
operator|=
literal|0
expr_stmt|;
block|}
comment|// end if: encoding
else|else
block|{
throw|throw
operator|new
name|java
operator|.
name|io
operator|.
name|IOException
argument_list|(
literal|"Base64 input not properly padded."
argument_list|)
throw|;
block|}
comment|// end else: decoding
block|}
comment|// end if: buffer partially full
block|}
comment|// end flush
comment|/**           * Flushes and closes (I think, in the superclass) the stream.           *          * @since 1.3          */
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
block|{
comment|// 1. Ensure that pending characters are written
name|flushBase64
argument_list|()
expr_stmt|;
comment|// 2. Actually close the stream
comment|// Base class both flushes and closes.
name|super
operator|.
name|close
argument_list|()
expr_stmt|;
name|buffer
operator|=
literal|null
expr_stmt|;
name|out
operator|=
literal|null
expr_stmt|;
block|}
comment|// end close
comment|/**          * Suspends encoding of the stream.          * May be helpful if you need to embed a piece of          * base64-encoded data in a stream.          *          * @throws java.io.IOException  if there's an error flushing          * @since 1.5.1          */
specifier|public
name|void
name|suspendEncoding
parameter_list|()
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
block|{
name|flushBase64
argument_list|()
expr_stmt|;
name|this
operator|.
name|suspendEncoding
operator|=
literal|true
expr_stmt|;
block|}
comment|// end suspendEncoding
comment|/**          * Resumes encoding of the stream.          * May be helpful if you need to embed a piece of          * base64-encoded data in a stream.          *          * @since 1.5.1          */
specifier|public
name|void
name|resumeEncoding
parameter_list|()
block|{
name|this
operator|.
name|suspendEncoding
operator|=
literal|false
expr_stmt|;
block|}
comment|// end resumeEncoding
block|}
comment|// end inner class OutputStream
block|}
end_class

begin_comment
comment|// end class Base64
end_comment

end_unit

