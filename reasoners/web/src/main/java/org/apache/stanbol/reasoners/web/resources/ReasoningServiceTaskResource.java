begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|reasoners
operator|.
name|web
operator|.
name|resources
package|;
end_package

begin_import
import|import static
name|javax
operator|.
name|ws
operator|.
name|rs
operator|.
name|core
operator|.
name|MediaType
operator|.
name|APPLICATION_FORM_URLENCODED
import|;
end_import

begin_import
import|import static
name|javax
operator|.
name|ws
operator|.
name|rs
operator|.
name|core
operator|.
name|MediaType
operator|.
name|MULTIPART_FORM_DATA
import|;
end_import

begin_import
import|import static
name|javax
operator|.
name|ws
operator|.
name|rs
operator|.
name|core
operator|.
name|MediaType
operator|.
name|TEXT_HTML
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|MalformedURLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|servlet
operator|.
name|ServletContext
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|ws
operator|.
name|rs
operator|.
name|Consumes
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|ws
operator|.
name|rs
operator|.
name|FormParam
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|ws
operator|.
name|rs
operator|.
name|GET
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|ws
operator|.
name|rs
operator|.
name|POST
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|ws
operator|.
name|rs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|ws
operator|.
name|rs
operator|.
name|PathParam
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|ws
operator|.
name|rs
operator|.
name|Produces
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|ws
operator|.
name|rs
operator|.
name|QueryParam
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|ws
operator|.
name|rs
operator|.
name|WebApplicationException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|ws
operator|.
name|rs
operator|.
name|core
operator|.
name|Context
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|ws
operator|.
name|rs
operator|.
name|core
operator|.
name|HttpHeaders
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|ws
operator|.
name|rs
operator|.
name|core
operator|.
name|MultivaluedMap
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|ws
operator|.
name|rs
operator|.
name|core
operator|.
name|Response
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|ws
operator|.
name|rs
operator|.
name|core
operator|.
name|Response
operator|.
name|Status
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Graph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|MGraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Triple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|UriRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|access
operator|.
name|TcManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|impl
operator|.
name|TripleImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|serializedform
operator|.
name|Parser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|serializedform
operator|.
name|Serializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|serializedform
operator|.
name|SupportedFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|web
operator|.
name|base
operator|.
name|ContextHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|web
operator|.
name|base
operator|.
name|format
operator|.
name|KRFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|web
operator|.
name|base
operator|.
name|resource
operator|.
name|BaseStanbolResource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|ontonet
operator|.
name|api
operator|.
name|ONManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|ontonet
operator|.
name|api
operator|.
name|ontology
operator|.
name|OntologyScope
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|ontologymanager
operator|.
name|ontonet
operator|.
name|api
operator|.
name|ontology
operator|.
name|OntologySpace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|owl
operator|.
name|transformation
operator|.
name|JenaToOwlConvert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|reasoners
operator|.
name|jena
operator|.
name|JenaReasoningService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|reasoners
operator|.
name|owlapi
operator|.
name|OWLApiReasoningService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|reasoners
operator|.
name|servicesapi
operator|.
name|ReasoningService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|reasoners
operator|.
name|servicesapi
operator|.
name|ReasoningServicesManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|reasoners
operator|.
name|servicesapi
operator|.
name|UnboundReasoningServiceException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|reasoners
operator|.
name|web
operator|.
name|utils
operator|.
name|ReasoningServiceExecutor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|rules
operator|.
name|base
operator|.
name|api
operator|.
name|NoSuchRecipeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|rules
operator|.
name|base
operator|.
name|api
operator|.
name|Recipe
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|rules
operator|.
name|base
operator|.
name|api
operator|.
name|RuleStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|rules
operator|.
name|base
operator|.
name|api
operator|.
name|util
operator|.
name|RuleList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|apibinding
operator|.
name|OWLManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|io
operator|.
name|OWLOntologyCreationIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|io
operator|.
name|RDFXMLOntologyFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|AddImport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|AxiomType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|IRI
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|MissingImportEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|MissingImportListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLAxiom
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLDataFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLOntology
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLOntologyChange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLOntologyCreationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLOntologyLoaderListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLOntologyManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLOntologyManagerProperties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLOntologySetProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLOntologyStorageException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|SWRLRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|util
operator|.
name|OWLOntologyMerger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|ontology
operator|.
name|OntModel
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|rdf
operator|.
name|model
operator|.
name|Model
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|rdf
operator|.
name|model
operator|.
name|ModelFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|reasoner
operator|.
name|rulesys
operator|.
name|Rule
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|shared
operator|.
name|DoesNotExistException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|vocabulary
operator|.
name|OWL
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|jersey
operator|.
name|api
operator|.
name|core
operator|.
name|HttpContext
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|jersey
operator|.
name|api
operator|.
name|core
operator|.
name|HttpRequestContext
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|jersey
operator|.
name|api
operator|.
name|view
operator|.
name|Viewable
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|jersey
operator|.
name|multipart
operator|.
name|BodyPart
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|jersey
operator|.
name|multipart
operator|.
name|FormDataBodyPart
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|jersey
operator|.
name|multipart
operator|.
name|FormDataMultiPart
import|;
end_import

begin_comment
comment|/**  * Endpoint for reasoning services. Services can be invoked using the service name and task in the request  * path. The related active SCR service is selected, then the concrete execution is delegated to a {@see  * ReasoningServiceExecutor}.  *   * Two different kind of implementation of {@see ReasoningService} are supported: {@see JenaReasoningService}  * and {@see OWLApiReasonngService}.  *   * This class includes methods to prepare the input and dispatch the output (back to the client in the  * requested format or saved in the triple store).  *   */
end_comment

begin_class
annotation|@
name|Path
argument_list|(
literal|"/reasoners/{service}/{task}"
argument_list|)
specifier|public
class|class
name|ReasoningServiceTaskResource
extends|extends
name|BaseStanbolResource
block|{
specifier|private
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|getClass
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
name|ServletContext
name|context
decl_stmt|;
specifier|private
name|ReasoningService
argument_list|<
name|?
argument_list|,
name|?
argument_list|,
name|?
argument_list|>
name|service
decl_stmt|;
specifier|private
name|String
name|taskID
decl_stmt|;
specifier|private
name|HttpContext
name|httpContext
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|parameters
decl_stmt|;
specifier|private
name|TcManager
name|tcManager
decl_stmt|;
specifier|private
name|HttpHeaders
name|headers
decl_stmt|;
specifier|private
name|ONManager
name|onm
decl_stmt|;
specifier|private
name|Serializer
name|serializer
decl_stmt|;
specifier|private
name|RuleStore
name|ruleStore
decl_stmt|;
specifier|public
name|ReasoningServiceTaskResource
parameter_list|(
annotation|@
name|PathParam
argument_list|(
name|value
operator|=
literal|"service"
argument_list|)
name|String
name|serviceID
parameter_list|,
annotation|@
name|PathParam
argument_list|(
name|value
operator|=
literal|"task"
argument_list|)
name|String
name|taskID
parameter_list|,
annotation|@
name|Context
name|ServletContext
name|servletContext
parameter_list|,
annotation|@
name|Context
name|HttpHeaders
name|headers
parameter_list|,
annotation|@
name|Context
name|HttpContext
name|httpContext
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Called service {} to perform task {}"
argument_list|,
name|serviceID
argument_list|,
name|taskID
argument_list|)
expr_stmt|;
comment|// ServletContext
name|this
operator|.
name|context
operator|=
name|servletContext
expr_stmt|;
comment|// HttpContext
name|this
operator|.
name|httpContext
operator|=
name|httpContext
expr_stmt|;
comment|// HttpHeaders
name|this
operator|.
name|headers
operator|=
name|headers
expr_stmt|;
comment|// Parameters for customized reasoning services
name|this
operator|.
name|parameters
operator|=
name|prepareParameters
argument_list|()
expr_stmt|;
comment|// Clerezza storage
name|this
operator|.
name|tcManager
operator|=
operator|(
name|TcManager
operator|)
name|ContextHelper
operator|.
name|getServiceFromContext
argument_list|(
name|TcManager
operator|.
name|class
argument_list|,
name|servletContext
argument_list|)
expr_stmt|;
comment|// Retrieve the ontology network manager
name|this
operator|.
name|onm
operator|=
operator|(
name|ONManager
operator|)
name|ContextHelper
operator|.
name|getServiceFromContext
argument_list|(
name|ONManager
operator|.
name|class
argument_list|,
name|servletContext
argument_list|)
expr_stmt|;
comment|// Retrieve the ontology network manager
name|this
operator|.
name|ruleStore
operator|=
operator|(
name|RuleStore
operator|)
name|ContextHelper
operator|.
name|getServiceFromContext
argument_list|(
name|RuleStore
operator|.
name|class
argument_list|,
name|servletContext
argument_list|)
expr_stmt|;
comment|// Retrieve the clerezza serializer
name|this
operator|.
name|serializer
operator|=
operator|(
name|Serializer
operator|)
name|ContextHelper
operator|.
name|getServiceFromContext
argument_list|(
name|Serializer
operator|.
name|class
argument_list|,
name|servletContext
argument_list|)
expr_stmt|;
comment|// Retrieve the service
try|try
block|{
name|service
operator|=
name|getService
argument_list|(
name|serviceID
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnboundReasoningServiceException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Service not found: {}"
argument_list|,
name|serviceID
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|WebApplicationException
argument_list|(
name|e
argument_list|,
name|Response
operator|.
name|Status
operator|.
name|NOT_FOUND
argument_list|)
throw|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Service retrieved"
argument_list|)
expr_stmt|;
comment|// Check if the task is allowed
if|if
condition|(
name|this
operator|.
name|service
operator|.
name|supportsTask
argument_list|(
name|taskID
argument_list|)
operator|||
name|taskID
operator|.
name|equals
argument_list|(
name|ReasoningServiceExecutor
operator|.
name|TASK_CHECK
argument_list|)
condition|)
block|{
name|this
operator|.
name|taskID
operator|=
name|taskID
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Unsupported task (not found): {}"
argument_list|,
name|taskID
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|WebApplicationException
argument_list|(
operator|new
name|Exception
argument_list|(
literal|"Unsupported task (not found): "
operator|+
name|taskID
argument_list|)
argument_list|,
name|Response
operator|.
name|Status
operator|.
name|BAD_REQUEST
argument_list|)
throw|;
block|}
comment|// Now we check if the service implementation is supported
if|if
condition|(
name|getCurrentService
argument_list|()
operator|instanceof
name|JenaReasoningService
condition|)
block|{}
elseif|else
if|if
condition|(
name|getCurrentService
argument_list|()
operator|instanceof
name|OWLApiReasoningService
condition|)
block|{}
else|else
block|{
name|log
operator|.
name|error
argument_list|(
literal|"This implementation of ReasoningService is not supported: {}"
argument_list|,
name|getCurrentService
argument_list|()
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|WebApplicationException
argument_list|(
operator|new
name|Exception
argument_list|(
literal|"This implementation of ReasoningService is not supported: "
operator|+
name|getCurrentService
argument_list|()
operator|.
name|getClass
argument_list|()
argument_list|)
argument_list|,
name|Response
operator|.
name|Status
operator|.
name|INTERNAL_SERVER_ERROR
argument_list|)
throw|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Implementation is supported"
argument_list|)
expr_stmt|;
block|}
comment|/**      *       * @return      */
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|prepareParameters
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|parameters
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Preparing parameters..."
argument_list|)
expr_stmt|;
name|HttpRequestContext
name|request
init|=
name|this
operator|.
name|httpContext
operator|.
name|getRequest
argument_list|()
decl_stmt|;
comment|// Parameters for a GET request
name|MultivaluedMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|queryParameters
init|=
name|request
operator|.
name|getQueryParameters
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"... {} query parameters found"
argument_list|,
name|queryParameters
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|e
range|:
name|queryParameters
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|parameters
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Parameters for a POST request with content-type
comment|// application/x-www-form-urlencoded
name|MultivaluedMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|formParameters
init|=
name|request
operator|.
name|getFormParameters
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"... {} form urlencoded parameters found"
argument_list|,
name|formParameters
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|e
range|:
name|formParameters
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|parameters
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Parameters prepared"
argument_list|)
expr_stmt|;
return|return
name|parameters
return|;
block|}
comment|/**      * This is an alias of the get method.      *       * @param url      * @param targetGraphID      * @return      */
annotation|@
name|POST
annotation|@
name|Consumes
argument_list|(
block|{
name|APPLICATION_FORM_URLENCODED
block|}
argument_list|)
annotation|@
name|Produces
argument_list|(
block|{
name|TEXT_HTML
block|,
literal|"text/plain"
block|,
name|KRFormat
operator|.
name|RDF_XML
block|,
name|KRFormat
operator|.
name|TURTLE
block|,
literal|"text/turtle"
block|,
literal|"text/n3"
block|}
argument_list|)
specifier|public
name|Response
name|post
parameter_list|(
annotation|@
name|FormParam
argument_list|(
literal|"url"
argument_list|)
name|String
name|url
parameter_list|,
annotation|@
name|FormParam
argument_list|(
literal|"scope"
argument_list|)
name|String
name|scope
parameter_list|,
annotation|@
name|FormParam
argument_list|(
literal|"session"
argument_list|)
name|String
name|session
parameter_list|,
annotation|@
name|FormParam
argument_list|(
literal|"recipe"
argument_list|)
name|String
name|recipe
parameter_list|,
annotation|@
name|FormParam
argument_list|(
literal|"target"
argument_list|)
name|String
name|targetGraphID
parameter_list|)
block|{
return|return
name|get
argument_list|(
name|url
argument_list|,
name|scope
argument_list|,
name|session
argument_list|,
name|recipe
argument_list|,
name|targetGraphID
argument_list|)
return|;
block|}
comment|/**      * Get the inferences from input URL. If url param is null, get the HTML description of this service/task      *       * @param url      * @return      */
annotation|@
name|GET
annotation|@
name|Produces
argument_list|(
block|{
name|TEXT_HTML
block|,
literal|"text/plain"
block|,
name|KRFormat
operator|.
name|RDF_XML
block|,
name|KRFormat
operator|.
name|TURTLE
block|,
literal|"text/turtle"
block|,
literal|"text/n3"
block|}
argument_list|)
specifier|public
name|Response
name|get
parameter_list|(
annotation|@
name|QueryParam
argument_list|(
literal|"url"
argument_list|)
name|String
name|url
parameter_list|,
annotation|@
name|QueryParam
argument_list|(
literal|"scope"
argument_list|)
name|String
name|scope
parameter_list|,
annotation|@
name|QueryParam
argument_list|(
literal|"session"
argument_list|)
name|String
name|session
parameter_list|,
annotation|@
name|QueryParam
argument_list|(
literal|"recipe"
argument_list|)
name|String
name|recipe
parameter_list|,
annotation|@
name|QueryParam
argument_list|(
literal|"target"
argument_list|)
name|String
name|targetGraphID
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Called {} with parameters: {} "
argument_list|,
name|httpContext
operator|.
name|getRequest
argument_list|()
operator|.
name|getMethod
argument_list|()
argument_list|,
name|parameters
operator|.
name|keySet
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|parameters
operator|.
name|keySet
argument_list|()
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|// If all parameters are missing we produce the service/task welcome
comment|// page
if|if
condition|(
name|this
operator|.
name|parameters
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|Response
operator|.
name|ok
argument_list|(
operator|new
name|Viewable
argument_list|(
literal|"index"
argument_list|,
name|this
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
if|if
condition|(
name|url
operator|!=
literal|null
condition|)
block|{
comment|// We remove it form the additional parameter list
name|this
operator|.
name|parameters
operator|.
name|remove
argument_list|(
literal|"url"
argument_list|)
expr_stmt|;
block|}
comment|// We remove also target
name|this
operator|.
name|parameters
operator|.
name|remove
argument_list|(
literal|"target"
argument_list|)
expr_stmt|;
comment|// The service executor
name|ReasoningServiceExecutor
name|executor
init|=
operator|new
name|ReasoningServiceExecutor
argument_list|(
name|tcManager
argument_list|,
name|headers
argument_list|,
name|servletContext
argument_list|,
name|uriInfo
argument_list|)
decl_stmt|;
comment|/**          * Select the service implementation TODO Question: how this part could be decoupled?          */
if|if
condition|(
name|getCurrentService
argument_list|()
operator|instanceof
name|JenaReasoningService
condition|)
block|{
comment|// Prepare input data
name|Model
name|input
decl_stmt|;
try|try
block|{
name|input
operator|=
name|prepareJenaInputFromGET
argument_list|(
name|url
argument_list|,
name|scope
argument_list|,
name|session
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DoesNotExistException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|WebApplicationException
argument_list|(
name|e
argument_list|,
name|Response
operator|.
name|Status
operator|.
name|NOT_FOUND
argument_list|)
throw|;
block|}
comment|// Prepare rules
comment|// TODO (this is not implemented yet!)
name|List
argument_list|<
name|Rule
argument_list|>
name|rules
init|=
name|prepareJenaRules
argument_list|(
name|recipe
argument_list|)
decl_stmt|;
return|return
name|executor
operator|.
name|executeJenaReasoningService
argument_list|(
name|getCurrentTask
argument_list|()
argument_list|,
operator|(
name|JenaReasoningService
operator|)
name|getCurrentService
argument_list|()
argument_list|,
name|input
argument_list|,
name|rules
argument_list|,
name|targetGraphID
argument_list|,
literal|false
argument_list|,
name|this
operator|.
name|parameters
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|getCurrentService
argument_list|()
operator|instanceof
name|OWLApiReasoningService
condition|)
block|{
name|OWLOntology
name|input
init|=
literal|null
decl_stmt|;
try|try
block|{
name|input
operator|=
name|prepareOWLApiInputFromGET
argument_list|(
name|url
argument_list|,
name|scope
argument_list|,
name|session
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OWLOntologyCreationIOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|WebApplicationException
argument_list|(
name|e
argument_list|,
name|Response
operator|.
name|Status
operator|.
name|NOT_FOUND
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|OWLOntologyCreationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|WebApplicationException
argument_list|(
name|e
argument_list|,
name|Response
operator|.
name|Status
operator|.
name|INTERNAL_SERVER_ERROR
argument_list|)
throw|;
block|}
comment|// Prepare rules
name|List
argument_list|<
name|SWRLRule
argument_list|>
name|rules
init|=
name|prepareOWLApiRules
argument_list|(
name|recipe
argument_list|)
decl_stmt|;
return|return
name|executor
operator|.
name|executeOWLApiReasoningService
argument_list|(
name|getCurrentTask
argument_list|()
argument_list|,
operator|(
name|OWLApiReasoningService
operator|)
name|getCurrentService
argument_list|()
argument_list|,
name|input
argument_list|,
name|rules
argument_list|,
name|targetGraphID
argument_list|,
literal|false
argument_list|,
name|this
operator|.
name|parameters
argument_list|)
return|;
block|}
throw|throw
operator|new
name|WebApplicationException
argument_list|(
operator|new
name|Exception
argument_list|(
literal|"Unsupported implementation"
argument_list|)
argument_list|,
name|Response
operator|.
name|Status
operator|.
name|INTERNAL_SERVER_ERROR
argument_list|)
throw|;
block|}
comment|/**      * To catch additional parameters in case of a POST with content-type multipart/form-data, we need to      * acces the {@link FormDataMultiPart} representation of the input.      *       * @param data      * @return      */
annotation|@
name|POST
annotation|@
name|Consumes
argument_list|(
block|{
name|MULTIPART_FORM_DATA
block|}
argument_list|)
annotation|@
name|Produces
argument_list|(
block|{
name|TEXT_HTML
block|,
literal|"text/plain"
block|,
name|KRFormat
operator|.
name|RDF_XML
block|,
name|KRFormat
operator|.
name|TURTLE
block|,
literal|"text/turtle"
block|,
literal|"text/n3"
block|}
argument_list|)
specifier|public
name|Response
name|post
parameter_list|(
name|FormDataMultiPart
name|data
parameter_list|)
block|{
name|File
name|file
init|=
literal|null
decl_stmt|;
name|String
name|scope
init|=
literal|null
decl_stmt|;
name|String
name|session
init|=
literal|null
decl_stmt|;
name|String
name|recipe
init|=
literal|null
decl_stmt|;
name|String
name|targetGraphID
init|=
literal|null
decl_stmt|;
for|for
control|(
name|BodyPart
name|bpart
range|:
name|data
operator|.
name|getBodyParts
argument_list|()
control|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"is a {}"
argument_list|,
name|bpart
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpart
operator|instanceof
name|FormDataBodyPart
condition|)
block|{
name|FormDataBodyPart
name|dbp
init|=
operator|(
name|FormDataBodyPart
operator|)
name|bpart
decl_stmt|;
if|if
condition|(
name|dbp
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"target"
argument_list|)
condition|)
block|{
name|targetGraphID
operator|=
name|dbp
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dbp
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"file"
argument_list|)
condition|)
block|{
name|file
operator|=
name|bpart
operator|.
name|getEntityAs
argument_list|(
name|File
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dbp
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"scope"
argument_list|)
condition|)
block|{
name|scope
operator|=
operator|(
operator|(
name|FormDataBodyPart
operator|)
name|bpart
operator|)
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dbp
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"session"
argument_list|)
condition|)
block|{
name|session
operator|=
operator|(
operator|(
name|FormDataBodyPart
operator|)
name|bpart
operator|)
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dbp
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"recipe"
argument_list|)
condition|)
block|{
name|recipe
operator|=
operator|(
operator|(
name|FormDataBodyPart
operator|)
name|bpart
operator|)
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// We put all the rest in the parameters field
comment|// XXX We supports here only simple fields
comment|// We do NOT support the sent of additional files, for
comment|// example
if|if
condition|(
name|dbp
operator|.
name|isSimple
argument_list|()
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|parameters
operator|.
name|containsKey
argument_list|(
name|dbp
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|this
operator|.
name|parameters
operator|.
name|get
argument_list|(
name|dbp
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|dbp
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|List
argument_list|<
name|String
argument_list|>
name|values
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|values
operator|.
name|add
argument_list|(
name|dbp
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|parameters
operator|.
name|put
argument_list|(
name|dbp
operator|.
name|getName
argument_list|()
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|postData
argument_list|(
name|file
argument_list|,
name|scope
argument_list|,
name|session
argument_list|,
name|recipe
argument_list|,
name|targetGraphID
argument_list|)
return|;
block|}
comment|/**      * Generate inferences from the input file. Output comes back to the client.      *       * @param file      * @return      */
specifier|private
name|Response
name|postData
parameter_list|(
name|File
name|file
parameter_list|,
name|String
name|scope
parameter_list|,
name|String
name|session
parameter_list|,
name|String
name|recipe
parameter_list|,
name|String
name|targetGraphID
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Called {} with parameters: {} "
argument_list|,
name|httpContext
operator|.
name|getRequest
argument_list|()
operator|.
name|getMethod
argument_list|()
argument_list|,
name|parameters
operator|.
name|keySet
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|parameters
operator|.
name|keySet
argument_list|()
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|.
name|exists
argument_list|()
operator|&&
name|file
operator|.
name|canRead
argument_list|()
condition|)
block|{
comment|// The service executor
name|ReasoningServiceExecutor
name|executor
init|=
operator|new
name|ReasoningServiceExecutor
argument_list|(
name|tcManager
argument_list|,
name|headers
argument_list|,
name|servletContext
argument_list|,
name|uriInfo
argument_list|)
decl_stmt|;
comment|// Select the service implementation
if|if
condition|(
name|getCurrentService
argument_list|()
operator|instanceof
name|JenaReasoningService
condition|)
block|{
comment|// Prepare input data
name|Model
name|input
decl_stmt|;
try|try
block|{
name|input
operator|=
name|prepareJenaInputFromPOST
argument_list|(
name|file
argument_list|,
name|scope
argument_list|,
name|session
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MalformedURLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|WebApplicationException
argument_list|(
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot read file"
argument_list|)
argument_list|,
name|Response
operator|.
name|Status
operator|.
name|INTERNAL_SERVER_ERROR
argument_list|)
throw|;
block|}
comment|// Prepare rules
name|List
argument_list|<
name|Rule
argument_list|>
name|rules
init|=
name|prepareJenaRules
argument_list|(
name|recipe
argument_list|)
decl_stmt|;
return|return
name|executor
operator|.
name|executeJenaReasoningService
argument_list|(
name|getCurrentTask
argument_list|()
argument_list|,
operator|(
name|JenaReasoningService
operator|)
name|getCurrentService
argument_list|()
argument_list|,
name|input
argument_list|,
name|rules
argument_list|,
name|targetGraphID
argument_list|,
literal|false
argument_list|,
name|this
operator|.
name|parameters
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|getCurrentService
argument_list|()
operator|instanceof
name|OWLApiReasoningService
condition|)
block|{
name|OWLOntology
name|input
init|=
literal|null
decl_stmt|;
try|try
block|{
name|input
operator|=
name|prepareOWLApiInputFromPOST
argument_list|(
name|file
argument_list|,
name|scope
argument_list|,
name|session
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OWLOntologyCreationIOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|WebApplicationException
argument_list|(
name|e
argument_list|,
name|Response
operator|.
name|Status
operator|.
name|NOT_FOUND
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|OWLOntologyCreationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|WebApplicationException
argument_list|(
name|e
argument_list|,
name|Response
operator|.
name|Status
operator|.
name|INTERNAL_SERVER_ERROR
argument_list|)
throw|;
block|}
comment|// Prepare rules
name|List
argument_list|<
name|SWRLRule
argument_list|>
name|rules
init|=
name|prepareOWLApiRules
argument_list|(
name|recipe
argument_list|)
decl_stmt|;
return|return
name|executor
operator|.
name|executeOWLApiReasoningService
argument_list|(
name|getCurrentTask
argument_list|()
argument_list|,
operator|(
name|OWLApiReasoningService
operator|)
name|getCurrentService
argument_list|()
argument_list|,
name|input
argument_list|,
name|rules
argument_list|,
name|targetGraphID
argument_list|,
literal|false
argument_list|,
name|this
operator|.
name|parameters
argument_list|)
return|;
block|}
throw|throw
operator|new
name|WebApplicationException
argument_list|(
operator|new
name|Exception
argument_list|(
literal|"Unsupported implementation"
argument_list|)
argument_list|,
name|Response
operator|.
name|Status
operator|.
name|INTERNAL_SERVER_ERROR
argument_list|)
throw|;
block|}
else|else
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Cannot read file: {}"
argument_list|,
name|file
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|WebApplicationException
argument_list|(
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot read file"
argument_list|)
argument_list|,
name|Response
operator|.
name|Status
operator|.
name|INTERNAL_SERVER_ERROR
argument_list|)
throw|;
block|}
block|}
specifier|private
name|OWLOntologyManager
name|createOWLOntologyManager
parameter_list|()
block|{
comment|// We isolate here the creation of the temporary manager
comment|// TODO How to behave when resolving owl:imports?
comment|// We should set the manager to use a service to lookup for ontologies,
comment|// instead of trying on the web
comment|// directly
name|OWLOntologyManager
name|manager
init|=
name|OWLManager
operator|.
name|createOWLOntologyManager
argument_list|()
decl_stmt|;
comment|// FIXME Which is the other way of doing this?
comment|// Maybe -> OWLOntologyManagerProperties();
name|manager
operator|.
name|setSilentMissingImportsHandling
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Listening for missing imports
name|manager
operator|.
name|addMissingImportListener
argument_list|(
operator|new
name|MissingImportListener
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|importMissing
parameter_list|(
name|MissingImportEvent
name|arg0
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Missing import {} "
argument_list|,
name|arg0
operator|.
name|getImportedOntologyURI
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|manager
operator|.
name|addOntologyLoaderListener
argument_list|(
operator|new
name|OWLOntologyLoaderListener
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|finishedLoadingOntology
parameter_list|(
name|LoadingFinishedEvent
name|arg0
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Finished loading {} (imported: {})"
argument_list|,
name|arg0
operator|.
name|getOntologyID
argument_list|()
argument_list|,
name|arg0
operator|.
name|isImported
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|startedLoadingOntology
parameter_list|(
name|LoadingStartedEvent
name|arg0
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Started loading {} (imported: {}) ..."
argument_list|,
name|arg0
operator|.
name|getOntologyID
argument_list|()
argument_list|,
name|arg0
operator|.
name|isImported
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|" ... from {}"
argument_list|,
name|arg0
operator|.
name|getDocumentIRI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|manager
return|;
block|}
comment|/**      * The actual path, to be used in the template.      *       * @return      */
specifier|public
name|String
name|getCurrentPath
parameter_list|()
block|{
return|return
name|uriInfo
operator|.
name|getPath
argument_list|()
operator|.
name|replaceAll
argument_list|(
literal|"[\\/]*$"
argument_list|,
literal|""
argument_list|)
return|;
block|}
comment|/**      * The selected service      *       * @return      */
specifier|public
name|ReasoningService
argument_list|<
name|?
argument_list|,
name|?
argument_list|,
name|?
argument_list|>
name|getCurrentService
parameter_list|()
block|{
return|return
name|this
operator|.
name|service
return|;
block|}
comment|/**      * The selected task      *       * @return      */
specifier|public
name|String
name|getCurrentTask
parameter_list|()
block|{
return|return
name|this
operator|.
name|taskID
return|;
block|}
comment|/**      * The list of supported tasks. We include CHECK, which is managed directly by the endpoint.      */
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getSupportedTasks
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|supported
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|supported
operator|.
name|add
argument_list|(
name|ReasoningServiceExecutor
operator|.
name|TASK_CHECK
argument_list|)
expr_stmt|;
name|supported
operator|.
name|addAll
argument_list|(
name|getCurrentService
argument_list|()
operator|.
name|getSupportedTasks
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|supported
return|;
block|}
comment|/**      * To retrieve the service using the service manager      *       * @param servicePath      * @return      * @throws UnboundReasoningServiceException      */
specifier|private
name|ReasoningService
argument_list|<
name|?
argument_list|,
name|?
argument_list|,
name|?
argument_list|>
name|getService
parameter_list|(
name|String
name|servicePath
parameter_list|)
throws|throws
name|UnboundReasoningServiceException
block|{
return|return
name|getServicesManager
argument_list|()
operator|.
name|get
argument_list|(
name|servicePath
argument_list|)
return|;
block|}
comment|/**      * Get the service manager from the context      *       * @return      */
specifier|private
name|ReasoningServicesManager
name|getServicesManager
parameter_list|()
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"(getServicesManager()) "
argument_list|)
expr_stmt|;
return|return
operator|(
name|ReasoningServicesManager
operator|)
name|ContextHelper
operator|.
name|getServiceFromContext
argument_list|(
name|ReasoningServicesManager
operator|.
name|class
argument_list|,
name|this
operator|.
name|context
argument_list|)
return|;
block|}
specifier|private
name|Object
name|getFromOntonet
parameter_list|(
name|String
name|scopeID
parameter_list|,
name|String
name|sessionID
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|type
parameter_list|)
block|{
comment|/**          * FIXME The code below does not work, even if it should, or the API is not clear at all...          *           *           * Set<SessionOntologySpace> spaces = onm.getSessionManager() .getSessionSpaces(sessionIRI);          *           * There MUST be 1 single session which such ID. Why this method? What happens if there are more then          * 1 space? Probably it is not possible, but why this method returns a set? In addition, the method          * returns **all** sessions (?!).          *           * The code below seems do not work properly (maybe I misunderstood something) also:          *           * try {          *           *           * if (!spaces.isEmpty()) {          *           * log.info("found {} session spaces", spaces.size());          *           * for (SessionOntologySpace s : spaces)          *           * log.info(" - {}", s.asOWLOntology());          *           * All empty ontologies! (and not only the one identified by the session ID, there are other sessions          * within, this is puzzling...)          *           * Then, even if we get the first possible, at the moment ...          *           * SessionOntologySpace session = spaces.iterator().next(); log.info("Found session: {}", session);          *           * OWLOntology sessionOntology = session.asOWLOntology();          *           *           * // WHAT I EXPECTED? I expect here to have the ontology network of the session, in this fashion:          *           * - The SESSION space ontology, which includes (owl:imports):          *           * 1) 0...n ontologies, loaded after session creation; they owl:imports the CUSTOM ontology          *           * 2) The CUSTOM space ontology, which includes (owl:imports):          *           * - 0...n ontologies, loaded after scope creation, they owl:imports the CORE          *           * - The CORE space ontology, which includes (owl:imports):          *           * - 0...n ontologies loaded on scope creation          *           *           * Instead, I have an empty ontology :(          *           * int importsSize = sessionOntology.getImports().size();          *           * log.info("Session ontology: {}", sessionOntology); // No axioms log.info("Imports {} ontologies",          * importsSize); // No imports          *           * for (OWLOntology i : sessionOntology.getImports()) { log.info(" - {}", i);          *           * }          *           * return sessionOntology;          *           * } else {          *           * log.error( "The session {} does not exists or have been deleted", sessionID);          *           * throw new IllegalArgumentException("Session does not exists!");          *           * }          *           * } catch (NonReferenceableSessionException e) {          * log.error("The session {} does not exists or have been deleted", sessionID);          *           * throw new IllegalArgumentException("Session does not exists!", e);          *           * }          */
comment|/**          * FIXME! Another problem with the OntoNet API: Sessions are retrieved from ANY scope, in other words          * if we have a session we cannot know which is the scope bound. Maybe because you can use data in a          * session with any other scope? If yes, why this method? Why I can access sessions from a scope?          *           * IRI sessionIRI = IRI.create(sessionID);          *           * ScopeRegistry registry = onm.getScopeRegistry();          *           * Set<OntologyScope> scopes = registry.getActiveScopes();          *           *           * OntologyScope scope = null;          *           * SessionOntologySpace sessionSpace = null;          *           * for (OntologyScope s : scopes) {          *           * sessionSpace = s.getSessionSpace(sessionIRI);          *           * if (sessionSpace != null) {          *           * log.info("Found session on scope {}", s.getID());          *           * scope = s;          *           * }          *           * }          */
comment|/**          * FIXME! THIS SHOULD BE DONE BY ONTONET! We pack the ontology network on our own...          *           */
try|try
block|{
comment|// We must know both scope and session
name|IRI
name|scopeIRI
init|=
name|IRI
operator|.
name|create
argument_list|(
name|scopeID
argument_list|)
decl_stmt|;
name|OntologyScope
name|scope
init|=
name|onm
operator|.
name|getScopeRegistry
argument_list|()
operator|.
name|getScope
argument_list|(
name|scopeIRI
argument_list|)
decl_stmt|;
if|if
condition|(
name|scope
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Scope {} cannot be retrieved"
argument_list|,
name|sessionID
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|WebApplicationException
argument_list|(
name|Response
operator|.
name|Status
operator|.
name|NOT_FOUND
argument_list|)
throw|;
block|}
name|OntologySpace
name|sessionSpace
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|sessionID
operator|!=
literal|null
condition|)
block|{
name|IRI
name|sessionIRI
init|=
name|IRI
operator|.
name|create
argument_list|(
name|sessionID
argument_list|)
decl_stmt|;
name|sessionSpace
operator|=
name|scope
operator|.
name|getSessionSpace
argument_list|(
name|sessionIRI
argument_list|)
expr_stmt|;
block|}
name|OntologySpace
name|coreSpace
init|=
name|scope
operator|.
name|getCoreSpace
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|OWLOntology
argument_list|>
name|coreOntologies
init|=
name|coreSpace
operator|.
name|getOntologies
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Found {} ontologies in core space"
argument_list|,
name|coreOntologies
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|OntologySpace
name|customSpace
init|=
name|scope
operator|.
name|getCustomSpace
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|OWLOntology
argument_list|>
name|customOntologies
init|=
name|customSpace
operator|.
name|getOntologies
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Found {} ontologies in custom space"
argument_list|,
name|coreOntologies
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|OWLOntology
argument_list|>
name|sessionOntologies
init|=
operator|new
name|HashSet
argument_list|<
name|OWLOntology
argument_list|>
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Found {} ontologies in session space"
argument_list|,
name|coreOntologies
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|sessionSpace
operator|!=
literal|null
condition|)
block|{
comment|// We collect all the ontologies in session (here we use
comment|// 'false')
comment|// The reason is that the set contains also an ontology which is
comment|// the
comment|// root of the session space, with buggy owl:import
name|sessionOntologies
operator|.
name|addAll
argument_list|(
name|sessionSpace
operator|.
name|getOntologies
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**              * FIXME Remove this code. It is not runtime code!!!              *               * We have tried here to create a real network, anyway this is very inefficient, so we use the              * latter way...              *               * We keep it here for the moment as study...              *               */
if|if
condition|(
literal|false
condition|)
block|{
comment|// Prepare the CORE space
name|OWLOntologyManager
name|m
init|=
name|createOWLOntologyManager
argument_list|()
decl_stmt|;
name|OWLDataFactory
name|f
init|=
name|m
operator|.
name|getOWLDataFactory
argument_list|()
decl_stmt|;
name|OWLOntology
name|on_CORE
init|=
name|m
operator|.
name|createOntology
argument_list|(
name|IRI
operator|.
name|create
argument_list|(
literal|"ontonet:__CORE__"
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|OWLOntologyChange
argument_list|>
name|addImports
init|=
operator|new
name|ArrayList
argument_list|<
name|OWLOntologyChange
argument_list|>
argument_list|()
decl_stmt|;
comment|// We want to load ALL ontologies (to support transitive
comment|// imports)
name|log
operator|.
name|info
argument_list|(
literal|"CORE space: {} [{}]"
argument_list|,
name|coreSpace
operator|.
name|getID
argument_list|()
argument_list|,
name|coreOntologies
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|OWLOntology
name|o
range|:
name|coreOntologies
control|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|" loading {}"
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|OWLOntology
name|oLoaded
init|=
name|decantOntology
argument_list|(
name|o
argument_list|,
name|m
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Loaded {}"
argument_list|,
name|oLoaded
argument_list|)
expr_stmt|;
comment|// We add the import if it is a direct import
if|if
condition|(
name|coreSpace
operator|.
name|getOntologies
argument_list|(
literal|false
argument_list|)
operator|.
name|contains
argument_list|(
name|o
argument_list|)
condition|)
block|{
comment|// The we prepare the import statement for the CORE
comment|// ontology
name|addImports
operator|.
name|add
argument_list|(
operator|new
name|AddImport
argument_list|(
name|on_CORE
argument_list|,
name|f
operator|.
name|getOWLImportsDeclaration
argument_list|(
name|oLoaded
operator|.
name|getOntologyID
argument_list|()
operator|.
name|getOntologyIRI
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|" preparing change CORE owl:imports {}"
argument_list|,
name|oLoaded
argument_list|)
expr_stmt|;
block|}
block|}
name|m
operator|.
name|applyChanges
argument_list|(
name|addImports
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Change applied"
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"NETWORK::CORE :: {}"
argument_list|,
name|on_CORE
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
name|buildImportsTree
argument_list|(
name|on_CORE
argument_list|)
argument_list|)
expr_stmt|;
comment|// Prepare the CUSTOM space
name|OWLOntology
name|on_CUSTOM
init|=
name|m
operator|.
name|createOntology
argument_list|(
name|IRI
operator|.
name|create
argument_list|(
literal|"ontonet:__CUSTOM__"
argument_list|)
argument_list|)
decl_stmt|;
comment|// Reset changes
name|addImports
operator|=
operator|new
name|ArrayList
argument_list|<
name|OWLOntologyChange
argument_list|>
argument_list|()
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"CUSTOM space: {} [{}]"
argument_list|,
name|customSpace
operator|.
name|getID
argument_list|()
argument_list|,
name|customOntologies
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|OWLOntology
name|o
range|:
name|customOntologies
control|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|" loading {}"
argument_list|,
name|o
argument_list|)
expr_stmt|;
comment|// We add the import if it is a direct import
if|if
condition|(
name|customSpace
operator|.
name|getOntologies
argument_list|(
literal|false
argument_list|)
operator|.
name|contains
argument_list|(
name|o
argument_list|)
condition|)
block|{
comment|/**                          * We need this conversion every time we want to change the imports declaration of an                          * ontology which contains axioms. This because an import statement change the way an                          * axiom is interpreted. For example, if a property is not defined as                          * OWLObjectProperty or rdfs:Property, it will be loaded as OWLAnnotationProperty !!!                          */
name|MGraph
name|g
init|=
name|toGraph
argument_list|(
name|o
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|" adding owl:imports CORE"
argument_list|)
expr_stmt|;
comment|// In the network, this ontology will import the CORE
name|g
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
operator|new
name|UriRef
argument_list|(
name|o
operator|.
name|getOntologyID
argument_list|()
operator|.
name|getOntologyIRI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
operator|new
name|UriRef
argument_list|(
name|OWL
operator|.
name|imports
operator|.
name|getURI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
operator|new
name|UriRef
argument_list|(
name|on_CORE
operator|.
name|getOntologyID
argument_list|()
operator|.
name|getOntologyIRI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Load in manager
name|OWLOntology
name|oImported
init|=
name|loadGraph
argument_list|(
name|g
argument_list|,
name|m
argument_list|)
decl_stmt|;
name|g
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Custom imports this ontology (custom is empty, so we
comment|// don't need a graph)
name|log
operator|.
name|info
argument_list|(
literal|" preparing change CUSTOM owl:imports {}"
argument_list|,
name|oImported
argument_list|)
expr_stmt|;
comment|// The we prepare the import statement for the CUSTOM
comment|// ontology
name|addImports
operator|.
name|add
argument_list|(
operator|new
name|AddImport
argument_list|(
name|on_CUSTOM
argument_list|,
name|f
operator|.
name|getOWLImportsDeclaration
argument_list|(
name|o
operator|.
name|getOntologyID
argument_list|()
operator|.
name|getOntologyIRI
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Loaded {}"
argument_list|,
name|oImported
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// We directly load it in the manager
name|OWLOntology
name|oLoaded
init|=
name|decantOntology
argument_list|(
name|o
argument_list|,
name|m
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Loaded {}"
argument_list|,
name|oLoaded
argument_list|)
expr_stmt|;
block|}
block|}
comment|// CUSTOM imports CORE
name|addImports
operator|.
name|add
argument_list|(
operator|new
name|AddImport
argument_list|(
name|on_CUSTOM
argument_list|,
name|f
operator|.
name|getOWLImportsDeclaration
argument_list|(
name|on_CORE
operator|.
name|getOntologyID
argument_list|()
operator|.
name|getOntologyIRI
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|" preparing change CUSTOM owl:imports CORE"
argument_list|)
expr_stmt|;
name|m
operator|.
name|applyChanges
argument_list|(
name|addImports
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"NETWORK::CUSTOM :: {}"
argument_list|,
name|on_CUSTOM
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
name|buildImportsTree
argument_list|(
name|on_CUSTOM
argument_list|)
argument_list|)
expr_stmt|;
comment|// /////////////////////////////////////////////////////////////////////////////////////////////////
comment|// Prepare the SESSION
name|OWLOntology
name|on_SESSION
init|=
name|m
operator|.
name|createOntology
argument_list|(
name|IRI
operator|.
name|create
argument_list|(
literal|"ontonet:__SESSION__"
argument_list|)
argument_list|)
decl_stmt|;
comment|// Reset changes
name|addImports
operator|=
operator|new
name|ArrayList
argument_list|<
name|OWLOntologyChange
argument_list|>
argument_list|()
expr_stmt|;
comment|// Prepare SESSION
name|log
operator|.
name|info
argument_list|(
literal|"SESSION space: {} [{}]"
argument_list|,
name|sessionSpace
operator|.
name|getID
argument_list|()
argument_list|,
name|sessionOntologies
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|OWLOntology
name|o
range|:
name|sessionOntologies
control|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|" loading {}"
argument_list|,
name|o
argument_list|)
expr_stmt|;
comment|// We add the import if it is a direct import
if|if
condition|(
name|sessionSpace
operator|.
name|getOntologies
argument_list|(
literal|false
argument_list|)
operator|.
name|contains
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|" adding owl:imports CUSTOM"
argument_list|)
expr_stmt|;
comment|/**                          * We need this conversion every time we want to change the imports declaration of an                          * ontology which contains axioms. This because an import statement change the way an                          * axiom is interpreted. For example, if a property is not defined as                          * OWLObjectProperty or rdfs:Property, it will be loaded as OWLAnnotationProperty !!!                          */
name|MGraph
name|g
init|=
name|toGraph
argument_list|(
name|o
argument_list|)
decl_stmt|;
comment|// In the network, this ontology will import the CUSTOM
name|Triple
name|triple
init|=
operator|new
name|TripleImpl
argument_list|(
operator|new
name|UriRef
argument_list|(
name|o
operator|.
name|getOntologyID
argument_list|()
operator|.
name|getOntologyIRI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
operator|new
name|UriRef
argument_list|(
name|OWL
operator|.
name|imports
operator|.
name|getURI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
operator|new
name|UriRef
argument_list|(
name|on_CUSTOM
operator|.
name|getOntologyID
argument_list|()
operator|.
name|getOntologyIRI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|" prepared import triple: {}"
argument_list|,
name|triple
argument_list|)
expr_stmt|;
name|g
operator|.
name|add
argument_list|(
name|triple
argument_list|)
expr_stmt|;
comment|// Load in manager
name|OWLOntology
name|oLoaded
init|=
name|loadGraph
argument_list|(
name|g
argument_list|,
name|m
argument_list|)
decl_stmt|;
comment|// remove the temporary mgraph
name|g
operator|.
name|clear
argument_list|()
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|" preparing change SESSION owl:imports {}"
argument_list|,
name|oLoaded
argument_list|)
expr_stmt|;
comment|// The we prepare the import statement for the CUSTOM
comment|// ontology
name|addImports
operator|.
name|add
argument_list|(
operator|new
name|AddImport
argument_list|(
name|on_SESSION
argument_list|,
name|f
operator|.
name|getOWLImportsDeclaration
argument_list|(
name|o
operator|.
name|getOntologyID
argument_list|()
operator|.
name|getOntologyIRI
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Loaded {}"
argument_list|,
name|oLoaded
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Or we directly go in the manager
name|OWLOntology
name|oLoaded
init|=
name|decantOntology
argument_list|(
name|o
argument_list|,
name|m
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Loaded {}"
argument_list|,
name|oLoaded
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|" loaded."
argument_list|)
expr_stmt|;
block|}
comment|// SESSION imports CUSTOM
name|log
operator|.
name|info
argument_list|(
literal|" preparing change SESSION owl:imports CUSTOM"
argument_list|)
expr_stmt|;
name|addImports
operator|.
name|add
argument_list|(
operator|new
name|AddImport
argument_list|(
name|on_SESSION
argument_list|,
name|f
operator|.
name|getOWLImportsDeclaration
argument_list|(
name|on_CUSTOM
operator|.
name|getOntologyID
argument_list|()
operator|.
name|getOntologyIRI
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|OWLOntologyChange
name|change
range|:
name|addImports
control|)
name|log
operator|.
name|info
argument_list|(
literal|"CHANGE : {}"
argument_list|,
name|change
argument_list|)
expr_stmt|;
name|m
operator|.
name|applyChanges
argument_list|(
name|addImports
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"NETWORK::SESSION :: {}"
argument_list|,
name|on_SESSION
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
name|buildImportsTree
argument_list|(
name|on_SESSION
argument_list|)
argument_list|)
expr_stmt|;
comment|// log.info("Check");
comment|// for (OWLOntology o : on_SESSION.getImports()) {
comment|// log.info("checking {}", o);
comment|// for (OWLAxiom a : o.getAxioms())
comment|// log.info("- {} [{}]", a, a.getAxiomType());
comment|// }
block|}
comment|/**              * This way is more efficient              */
specifier|final
name|Set
argument_list|<
name|OWLOntology
argument_list|>
name|set
init|=
operator|new
name|HashSet
argument_list|<
name|OWLOntology
argument_list|>
argument_list|()
decl_stmt|;
name|set
operator|.
name|addAll
argument_list|(
name|coreOntologies
argument_list|)
expr_stmt|;
name|set
operator|.
name|addAll
argument_list|(
name|customOntologies
argument_list|)
expr_stmt|;
name|set
operator|.
name|addAll
argument_list|(
name|sessionOntologies
argument_list|)
expr_stmt|;
comment|/**              * Now we merge the ontologies              */
name|OWLOntologyMerger
name|merger
init|=
operator|new
name|OWLOntologyMerger
argument_list|(
operator|new
name|OWLOntologySetProvider
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|OWLOntology
argument_list|>
name|getOntologies
parameter_list|()
block|{
return|return
name|set
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|OWLOntology
name|merged
init|=
name|merger
operator|.
name|createMergedOntology
argument_list|(
name|createOWLOntologyManager
argument_list|()
argument_list|,
name|IRI
operator|.
name|create
argument_list|(
literal|"reasoners:input-"
operator|+
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|Object
name|output
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|isAssignableFrom
argument_list|(
name|Model
operator|.
name|class
argument_list|)
condition|)
block|{
name|output
operator|=
operator|new
name|JenaToOwlConvert
argument_list|()
operator|.
name|ModelOwlToJenaConvert
argument_list|(
name|merged
argument_list|,
literal|"RDF/XML"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|isAssignableFrom
argument_list|(
name|OWLOntology
operator|.
name|class
argument_list|)
condition|)
block|{
name|OWLOntology
name|ready
init|=
name|decantOntology
argument_list|(
name|merged
argument_list|,
name|createOWLOntologyManager
argument_list|()
argument_list|)
decl_stmt|;
name|output
operator|=
name|ready
expr_stmt|;
comment|//output = merged;
block|}
else|else
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
operator|new
name|Exception
argument_list|(
literal|"Only Model.class and OWLOntology.class are allowed"
argument_list|)
argument_list|)
throw|;
return|return
name|output
return|;
block|}
catch|catch
parameter_list|(
name|OWLOntologyCreationException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"The network for scope/session cannot be retrieved:"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
catch|catch
parameter_list|(
name|OWLOntologyStorageException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"The network for scope/session cannot be retrieved:"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The network for scope/session cannot be retrieved"
argument_list|)
throw|;
block|}
block|}
specifier|private
name|OWLOntology
name|decantOntology
parameter_list|(
name|OWLOntology
name|o
parameter_list|,
name|OWLOntologyManager
name|into
parameter_list|)
throws|throws
name|OWLOntologyStorageException
throws|,
name|OWLOntologyCreationException
block|{
name|ByteArrayOutputStream
name|baos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|o
operator|.
name|getOWLOntologyManager
argument_list|()
operator|.
name|saveOntology
argument_list|(
name|o
argument_list|,
name|baos
argument_list|)
expr_stmt|;
name|ByteArrayInputStream
name|bais
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|baos
operator|.
name|toByteArray
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|into
operator|.
name|loadOntologyFromOntologyDocument
argument_list|(
name|bais
argument_list|)
return|;
block|}
comment|/**      * The returned graph must be removed as soon as possible!      *       * @param o      * @return      * @throws OWLOntologyStorageException      */
specifier|private
name|MGraph
name|toGraph
parameter_list|(
name|OWLOntology
name|o
parameter_list|)
throws|throws
name|OWLOntologyStorageException
block|{
name|ByteArrayOutputStream
name|baos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|o
operator|.
name|getOWLOntologyManager
argument_list|()
operator|.
name|saveOntology
argument_list|(
name|o
argument_list|,
operator|new
name|RDFXMLOntologyFormat
argument_list|()
argument_list|,
name|baos
argument_list|)
expr_stmt|;
name|ByteArrayInputStream
name|bais
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|baos
operator|.
name|toByteArray
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Parser
name|parser
init|=
name|Parser
operator|.
name|getInstance
argument_list|()
decl_stmt|;
name|Graph
name|deserializedGraph
init|=
name|parser
operator|.
name|parse
argument_list|(
name|bais
argument_list|,
literal|"application/rdf+xml"
argument_list|)
decl_stmt|;
comment|// FIXME Find a better way to generate the temporary ID
name|String
name|temporaryID
init|=
literal|"reasoners-network-temporary-"
operator|+
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|MGraph
name|temporaryGraph
init|=
name|tcManager
operator|.
name|createMGraph
argument_list|(
operator|new
name|UriRef
argument_list|(
name|temporaryID
argument_list|)
argument_list|)
decl_stmt|;
name|temporaryGraph
operator|.
name|addAll
argument_list|(
name|deserializedGraph
argument_list|)
expr_stmt|;
return|return
name|temporaryGraph
return|;
block|}
specifier|private
name|OWLOntology
name|loadGraph
parameter_list|(
name|MGraph
name|g
parameter_list|,
name|OWLOntologyManager
name|m
parameter_list|)
throws|throws
name|OWLOntologyCreationException
block|{
name|ByteArrayOutputStream
name|baos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|serializer
operator|.
name|serialize
argument_list|(
name|baos
argument_list|,
name|g
argument_list|,
name|SupportedFormat
operator|.
name|RDF_XML
argument_list|)
expr_stmt|;
return|return
name|m
operator|.
name|loadOntologyFromOntologyDocument
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|baos
operator|.
name|toByteArray
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|StringBuilder
name|recursiveImportsTree
parameter_list|(
name|OWLOntology
name|on
parameter_list|,
name|StringBuilder
name|builder
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|String
name|ls
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
decl_stmt|;
name|String
name|lvl
init|=
literal|"--"
decl_stmt|;
for|for
control|(
name|OWLOntology
name|ch
range|:
name|on
operator|.
name|getDirectImports
argument_list|()
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|ls
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|level
condition|;
name|x
operator|++
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|lvl
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|append
argument_list|(
literal|"> "
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|ch
operator|.
name|getOntologyID
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|" [imports: "
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|ch
operator|.
name|getDirectImports
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|"] [axioms: "
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|ch
operator|.
name|getAxiomCount
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|"] [logical axioms: "
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|ch
operator|.
name|getLogicalAxiomCount
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|"] [annotations: "
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|ch
operator|.
name|getAxiomCount
argument_list|(
name|AxiomType
operator|.
name|ANNOTATION_ASSERTION
argument_list|)
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|.
name|getDirectImports
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|builder
operator|=
name|recursiveImportsTree
argument_list|(
name|ch
argument_list|,
name|builder
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|builder
return|;
block|}
specifier|private
name|String
name|buildImportsTree
parameter_list|(
name|OWLOntology
name|o
parameter_list|)
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|b
operator|.
name|append
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
name|recursiveImportsTree
argument_list|(
name|o
argument_list|,
name|b
argument_list|,
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Gets the list of active services      *       * @return      */
specifier|public
name|Set
argument_list|<
name|ReasoningService
argument_list|<
name|?
argument_list|,
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|getActiveServices
parameter_list|()
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"(getActiveServices()) There are {} reasoning services"
argument_list|,
name|getServicesManager
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|getServicesManager
argument_list|()
operator|.
name|asUnmodifiableSet
argument_list|()
return|;
block|}
specifier|private
name|Model
name|prepareJenaInputFromGET
parameter_list|(
name|String
name|url
parameter_list|,
name|String
name|scope
parameter_list|,
name|String
name|session
parameter_list|)
block|{
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"[start] Prepare input for Jena "
argument_list|)
expr_stmt|;
name|OntModel
name|input
init|=
name|ModelFactory
operator|.
name|createOntologyModel
argument_list|()
decl_stmt|;
comment|// Get the network as Jena model
if|if
condition|(
name|scope
operator|!=
literal|null
condition|)
block|{
name|input
operator|.
name|add
argument_list|(
operator|(
name|Model
operator|)
name|getFromOntonet
argument_list|(
name|scope
argument_list|,
name|session
argument_list|,
name|Model
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// If url exists, merge the location within the model
if|if
condition|(
name|url
operator|!=
literal|null
condition|)
block|{
name|input
operator|.
name|read
argument_list|(
name|url
argument_list|)
expr_stmt|;
block|}
name|long
name|end
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"[end] Prepared input for Jena in {} ms. Size is: {}"
argument_list|,
operator|(
name|end
operator|-
name|start
operator|)
argument_list|,
name|input
operator|.
name|getGraph
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|input
return|;
block|}
specifier|private
name|Model
name|prepareJenaInputFromPOST
parameter_list|(
name|File
name|file
parameter_list|,
name|String
name|scope
parameter_list|,
name|String
name|session
parameter_list|)
throws|throws
name|MalformedURLException
block|{
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"[start] Prepare input for Jena "
argument_list|)
expr_stmt|;
name|OntModel
name|input
init|=
name|ModelFactory
operator|.
name|createOntologyModel
argument_list|()
decl_stmt|;
comment|// Get the network as Jena model
if|if
condition|(
name|scope
operator|!=
literal|null
condition|)
block|{
name|input
operator|.
name|add
argument_list|(
operator|(
name|Model
operator|)
name|getFromOntonet
argument_list|(
name|scope
argument_list|,
name|session
argument_list|,
name|Model
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// If file exists, merge the location within the model
if|if
condition|(
name|file
operator|!=
literal|null
condition|)
block|{
name|input
operator|.
name|read
argument_list|(
name|file
operator|.
name|toURI
argument_list|()
operator|.
name|toURL
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|long
name|end
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"[end] Prepared input for Jena in {} ms. Size is: {}"
argument_list|,
operator|(
name|end
operator|-
name|start
operator|)
argument_list|,
name|input
operator|.
name|getGraph
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|input
return|;
block|}
specifier|private
name|OWLOntology
name|prepareOWLApiInputFromGET
parameter_list|(
name|String
name|url
parameter_list|,
name|String
name|scope
parameter_list|,
name|String
name|session
parameter_list|)
throws|throws
name|OWLOntologyCreationException
block|{
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"[start] Prepare input for OWLApi "
argument_list|)
expr_stmt|;
name|OWLOntology
name|input
decl_stmt|;
if|if
condition|(
name|scope
operator|!=
literal|null
condition|)
block|{
name|input
operator|=
operator|(
name|OWLOntology
operator|)
name|getFromOntonet
argument_list|(
name|scope
argument_list|,
name|session
argument_list|,
name|OWLOntology
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|input
operator|=
name|createOWLOntologyManager
argument_list|()
operator|.
name|createOntology
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|url
operator|!=
literal|null
condition|)
block|{
comment|// We add additional axioms
name|OWLOntology
name|fromUrl
init|=
name|input
operator|.
name|getOWLOntologyManager
argument_list|()
operator|.
name|loadOntologyFromOntologyDocument
argument_list|(
name|IRI
operator|.
name|create
argument_list|(
name|url
argument_list|)
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|OWLOntology
argument_list|>
name|all
init|=
name|fromUrl
operator|.
name|getImportsClosure
argument_list|()
decl_stmt|;
for|for
control|(
name|OWLOntology
name|o
range|:
name|all
control|)
block|{
for|for
control|(
name|OWLAxiom
name|a
range|:
name|o
operator|.
name|getAxioms
argument_list|()
control|)
block|{
name|input
operator|.
name|getOWLOntologyManager
argument_list|()
operator|.
name|addAxiom
argument_list|(
name|input
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
block|}
block|}
try|try
block|{
synchronized|synchronized
init|(
name|input
init|)
block|{
name|input
operator|=
name|decantOntology
argument_list|(
name|input
argument_list|,
name|OWLManager
operator|.
name|createOWLOntologyManager
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|OWLOntologyStorageException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Cannot prepare the input"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|OWLOntologyCreationException
argument_list|()
throw|;
block|}
name|long
name|end
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"[end] Prepared input for OWLApi in {} ms. Size is: {}"
argument_list|,
operator|(
name|end
operator|-
name|start
operator|)
argument_list|,
name|input
operator|.
name|getAxiomCount
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|input
return|;
block|}
specifier|private
name|OWLOntology
name|prepareOWLApiInputFromPOST
parameter_list|(
name|File
name|file
parameter_list|,
name|String
name|scope
parameter_list|,
name|String
name|session
parameter_list|)
throws|throws
name|OWLOntologyCreationException
block|{
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"[start] Prepare input for OWLApi "
argument_list|)
expr_stmt|;
name|OWLOntology
name|input
decl_stmt|;
if|if
condition|(
name|scope
operator|!=
literal|null
condition|)
block|{
name|input
operator|=
operator|(
name|OWLOntology
operator|)
name|getFromOntonet
argument_list|(
name|scope
argument_list|,
name|session
argument_list|,
name|OWLOntology
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|input
operator|=
name|createOWLOntologyManager
argument_list|()
operator|.
name|createOntology
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|file
operator|!=
literal|null
condition|)
block|{
comment|// We add additional axioms
name|OWLOntology
name|fromUrl
init|=
name|input
operator|.
name|getOWLOntologyManager
argument_list|()
operator|.
name|loadOntologyFromOntologyDocument
argument_list|(
name|file
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|OWLOntology
argument_list|>
name|all
init|=
name|fromUrl
operator|.
name|getImportsClosure
argument_list|()
decl_stmt|;
for|for
control|(
name|OWLOntology
name|o
range|:
name|all
control|)
block|{
for|for
control|(
name|OWLAxiom
name|a
range|:
name|o
operator|.
name|getAxioms
argument_list|()
control|)
block|{
name|input
operator|.
name|getOWLOntologyManager
argument_list|()
operator|.
name|addAxiom
argument_list|(
name|input
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
block|}
block|}
try|try
block|{
synchronized|synchronized
init|(
name|input
init|)
block|{
name|input
operator|=
name|decantOntology
argument_list|(
name|input
argument_list|,
name|OWLManager
operator|.
name|createOWLOntologyManager
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|OWLOntologyStorageException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Cannot prepare the input"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|OWLOntologyCreationException
argument_list|()
throw|;
block|}
name|long
name|end
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"[end] Prepared input for OWLApi in {} ms. Size is: {}"
argument_list|,
operator|(
name|end
operator|-
name|start
operator|)
argument_list|,
name|input
operator|.
name|getAxiomCount
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|input
return|;
block|}
specifier|private
name|List
argument_list|<
name|Rule
argument_list|>
name|prepareJenaRules
parameter_list|(
name|String
name|recipe
parameter_list|)
block|{
if|if
condition|(
name|recipe
operator|!=
literal|null
condition|)
block|{
comment|// If recipe exists, parse it as a list of Jena rules
comment|// TODO This cannot be implemented since Jena rules format is not
comment|// yet supported by the Rules
comment|// module!!! (See STANBOL-186)
name|log
operator|.
name|error
argument_list|(
literal|"prepareJenaRules(String recipe) Not implemented yet!"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|WebApplicationException
argument_list|(
literal|501
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|List
argument_list|<
name|SWRLRule
argument_list|>
name|prepareOWLApiRules
parameter_list|(
name|String
name|recipe
parameter_list|)
block|{
name|List
argument_list|<
name|SWRLRule
argument_list|>
name|rules
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|recipe
operator|!=
literal|null
condition|)
block|{
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"[start] Prepare rules for OWLApi "
argument_list|)
expr_stmt|;
comment|// If recipe exists, return it as a list of SWRL rules
name|rules
operator|=
operator|new
name|ArrayList
argument_list|<
name|SWRLRule
argument_list|>
argument_list|()
expr_stmt|;
try|try
block|{
name|Recipe
name|rec
init|=
name|ruleStore
operator|.
name|getRecipe
argument_list|(
name|IRI
operator|.
name|create
argument_list|(
name|recipe
argument_list|)
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Recipe is: {}"
argument_list|,
name|rec
argument_list|)
expr_stmt|;
name|RuleList
name|ruleList
init|=
name|rec
operator|.
name|getkReSRuleList
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"RuleList is: {}"
argument_list|,
name|ruleList
argument_list|)
expr_stmt|;
for|for
control|(
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|rules
operator|.
name|base
operator|.
name|api
operator|.
name|Rule
name|r
range|:
name|ruleList
control|)
block|{
name|SWRLRule
name|swrl
init|=
name|r
operator|.
name|toSWRL
argument_list|(
name|OWLManager
operator|.
name|getOWLDataFactory
argument_list|()
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Prepared rule: {}"
argument_list|,
name|swrl
argument_list|)
expr_stmt|;
name|rules
operator|.
name|add
argument_list|(
name|swrl
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NoSuchRecipeException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Recipe {} does not exists"
argument_list|,
name|recipe
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|WebApplicationException
argument_list|(
name|e
argument_list|,
name|Status
operator|.
name|NOT_FOUND
argument_list|)
throw|;
block|}
name|long
name|end
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"[end] Prepared {} rules for OWLApi in {} ms."
argument_list|,
name|rules
operator|.
name|size
argument_list|()
argument_list|,
operator|(
name|end
operator|-
name|start
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|rules
return|;
block|}
block|}
end_class

end_unit

