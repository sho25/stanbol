begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|reasoners
operator|.
name|hermit
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|reasoners
operator|.
name|servicesapi
operator|.
name|InconsistentInputException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|reasoners
operator|.
name|servicesapi
operator|.
name|ReasoningService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|reasoners
operator|.
name|servicesapi
operator|.
name|ReasoningServiceException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|reasoners
operator|.
name|servicesapi
operator|.
name|UnsupportedTaskException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|AddImport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|AxiomType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|IRI
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLAxiom
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLClassAssertionAxiom
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLDisjointClassesAxiom
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLEquivalentClassesAxiom
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLImportsDeclaration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLLogicalAxiom
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLOntology
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLOntologyCreationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLOntologyID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLOntologyManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLSubClassOfAxiom
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|SWRLRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|reasoner
operator|.
name|OWLReasoner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|util
operator|.
name|InferredAxiomGenerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|util
operator|.
name|InferredClassAssertionAxiomGenerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Tests for the HermitReasoningService These tests should be significant for any OWLApiReasoningService.  *   * TODO: we may want to isolate this is a separate test mini-framework.  *   */
end_comment

begin_class
specifier|public
class|class
name|HermitReasoningServiceTest
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|HermitReasoningServiceTest
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
name|HermitReasoningService
name|theinstance
decl_stmt|;
comment|/**      * This method instantiate the reasoning services to work with in this tests      */
annotation|@
name|Before
specifier|public
name|void
name|setUp
parameter_list|()
block|{
name|this
operator|.
name|theinstance
operator|=
operator|new
name|HermitReasoningService
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testInstantiation
parameter_list|()
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Testing the innstantiation of an HermitReasoningService"
argument_list|)
expr_stmt|;
name|OWLOntology
name|foaf
init|=
name|TestData
operator|.
name|manager
operator|.
name|getOntology
argument_list|(
name|IRI
operator|.
name|create
argument_list|(
name|TestData
operator|.
name|FOAF_NS
argument_list|)
argument_list|)
decl_stmt|;
comment|// Here we want to be sure that the getReasoner() method creates an
comment|// instance correctly
name|HermitReasoningService
name|akindofhermit
init|=
operator|new
name|HermitReasoningService
argument_list|()
block|{
specifier|protected
name|OWLReasoner
name|getReasoner
parameter_list|(
name|OWLOntology
name|ontology
parameter_list|)
block|{
try|try
block|{
name|OWLReasoner
name|reasoner
init|=
name|super
operator|.
name|getReasoner
argument_list|(
name|ontology
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|reasoner
operator|!=
literal|null
argument_list|)
expr_stmt|;
return|return
name|reasoner
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Some prolem occurred while instantiating the HermitReasoningService. Message was: {}"
argument_list|,
name|t
operator|.
name|getLocalizedMessage
argument_list|()
argument_list|)
expr_stmt|;
comment|// We force tests to stop here
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
block|}
decl_stmt|;
name|long
name|startHere
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
comment|// This is possible only because the subclass is in this scope...
name|akindofhermit
operator|.
name|getReasoner
argument_list|(
name|foaf
argument_list|)
expr_stmt|;
name|long
name|endHere
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Instantiating an Hermit reasoner lasts {} milliseconds"
argument_list|,
operator|(
name|endHere
operator|-
name|startHere
operator|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|testRun
parameter_list|(
name|String
name|testID
parameter_list|,
name|String
name|expectedID
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Testing the run() method"
argument_list|)
expr_stmt|;
name|OWLOntologyManager
name|manager
init|=
name|TestData
operator|.
name|manager
decl_stmt|;
comment|// We prepare the input ontology
try|try
block|{
name|OWLOntology
name|testOntology
init|=
name|manager
operator|.
name|createOntology
argument_list|()
decl_stmt|;
name|OWLOntologyID
name|testOntologyID
init|=
name|testOntology
operator|.
name|getOntologyID
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Created test ontology with ID: {}"
argument_list|,
name|testOntologyID
argument_list|)
expr_stmt|;
name|AddImport
name|addImport
init|=
operator|new
name|AddImport
argument_list|(
name|testOntology
argument_list|,
name|TestData
operator|.
name|factory
operator|.
name|getOWLImportsDeclaration
argument_list|(
name|IRI
operator|.
name|create
argument_list|(
name|testID
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|manager
operator|.
name|applyChange
argument_list|(
name|addImport
argument_list|)
expr_stmt|;
comment|// We just test class assertions
name|List
argument_list|<
name|InferredAxiomGenerator
argument_list|<
name|?
extends|extends
name|OWLAxiom
argument_list|>
argument_list|>
name|gens
init|=
operator|new
name|ArrayList
argument_list|<
name|InferredAxiomGenerator
argument_list|<
name|?
extends|extends
name|OWLAxiom
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|gens
operator|.
name|add
argument_list|(
operator|new
name|InferredClassAssertionAxiomGenerator
argument_list|()
argument_list|)
expr_stmt|;
comment|// Maybe we want to see what is in before
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|TestUtils
operator|.
name|debug
argument_list|(
name|manager
operator|.
name|getOntology
argument_list|(
name|testOntologyID
argument_list|)
argument_list|,
name|log
argument_list|)
expr_stmt|;
comment|// Now we test the method
name|log
operator|.
name|debug
argument_list|(
literal|"Running HermiT"
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|OWLAxiom
argument_list|>
name|inferred
init|=
name|this
operator|.
name|theinstance
operator|.
name|run
argument_list|(
name|manager
operator|.
name|getOntology
argument_list|(
name|testOntologyID
argument_list|)
argument_list|,
name|gens
argument_list|)
decl_stmt|;
comment|// Maybe we want to see the inferred axiom list
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|TestUtils
operator|.
name|debug
argument_list|(
name|inferred
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
comment|// These are the set of expected axioms
name|Set
argument_list|<
name|OWLLogicalAxiom
argument_list|>
name|expectedAxioms
init|=
name|manager
operator|.
name|getOntology
argument_list|(
name|IRI
operator|.
name|create
argument_list|(
name|expectedID
argument_list|)
argument_list|)
operator|.
name|getLogicalAxioms
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|OWLAxiom
argument_list|>
name|missing
init|=
operator|new
name|HashSet
argument_list|<
name|OWLAxiom
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|OWLAxiom
name|expected
range|:
name|expectedAxioms
control|)
block|{
if|if
condition|(
operator|!
name|inferred
operator|.
name|contains
argument_list|(
name|expected
argument_list|)
condition|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"missing expected axiom: {}"
argument_list|,
name|expected
argument_list|)
expr_stmt|;
name|missing
operator|.
name|add
argument_list|(
name|expected
argument_list|)
expr_stmt|;
block|}
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Are all expected axioms in the result (true)? {}"
argument_list|,
name|missing
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|missing
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
comment|// We want to remove the ontology from the manager
name|manager
operator|.
name|removeOntology
argument_list|(
name|testOntology
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OWLOntologyCreationException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"An {} have been thrown while creating the input ontology for test"
argument_list|,
name|e
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|reasoners
operator|.
name|servicesapi
operator|.
name|ReasoningServiceException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"An {} have been thrown while executing the reasoning"
argument_list|,
name|e
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|reasoners
operator|.
name|servicesapi
operator|.
name|InconsistentInputException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"An {} have been thrown while executing the reasoning"
argument_list|,
name|e
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRun
parameter_list|()
block|{
name|testRun
argument_list|(
name|TestData
operator|.
name|TEST_1_NS
argument_list|,
name|TestData
operator|.
name|TEST_1_expected_NS
argument_list|)
expr_stmt|;
block|}
comment|/**      * Tests the classify() method      */
annotation|@
name|Test
specifier|public
name|void
name|testClassify
parameter_list|()
block|{
name|testClassify
argument_list|(
name|TestData
operator|.
name|TEST_1_NS
argument_list|,
name|TestData
operator|.
name|TEST_1_expected_NS
argument_list|)
expr_stmt|;
block|}
comment|/**      * We may want to test this method with more then 1 ontology. This is why the implementation is in      * aprivate method. This method tests if all the logical axioms in testExpectedID ontology are inferences      * of the testID ontology.      *       * @param testID      *            // The ID of the ontology to be the input (loaded in the TestData.manager)      * @param testExpectedID      *            // The ID of the ontology which contains logical axioms expected in the result      */
specifier|private
name|void
name|testClassify
parameter_list|(
name|String
name|testID
parameter_list|,
name|String
name|testExpectedID
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Testing the CLASSIFY task"
argument_list|)
expr_stmt|;
name|OWLOntologyManager
name|manager
init|=
name|TestData
operator|.
name|manager
decl_stmt|;
comment|// We prepare the input ontology
try|try
block|{
name|OWLOntology
name|testOntology
init|=
name|manager
operator|.
name|createOntology
argument_list|()
decl_stmt|;
name|OWLOntologyID
name|testOntologyID
init|=
name|testOntology
operator|.
name|getOntologyID
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Created test ontology with ID: {}"
argument_list|,
name|testOntologyID
argument_list|)
expr_stmt|;
name|manager
operator|.
name|applyChange
argument_list|(
operator|new
name|AddImport
argument_list|(
name|testOntology
argument_list|,
name|TestData
operator|.
name|factory
operator|.
name|getOWLImportsDeclaration
argument_list|(
name|IRI
operator|.
name|create
argument_list|(
name|testID
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Maybe we want to see what is in before
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|TestUtils
operator|.
name|debug
argument_list|(
name|manager
operator|.
name|getOntology
argument_list|(
name|testOntologyID
argument_list|)
argument_list|,
name|log
argument_list|)
expr_stmt|;
comment|// Now we test the method
name|log
operator|.
name|debug
argument_list|(
literal|"Running HermiT"
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|OWLAxiom
argument_list|>
name|inferred
init|=
name|this
operator|.
name|theinstance
operator|.
name|runTask
argument_list|(
name|ReasoningService
operator|.
name|Tasks
operator|.
name|CLASSIFY
argument_list|,
name|manager
operator|.
name|getOntology
argument_list|(
name|testOntologyID
argument_list|)
argument_list|)
decl_stmt|;
comment|// Maybe we want to see the inferred axiom list
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|TestUtils
operator|.
name|debug
argument_list|(
name|inferred
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|OWLLogicalAxiom
argument_list|>
name|expectedAxioms
init|=
name|manager
operator|.
name|getOntology
argument_list|(
name|IRI
operator|.
name|create
argument_list|(
name|testExpectedID
argument_list|)
argument_list|)
operator|.
name|getLogicalAxioms
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|OWLAxiom
argument_list|>
name|missing
init|=
operator|new
name|HashSet
argument_list|<
name|OWLAxiom
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|OWLAxiom
name|expected
range|:
name|expectedAxioms
control|)
block|{
if|if
condition|(
operator|!
name|inferred
operator|.
name|contains
argument_list|(
name|expected
argument_list|)
condition|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"missing expected axiom: {}"
argument_list|,
name|expected
argument_list|)
expr_stmt|;
name|missing
operator|.
name|add
argument_list|(
name|expected
argument_list|)
expr_stmt|;
block|}
block|}
name|assertTrue
argument_list|(
name|missing
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
comment|// We want only Class related axioms in the result set
for|for
control|(
name|OWLAxiom
name|a
range|:
name|inferred
control|)
block|{
name|assertTrue
argument_list|(
name|a
operator|instanceof
name|OWLClassAssertionAxiom
operator|||
name|a
operator|instanceof
name|OWLSubClassOfAxiom
operator|||
name|a
operator|instanceof
name|OWLEquivalentClassesAxiom
operator|||
name|a
operator|instanceof
name|OWLDisjointClassesAxiom
argument_list|)
expr_stmt|;
block|}
comment|// We want to remove the ontology from the manager
name|manager
operator|.
name|removeOntology
argument_list|(
name|testOntology
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OWLOntologyCreationException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"An {} have been thrown while creating the input ontology for test"
argument_list|,
name|e
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReasoningServiceException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"An {} have been thrown while executing the reasoning"
argument_list|,
name|e
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InconsistentInputException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"An {} have been thrown while executing the reasoning"
argument_list|,
name|e
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedTaskException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"An {} have been thrown while executing the reasoning"
argument_list|,
name|e
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * We may want to test this method with more then 1 ontology. This is why the implementation is in      * aprivate method. This method tests if all the logical axioms in testExpectedID ontology are inferences      * of the testID ontology.      *       * TODO: This method is the same as testClassify(String,String), with the only difference - the task      * called. We may want to have this procedure isolated.      *       * @param testID      *            // The ID of the ontology to be the input (loaded in the TestData.manager)      * @param testExpectedID      *            // The ID of the ontology which contains logical axioms expected in the result      */
specifier|private
name|void
name|testEnrich
parameter_list|(
name|String
name|testID
parameter_list|,
name|String
name|testExpectedID
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Testing the ENRICH task"
argument_list|)
expr_stmt|;
name|OWLOntologyManager
name|manager
init|=
name|TestData
operator|.
name|manager
decl_stmt|;
comment|// We prepare the input ontology
try|try
block|{
name|OWLOntology
name|testOntology
init|=
name|manager
operator|.
name|createOntology
argument_list|()
decl_stmt|;
name|OWLOntologyID
name|testOntologyID
init|=
name|testOntology
operator|.
name|getOntologyID
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Created test ontology with ID: {}"
argument_list|,
name|testOntologyID
argument_list|)
expr_stmt|;
name|OWLImportsDeclaration
name|importTest
init|=
name|TestData
operator|.
name|factory
operator|.
name|getOWLImportsDeclaration
argument_list|(
name|IRI
operator|.
name|create
argument_list|(
name|testID
argument_list|)
argument_list|)
decl_stmt|;
name|manager
operator|.
name|applyChange
argument_list|(
operator|new
name|AddImport
argument_list|(
name|testOntology
argument_list|,
name|importTest
argument_list|)
argument_list|)
expr_stmt|;
comment|// Maybe we want to see what is in before
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|TestUtils
operator|.
name|debug
argument_list|(
name|manager
operator|.
name|getOntology
argument_list|(
name|testOntologyID
argument_list|)
argument_list|,
name|log
argument_list|)
expr_stmt|;
comment|// Now we test the method
name|log
operator|.
name|debug
argument_list|(
literal|"Running HermiT"
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|OWLAxiom
argument_list|>
name|inferred
init|=
name|this
operator|.
name|theinstance
operator|.
name|runTask
argument_list|(
name|ReasoningService
operator|.
name|Tasks
operator|.
name|ENRICH
argument_list|,
name|manager
operator|.
name|getOntology
argument_list|(
name|testOntologyID
argument_list|)
argument_list|)
decl_stmt|;
comment|// Maybe we want to see the inferred axiom list
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|TestUtils
operator|.
name|debug
argument_list|(
name|inferred
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|OWLLogicalAxiom
argument_list|>
name|expectedAxioms
init|=
name|manager
operator|.
name|getOntology
argument_list|(
name|IRI
operator|.
name|create
argument_list|(
name|testExpectedID
argument_list|)
argument_list|)
operator|.
name|getLogicalAxioms
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|OWLAxiom
argument_list|>
name|missing
init|=
operator|new
name|HashSet
argument_list|<
name|OWLAxiom
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|OWLAxiom
name|expected
range|:
name|expectedAxioms
control|)
block|{
if|if
condition|(
operator|!
name|inferred
operator|.
name|contains
argument_list|(
name|expected
argument_list|)
condition|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"missing expected axiom: {}"
argument_list|,
name|expected
argument_list|)
expr_stmt|;
name|missing
operator|.
name|add
argument_list|(
name|expected
argument_list|)
expr_stmt|;
block|}
block|}
name|assertTrue
argument_list|(
name|missing
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
comment|// We want to remove the ontology from the manager
name|manager
operator|.
name|removeOntology
argument_list|(
name|testOntology
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OWLOntologyCreationException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"An {} have been thrown while creating the input ontology for test"
argument_list|,
name|e
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReasoningServiceException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"An {} have been thrown while executing the reasoning"
argument_list|,
name|e
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InconsistentInputException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"An {} have been thrown while executing the reasoning"
argument_list|,
name|e
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedTaskException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"An {} have been thrown while executing the reasoning"
argument_list|,
name|e
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * This method check if the result types are the ones expected      *       */
annotation|@
name|Test
specifier|public
name|void
name|testEnrichResultTypes
parameter_list|()
block|{
comment|// We want all kind of Axioms in the result set
comment|// Well, not all types, but at least 1 for each
comment|// InferredAxiomGenerator<?>
name|AxiomType
argument_list|<
name|?
argument_list|>
index|[]
name|types
init|=
block|{
name|AxiomType
operator|.
name|CLASS_ASSERTION
block|,
name|AxiomType
operator|.
name|SUBCLASS_OF
block|,
name|AxiomType
operator|.
name|SUB_DATA_PROPERTY
block|,
name|AxiomType
operator|.
name|SUB_OBJECT_PROPERTY
block|,
name|AxiomType
operator|.
name|DISJOINT_CLASSES
block|,
name|AxiomType
operator|.
name|EQUIVALENT_DATA_PROPERTIES
block|,
name|AxiomType
operator|.
name|EQUIVALENT_OBJECT_PROPERTIES
block|,
name|AxiomType
operator|.
name|INVERSE_OBJECT_PROPERTIES
block|,
name|AxiomType
operator|.
name|EQUIVALENT_CLASSES
block|,
name|AxiomType
operator|.
name|DISJOINT_CLASSES
block|}
decl_stmt|;
comment|// Call the test method
name|testEnrichResultTypes
argument_list|(
name|TestData
operator|.
name|TEST_1_NS
argument_list|,
name|types
argument_list|)
expr_stmt|;
block|}
comment|/**      *       * @param testID      *            // The ontology to run      * @param types      *            // The type of axioms we expect in the result      */
specifier|private
name|void
name|testEnrichResultTypes
parameter_list|(
name|String
name|testID
parameter_list|,
name|AxiomType
argument_list|<
name|?
argument_list|>
index|[]
name|types
parameter_list|)
block|{
name|List
argument_list|<
name|AxiomType
argument_list|<
name|?
argument_list|>
argument_list|>
name|typelist
init|=
operator|new
name|ArrayList
argument_list|<
name|AxiomType
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|typelist
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|types
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Testing the enrich() method (result axioms types)"
argument_list|)
expr_stmt|;
name|OWLOntologyManager
name|manager
init|=
name|TestData
operator|.
name|manager
decl_stmt|;
comment|// We prepare the input ontology
try|try
block|{
name|OWLOntology
name|testOntology
init|=
name|manager
operator|.
name|createOntology
argument_list|()
decl_stmt|;
name|OWLOntologyID
name|testOntologyID
init|=
name|testOntology
operator|.
name|getOntologyID
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Created test ontology with ID: {}"
argument_list|,
name|testOntologyID
argument_list|)
expr_stmt|;
name|OWLImportsDeclaration
name|importTest
init|=
name|TestData
operator|.
name|factory
operator|.
name|getOWLImportsDeclaration
argument_list|(
name|IRI
operator|.
name|create
argument_list|(
name|testID
argument_list|)
argument_list|)
decl_stmt|;
name|manager
operator|.
name|applyChange
argument_list|(
operator|new
name|AddImport
argument_list|(
name|testOntology
argument_list|,
name|importTest
argument_list|)
argument_list|)
expr_stmt|;
comment|// Maybe we want to see what is in before
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|TestUtils
operator|.
name|debug
argument_list|(
name|manager
operator|.
name|getOntology
argument_list|(
name|testOntologyID
argument_list|)
argument_list|,
name|log
argument_list|)
expr_stmt|;
comment|// Now we test the method
name|log
operator|.
name|debug
argument_list|(
literal|"Running HermiT"
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|OWLAxiom
argument_list|>
name|inferred
init|=
name|this
operator|.
name|theinstance
operator|.
name|runTask
argument_list|(
name|ReasoningService
operator|.
name|Tasks
operator|.
name|ENRICH
argument_list|,
name|manager
operator|.
name|getOntology
argument_list|(
name|testOntologyID
argument_list|)
argument_list|)
decl_stmt|;
comment|// Maybe we want to see the inferred axiom list
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|TestUtils
operator|.
name|debug
argument_list|(
name|inferred
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|OWLAxiom
name|a
range|:
name|inferred
control|)
block|{
name|typelist
operator|.
name|remove
argument_list|(
name|a
operator|.
name|getAxiomType
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|typelist
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|AxiomType
argument_list|<
name|?
argument_list|>
name|t
range|:
name|typelist
control|)
name|log
operator|.
name|error
argument_list|(
literal|"Missing axiom type: {}"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|assertTrue
argument_list|(
name|typelist
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
comment|// We want to remove the ontology from the manager
name|manager
operator|.
name|removeOntology
argument_list|(
name|testOntology
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OWLOntologyCreationException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"An {} have been thrown while creating the input ontology for test"
argument_list|,
name|e
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReasoningServiceException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"An {} have been thrown while executing the reasoning"
argument_list|,
name|e
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InconsistentInputException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"An {} have been thrown while executing the reasoning"
argument_list|,
name|e
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedTaskException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"An {} have been thrown while executing the reasoning"
argument_list|,
name|e
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testEnrich
parameter_list|()
block|{
name|testEnrich
argument_list|(
name|TestData
operator|.
name|TEST_1_NS
argument_list|,
name|TestData
operator|.
name|TEST_1_expected_NS
argument_list|)
expr_stmt|;
block|}
comment|/**      * Test if the ontology is consistent or not.      */
annotation|@
name|Test
specifier|public
name|void
name|testIsConsistent
parameter_list|()
block|{
comment|// This first ontology is consistent
name|testIsConsistent
argument_list|(
name|TestData
operator|.
name|TEST_1_NS
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// The second is not consistent
name|testIsConsistent
argument_list|(
name|TestData
operator|.
name|TEST_2_NS
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Check whether the ontology is consistent      *       * @param testID      *            // The ID of the ontology to test      * @param expected      *            // If it is expected to be consistent or not      */
specifier|private
name|void
name|testIsConsistent
parameter_list|(
name|String
name|testID
parameter_list|,
name|boolean
name|expected
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Testing the isConsistent method"
argument_list|)
expr_stmt|;
name|OWLOntologyManager
name|manager
init|=
name|TestData
operator|.
name|manager
decl_stmt|;
comment|// We prepare the input ontology
try|try
block|{
name|OWLOntology
name|testOntology
init|=
name|manager
operator|.
name|createOntology
argument_list|()
decl_stmt|;
name|OWLOntologyID
name|testOntologyID
init|=
name|testOntology
operator|.
name|getOntologyID
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Created test ontology with ID: {}"
argument_list|,
name|testOntologyID
argument_list|)
expr_stmt|;
name|OWLImportsDeclaration
name|importTest
init|=
name|TestData
operator|.
name|factory
operator|.
name|getOWLImportsDeclaration
argument_list|(
name|IRI
operator|.
name|create
argument_list|(
name|testID
argument_list|)
argument_list|)
decl_stmt|;
name|manager
operator|.
name|applyChange
argument_list|(
operator|new
name|AddImport
argument_list|(
name|testOntology
argument_list|,
name|importTest
argument_list|)
argument_list|)
expr_stmt|;
comment|// Maybe we want to see what is in before
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|TestUtils
operator|.
name|debug
argument_list|(
name|manager
operator|.
name|getOntology
argument_list|(
name|testOntologyID
argument_list|)
argument_list|,
name|log
argument_list|)
expr_stmt|;
comment|// Now we test the method
name|log
operator|.
name|debug
argument_list|(
literal|"Running HermiT"
argument_list|)
expr_stmt|;
try|try
block|{
name|assertTrue
argument_list|(
name|this
operator|.
name|theinstance
operator|.
name|isConsistent
argument_list|(
name|testOntology
argument_list|)
operator|==
name|expected
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReasoningServiceException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Error while testing the isConsistent method. Message was: {}"
argument_list|,
name|e
operator|.
name|getLocalizedMessage
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// We want to remove the ontology from the manager
name|manager
operator|.
name|removeOntology
argument_list|(
name|testOntology
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OWLOntologyCreationException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"An {} have been thrown while creating the input ontology for test"
argument_list|,
name|e
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testClassifyWithRules
parameter_list|()
block|{
name|testClassifyWithRules
argument_list|(
name|TestData
operator|.
name|TEST_3_NS
argument_list|,
name|TestData
operator|.
name|TEST_3_rules_NS
argument_list|,
name|TestData
operator|.
name|TEST_3_expected_NS
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testEnrichWithRules
parameter_list|()
block|{
name|testEnrichWithRules
argument_list|(
name|TestData
operator|.
name|TEST_3_NS
argument_list|,
name|TestData
operator|.
name|TEST_3_rules_NS
argument_list|,
name|TestData
operator|.
name|TEST_3_expected_NS
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|testClassifyWithRules
parameter_list|(
name|String
name|testID
parameter_list|,
name|String
name|rulesID
parameter_list|,
name|String
name|testExpectedID
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Testing the task CLASSIFY with rules"
argument_list|)
expr_stmt|;
name|OWLOntologyManager
name|manager
init|=
name|TestData
operator|.
name|manager
decl_stmt|;
comment|// We prepare the input ontology
try|try
block|{
name|OWLOntology
name|testOntology
init|=
name|manager
operator|.
name|createOntology
argument_list|()
decl_stmt|;
name|OWLOntologyID
name|testOntologyID
init|=
name|testOntology
operator|.
name|getOntologyID
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Created test ontology with ID: {}"
argument_list|,
name|testOntologyID
argument_list|)
expr_stmt|;
name|OWLImportsDeclaration
name|importTest
init|=
name|TestData
operator|.
name|factory
operator|.
name|getOWLImportsDeclaration
argument_list|(
name|IRI
operator|.
name|create
argument_list|(
name|testID
argument_list|)
argument_list|)
decl_stmt|;
name|manager
operator|.
name|applyChange
argument_list|(
operator|new
name|AddImport
argument_list|(
name|testOntology
argument_list|,
name|importTest
argument_list|)
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|SWRLRule
argument_list|>
name|rules
init|=
name|manager
operator|.
name|getOntology
argument_list|(
name|IRI
operator|.
name|create
argument_list|(
name|rulesID
argument_list|)
argument_list|)
operator|.
name|getAxioms
argument_list|(
name|AxiomType
operator|.
name|SWRL_RULE
argument_list|)
decl_stmt|;
comment|// Maybe we want to see the list of rules
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"List of {} rules: "
argument_list|,
name|rules
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|TestUtils
operator|.
name|debug
argument_list|(
name|rules
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|debug
argument_list|(
literal|"We add the rules to the ontology"
argument_list|)
expr_stmt|;
name|manager
operator|.
name|addAxioms
argument_list|(
name|manager
operator|.
name|getOntology
argument_list|(
name|testOntologyID
argument_list|)
argument_list|,
name|rules
argument_list|)
expr_stmt|;
comment|// Maybe we want to see what is in before
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|log
operator|.
name|debug
argument_list|(
literal|"Content of the input is:"
argument_list|)
expr_stmt|;
name|TestUtils
operator|.
name|debug
argument_list|(
name|manager
operator|.
name|getOntology
argument_list|(
name|testOntologyID
argument_list|)
argument_list|,
name|log
argument_list|)
expr_stmt|;
comment|// Now we test the method
name|log
operator|.
name|debug
argument_list|(
literal|"Running HermiT"
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|OWLAxiom
argument_list|>
name|inferred
init|=
name|this
operator|.
name|theinstance
operator|.
name|runTask
argument_list|(
name|ReasoningService
operator|.
name|Tasks
operator|.
name|CLASSIFY
argument_list|,
name|manager
operator|.
name|getOntology
argument_list|(
name|testOntologyID
argument_list|)
argument_list|)
decl_stmt|;
comment|// Maybe we want to see the inferred axiom list
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"{} inferred axioms:"
argument_list|,
name|inferred
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|TestUtils
operator|.
name|debug
argument_list|(
name|inferred
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|OWLLogicalAxiom
argument_list|>
name|expectedAxioms
init|=
name|manager
operator|.
name|getOntology
argument_list|(
name|IRI
operator|.
name|create
argument_list|(
name|testExpectedID
argument_list|)
argument_list|)
operator|.
name|getLogicalAxioms
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|OWLAxiom
argument_list|>
name|missing
init|=
operator|new
name|HashSet
argument_list|<
name|OWLAxiom
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|OWLAxiom
name|expected
range|:
name|expectedAxioms
control|)
block|{
comment|// We consider here only two kind of axioms
if|if
condition|(
name|expected
operator|instanceof
name|OWLSubClassOfAxiom
operator|||
name|expected
operator|instanceof
name|OWLClassAssertionAxiom
condition|)
block|{
if|if
condition|(
operator|!
name|inferred
operator|.
name|contains
argument_list|(
name|expected
argument_list|)
condition|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"missing expected axiom: {}"
argument_list|,
name|expected
argument_list|)
expr_stmt|;
name|missing
operator|.
name|add
argument_list|(
name|expected
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|assertTrue
argument_list|(
name|missing
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
comment|// We want to remove the ontology from the manager
name|manager
operator|.
name|removeOntology
argument_list|(
name|testOntology
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OWLOntologyCreationException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"An {} have been thrown while creating the input ontology for test"
argument_list|,
name|e
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReasoningServiceException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"An {} have been thrown while executing the reasoning"
argument_list|,
name|e
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InconsistentInputException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"An {} have been thrown while executing the reasoning"
argument_list|,
name|e
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedTaskException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"An {} have been thrown while executing the reasoning"
argument_list|,
name|e
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|testEnrichWithRules
parameter_list|(
name|String
name|testID
parameter_list|,
name|String
name|rulesID
parameter_list|,
name|String
name|testExpectedID
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Testing the task ENRICH with rules"
argument_list|)
expr_stmt|;
name|OWLOntologyManager
name|manager
init|=
name|TestData
operator|.
name|manager
decl_stmt|;
comment|// We prepare the input ontology
try|try
block|{
name|OWLOntology
name|testOntology
init|=
name|manager
operator|.
name|createOntology
argument_list|()
decl_stmt|;
name|OWLOntologyID
name|testOntologyID
init|=
name|testOntology
operator|.
name|getOntologyID
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Created test ontology with ID: {}"
argument_list|,
name|testOntologyID
argument_list|)
expr_stmt|;
name|OWLImportsDeclaration
name|importTest
init|=
name|TestData
operator|.
name|factory
operator|.
name|getOWLImportsDeclaration
argument_list|(
name|IRI
operator|.
name|create
argument_list|(
name|testID
argument_list|)
argument_list|)
decl_stmt|;
name|manager
operator|.
name|applyChange
argument_list|(
operator|new
name|AddImport
argument_list|(
name|testOntology
argument_list|,
name|importTest
argument_list|)
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|SWRLRule
argument_list|>
name|rules
init|=
name|manager
operator|.
name|getOntology
argument_list|(
name|IRI
operator|.
name|create
argument_list|(
name|rulesID
argument_list|)
argument_list|)
operator|.
name|getAxioms
argument_list|(
name|AxiomType
operator|.
name|SWRL_RULE
argument_list|)
decl_stmt|;
comment|// Maybe we want to see the list of rules
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"List of {} rules: "
argument_list|,
name|rules
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|TestUtils
operator|.
name|debug
argument_list|(
name|rules
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|debug
argument_list|(
literal|"We add the rules to the ontology"
argument_list|)
expr_stmt|;
name|manager
operator|.
name|addAxioms
argument_list|(
name|manager
operator|.
name|getOntology
argument_list|(
name|testOntologyID
argument_list|)
argument_list|,
name|rules
argument_list|)
expr_stmt|;
comment|// Maybe we want to see what is in before
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|log
operator|.
name|debug
argument_list|(
literal|"Content of the input is:"
argument_list|)
expr_stmt|;
name|TestUtils
operator|.
name|debug
argument_list|(
name|manager
operator|.
name|getOntology
argument_list|(
name|testOntologyID
argument_list|)
argument_list|,
name|log
argument_list|)
expr_stmt|;
comment|// Now we test the method
name|log
operator|.
name|debug
argument_list|(
literal|"Running HermiT"
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|OWLAxiom
argument_list|>
name|inferred
init|=
name|this
operator|.
name|theinstance
operator|.
name|runTask
argument_list|(
name|ReasoningService
operator|.
name|Tasks
operator|.
name|ENRICH
argument_list|,
name|manager
operator|.
name|getOntology
argument_list|(
name|testOntologyID
argument_list|)
argument_list|)
decl_stmt|;
comment|// Maybe we want to see the inferred axiom list
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"{} inferred axioms:"
argument_list|,
name|inferred
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|TestUtils
operator|.
name|debug
argument_list|(
name|inferred
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|OWLLogicalAxiom
argument_list|>
name|expectedAxioms
init|=
name|manager
operator|.
name|getOntology
argument_list|(
name|IRI
operator|.
name|create
argument_list|(
name|testExpectedID
argument_list|)
argument_list|)
operator|.
name|getLogicalAxioms
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|OWLAxiom
argument_list|>
name|missing
init|=
operator|new
name|HashSet
argument_list|<
name|OWLAxiom
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|OWLAxiom
name|expected
range|:
name|expectedAxioms
control|)
block|{
comment|// We consider here all kind of axioms
if|if
condition|(
operator|!
name|inferred
operator|.
name|contains
argument_list|(
name|expected
argument_list|)
condition|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"missing expected axiom: {}"
argument_list|,
name|expected
argument_list|)
expr_stmt|;
name|missing
operator|.
name|add
argument_list|(
name|expected
argument_list|)
expr_stmt|;
block|}
block|}
name|assertTrue
argument_list|(
name|missing
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
comment|// We want to remove the ontology from the manager
name|manager
operator|.
name|removeOntology
argument_list|(
name|testOntology
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OWLOntologyCreationException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"An {} have been thrown while creating the input ontology for test"
argument_list|,
name|e
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReasoningServiceException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"An {} have been thrown while executing the reasoning"
argument_list|,
name|e
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InconsistentInputException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"An {} have been thrown while executing the reasoning"
argument_list|,
name|e
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedTaskException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"An {} have been thrown while executing the reasoning"
argument_list|,
name|e
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

