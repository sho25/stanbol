begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|reasoners
operator|.
name|owlapi
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|reasoners
operator|.
name|servicesapi
operator|.
name|InconsistentInputException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|reasoners
operator|.
name|servicesapi
operator|.
name|ReasoningService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|reasoners
operator|.
name|servicesapi
operator|.
name|ReasoningServiceException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|reasoners
operator|.
name|servicesapi
operator|.
name|UnsupportedTaskException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|apibinding
operator|.
name|OWLManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|MissingImportEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|MissingImportListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLAxiom
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLOntology
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLOntologyCreationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLOntologyLoaderListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLOntologyManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|SWRLRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLOntologyLoaderListener
operator|.
name|LoadingFinishedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLOntologyLoaderListener
operator|.
name|LoadingStartedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|reasoner
operator|.
name|InconsistentOntologyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|reasoner
operator|.
name|OWLReasoner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|util
operator|.
name|InferredAxiomGenerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|util
operator|.
name|InferredClassAssertionAxiomGenerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|util
operator|.
name|InferredDataPropertyCharacteristicAxiomGenerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|util
operator|.
name|InferredDisjointClassesAxiomGenerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|util
operator|.
name|InferredEquivalentClassAxiomGenerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|util
operator|.
name|InferredEquivalentDataPropertiesAxiomGenerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|util
operator|.
name|InferredEquivalentObjectPropertyAxiomGenerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|util
operator|.
name|InferredInverseObjectPropertiesAxiomGenerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|util
operator|.
name|InferredObjectPropertyCharacteristicAxiomGenerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|util
operator|.
name|InferredOntologyGenerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|util
operator|.
name|InferredPropertyAssertionGenerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|util
operator|.
name|InferredSubClassAxiomGenerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|util
operator|.
name|InferredSubDataPropertyAxiomGenerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|util
operator|.
name|InferredSubObjectPropertyAxiomGenerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * This abstract class implements basic methods for a reasoning service based on OWLApi  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|AbstractOWLApiReasoningService
implements|implements
name|OWLApiReasoningService
block|{
specifier|private
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|getClass
argument_list|()
argument_list|)
decl_stmt|;
comment|/**      * An OWLOntologyManager to be used to place a target ontology. We don't want to use the manager bound to      * the input ontologies for that, we don't want to interfere with it.      *       * Other {@see OWLApiReasoningService}s may want to change this.      *       * @return      */
specifier|protected
name|OWLOntologyManager
name|createOWLOntologyManager
parameter_list|()
block|{
name|log
operator|.
name|info
argument_list|(
literal|"createOWLOntologyManager()"
argument_list|)
expr_stmt|;
comment|// We want a single instance here
name|OWLOntologyManager
name|manager
init|=
name|OWLManager
operator|.
name|createOWLOntologyManager
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"manager: {}"
argument_list|,
name|manager
argument_list|)
expr_stmt|;
comment|// FIXME Which is the other way of doing this?
comment|// Maybe -> OWLOntologyManagerProperties();
name|manager
operator|.
name|setSilentMissingImportsHandling
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Listening for missing imports
name|manager
operator|.
name|addMissingImportListener
argument_list|(
operator|new
name|MissingImportListener
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|importMissing
parameter_list|(
name|MissingImportEvent
name|arg0
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Missing import {} "
argument_list|,
name|arg0
operator|.
name|getImportedOntologyURI
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|manager
operator|.
name|addOntologyLoaderListener
argument_list|(
operator|new
name|OWLOntologyLoaderListener
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|finishedLoadingOntology
parameter_list|(
name|LoadingFinishedEvent
name|arg0
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Finished loading {} (imported: {})"
argument_list|,
name|arg0
operator|.
name|getOntologyID
argument_list|()
argument_list|,
name|arg0
operator|.
name|isImported
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|startedLoadingOntology
parameter_list|(
name|LoadingStartedEvent
name|arg0
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Started loading {} (imported: {}) ..."
argument_list|,
name|arg0
operator|.
name|getOntologyID
argument_list|()
argument_list|,
name|arg0
operator|.
name|isImported
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|" ... from {}"
argument_list|,
name|arg0
operator|.
name|getDocumentIRI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|manager
return|;
block|}
comment|/**      * Method to be implemented by subclasses.      *       * @param ontology      * @return      */
specifier|protected
specifier|abstract
name|OWLReasoner
name|getReasoner
parameter_list|(
name|OWLOntology
name|ontology
parameter_list|)
function_decl|;
comment|/**      * Generic method for running the reasoner      *       * @param input      * @param generators      * @return      */
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|OWLAxiom
argument_list|>
name|run
parameter_list|(
name|OWLOntology
name|input
parameter_list|,
name|List
argument_list|<
name|InferredAxiomGenerator
argument_list|<
name|?
extends|extends
name|OWLAxiom
argument_list|>
argument_list|>
name|generators
parameter_list|)
throws|throws
name|ReasoningServiceException
throws|,
name|InconsistentInputException
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"run(OWLOntology input, List<InferredAxiomGenerator<? extends OWLAxiom>> generators)"
argument_list|)
expr_stmt|;
try|try
block|{
comment|// Get the manager
name|OWLOntologyManager
name|manager
init|=
name|createOWLOntologyManager
argument_list|()
decl_stmt|;
comment|// Get the reasoner
name|OWLReasoner
name|reasoner
init|=
name|getReasoner
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Running {} reasoner on {} "
argument_list|,
name|reasoner
operator|.
name|getClass
argument_list|()
argument_list|,
name|input
operator|.
name|getOntologyID
argument_list|()
argument_list|)
expr_stmt|;
comment|// To generate inferred axioms
name|InferredOntologyGenerator
name|inferred
init|=
operator|new
name|InferredOntologyGenerator
argument_list|(
name|reasoner
argument_list|,
name|generators
argument_list|)
decl_stmt|;
comment|// We fill an anonymous ontology with the result, the return the
comment|// axiom set
name|Set
argument_list|<
name|OWLAxiom
argument_list|>
name|axioms
init|=
operator|new
name|HashSet
argument_list|<
name|OWLAxiom
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
name|OWLOntology
name|output
init|=
name|manager
operator|.
name|createOntology
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Created output ontology: {}"
argument_list|,
name|output
argument_list|)
expr_stmt|;
try|try
block|{
name|inferred
operator|.
name|fillOntology
argument_list|(
name|manager
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InconsistentOntologyException
name|i
parameter_list|)
block|{
throw|throw
name|i
throw|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Some problem occurred:\n {}"
argument_list|,
name|t
operator|.
name|getStackTrace
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ReasoningServiceException
argument_list|()
throw|;
block|}
name|log
operator|.
name|debug
argument_list|(
literal|"Filled ontology: {}"
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Temporary ID is {}"
argument_list|,
name|output
operator|.
name|getOntologyID
argument_list|()
argument_list|)
expr_stmt|;
name|axioms
operator|=
name|manager
operator|.
name|getOntology
argument_list|(
name|output
operator|.
name|getOntologyID
argument_list|()
argument_list|)
operator|.
name|getAxioms
argument_list|()
expr_stmt|;
comment|// IMPORTANT We remove the ontology from the manager
name|manager
operator|.
name|removeOntology
argument_list|(
name|output
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OWLOntologyCreationException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"An exception have been thrown when instantiating the ontology"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ReasoningServiceException
argument_list|()
throw|;
block|}
return|return
name|axioms
return|;
block|}
catch|catch
parameter_list|(
name|InconsistentOntologyException
name|inconsistent
parameter_list|)
block|{
comment|/**              * TODO Add report. Why it is inconsistent?              */
throw|throw
operator|new
name|InconsistentInputException
argument_list|()
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|exception
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"An exception have been thrown while executing method run()"
argument_list|,
name|exception
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ReasoningServiceException
argument_list|()
throw|;
block|}
block|}
comment|/**      * Merges the SWRL rules in the input ontology, then calls run(OWLOntology,List<InferredAxiomGenerator<?      * extends OWLAxiom>>)      *       * @param ontology      * @param rules      * @param generators      * @return      */
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|OWLAxiom
argument_list|>
name|run
parameter_list|(
name|OWLOntology
name|ontology
parameter_list|,
name|List
argument_list|<
name|SWRLRule
argument_list|>
name|rules
parameter_list|,
name|List
argument_list|<
name|InferredAxiomGenerator
argument_list|<
name|?
extends|extends
name|OWLAxiom
argument_list|>
argument_list|>
name|generators
parameter_list|)
throws|throws
name|ReasoningServiceException
throws|,
name|InconsistentInputException
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Called method run(OWLOntology,List<SWRLRule>,List)"
argument_list|)
expr_stmt|;
name|OWLOntologyManager
name|manager
init|=
name|ontology
operator|.
name|getOWLOntologyManager
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Adding SWRL rules to the input ontology."
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|SWRLRule
argument_list|>
name|ruleSet
init|=
operator|new
name|HashSet
argument_list|<
name|SWRLRule
argument_list|>
argument_list|()
decl_stmt|;
name|ruleSet
operator|.
name|addAll
argument_list|(
name|rules
argument_list|)
expr_stmt|;
name|manager
operator|.
name|addAxioms
argument_list|(
name|ontology
argument_list|,
name|ruleSet
argument_list|)
expr_stmt|;
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
for|for
control|(
name|OWLAxiom
name|a
range|:
name|ontology
operator|.
name|getAxioms
argument_list|()
control|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Axiom {}"
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|debug
argument_list|(
literal|"Calling the run method."
argument_list|)
expr_stmt|;
return|return
name|run
argument_list|(
name|ontology
argument_list|,
name|generators
argument_list|)
return|;
block|}
comment|/**      * This method provides the default implementation for executing one of the default tasks with no      * additional arguments.      *       * TODO: Add support for the filtered parameter on task 'classify';      */
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|OWLAxiom
argument_list|>
name|runTask
parameter_list|(
name|String
name|taskID
parameter_list|,
name|OWLOntology
name|data
parameter_list|)
throws|throws
name|UnsupportedTaskException
throws|,
name|ReasoningServiceException
throws|,
name|InconsistentInputException
block|{
if|if
condition|(
name|taskID
operator|.
name|equals
argument_list|(
name|ReasoningService
operator|.
name|Tasks
operator|.
name|CLASSIFY
argument_list|)
condition|)
block|{
return|return
name|classify
argument_list|(
name|data
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|taskID
operator|.
name|equals
argument_list|(
name|ReasoningService
operator|.
name|Tasks
operator|.
name|ENRICH
argument_list|)
condition|)
block|{
return|return
name|enrich
argument_list|(
name|data
argument_list|)
return|;
block|}
else|else
throw|throw
operator|new
name|UnsupportedTaskException
argument_list|()
throw|;
block|}
comment|/**      * This method provides the default implementation for executing one of the default tasks.      *       * TODO: Add support for the filtered parameter on task 'classify';      */
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|OWLAxiom
argument_list|>
name|runTask
parameter_list|(
name|String
name|taskID
parameter_list|,
name|OWLOntology
name|data
parameter_list|,
name|List
argument_list|<
name|SWRLRule
argument_list|>
name|rules
parameter_list|,
name|boolean
name|filtered
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|parameters
parameter_list|)
throws|throws
name|UnsupportedTaskException
throws|,
name|ReasoningServiceException
throws|,
name|InconsistentInputException
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Called task {} with data {}"
argument_list|,
name|taskID
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|taskID
operator|.
name|equals
argument_list|(
name|ReasoningService
operator|.
name|Tasks
operator|.
name|CLASSIFY
argument_list|)
condition|)
block|{
if|if
condition|(
name|rules
operator|!=
literal|null
condition|)
block|{
return|return
name|classify
argument_list|(
name|data
argument_list|,
name|rules
argument_list|)
return|;
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"No rules attached"
argument_list|)
expr_stmt|;
return|return
name|classify
argument_list|(
name|data
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|taskID
operator|.
name|equals
argument_list|(
name|ReasoningService
operator|.
name|Tasks
operator|.
name|ENRICH
argument_list|)
condition|)
block|{
if|if
condition|(
name|rules
operator|!=
literal|null
condition|)
block|{
return|return
name|enrich
argument_list|(
name|data
argument_list|,
name|rules
argument_list|,
name|filtered
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|enrich
argument_list|(
name|data
argument_list|,
name|filtered
argument_list|)
return|;
block|}
block|}
else|else
throw|throw
operator|new
name|UnsupportedTaskException
argument_list|()
throw|;
block|}
comment|/**      * {@see InferredAxiomGenerator}s to use for the classify() reasoning method.      *       * Subclasses may want to change this.      *       * @return      */
specifier|protected
name|List
argument_list|<
name|InferredAxiomGenerator
argument_list|<
name|?
extends|extends
name|OWLAxiom
argument_list|>
argument_list|>
name|getClassifyAxiomGenerators
parameter_list|()
block|{
name|List
argument_list|<
name|InferredAxiomGenerator
argument_list|<
name|?
extends|extends
name|OWLAxiom
argument_list|>
argument_list|>
name|gens
init|=
operator|new
name|ArrayList
argument_list|<
name|InferredAxiomGenerator
argument_list|<
name|?
extends|extends
name|OWLAxiom
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|gens
operator|.
name|add
argument_list|(
operator|new
name|InferredClassAssertionAxiomGenerator
argument_list|()
argument_list|)
expr_stmt|;
name|gens
operator|.
name|add
argument_list|(
operator|new
name|InferredSubClassAxiomGenerator
argument_list|()
argument_list|)
expr_stmt|;
name|gens
operator|.
name|add
argument_list|(
operator|new
name|InferredEquivalentClassAxiomGenerator
argument_list|()
argument_list|)
expr_stmt|;
name|gens
operator|.
name|add
argument_list|(
operator|new
name|InferredDisjointClassesAxiomGenerator
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|gens
return|;
block|}
comment|/**      * {@see InferredAxiomGenerator}s to use for the enrich() reasoning method.      *       * Subclasses may want to change this.      *       * @return      */
specifier|protected
name|List
argument_list|<
name|InferredAxiomGenerator
argument_list|<
name|?
extends|extends
name|OWLAxiom
argument_list|>
argument_list|>
name|getEnrichAxiomGenerators
parameter_list|()
block|{
name|List
argument_list|<
name|InferredAxiomGenerator
argument_list|<
name|?
extends|extends
name|OWLAxiom
argument_list|>
argument_list|>
name|gens
init|=
operator|new
name|ArrayList
argument_list|<
name|InferredAxiomGenerator
argument_list|<
name|?
extends|extends
name|OWLAxiom
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|// Classes
name|gens
operator|.
name|add
argument_list|(
operator|new
name|InferredClassAssertionAxiomGenerator
argument_list|()
argument_list|)
expr_stmt|;
name|gens
operator|.
name|add
argument_list|(
operator|new
name|InferredSubClassAxiomGenerator
argument_list|()
argument_list|)
expr_stmt|;
name|gens
operator|.
name|add
argument_list|(
operator|new
name|InferredEquivalentClassAxiomGenerator
argument_list|()
argument_list|)
expr_stmt|;
name|gens
operator|.
name|add
argument_list|(
operator|new
name|InferredDisjointClassesAxiomGenerator
argument_list|()
argument_list|)
expr_stmt|;
comment|// data properties
name|gens
operator|.
name|add
argument_list|(
operator|new
name|InferredDataPropertyCharacteristicAxiomGenerator
argument_list|()
argument_list|)
expr_stmt|;
name|gens
operator|.
name|add
argument_list|(
operator|new
name|InferredEquivalentDataPropertiesAxiomGenerator
argument_list|()
argument_list|)
expr_stmt|;
name|gens
operator|.
name|add
argument_list|(
operator|new
name|InferredSubDataPropertyAxiomGenerator
argument_list|()
argument_list|)
expr_stmt|;
comment|// object properties
name|gens
operator|.
name|add
argument_list|(
operator|new
name|InferredEquivalentObjectPropertyAxiomGenerator
argument_list|()
argument_list|)
expr_stmt|;
name|gens
operator|.
name|add
argument_list|(
operator|new
name|InferredInverseObjectPropertiesAxiomGenerator
argument_list|()
argument_list|)
expr_stmt|;
name|gens
operator|.
name|add
argument_list|(
operator|new
name|InferredObjectPropertyCharacteristicAxiomGenerator
argument_list|()
argument_list|)
expr_stmt|;
name|gens
operator|.
name|add
argument_list|(
operator|new
name|InferredSubObjectPropertyAxiomGenerator
argument_list|()
argument_list|)
expr_stmt|;
comment|// individuals
name|gens
operator|.
name|add
argument_list|(
operator|new
name|InferredClassAssertionAxiomGenerator
argument_list|()
argument_list|)
expr_stmt|;
name|gens
operator|.
name|add
argument_list|(
operator|new
name|InferredPropertyAssertionGenerator
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|gens
return|;
block|}
comment|/**      * Classify, returns only axioms about classes and instances      *       * This is the default implementation of task {@see ReasoningService.Tasks.CLASSIFY}. Subclasses may want      * to change it.      *       * @param ontology      * @return      */
specifier|protected
name|Set
argument_list|<
name|OWLAxiom
argument_list|>
name|classify
parameter_list|(
name|OWLOntology
name|ontology
parameter_list|)
throws|throws
name|ReasoningServiceException
throws|,
name|InconsistentInputException
block|{
name|log
operator|.
name|info
argument_list|(
literal|"classify(OWLOntology ontology)"
argument_list|)
expr_stmt|;
return|return
name|run
argument_list|(
name|ontology
argument_list|,
name|getClassifyAxiomGenerators
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Classify, merge SWRL rules in the input ontology, before      *       * This is the default implementation of task {@see ReasoningService.Tasks.CLASSIFY} when rules are given.      * Subclasses may want to change it.      *       * @param ontology      * @param rules      * @return      * @throws InconsistentInputException      * @throws ReasoningServiceException      */
specifier|protected
name|Set
argument_list|<
name|OWLAxiom
argument_list|>
name|classify
parameter_list|(
name|OWLOntology
name|ontology
parameter_list|,
name|List
argument_list|<
name|SWRLRule
argument_list|>
name|rules
parameter_list|)
throws|throws
name|ReasoningServiceException
throws|,
name|InconsistentInputException
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Calling classify(OWLOntology ontology, List<SWRLRule> rules) "
argument_list|)
expr_stmt|;
return|return
name|run
argument_list|(
name|ontology
argument_list|,
name|rules
argument_list|,
name|getClassifyAxiomGenerators
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Enrich, return all inferences. This is the same as enrich(ontology,false);      *       * This is the default implementation of task {@see ReasoningService.Tasks.ENRICH}. Subclasses may want to      * change it.      *       * @param ontology      * @return      * @throws ReasoningServiceException      * @throws InconsistentInputException      */
specifier|protected
name|Set
argument_list|<
name|OWLAxiom
argument_list|>
name|enrich
parameter_list|(
name|OWLOntology
name|ontology
parameter_list|)
throws|throws
name|ReasoningServiceException
throws|,
name|InconsistentInputException
block|{
return|return
name|run
argument_list|(
name|ontology
argument_list|,
name|getEnrichAxiomGenerators
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Enrich, return all inferences. If filtered = false, then merge the inferences with the input      *       * This is the default implementation of task {@see ReasoningService.Tasks.ENRICH}. Subclasses may want to      * change it.      *       * @param ontology      * @param filtered      * @return      * @throws ReasoningServiceException      * @throws InconsistentInputException      */
specifier|protected
name|Set
argument_list|<
name|OWLAxiom
argument_list|>
name|enrich
parameter_list|(
name|OWLOntology
name|ontology
parameter_list|,
name|boolean
name|filtered
parameter_list|)
throws|throws
name|ReasoningServiceException
throws|,
name|InconsistentInputException
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Calling enrich(OWLOntology ontology, filtered) "
argument_list|)
expr_stmt|;
comment|// If filtered = false, then we merge the output with the input
if|if
condition|(
name|filtered
condition|)
block|{
return|return
name|run
argument_list|(
name|ontology
argument_list|,
name|getEnrichAxiomGenerators
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
name|Set
argument_list|<
name|OWLAxiom
argument_list|>
name|output
init|=
name|ontology
operator|.
name|getAxioms
argument_list|()
decl_stmt|;
name|output
operator|.
name|addAll
argument_list|(
name|run
argument_list|(
name|ontology
argument_list|,
name|getEnrichAxiomGenerators
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
block|}
comment|/**      * Enrich, merge SWRL rules and return all inferences. This is the same as enrich(ontology,rules,false)      *       * This is the default implementation of task {@see ReasoningService.Tasks.ENRICH}. Subclasses may want to      * change it.      *       * @param ontology      * @param rules      * @return      * @throws ReasoningServiceException      * @throws InconsistentInputException      */
specifier|protected
name|Set
argument_list|<
name|OWLAxiom
argument_list|>
name|enrich
parameter_list|(
name|OWLOntology
name|ontology
parameter_list|,
name|List
argument_list|<
name|SWRLRule
argument_list|>
name|rules
parameter_list|)
throws|throws
name|ReasoningServiceException
throws|,
name|InconsistentInputException
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Calling enrich(OWLOntology ontology, List<SWRLRule> rules) "
argument_list|)
expr_stmt|;
return|return
name|run
argument_list|(
name|ontology
argument_list|,
name|rules
argument_list|,
name|getEnrichAxiomGenerators
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Enrich, merge SWRL rules and return all inferences. If filtered = false, then merge the inferences with      * the input.      *       * This is the default implementation of task {@see ReasoningService.Tasks.ENRICH}. Subclasses may want to      * change it.      *       * @param ontology      * @param rules      * @param filtered      * @return      * @throws ReasoningServiceException      * @throws InconsistentInputException      */
specifier|protected
name|Set
argument_list|<
name|OWLAxiom
argument_list|>
name|enrich
parameter_list|(
name|OWLOntology
name|ontology
parameter_list|,
name|List
argument_list|<
name|SWRLRule
argument_list|>
name|rules
parameter_list|,
name|boolean
name|filtered
parameter_list|)
throws|throws
name|ReasoningServiceException
throws|,
name|InconsistentInputException
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Calling enrich(OWLOntology ontology, List<SWRLRule> rules) "
argument_list|)
expr_stmt|;
if|if
condition|(
name|filtered
condition|)
block|{
return|return
name|run
argument_list|(
name|ontology
argument_list|,
name|rules
argument_list|,
name|getEnrichAxiomGenerators
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
name|Set
argument_list|<
name|OWLAxiom
argument_list|>
name|output
init|=
name|ontology
operator|.
name|getAxioms
argument_list|()
decl_stmt|;
name|output
operator|.
name|addAll
argument_list|(
name|run
argument_list|(
name|ontology
argument_list|,
name|rules
argument_list|,
name|getEnrichAxiomGenerators
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
block|}
comment|/**      * Only check consistency.      *       * Subclasses may want to change how.      *       * @param ontology      * @return      * @throws ReasoningServiceException      */
annotation|@
name|Override
specifier|public
name|boolean
name|isConsistent
parameter_list|(
name|OWLOntology
name|ontology
parameter_list|)
throws|throws
name|ReasoningServiceException
block|{
try|try
block|{
return|return
name|getReasoner
argument_list|(
name|ontology
argument_list|)
operator|.
name|isConsistent
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"An error have been thrown while attempting to check consistency. Message was: {}"
argument_list|,
name|e
operator|.
name|getLocalizedMessage
argument_list|()
argument_list|)
expr_stmt|;
comment|// TODO Add explanation of this exception
throw|throw
operator|new
name|ReasoningServiceException
argument_list|()
throw|;
block|}
block|}
comment|/**      * Only check consistency.      *       * Subclasses may want to change how.      *       * @param ontology      * @param rules      * @return      * @throws ReasoningServiceException      */
annotation|@
name|Override
specifier|public
name|boolean
name|isConsistent
parameter_list|(
name|OWLOntology
name|ontology
parameter_list|,
name|List
argument_list|<
name|SWRLRule
argument_list|>
name|rules
parameter_list|)
throws|throws
name|ReasoningServiceException
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Create a input ontology to merge rules in."
argument_list|)
expr_stmt|;
name|OWLOntology
name|input
decl_stmt|;
try|try
block|{
name|OWLOntologyManager
name|manager
init|=
name|createOWLOntologyManager
argument_list|()
decl_stmt|;
name|input
operator|=
name|manager
operator|.
name|createOntology
argument_list|()
expr_stmt|;
name|Set
argument_list|<
name|SWRLRule
argument_list|>
name|ruleSet
init|=
operator|new
name|HashSet
argument_list|<
name|SWRLRule
argument_list|>
argument_list|()
decl_stmt|;
name|ruleSet
operator|.
name|addAll
argument_list|(
name|rules
argument_list|)
expr_stmt|;
name|manager
operator|.
name|addAxioms
argument_list|(
name|input
argument_list|,
name|ruleSet
argument_list|)
expr_stmt|;
name|input
operator|=
name|manager
operator|.
name|getOntology
argument_list|(
name|input
operator|.
name|getOntologyID
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Created ontology: {}"
argument_list|,
name|input
argument_list|)
expr_stmt|;
return|return
name|getReasoner
argument_list|(
name|ontology
argument_list|)
operator|.
name|isConsistent
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|OWLOntologyCreationException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"An error have been thrown while attempting to create ontology. Message was: {}"
argument_list|,
name|e
operator|.
name|getLocalizedMessage
argument_list|()
argument_list|)
expr_stmt|;
comment|// TODO Add explanation of this exception
throw|throw
operator|new
name|ReasoningServiceException
argument_list|()
throw|;
block|}
block|}
comment|/**      * The abstract implementation of an OWLApi based reasoning service supports all default {@see      * ReasoningService.Tasks}. Subclasses may want to extend this.      */
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getSupportedTasks
parameter_list|()
block|{
return|return
name|ReasoningService
operator|.
name|Tasks
operator|.
name|DEFAULT_TASKS
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|supportsTask
parameter_list|(
name|String
name|taskID
parameter_list|)
block|{
return|return
name|getSupportedTasks
argument_list|()
operator|.
name|contains
argument_list|(
name|taskID
argument_list|)
return|;
block|}
comment|/**      * OWLApi based reasoning services have type {@see OWLOntology} as input type      */
specifier|public
name|Class
argument_list|<
name|OWLOntology
argument_list|>
name|getModelType
parameter_list|()
block|{
return|return
name|OWLOntology
operator|.
name|class
return|;
block|}
comment|/**      * OWLApi based reasoning services have type {@see SWRLRule} as rule type      */
specifier|public
name|Class
argument_list|<
name|SWRLRule
argument_list|>
name|getRuleType
parameter_list|()
block|{
return|return
name|SWRLRule
operator|.
name|class
return|;
block|}
comment|/**      * OWLApi based reasoning services have type {@see OWLAxiom} as statement type      */
specifier|public
name|Class
argument_list|<
name|OWLAxiom
argument_list|>
name|getStatementType
parameter_list|()
block|{
return|return
name|OWLAxiom
operator|.
name|class
return|;
block|}
block|}
end_class

end_unit

