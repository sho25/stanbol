begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|reasoners
operator|.
name|jena
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|reasoners
operator|.
name|servicesapi
operator|.
name|InconsistentInputException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|reasoners
operator|.
name|servicesapi
operator|.
name|ReasoningService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|reasoners
operator|.
name|servicesapi
operator|.
name|ReasoningServiceException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|reasoners
operator|.
name|servicesapi
operator|.
name|UnsupportedTaskException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|rdf
operator|.
name|model
operator|.
name|Model
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|rdf
operator|.
name|model
operator|.
name|ModelFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|rdf
operator|.
name|model
operator|.
name|Property
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|rdf
operator|.
name|model
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|rdf
operator|.
name|model
operator|.
name|Statement
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|reasoner
operator|.
name|Reasoner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|reasoner
operator|.
name|rulesys
operator|.
name|GenericRuleReasonerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|reasoner
operator|.
name|rulesys
operator|.
name|Rule
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|vocabulary
operator|.
name|RDF
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|vocabulary
operator|.
name|ReasonerVocabulary
import|;
end_import

begin_comment
comment|/**  * Here we develop tests related to the methods of the shared interface. All the tests here should work at the  * simplest possible (RDFS) level, because inferences must be the same for all the standard Jena reasoners.  *   */
end_comment

begin_class
specifier|public
class|class
name|JenaReasoningServiceTest
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|JenaReasoningServiceTest
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
name|List
argument_list|<
name|JenaReasoningService
argument_list|>
name|reasoners
decl_stmt|;
comment|/**      * This method instantiate the reasoning services to work with in this tests      */
annotation|@
name|Before
specifier|public
name|void
name|setUp
parameter_list|()
block|{
name|reasoners
operator|=
operator|new
name|ArrayList
argument_list|<
name|JenaReasoningService
argument_list|>
argument_list|()
expr_stmt|;
name|reasoners
operator|.
name|add
argument_list|(
operator|new
name|JenaOWLReasoningService
argument_list|()
argument_list|)
expr_stmt|;
name|reasoners
operator|.
name|add
argument_list|(
operator|new
name|JenaRDFSReasoningService
argument_list|()
argument_list|)
expr_stmt|;
name|reasoners
operator|.
name|add
argument_list|(
operator|new
name|JenaOWLMiniReasoningService
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testClassify
parameter_list|()
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Testing the classify() method with all available reasoners"
argument_list|)
expr_stmt|;
for|for
control|(
name|JenaReasoningService
name|service
range|:
name|reasoners
control|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Testing : {}"
argument_list|,
name|service
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|testClassify
argument_list|(
name|service
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testEnrich
parameter_list|()
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Testing the enrich() method with all available reasoners"
argument_list|)
expr_stmt|;
for|for
control|(
name|JenaReasoningService
name|service
range|:
name|reasoners
control|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Testing : {}"
argument_list|,
name|service
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|testEnrich
argument_list|(
name|service
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testEnrich2
parameter_list|()
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Testing the enrich() method (filtered = false) with all available reasoners"
argument_list|)
expr_stmt|;
for|for
control|(
name|JenaReasoningService
name|service
range|:
name|reasoners
control|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Testing : {}"
argument_list|,
name|service
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|testEnrich2
argument_list|(
name|service
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testIsConsistent
parameter_list|()
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Testing the isConsistent() method with all available reasoners with consistent data"
argument_list|)
expr_stmt|;
comment|/**          * Note: since the inconsistency depends on the reasoner type, we move that check on the respective          * test classes          */
for|for
control|(
name|JenaReasoningService
name|service
range|:
name|reasoners
control|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Testing : {}"
argument_list|,
name|service
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|testIsConsistent
argument_list|(
name|service
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Tests the classify() method      */
specifier|private
name|void
name|testClassify
parameter_list|(
name|JenaReasoningService
name|reasoningService
parameter_list|)
block|{
comment|// Clean data
name|TestData
operator|.
name|alexdma
operator|.
name|removeProperties
argument_list|()
expr_stmt|;
comment|// Prepare data
name|TestData
operator|.
name|alexdma
operator|.
name|addProperty
argument_list|(
name|RDF
operator|.
name|type
argument_list|,
name|TestData
operator|.
name|foaf_Person
argument_list|)
expr_stmt|;
comment|// Setup input for the reasoner
name|Model
name|input
init|=
name|ModelFactory
operator|.
name|createUnion
argument_list|(
name|TestData
operator|.
name|foaf
argument_list|,
name|TestData
operator|.
name|alexdma
operator|.
name|getModel
argument_list|()
argument_list|)
decl_stmt|;
comment|// Run the method
name|Set
argument_list|<
name|Statement
argument_list|>
name|inferred
decl_stmt|;
try|try
block|{
name|inferred
operator|=
name|reasoningService
operator|.
name|runTask
argument_list|(
name|ReasoningService
operator|.
name|Tasks
operator|.
name|CLASSIFY
argument_list|,
name|input
argument_list|)
expr_stmt|;
name|boolean
name|foafAgentExists
init|=
literal|false
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Check for statements to be rdf:type only"
argument_list|)
expr_stmt|;
for|for
control|(
name|Statement
name|stat
range|:
name|inferred
control|)
block|{
comment|// Here we want only rdf:type statements
if|if
condition|(
operator|!
name|stat
operator|.
name|getPredicate
argument_list|()
operator|.
name|equals
argument_list|(
name|RDF
operator|.
name|type
argument_list|)
condition|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"This statement is not rdf:type: {}"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
block|}
name|assertTrue
argument_list|(
name|stat
operator|.
name|getPredicate
argument_list|()
operator|.
name|equals
argument_list|(
name|RDF
operator|.
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|.
name|getObject
argument_list|()
operator|.
name|isResource
argument_list|()
condition|)
block|{
if|if
condition|(
name|stat
operator|.
name|getObject
argument_list|()
operator|.
name|asResource
argument_list|()
operator|.
name|equals
argument_list|(
name|TestData
operator|.
name|foaf_Agent
argument_list|)
condition|)
block|{
name|foafAgentExists
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Does the statement: example:me rdf:type foaf:Agent exists (true)? {}"
argument_list|,
name|foafAgentExists
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|foafAgentExists
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReasoningServiceException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Error thrown: {}"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InconsistentInputException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Error thrown: {}"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedTaskException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Error thrown: {}"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// Clean data
name|TestData
operator|.
name|alexdma
operator|.
name|removeProperties
argument_list|()
expr_stmt|;
block|}
comment|/**      * Tests the enrich(Model data) method      *       * @param service      */
specifier|private
name|void
name|testEnrich
parameter_list|(
name|JenaReasoningService
name|service
parameter_list|)
block|{
comment|// Clean data
name|TestData
operator|.
name|alexdma
operator|.
name|removeProperties
argument_list|()
expr_stmt|;
comment|// Prepare data
name|TestData
operator|.
name|alexdma
operator|.
name|addProperty
argument_list|(
name|RDF
operator|.
name|type
argument_list|,
name|TestData
operator|.
name|foaf_Person
argument_list|)
expr_stmt|;
comment|// Setup input for the reasoner
name|Model
name|input
init|=
name|ModelFactory
operator|.
name|createUnion
argument_list|(
name|TestData
operator|.
name|foaf
argument_list|,
name|TestData
operator|.
name|alexdma
operator|.
name|getModel
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
comment|// Run the method
name|Set
argument_list|<
name|Statement
argument_list|>
name|inferred
init|=
name|service
operator|.
name|runTask
argument_list|(
name|ReasoningService
operator|.
name|Tasks
operator|.
name|ENRICH
argument_list|,
name|input
argument_list|)
decl_stmt|;
comment|// Prepare the input statements to check the output with
name|Set
argument_list|<
name|Statement
argument_list|>
name|inputStatements
init|=
name|input
operator|.
name|listStatements
argument_list|()
operator|.
name|toSet
argument_list|()
decl_stmt|;
name|boolean
name|onlyInferred
init|=
literal|true
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Check for statements to be only the inferred ones"
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|Statement
argument_list|>
name|badOnes
init|=
operator|new
name|HashSet
argument_list|<
name|Statement
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Statement
name|stat
range|:
name|inferred
control|)
block|{
comment|// Must not be a statement in input
if|if
condition|(
name|inputStatements
operator|.
name|contains
argument_list|(
name|stat
argument_list|)
condition|)
block|{
name|onlyInferred
operator|=
literal|false
expr_stmt|;
name|badOnes
operator|.
name|add
argument_list|(
name|stat
argument_list|)
expr_stmt|;
block|}
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Are there only inferred statements (true)? {}"
argument_list|,
name|onlyInferred
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|onlyInferred
condition|)
block|{
for|for
control|(
name|Statement
name|bad
range|:
name|badOnes
control|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Found a bad statement in output: {}"
argument_list|,
name|bad
argument_list|)
expr_stmt|;
block|}
block|}
name|assertTrue
argument_list|(
name|onlyInferred
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReasoningServiceException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Error thrown: {}"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InconsistentInputException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Error thrown: {}"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedTaskException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Error thrown: {}"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// Clean data
name|TestData
operator|.
name|alexdma
operator|.
name|removeProperties
argument_list|()
expr_stmt|;
block|}
comment|/**      * Tests the enrich(Model data,boolean filtered) method      *       * @param service      */
specifier|private
name|void
name|testEnrich2
parameter_list|(
name|JenaReasoningService
name|service
parameter_list|)
block|{
comment|// Clean data
name|TestData
operator|.
name|alexdma
operator|.
name|removeProperties
argument_list|()
expr_stmt|;
comment|// Prepare data
name|TestData
operator|.
name|alexdma
operator|.
name|addProperty
argument_list|(
name|RDF
operator|.
name|type
argument_list|,
name|TestData
operator|.
name|foaf_Person
argument_list|)
expr_stmt|;
comment|// Setup input for the reasoner
name|Model
name|input
init|=
name|ModelFactory
operator|.
name|createUnion
argument_list|(
name|TestData
operator|.
name|foaf
argument_list|,
name|TestData
operator|.
name|alexdma
operator|.
name|getModel
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
comment|// Run the method
name|Set
argument_list|<
name|Statement
argument_list|>
name|inferred
init|=
name|service
operator|.
name|runTask
argument_list|(
name|ReasoningService
operator|.
name|Tasks
operator|.
name|ENRICH
argument_list|,
name|input
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// Prepare the input statements to check the output with
name|Set
argument_list|<
name|Statement
argument_list|>
name|inputStatements
init|=
name|input
operator|.
name|listStatements
argument_list|()
operator|.
name|toSet
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"All the input statements must be in the inferred output"
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|Statement
argument_list|>
name|notInOutput
init|=
operator|new
name|HashSet
argument_list|<
name|Statement
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Statement
name|stat
range|:
name|inputStatements
control|)
block|{
if|if
condition|(
operator|!
name|inferred
operator|.
name|contains
argument_list|(
name|stat
argument_list|)
condition|)
block|{
name|notInOutput
operator|.
name|add
argument_list|(
name|stat
argument_list|)
expr_stmt|;
block|}
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Are all input statements in the inferred set (true)? {}"
argument_list|,
name|notInOutput
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|notInOutput
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Statement
name|bad
range|:
name|notInOutput
control|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Found a statement not included in output: {}"
argument_list|,
name|bad
argument_list|)
expr_stmt|;
block|}
block|}
name|assertTrue
argument_list|(
name|notInOutput
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReasoningServiceException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Error thrown: {}"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InconsistentInputException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Error thrown: {}"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedTaskException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Error thrown: {}"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// Clean data
name|TestData
operator|.
name|alexdma
operator|.
name|removeProperties
argument_list|()
expr_stmt|;
block|}
comment|/**      *       * @param service      */
specifier|private
name|void
name|testIsConsistent
parameter_list|(
name|JenaReasoningService
name|service
parameter_list|)
block|{
comment|// Clean data
name|TestData
operator|.
name|alexdma
operator|.
name|removeProperties
argument_list|()
expr_stmt|;
comment|// Prepare data
name|TestData
operator|.
name|alexdma
operator|.
name|addProperty
argument_list|(
name|RDF
operator|.
name|type
argument_list|,
name|TestData
operator|.
name|foaf_Person
argument_list|)
expr_stmt|;
comment|// Setup input for the reasoner
name|Model
name|input
init|=
name|ModelFactory
operator|.
name|createUnion
argument_list|(
name|TestData
operator|.
name|foaf
argument_list|,
name|TestData
operator|.
name|alexdma
operator|.
name|getModel
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
comment|// Run the method
name|assertTrue
argument_list|(
name|service
operator|.
name|isConsistent
argument_list|(
name|input
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReasoningServiceException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Error thrown: {}"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// Clean data
name|TestData
operator|.
name|alexdma
operator|.
name|removeProperties
argument_list|()
expr_stmt|;
block|}
comment|/**      * Test the GenericRuleReasoner      *       */
annotation|@
name|Test
specifier|public
name|void
name|testGenericRuleReasoner
parameter_list|()
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Test a Generic Rule Reasoner with RDFS rules"
argument_list|)
expr_stmt|;
comment|// Configuration
name|Model
name|m
init|=
name|ModelFactory
operator|.
name|createDefaultModel
argument_list|()
decl_stmt|;
name|Resource
name|configuration
init|=
name|m
operator|.
name|createResource
argument_list|()
decl_stmt|;
name|configuration
operator|.
name|addProperty
argument_list|(
name|ReasonerVocabulary
operator|.
name|PROPruleMode
argument_list|,
literal|"hybrid"
argument_list|)
expr_stmt|;
name|configuration
operator|.
name|addProperty
argument_list|(
name|ReasonerVocabulary
operator|.
name|PROPruleSet
argument_list|,
literal|"generic.rdfs.rules"
argument_list|)
expr_stmt|;
comment|// Create an instance of such a reasoner
name|Reasoner
name|reasoner
init|=
name|GenericRuleReasonerFactory
operator|.
name|theInstance
argument_list|()
operator|.
name|create
argument_list|(
name|configuration
argument_list|)
decl_stmt|;
comment|// This should behave as the RDFSReasoner
name|JenaReasoningService
name|genericRdfs
init|=
operator|new
name|AbstractJenaReasoningService
argument_list|(
name|reasoner
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|String
name|getPath
parameter_list|()
block|{
comment|// We don't need this now
return|return
literal|null
return|;
block|}
block|}
decl_stmt|;
comment|// Then test the three methods
name|testClassify
argument_list|(
name|genericRdfs
argument_list|)
expr_stmt|;
name|testEnrich
argument_list|(
name|genericRdfs
argument_list|)
expr_stmt|;
name|testIsConsistent
argument_list|(
name|genericRdfs
argument_list|)
expr_stmt|;
block|}
comment|/**      * Run reasoner with a simple rule set as additional input      */
annotation|@
name|Test
specifier|public
name|void
name|testRunWithRules
parameter_list|()
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Testing the run(Model model, List<Rule> rules) method with all available reasoners"
argument_list|)
expr_stmt|;
for|for
control|(
name|JenaReasoningService
name|service
range|:
name|reasoners
control|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Testing : {}"
argument_list|,
name|service
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|testRunWithRules
argument_list|(
name|service
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Check consistency with a simple rule set as additional input      */
annotation|@
name|Test
specifier|public
name|void
name|testIsConsistentWithRules
parameter_list|()
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Testing the isConsistent(Model model, List<Rule> rules) method with all available reasoners"
argument_list|)
expr_stmt|;
for|for
control|(
name|JenaReasoningService
name|service
range|:
name|reasoners
control|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Testing : {}"
argument_list|,
name|service
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|testIsConsistentWithRules
argument_list|(
name|service
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Tests the isConsistent(Model,List<Rule>) method of a service      *       * @param service      */
specifier|private
name|void
name|testIsConsistentWithRules
parameter_list|(
name|JenaReasoningService
name|service
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Testing reasoner of type {}"
argument_list|,
name|service
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
comment|// Prepare the rule set
name|String
name|source
init|=
literal|""
operator|+
literal|"\n@prefix foaf:<"
operator|+
name|TestData
operator|.
name|FOAF_NS
operator|+
literal|">."
operator|+
literal|"\n@prefix ex:<"
operator|+
name|TestData
operator|.
name|TEST_NS
operator|+
literal|">."
operator|+
literal|"\n[rule1: (?a foaf:knows ?b) (?a foaf:workplaceHomepage ?w) (?b foaf:workplaceHomepage ?w) -> (?a ex:collegueOf ?b)] "
operator|+
literal|"\n[rule2: (?b foaf:knows ?a) -> (?a foaf:knows ?b)] "
operator|+
literal|"\n[rule3: (?a ex:collegueOf ?b) -> (?b ex:collegueOf ?a)] "
decl_stmt|;
comment|// log.info("This is the ruleset: \n {}", source);
name|List
argument_list|<
name|Rule
argument_list|>
name|rules
init|=
name|TestUtils
operator|.
name|parseRuleStringAsFile
argument_list|(
name|source
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Loaded {} rules"
argument_list|,
name|rules
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// Clean data
name|TestData
operator|.
name|alexdma
operator|.
name|removeProperties
argument_list|()
expr_stmt|;
name|TestData
operator|.
name|enridaga
operator|.
name|removeProperties
argument_list|()
expr_stmt|;
name|Resource
name|wphomepage
init|=
name|TestData
operator|.
name|model
operator|.
name|createResource
argument_list|(
literal|"http://stlab.istc.cnr.it"
argument_list|)
decl_stmt|;
comment|// Prepare data
name|TestData
operator|.
name|alexdma
operator|.
name|addProperty
argument_list|(
name|TestData
operator|.
name|foaf_knows
argument_list|,
name|TestData
operator|.
name|enridaga
argument_list|)
expr_stmt|;
name|TestData
operator|.
name|alexdma
operator|.
name|addProperty
argument_list|(
name|TestData
operator|.
name|foaf_workplaceHomepage
argument_list|,
name|wphomepage
argument_list|)
expr_stmt|;
name|TestData
operator|.
name|enridaga
operator|.
name|addProperty
argument_list|(
name|TestData
operator|.
name|foaf_workplaceHomepage
argument_list|,
name|wphomepage
argument_list|)
expr_stmt|;
comment|// Setup input for the reasoner
name|Model
name|input
init|=
name|ModelFactory
operator|.
name|createUnion
argument_list|(
name|TestData
operator|.
name|enridaga
operator|.
name|getModel
argument_list|()
argument_list|,
name|TestData
operator|.
name|alexdma
operator|.
name|getModel
argument_list|()
argument_list|)
decl_stmt|;
name|input
operator|=
name|ModelFactory
operator|.
name|createUnion
argument_list|(
name|input
argument_list|,
name|TestData
operator|.
name|foaf
argument_list|)
expr_stmt|;
try|try
block|{
comment|// Run the method
name|boolean
name|isConsistent
init|=
name|service
operator|.
name|isConsistent
argument_list|(
name|input
argument_list|,
name|rules
argument_list|)
decl_stmt|;
comment|// Assert true
name|log
operator|.
name|info
argument_list|(
literal|"Is consistent (true)? {}"
argument_list|,
name|isConsistent
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|isConsistent
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReasoningServiceException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Error thrown: {}"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// Clean data
name|TestData
operator|.
name|alexdma
operator|.
name|removeProperties
argument_list|()
expr_stmt|;
name|TestData
operator|.
name|enridaga
operator|.
name|removeProperties
argument_list|()
expr_stmt|;
block|}
comment|/**      * Tests the run(Model,List<Rule>) method of a service      *       * @param service      */
specifier|private
name|void
name|testRunWithRules
parameter_list|(
name|JenaReasoningService
name|service
parameter_list|)
block|{
comment|// Prepare the rule set
name|String
name|source
init|=
literal|""
operator|+
literal|"\n@prefix foaf:<"
operator|+
name|TestData
operator|.
name|FOAF_NS
operator|+
literal|">."
operator|+
literal|"\n@prefix ex:<"
operator|+
name|TestData
operator|.
name|TEST_NS
operator|+
literal|">."
operator|+
literal|"\n[rule1: (?a foaf:knows ?b) (?a foaf:workplaceHomepage ?w) (?b foaf:workplaceHomepage ?w) -> (?a ex:collegueOf ?b)] "
operator|+
literal|"\n[rule2: (?b foaf:knows ?a) -> (?a foaf:knows ?b)] "
operator|+
literal|"\n[rule3: (?a ex:collegueOf ?b) -> (?b ex:collegueOf ?a)] "
decl_stmt|;
comment|// log.info("This is the ruleset: \n {}", source);
name|List
argument_list|<
name|Rule
argument_list|>
name|rules
init|=
name|TestUtils
operator|.
name|parseRuleStringAsFile
argument_list|(
name|source
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Loaded {} rules"
argument_list|,
name|rules
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// Clean data
name|TestData
operator|.
name|alexdma
operator|.
name|removeProperties
argument_list|()
expr_stmt|;
name|TestData
operator|.
name|enridaga
operator|.
name|removeProperties
argument_list|()
expr_stmt|;
name|Resource
name|wphomepage
init|=
name|TestData
operator|.
name|model
operator|.
name|createResource
argument_list|(
literal|"http://stlab.istc.cnr.it"
argument_list|)
decl_stmt|;
comment|// Prepare data
name|TestData
operator|.
name|alexdma
operator|.
name|addProperty
argument_list|(
name|TestData
operator|.
name|foaf_knows
argument_list|,
name|TestData
operator|.
name|enridaga
argument_list|)
expr_stmt|;
name|TestData
operator|.
name|alexdma
operator|.
name|addProperty
argument_list|(
name|TestData
operator|.
name|foaf_workplaceHomepage
argument_list|,
name|wphomepage
argument_list|)
expr_stmt|;
name|TestData
operator|.
name|enridaga
operator|.
name|addProperty
argument_list|(
name|TestData
operator|.
name|foaf_workplaceHomepage
argument_list|,
name|wphomepage
argument_list|)
expr_stmt|;
comment|// Setup input for the reasoner
name|Model
name|input
init|=
name|ModelFactory
operator|.
name|createUnion
argument_list|(
name|TestData
operator|.
name|enridaga
operator|.
name|getModel
argument_list|()
argument_list|,
name|TestData
operator|.
name|alexdma
operator|.
name|getModel
argument_list|()
argument_list|)
decl_stmt|;
name|input
operator|=
name|ModelFactory
operator|.
name|createUnion
argument_list|(
name|input
argument_list|,
name|TestData
operator|.
name|foaf
argument_list|)
expr_stmt|;
comment|// Run the method
name|Set
argument_list|<
name|Statement
argument_list|>
name|inferred
init|=
name|service
operator|.
name|run
argument_list|(
name|input
argument_list|,
name|rules
argument_list|)
operator|.
name|listStatements
argument_list|()
operator|.
name|toSet
argument_list|()
decl_stmt|;
comment|// Expected statements
name|Property
name|collegueOf
init|=
name|TestData
operator|.
name|model
operator|.
name|createProperty
argument_list|(
name|TestData
operator|.
name|TEST_NS
operator|+
literal|"collegueOf"
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|Statement
argument_list|>
name|expected
init|=
operator|new
name|HashSet
argument_list|<
name|Statement
argument_list|>
argument_list|()
decl_stmt|;
name|expected
operator|.
name|add
argument_list|(
name|TestData
operator|.
name|model
operator|.
name|createStatement
argument_list|(
name|TestData
operator|.
name|alexdma
argument_list|,
name|collegueOf
argument_list|,
name|TestData
operator|.
name|enridaga
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
name|TestData
operator|.
name|model
operator|.
name|createStatement
argument_list|(
name|TestData
operator|.
name|enridaga
argument_list|,
name|collegueOf
argument_list|,
name|TestData
operator|.
name|alexdma
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"All the expected statements must be in the inferred output"
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|Statement
argument_list|>
name|notInOutput
init|=
name|TestUtils
operator|.
name|expectedStatementsCheck
argument_list|(
name|inferred
argument_list|,
name|expected
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Are all expected statements in the inferred set (true)? {}"
argument_list|,
name|notInOutput
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|notInOutput
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Statement
name|bad
range|:
name|notInOutput
control|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"The following statement is not included in the reasoner output: {}"
argument_list|,
name|bad
argument_list|)
expr_stmt|;
block|}
block|}
name|assertTrue
argument_list|(
name|notInOutput
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
comment|// Clean data
name|TestData
operator|.
name|alexdma
operator|.
name|removeProperties
argument_list|()
expr_stmt|;
name|TestData
operator|.
name|enridaga
operator|.
name|removeProperties
argument_list|()
expr_stmt|;
block|}
comment|/**      * Check consistency with a simple rule set as additional input      */
annotation|@
name|Test
specifier|public
name|void
name|testClassifyWithRules
parameter_list|()
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Testing the classify(Model model, List<Rule> rules) method with all available reasoners"
argument_list|)
expr_stmt|;
for|for
control|(
name|JenaReasoningService
name|service
range|:
name|reasoners
control|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Testing : {}"
argument_list|,
name|service
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|testClassifyWithRule
argument_list|(
name|service
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Tests the classify(Model data, List<Rule> rules) method      */
specifier|private
name|void
name|testClassifyWithRule
parameter_list|(
name|JenaReasoningService
name|service
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Testing {}"
argument_list|,
name|service
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
comment|// Prepare the rule set
name|String
name|source
init|=
literal|""
operator|+
literal|"\n@prefix rdf:<"
operator|+
name|RDF
operator|.
name|getURI
argument_list|()
operator|+
literal|">."
operator|+
literal|"\n@prefix foaf:<"
operator|+
name|TestData
operator|.
name|FOAF_NS
operator|+
literal|">."
operator|+
literal|"\n@prefix ex:<"
operator|+
name|TestData
operator|.
name|TEST_NS
operator|+
literal|">."
operator|+
literal|"\n[rule: (?a foaf:workplaceHomepage ?w) (?w rdf:type ex:SWResearchLab) -> (?a rdf:type ex:SWResearcher)] "
decl_stmt|;
comment|// log.info("This is the ruleset: \n {}", source);
name|List
argument_list|<
name|Rule
argument_list|>
name|rules
init|=
name|TestUtils
operator|.
name|parseRuleStringAsFile
argument_list|(
name|source
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Loaded {} rules"
argument_list|,
name|rules
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// Clean data
name|TestData
operator|.
name|alexdma
operator|.
name|removeProperties
argument_list|()
expr_stmt|;
name|TestData
operator|.
name|enridaga
operator|.
name|removeProperties
argument_list|()
expr_stmt|;
name|Resource
name|wphomepage
init|=
name|TestData
operator|.
name|model
operator|.
name|createResource
argument_list|(
literal|"http://stlab.istc.cnr.it"
argument_list|)
decl_stmt|;
name|Resource
name|swResearchLab
init|=
name|TestData
operator|.
name|model
operator|.
name|createResource
argument_list|(
name|TestData
operator|.
name|TEST_NS
operator|+
literal|"SWResearchLab"
argument_list|)
decl_stmt|;
comment|// Prepare data
name|TestData
operator|.
name|alexdma
operator|.
name|addProperty
argument_list|(
name|TestData
operator|.
name|foaf_workplaceHomepage
argument_list|,
name|wphomepage
argument_list|)
expr_stmt|;
name|TestData
operator|.
name|enridaga
operator|.
name|addProperty
argument_list|(
name|TestData
operator|.
name|foaf_workplaceHomepage
argument_list|,
name|wphomepage
argument_list|)
expr_stmt|;
name|wphomepage
operator|.
name|addProperty
argument_list|(
name|RDF
operator|.
name|type
argument_list|,
name|swResearchLab
argument_list|)
expr_stmt|;
comment|// Setup input for the reasoner
name|Model
name|input
init|=
name|ModelFactory
operator|.
name|createUnion
argument_list|(
name|TestData
operator|.
name|enridaga
operator|.
name|getModel
argument_list|()
argument_list|,
name|TestData
operator|.
name|alexdma
operator|.
name|getModel
argument_list|()
argument_list|)
decl_stmt|;
name|input
operator|=
name|ModelFactory
operator|.
name|createUnion
argument_list|(
name|input
argument_list|,
name|wphomepage
operator|.
name|getModel
argument_list|()
argument_list|)
expr_stmt|;
name|input
operator|=
name|ModelFactory
operator|.
name|createUnion
argument_list|(
name|input
argument_list|,
name|TestData
operator|.
name|foaf
argument_list|)
expr_stmt|;
try|try
block|{
comment|// Run the method
name|Set
argument_list|<
name|Statement
argument_list|>
name|inferred
init|=
name|service
operator|.
name|runTask
argument_list|(
name|ReasoningService
operator|.
name|Tasks
operator|.
name|CLASSIFY
argument_list|,
name|input
argument_list|,
name|rules
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// Expected statements
name|Resource
name|swResearcher
init|=
name|TestData
operator|.
name|model
operator|.
name|createResource
argument_list|(
name|TestData
operator|.
name|TEST_NS
operator|+
literal|"SWResearcher"
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|Statement
argument_list|>
name|expected
init|=
operator|new
name|HashSet
argument_list|<
name|Statement
argument_list|>
argument_list|()
decl_stmt|;
name|expected
operator|.
name|add
argument_list|(
name|TestData
operator|.
name|model
operator|.
name|createStatement
argument_list|(
name|TestData
operator|.
name|alexdma
argument_list|,
name|RDF
operator|.
name|type
argument_list|,
name|swResearcher
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
name|TestData
operator|.
name|model
operator|.
name|createStatement
argument_list|(
name|TestData
operator|.
name|enridaga
argument_list|,
name|RDF
operator|.
name|type
argument_list|,
name|swResearcher
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"All the expected statements must be in the inferred output"
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|Statement
argument_list|>
name|notInOutput
init|=
name|TestUtils
operator|.
name|expectedStatementsCheck
argument_list|(
name|inferred
argument_list|,
name|expected
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Are all expected statements in the inferred set (true)? {}"
argument_list|,
name|notInOutput
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|notInOutput
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Statement
name|bad
range|:
name|notInOutput
control|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"The following statement is not included in the reasoner output: {}"
argument_list|,
name|bad
argument_list|)
expr_stmt|;
block|}
block|}
name|assertTrue
argument_list|(
name|notInOutput
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
comment|// There must be only rdf:type output
name|boolean
name|onlyRdf
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Statement
name|stat
range|:
name|inferred
control|)
block|{
comment|// Here we want only rdf:type statements
if|if
condition|(
operator|!
name|stat
operator|.
name|getPredicate
argument_list|()
operator|.
name|equals
argument_list|(
name|RDF
operator|.
name|type
argument_list|)
condition|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"This statement is not rdf:type: {}"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|stat
operator|.
name|getPredicate
argument_list|()
operator|.
name|equals
argument_list|(
name|RDF
operator|.
name|type
argument_list|)
condition|)
block|{
name|onlyRdf
operator|=
literal|false
expr_stmt|;
block|}
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Check for statements to be rdf:type only (true): {}"
argument_list|,
name|onlyRdf
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|onlyRdf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReasoningServiceException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Error thrown: {}"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InconsistentInputException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Error thrown: {}"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedTaskException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Error thrown: {}"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// Clean data
name|TestData
operator|.
name|alexdma
operator|.
name|removeProperties
argument_list|()
expr_stmt|;
name|TestData
operator|.
name|enridaga
operator|.
name|removeProperties
argument_list|()
expr_stmt|;
block|}
block|}
end_class

end_unit

