begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|impl
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|impl
operator|.
name|IndexerConstants
operator|.
name|INDEXING_COMPLETED_QUEUE_ITEM
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|impl
operator|.
name|IndexerConstants
operator|.
name|SCORE_FIELD
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ArrayBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|BlockingQueue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|EntityDataIterable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|EntityDataIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|EntityDataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|EntityIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|EntityProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|EntityScoreProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|Indexer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|IndexingComponent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|IndexingDestination
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|destination
operator|.
name|OsgiConfigurationUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|event
operator|.
name|IndexingEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|event
operator|.
name|IndexingListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|impl
operator|.
name|IndexingDaemon
operator|.
name|IndexingDaemonEventObject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|impl
operator|.
name|IndexingDaemon
operator|.
name|IndexingDaemonListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|impl
operator|.
name|IndexingSourceInitialiser
operator|.
name|IndexingSourceEventObject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|impl
operator|.
name|IndexingSourceInitialiser
operator|.
name|IndexingSourceInitialiserListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|normaliser
operator|.
name|ScoreNormaliser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|processor
operator|.
name|EmptyProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Representation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|yard
operator|.
name|Yard
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Abstract Implementation of the Indexer.<p>  * Principally there are two ways how to index entities<ol>  *<li> Iterate of the the entityIds/scores by using an {@link EntityIterator}  * and lookup the data by using an {@link EntityDataProvider}.  *<li> Iterate over the data by using an {@link EntityDataIterator} (provided  * by an {@link EntityDataIterable}) and lookup/calculate the scores by using an   * {@link EntityScoreProvider}.  *</ol>  * This Implementation provides a static createInstance(..) method for each of  * the two variants.<p>  * After the Entities are loaded from the source they are processed by using the  * configured {@link EntityProcessor}. Finally the processed entities are  * persisted in a {@link Yard}.   * @author Rupert Westenthaler  *  */
end_comment

begin_class
specifier|public
class|class
name|IndexerImpl
implements|implements
name|Indexer
block|{
comment|//protected to allow internal classes direct access!
specifier|protected
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|IndexerImpl
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * Holds the indexing listener      */
specifier|private
specifier|final
name|Set
argument_list|<
name|IndexingListener
argument_list|>
name|listeners
decl_stmt|;
specifier|private
name|int
name|chunkSize
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|MIN_QUEUE_SIZE
init|=
literal|500
decl_stmt|;
comment|/**      * Queue used to add Entities read from the IndexingSource(s). This queue      * is consumed by the {@link EntityProcessorRunnable}.      */
specifier|private
name|BlockingQueue
argument_list|<
name|QueueItem
argument_list|<
name|Representation
argument_list|>
argument_list|>
name|indexedEntityQueue
decl_stmt|;
comment|/**      * Queue used to add processed Entities. This queue is consumed by the      * {@link EntityPersisterRunnable}.      */
specifier|private
name|BlockingQueue
argument_list|<
name|QueueItem
argument_list|<
name|Representation
argument_list|>
argument_list|>
name|processedEntityQueue
decl_stmt|;
comment|/**      * Queue used to add finished Entities. Mainly used for counting and      * logging      */
specifier|private
name|BlockingQueue
argument_list|<
name|QueueItem
argument_list|<
name|Representation
argument_list|>
argument_list|>
name|finishedEntityQueue
decl_stmt|;
specifier|private
name|BlockingQueue
argument_list|<
name|QueueItem
argument_list|<
name|IndexingError
argument_list|>
argument_list|>
name|errorEntityQueue
decl_stmt|;
specifier|private
name|boolean
name|indexAllEntitiesState
init|=
literal|false
decl_stmt|;
comment|//entityMode
specifier|private
name|EntityIterator
name|entityIterator
decl_stmt|;
specifier|private
name|EntityDataProvider
name|dataProvider
decl_stmt|;
comment|//dataMode
specifier|private
name|EntityDataIterable
name|dataIterable
decl_stmt|;
specifier|private
name|EntityScoreProvider
name|scoreProvider
decl_stmt|;
specifier|private
specifier|final
name|Collection
argument_list|<
name|IndexingComponent
argument_list|>
name|indexingComponents
decl_stmt|;
specifier|private
specifier|final
name|IndexingDestination
name|indexingDestination
decl_stmt|;
specifier|private
specifier|final
name|EntityProcessor
name|entityProcessor
decl_stmt|;
specifier|private
specifier|final
name|ScoreNormaliser
name|scoreNormaliser
decl_stmt|;
specifier|private
name|State
name|state
init|=
name|State
operator|.
name|UNINITIALISED
decl_stmt|;
specifier|private
specifier|final
name|Object
name|stateSync
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|public
name|IndexerImpl
parameter_list|(
name|EntityIterator
name|entityIterator
parameter_list|,
name|EntityDataProvider
name|dataProvider
parameter_list|,
name|ScoreNormaliser
name|normaliser
parameter_list|,
name|IndexingDestination
name|indexingDestination
parameter_list|,
name|EntityProcessor
name|entityProcessor
parameter_list|)
block|{
name|this
argument_list|(
name|normaliser
argument_list|,
name|indexingDestination
argument_list|,
name|entityProcessor
argument_list|)
expr_stmt|;
comment|//set entityMode interfaces
if|if
condition|(
name|entityIterator
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The EntityIterator MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|this
operator|.
name|entityIterator
operator|=
name|entityIterator
expr_stmt|;
name|this
operator|.
name|dataProvider
operator|=
name|dataProvider
expr_stmt|;
comment|//add the parsed indexingSources to the list
name|this
operator|.
name|indexingComponents
operator|.
name|add
argument_list|(
name|entityIterator
argument_list|)
expr_stmt|;
name|this
operator|.
name|indexingComponents
operator|.
name|add
argument_list|(
name|dataProvider
argument_list|)
expr_stmt|;
block|}
specifier|public
name|IndexerImpl
parameter_list|(
name|EntityDataIterable
name|dataIterable
parameter_list|,
name|EntityScoreProvider
name|scoreProvider
parameter_list|,
name|ScoreNormaliser
name|normaliser
parameter_list|,
name|IndexingDestination
name|indexingDestination
parameter_list|,
name|EntityProcessor
name|entityProcessor
parameter_list|)
block|{
name|this
argument_list|(
name|normaliser
argument_list|,
name|indexingDestination
argument_list|,
name|entityProcessor
argument_list|)
expr_stmt|;
comment|//deactivate entityMode interfaces
name|this
operator|.
name|entityIterator
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|scoreProvider
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The EntityScoreProvider MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|this
operator|.
name|scoreProvider
operator|=
name|scoreProvider
expr_stmt|;
name|this
operator|.
name|dataIterable
operator|=
name|dataIterable
expr_stmt|;
comment|//add the parsed indexingSources to the list
name|this
operator|.
name|indexingComponents
operator|.
name|add
argument_list|(
name|scoreProvider
argument_list|)
expr_stmt|;
name|this
operator|.
name|indexingComponents
operator|.
name|add
argument_list|(
name|dataIterable
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|IndexerImpl
parameter_list|(
name|ScoreNormaliser
name|normaliser
parameter_list|,
name|IndexingDestination
name|indexingDestination
parameter_list|,
name|EntityProcessor
name|entityProcessor
parameter_list|)
block|{
if|if
condition|(
name|indexingDestination
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The Yard MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|this
operator|.
name|indexingDestination
operator|=
name|indexingDestination
expr_stmt|;
if|if
condition|(
name|entityProcessor
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|entityProcessor
operator|=
operator|new
name|EmptyProcessor
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|entityProcessor
operator|=
name|entityProcessor
expr_stmt|;
block|}
name|setChunkSize
argument_list|(
name|DEFAULT_CHUNK_SIZE
argument_list|)
expr_stmt|;
comment|//init the chunk size and the cache
name|this
operator|.
name|scoreNormaliser
operator|=
name|normaliser
expr_stmt|;
name|indexingComponents
operator|=
operator|new
name|ArrayList
argument_list|<
name|IndexingComponent
argument_list|>
argument_list|()
expr_stmt|;
name|indexingComponents
operator|.
name|add
argument_list|(
name|indexingDestination
argument_list|)
expr_stmt|;
name|indexingComponents
operator|.
name|add
argument_list|(
name|entityProcessor
argument_list|)
expr_stmt|;
name|listeners
operator|=
operator|new
name|HashSet
argument_list|<
name|IndexingListener
argument_list|>
argument_list|()
expr_stmt|;
block|}
specifier|public
name|boolean
name|addIndexListener
parameter_list|(
name|IndexingListener
name|listener
parameter_list|)
block|{
if|if
condition|(
name|listener
operator|!=
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|listeners
init|)
block|{
return|return
name|listeners
operator|.
name|add
argument_list|(
name|listener
argument_list|)
return|;
block|}
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
specifier|public
name|boolean
name|removeIndexListener
parameter_list|(
name|IndexingListener
name|listener
parameter_list|)
block|{
if|if
condition|(
name|listener
operator|!=
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|listeners
init|)
block|{
return|return
name|listeners
operator|.
name|remove
argument_list|(
name|listener
argument_list|)
return|;
block|}
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
specifier|protected
name|void
name|fireStateChanged
parameter_list|()
block|{
name|IndexingEvent
name|event
init|=
operator|new
name|IndexingEvent
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|IndexingListener
argument_list|>
name|copy
init|=
operator|new
name|ArrayList
argument_list|<
name|IndexingListener
argument_list|>
argument_list|(
name|listeners
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|listeners
init|)
block|{
name|copy
operator|.
name|addAll
argument_list|(
name|listeners
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|IndexingListener
name|listener
range|:
name|copy
control|)
block|{
name|listener
operator|.
name|stateChanged
argument_list|(
name|event
argument_list|)
expr_stmt|;
comment|//if the state is finished also send the completed event
if|if
condition|(
name|getState
argument_list|()
operator|==
name|State
operator|.
name|FINISHED
condition|)
block|{
name|listener
operator|.
name|indexingCompleted
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* (non-Javadoc)      * @see org.apache.stanbol.entityhub.indexing.core.IndexerInterface#setChunkSize(int)      */
specifier|public
name|void
name|setChunkSize
parameter_list|(
name|int
name|chunkSize
parameter_list|)
throws|throws
name|IllegalStateException
block|{
if|if
condition|(
name|getState
argument_list|()
operator|.
name|ordinal
argument_list|()
operator|>=
name|State
operator|.
name|INDEXING
operator|.
name|ordinal
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Setting the chunkSize is only allowed before starting the indexing process!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|chunkSize
operator|<=
literal|0
condition|)
block|{
name|chunkSize
operator|=
name|DEFAULT_CHUNK_SIZE
expr_stmt|;
block|}
name|this
operator|.
name|chunkSize
operator|=
name|chunkSize
expr_stmt|;
block|}
comment|/* (non-Javadoc)      * @see org.apache.stanbol.entityhub.indexing.core.IndexerInterface#getChunkSize()      */
specifier|public
name|int
name|getChunkSize
parameter_list|()
block|{
return|return
name|chunkSize
return|;
block|}
comment|/* (non-Javadoc)      * @see org.apache.stanbol.entityhub.indexing.core.IndexerInterface#getYard()      */
specifier|public
name|Yard
name|getYard
parameter_list|()
block|{
return|return
name|indexingDestination
operator|.
name|getYard
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|initialiseIndexingSources
parameter_list|()
block|{
synchronized|synchronized
init|(
name|stateSync
init|)
block|{
comment|//ensure that two threads do not start the
comment|//initialisation at the same time ...
if|if
condition|(
name|getState
argument_list|()
operator|!=
name|State
operator|.
name|UNINITIALISED
condition|)
block|{
return|return;
block|}
name|setState
argument_list|(
name|State
operator|.
name|INITIALISING
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Initialisation started ..."
argument_list|)
expr_stmt|;
block|}
comment|//add all IndexingSources that need to be initialised to a set
specifier|final
name|Collection
argument_list|<
name|IndexingComponent
argument_list|>
name|toInitialise
init|=
operator|new
name|HashSet
argument_list|<
name|IndexingComponent
argument_list|>
argument_list|()
decl_stmt|;
comment|//we need an simple listener that removes the IndexingSerouces from the
comment|//above list
specifier|final
name|IndexingSourceInitialiserListener
name|listener
init|=
operator|new
name|IndexingSourceInitialiserListener
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|indexingSourceInitialised
parameter_list|(
name|IndexingSourceEventObject
name|eventObject
parameter_list|)
block|{
comment|//remove the IndexingSource from the toInitialise set
synchronized|synchronized
init|(
name|toInitialise
init|)
block|{
name|toInitialise
operator|.
name|remove
argument_list|(
name|eventObject
operator|.
name|getIndexingSource
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|toInitialise
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//if no more left to initialise
comment|//notify others about it
name|toInitialise
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
comment|//finally remove this listener
name|eventObject
operator|.
name|getSource
argument_list|()
operator|.
name|removeIndexingSourceInitialiserListener
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
comment|//now create the IndexingSourceInitialiser that initialise the
comment|//Indexing Sources in their own Thread
for|for
control|(
name|IndexingComponent
name|source
range|:
name|indexingComponents
control|)
block|{
if|if
condition|(
name|source
operator|.
name|needsInitialisation
argument_list|()
condition|)
block|{
comment|//if it need to be initialised
name|toInitialise
operator|.
name|add
argument_list|(
name|source
argument_list|)
expr_stmt|;
comment|// add it to the list
comment|//create an initialiser
name|IndexingSourceInitialiser
name|initialiser
init|=
operator|new
name|IndexingSourceInitialiser
argument_list|(
name|source
argument_list|)
decl_stmt|;
comment|//add the listener
name|initialiser
operator|.
name|addIndexingSourceInitialiserListener
argument_list|(
name|listener
argument_list|)
expr_stmt|;
comment|//create and init the Thread
name|Thread
name|thread
init|=
operator|new
name|Thread
argument_list|(
name|initialiser
argument_list|)
decl_stmt|;
name|thread
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|thread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|//else no initialisation is needed
block|}
comment|//now wait until all IndexingSources are initialised!
while|while
condition|(
operator|!
name|toInitialise
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
synchronized|synchronized
init|(
name|toInitialise
init|)
block|{
try|try
block|{
name|toInitialise
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|//year looks like all IndexingSources are initialised!
block|}
block|}
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Initialisation completed"
argument_list|)
expr_stmt|;
name|setState
argument_list|(
name|State
operator|.
name|INITIALISED
argument_list|)
expr_stmt|;
block|}
comment|/* (non-Javadoc)      * @see org.apache.stanbol.entityhub.indexing.core.IndexerInterface#index()      */
specifier|public
name|void
name|index
parameter_list|()
block|{
name|Set
argument_list|<
name|State
argument_list|>
name|supportedStates
init|=
name|EnumSet
operator|.
name|of
argument_list|(
name|State
operator|.
name|UNINITIALISED
argument_list|,
name|State
operator|.
name|INITIALISED
argument_list|,
name|State
operator|.
name|INDEXED
argument_list|,
name|State
operator|.
name|FINISHED
argument_list|)
decl_stmt|;
comment|//this is only used to inform about wrong usage. It does not ensure
comment|//that index is called twice by different threads. This check is done
comment|//within the initialise, index and finalise methods!
name|State
name|state
init|=
name|getState
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|supportedStates
operator|.
name|contains
argument_list|(
name|state
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Calling this Method is not supported while in State %s! Supported States are "
argument_list|,
name|state
argument_list|,
name|supportedStates
argument_list|)
argument_list|)
throw|;
block|}
name|initialiseIndexingSources
argument_list|()
expr_stmt|;
comment|//if now the state is an unsupported one it indicates that
comment|//initialiseIndexingSources() was called by an other thread before this one!
name|state
operator|=
name|getState
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|supportedStates
operator|.
name|contains
argument_list|(
name|state
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Calling this Method is not supported while in State %s! Supported States are "
argument_list|,
name|state
argument_list|,
name|supportedStates
argument_list|)
argument_list|)
throw|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Start Indexing"
argument_list|)
expr_stmt|;
name|indexAllEntities
argument_list|()
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Indexing completed ..."
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"start finalisation...."
argument_list|)
expr_stmt|;
name|finaliseIndexingTarget
argument_list|()
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Indexing finished!"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|finaliseIndexingTarget
parameter_list|()
block|{
synchronized|synchronized
init|(
name|stateSync
init|)
block|{
comment|//ensure that two threads do not start the
comment|//initialisation at the same time ...
name|State
name|state
init|=
name|getState
argument_list|()
decl_stmt|;
if|if
condition|(
name|state
operator|.
name|ordinal
argument_list|()
operator|<
name|State
operator|.
name|INDEXED
operator|.
name|ordinal
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"The Indexer MUST BE already "
operator|+
name|State
operator|.
name|INDEXED
operator|+
literal|" when calling this Method!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|state
operator|!=
name|State
operator|.
name|INDEXED
condition|)
block|{
comment|//if state> INITIALISED
return|return;
comment|// ignore this call
block|}
name|setState
argument_list|(
name|State
operator|.
name|FINALISING
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Indexing started ..."
argument_list|)
expr_stmt|;
block|}
name|indexingDestination
operator|.
name|finalise
argument_list|()
expr_stmt|;
name|setState
argument_list|(
name|State
operator|.
name|FINISHED
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|indexAllEntities
parameter_list|()
block|{
synchronized|synchronized
init|(
name|stateSync
init|)
block|{
comment|//ensure that two threads do not start the
comment|//initialisation at the same time ...
name|State
name|state
init|=
name|getState
argument_list|()
decl_stmt|;
if|if
condition|(
name|state
operator|.
name|ordinal
argument_list|()
operator|<
name|State
operator|.
name|INITIALISED
operator|.
name|ordinal
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"The Indexer MUST BE already "
operator|+
name|State
operator|.
name|INITIALISED
operator|+
literal|" when calling this Method!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|state
operator|!=
name|State
operator|.
name|INITIALISED
condition|)
block|{
comment|//if state> INITIALISED
return|return;
comment|// ignore this call
block|}
name|setState
argument_list|(
name|State
operator|.
name|INDEXING
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Indexing started ..."
argument_list|)
expr_stmt|;
block|}
comment|//init the queues
name|int
name|queueSize
init|=
name|Math
operator|.
name|max
argument_list|(
name|MIN_QUEUE_SIZE
argument_list|,
name|chunkSize
operator|*
literal|2
argument_list|)
decl_stmt|;
name|indexedEntityQueue
operator|=
operator|new
name|ArrayBlockingQueue
argument_list|<
name|QueueItem
argument_list|<
name|Representation
argument_list|>
argument_list|>
argument_list|(
name|queueSize
argument_list|)
expr_stmt|;
name|processedEntityQueue
operator|=
operator|new
name|ArrayBlockingQueue
argument_list|<
name|QueueItem
argument_list|<
name|Representation
argument_list|>
argument_list|>
argument_list|(
name|queueSize
argument_list|)
expr_stmt|;
name|finishedEntityQueue
operator|=
operator|new
name|ArrayBlockingQueue
argument_list|<
name|QueueItem
argument_list|<
name|Representation
argument_list|>
argument_list|>
argument_list|(
name|queueSize
argument_list|)
expr_stmt|;
name|errorEntityQueue
operator|=
operator|new
name|ArrayBlockingQueue
argument_list|<
name|QueueItem
argument_list|<
name|IndexingError
argument_list|>
argument_list|>
argument_list|(
name|queueSize
argument_list|)
expr_stmt|;
comment|//Set holding all active IndexingDaemons
specifier|final
name|SortedSet
argument_list|<
name|IndexingDaemon
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|activeIndexingDeamons
init|=
operator|new
name|TreeSet
argument_list|<
name|IndexingDaemon
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|//create the IndexingDaemos
comment|//TODO: Here we would need to create multiple instances in case
comment|//      one would e.g. like to use several threads for processing entities
comment|//(1) the daemon reading from the IndexingSources
name|String
name|entitySourceReaderName
init|=
literal|"Indexing: Entity Source Reader Deamon"
decl_stmt|;
if|if
condition|(
name|entityIterator
operator|!=
literal|null
condition|)
block|{
name|activeIndexingDeamons
operator|.
name|add
argument_list|(
operator|new
name|EntityIdBasedIndexingDaemon
argument_list|(
name|entitySourceReaderName
argument_list|,
name|indexedEntityQueue
argument_list|,
name|errorEntityQueue
argument_list|,
name|entityIterator
argument_list|,
name|dataProvider
argument_list|,
name|scoreNormaliser
argument_list|,
name|indexAllEntitiesState
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|activeIndexingDeamons
operator|.
name|add
argument_list|(
operator|new
name|EntityDataBasedIndexingDaemon
argument_list|(
name|entitySourceReaderName
argument_list|,
name|indexedEntityQueue
argument_list|,
name|errorEntityQueue
argument_list|,
name|dataIterable
argument_list|,
name|scoreProvider
argument_list|,
name|scoreNormaliser
argument_list|,
name|indexAllEntitiesState
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//(2) The daemon for processing the entities
name|activeIndexingDeamons
operator|.
name|add
argument_list|(
operator|new
name|EntityProcessorRunnable
argument_list|(
literal|"Indexing: Entity Processor Deamon"
argument_list|,
name|indexedEntityQueue
argument_list|,
comment|//it consumes indexed Entities
name|processedEntityQueue
argument_list|,
comment|//it produces processed Entities
name|errorEntityQueue
argument_list|,
name|entityProcessor
argument_list|,
name|Collections
operator|.
name|singleton
argument_list|(
name|SCORE_FIELD
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|//(3) The daemon for persisting the entities
name|activeIndexingDeamons
operator|.
name|add
argument_list|(
operator|new
name|EntityPersisterRunnable
argument_list|(
literal|"Indexing: Entity Perstisting Deamon"
argument_list|,
name|processedEntityQueue
argument_list|,
comment|//it consumes processed Entities
name|finishedEntityQueue
argument_list|,
comment|//it produces finished Entities
name|errorEntityQueue
argument_list|,
name|chunkSize
argument_list|,
name|indexingDestination
operator|.
name|getYard
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|//(4) The daemon for logging finished entities
name|activeIndexingDeamons
operator|.
name|add
argument_list|(
operator|new
name|FinishedEntityDaemon
argument_list|(
name|finishedEntityQueue
argument_list|,
operator|-
literal|1
argument_list|,
name|log
argument_list|)
argument_list|)
expr_stmt|;
comment|//(5) The daemon for logging errors
name|activeIndexingDeamons
operator|.
name|add
argument_list|(
operator|new
name|EntityErrorLoggerDaemon
argument_list|(
name|errorEntityQueue
argument_list|,
name|log
argument_list|)
argument_list|)
expr_stmt|;
comment|//We need an listener for the IndexingDaemons we are about to start!
specifier|final
name|IndexingDaemonListener
name|listener
init|=
operator|new
name|IndexingDaemonListener
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|indexingDaemonFinished
parameter_list|(
name|IndexingDaemonEventObject
name|indexingDaemonEventObject
parameter_list|)
block|{
comment|//looks like one has finished
name|IndexingDaemon
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|indexingDaemon
init|=
name|indexingDaemonEventObject
operator|.
name|getSource
argument_list|()
decl_stmt|;
comment|//handle the finished indexing daemon
name|handleFinishedIndexingDaemon
argument_list|(
name|activeIndexingDeamons
argument_list|,
name|indexingDaemon
argument_list|)
expr_stmt|;
comment|//finally remove the listener
name|indexingDaemon
operator|.
name|removeIndexingDaemonListener
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
comment|//now start the IndexingDaemons in their own Threads
name|Set
argument_list|<
name|IndexingDaemon
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|deamonCopy
init|=
operator|new
name|HashSet
argument_list|<
name|IndexingDaemon
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
argument_list|(
name|activeIndexingDeamons
argument_list|)
decl_stmt|;
for|for
control|(
name|IndexingDaemon
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|deamon
range|:
name|deamonCopy
control|)
block|{
name|deamon
operator|.
name|addIndexingDaemonListener
argument_list|(
name|listener
argument_list|)
expr_stmt|;
comment|//add the listener
name|Thread
name|thread
init|=
operator|new
name|Thread
argument_list|(
name|deamon
argument_list|)
decl_stmt|;
comment|// create the thread
name|thread
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|//ensure that the JVM can terminate
name|thread
operator|.
name|setName
argument_list|(
name|deamon
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
comment|// set the name of the thread
name|thread
operator|.
name|start
argument_list|()
expr_stmt|;
comment|//start the Thread
block|}
comment|//now we need to wait until all Threads have finished ...
while|while
condition|(
operator|!
name|activeIndexingDeamons
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
synchronized|synchronized
init|(
name|activeIndexingDeamons
init|)
block|{
try|try
block|{
name|activeIndexingDeamons
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|//year ... looks like we are done
block|}
block|}
block|}
comment|//set the new state to INDEXED
name|setState
argument_list|(
name|State
operator|.
name|INDEXED
argument_list|)
expr_stmt|;
block|}
comment|/**      * Handles the necessary actions if an {@link IndexingDaemon} used for the      * work done within {@link #indexAllEntities()} completes its work (meaning      * it has executed all entities).<p>      * The parsed SortedSet is created within  {@link #indexAllEntities()} and       * contains all {@link IndexingDaemon}s that have not yet finished. It is       * the responsibility of this method to remove finished       * {@link IndexingDaemon}s from this set.<p>      * In addition this Method is responsible to {@link BlockingQueue#put(Object)}      * the {@link IndexerConstants#INDEXING_COMPLETED_QUEUE_ITEM} to the      * consuming queue of {@link IndexingDaemon}s as soon as all       * {@link IndexingDaemon}s of the previous indexing steps have finished.      * This is checked comparing the {@link IndexingDaemon#getSequence()} number      * of the first entry within the sorted activeIndexingDeamons set.      * If the sequence number of the first element has increased after the      * finished {@link IndexingDaemon} was removed this Method puts the      * {@link IndexerConstants#INDEXING_COMPLETED_QUEUE_ITEM} item to the      * consuming queue of the new first entry of activeIndexingDeamons.       * @param activeIndexingDeamons The SortedSet containing all       * {@link IndexingDaemon}s that are still active.      * @param indexingDaemon the {@link IndexingDaemon} that completed its work.      */
specifier|private
name|void
name|handleFinishedIndexingDaemon
parameter_list|(
specifier|final
name|SortedSet
argument_list|<
name|IndexingDaemon
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|activeIndexingDeamons
parameter_list|,
name|IndexingDaemon
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|indexingDaemon
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"{} completed (sequence={}) ... "
argument_list|,
name|indexingDaemon
operator|.
name|getName
argument_list|()
argument_list|,
name|indexingDaemon
operator|.
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
name|IndexingDaemon
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|sendEndofQueue
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|activeIndexingDeamons
init|)
block|{
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|" Active Indexing Deamons:"
argument_list|)
expr_stmt|;
for|for
control|(
name|IndexingDaemon
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|active
range|:
name|activeIndexingDeamons
control|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"> {} {}"
argument_list|,
name|active
operator|.
name|getSequence
argument_list|()
argument_list|,
name|active
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|//get the SequenceNumber of the first Element
if|if
condition|(
operator|!
name|activeIndexingDeamons
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Integer
name|sequenceNumber
init|=
name|activeIndexingDeamons
operator|.
name|first
argument_list|()
operator|.
name|getSequence
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"> current sequence : {}"
argument_list|,
name|sequenceNumber
argument_list|)
expr_stmt|;
comment|//try to remove it from the activeDeamons list
name|activeIndexingDeamons
operator|.
name|remove
argument_list|(
name|indexingDaemon
argument_list|)
expr_stmt|;
if|if
condition|(
name|activeIndexingDeamons
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//if no active is left
name|log
operator|.
name|debug
argument_list|(
literal|"  - indexingDeamons list now emoty ... notifyAll to indicate indexing has completed!"
argument_list|)
expr_stmt|;
name|activeIndexingDeamons
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
comment|//notify all others!
block|}
else|else
block|{
comment|//check new SequenceNumber
name|IndexingDaemon
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|first
init|=
name|activeIndexingDeamons
operator|.
name|first
argument_list|()
decl_stmt|;
if|if
condition|(
name|sequenceNumber
operator|.
name|compareTo
argument_list|(
name|first
operator|.
name|getSequence
argument_list|()
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"> new sequence: {}"
argument_list|,
name|first
operator|.
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
comment|//sequence number increased ->
comment|// ... all Daemons for the step have completed
comment|// ... send EndOfQueue
comment|// ... but outside of the synchronized block!
name|sendEndofQueue
operator|=
name|first
expr_stmt|;
block|}
block|}
block|}
comment|//already empty ... nothing todo
block|}
if|if
condition|(
name|sendEndofQueue
operator|!=
literal|null
condition|)
block|{
comment|//send endOfQueue
comment|//to the consuming Queue of this one
try|try
block|{
comment|//ignore the Type safety because the item is of
comment|//INDEXING_COMPLETED_QUEUE_ITEM is anyway null
name|log
operator|.
name|info
argument_list|(
literal|"Send end-of-queue to Deamons with Sequence "
operator|+
name|sendEndofQueue
operator|.
name|getSequence
argument_list|()
argument_list|)
expr_stmt|;
name|sendEndofQueue
operator|.
name|getConsumeQueue
argument_list|()
operator|.
name|put
argument_list|(
name|INDEXING_COMPLETED_QUEUE_ITEM
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Interupped while sending EnodOfQueue Item to consuming queue of "
operator|+
name|sendEndofQueue
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* (non-Javadoc)      * @see org.apache.stanbol.entityhub.indexing.core.IndexerInterface#setIndexAllEntitiesState(boolean)      */
specifier|public
name|void
name|setIndexAllEntitiesState
parameter_list|(
name|boolean
name|indexAllEntitiesState
parameter_list|)
block|{
name|this
operator|.
name|indexAllEntitiesState
operator|=
name|indexAllEntitiesState
expr_stmt|;
block|}
comment|/* (non-Javadoc)      * @see org.apache.stanbol.entityhub.indexing.core.IndexerInterface#isIndexAllEntitiesState()      */
specifier|public
name|boolean
name|isIndexAllEntitiesState
parameter_list|()
block|{
return|return
name|indexAllEntitiesState
return|;
block|}
comment|/**      * Setter for the state.<p>      * Implementation Note: This setter is synchronised to the sync object for      * the state      * @param state the state to set      */
specifier|private
name|void
name|setState
parameter_list|(
name|State
name|state
parameter_list|)
block|{
name|boolean
name|changed
decl_stmt|;
synchronized|synchronized
init|(
name|stateSync
init|)
block|{
name|changed
operator|=
name|state
operator|!=
name|this
operator|.
name|state
expr_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
name|this
operator|.
name|state
operator|=
name|state
expr_stmt|;
block|}
block|}
if|if
condition|(
name|changed
condition|)
block|{
comment|//do not fire events within synchronized blocks ...
name|fireStateChanged
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* (non-Javadoc)      * @see org.apache.stanbol.entityhub.indexing.core.IndexerInterface#getState()      */
specifier|public
name|State
name|getState
parameter_list|()
block|{
return|return
name|state
return|;
block|}
block|}
end_class

end_unit

