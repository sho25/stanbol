begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|config
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|config
operator|.
name|IndexingConstants
operator|.
name|KEY_DESCRIPTION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|config
operator|.
name|IndexingConstants
operator|.
name|KEY_ENTITY_DATA_ITERABLE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|config
operator|.
name|IndexingConstants
operator|.
name|KEY_ENTITY_DATA_PROVIDER
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|config
operator|.
name|IndexingConstants
operator|.
name|KEY_ENTITY_ID_ITERATOR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|config
operator|.
name|IndexingConstants
operator|.
name|KEY_ENTITY_POST_PROCESSOR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|config
operator|.
name|IndexingConstants
operator|.
name|KEY_ENTITY_PROCESSOR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|config
operator|.
name|IndexingConstants
operator|.
name|KEY_ENTITY_SCORE_PROVIDER
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|config
operator|.
name|IndexingConstants
operator|.
name|KEY_INDEXING_DESTINATION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|config
operator|.
name|IndexingConstants
operator|.
name|KEY_INDEX_FIELD_CONFIG
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|config
operator|.
name|IndexingConstants
operator|.
name|KEY_NAME
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URLDecoder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|jar
operator|.
name|JarEntry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|jar
operator|.
name|JarFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|FileUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|FilenameUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|LineIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|namespaceprefix
operator|.
name|NamespacePrefixService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|namespaceprefix
operator|.
name|service
operator|.
name|StanbolNamespacePrefixService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|core
operator|.
name|mapping
operator|.
name|FieldMappingUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|EntityDataIterable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|EntityDataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|EntityIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|EntityProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|EntityScoreProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|IndexingDestination
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|normaliser
operator|.
name|DefaultNormaliser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|normaliser
operator|.
name|ScoreNormaliser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|mapping
operator|.
name|FieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|mapping
operator|.
name|FieldMapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|site
operator|.
name|SiteConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_class
specifier|public
class|class
name|IndexingConfig
block|{
specifier|private
specifier|static
specifier|final
name|String
name|DEFAULT_ROOT_PATH
init|=
literal|"indexing"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|CONFIG_FOLDER
init|=
literal|"config"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|CONFIG_PATH
init|=
name|DEFAULT_ROOT_PATH
operator|+
name|File
operator|.
name|separatorChar
operator|+
name|CONFIG_FOLDER
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|SOURCE_FOLDER
init|=
literal|"resources"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|SOURCE_PATH
init|=
name|DEFAULT_ROOT_PATH
operator|+
name|File
operator|.
name|separatorChar
operator|+
name|SOURCE_FOLDER
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|DESTINATION_FOLDER
init|=
literal|"destination"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|DISTRIBUTION_FOLDER
init|=
literal|"dist"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|INDEXING_PROPERTIES
init|=
literal|"indexing.properties"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|CONFIG_PARAM
init|=
literal|"config"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|KEY_INDEXING_CONFIG
init|=
literal|"indexingConfig"
decl_stmt|;
comment|/**      * Internally used to explain the syntax in the configuration file to parse parameters      */
specifier|private
specifier|static
specifier|final
name|String
name|SYNTAX_ERROR_MESSAGE
init|=
literal|"{key}={value1},{param1}:{value1},{param2}:{value2};{value2},{param1}:{value1} ..."
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|IndexingConfig
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|DEFAULT_INDEX_FIELD_CONFIG_FILE_NAME
init|=
literal|"indexFieldConfig.txt"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_INDEXED_ENTITIES_ID_FILE_NAME
init|=
literal|"indexed-entities-ids.zip"
decl_stmt|;
comment|/**      * This stores the context within the classpath to initialise missing      * configurations and source based on the defaults in the classpath.      * This might be a directory or an jar file.       * @see {@link #loadViaClasspath(String)}      * @see #getConfigClasspathRootFolder()      */
specifier|private
specifier|final
name|File
name|classPathRootDir
decl_stmt|;
comment|/**      * The root directory for the indexing (defaults to {@link #DEFAULT_ROOT_PATH})      */
specifier|private
specifier|final
name|File
name|rootDir
decl_stmt|;
comment|//    /**
comment|//     * The root directory for the configuration
comment|//     */
comment|//    private final File configDir;
comment|//    /**
comment|//     * The root directory for the resources (indexing source files)
comment|//     */
comment|//    private final File sourceDir;
comment|//    /**
comment|//     * The root directory for the files created during the indexing process
comment|//     */
comment|//    private final File destinationDir;
comment|//    /**
comment|//     * The root directory for the distribution files created in the finalisation
comment|//     * phase of the indexing (e.g. The archive with the index,
comment|//     * OSGI configuration, ...)
comment|//     */
comment|//    private final File distributionDir;
comment|//
comment|//    /**
comment|//     * Map between the relative paths stored in {@link #rootDir}, {@link #configDir},
comment|//     * {@link #sourceDir}, {@link #destinationDir} and {@link #distributionDir}
comment|//     * to the {@link File#getCanonicalFile()} counterparts as returned by the
comment|//     * {@link #getRootFolder()} ... methods.
comment|//     */
comment|//    private final Map<File,File> canonicalDirs = new HashMap<File,File>();
comment|/**      * The main indexing configuration as parsed form {@link #INDEXING_PROPERTIES}      * file within the {@link #configDir}.      */
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|configuration
decl_stmt|;
comment|/**      * The value of the {@link IndexingConstants#KEY_NAME} property      */
specifier|private
name|String
name|name
decl_stmt|;
comment|/**      * The {@link EntityDataIterable} instance initialised based on the value      * of the {@link IndexingConstants#KEY_ENTITY_DATA_ITERABLE} key or      *<code>null</code> if not configured.      * This variable uses lazy initialisation      * @see #getDataIterable()      */
specifier|private
name|EntityDataIterable
name|entityDataIterable
init|=
literal|null
decl_stmt|;
comment|/**      * The {@link EntityDataProvider} instance initialised based on the value      * of the {@link IndexingConstants#KEY_ENTITY_DATA_PROVIDER} key or      *<code>null</code> if not configured.      * This variable uses lazy initialisation      * @see #getEntityDataProvider()      */
specifier|private
name|EntityDataProvider
name|entityDataProvider
init|=
literal|null
decl_stmt|;
comment|/**      * The {@link EntityIterator} instance initialised based on the value      * of the {@link IndexingConstants#KEY_ENTITY_ID_ITERATOR} key or      *<code>null</code> if not configured.      * This variable uses lazy initialisation      * @see #getEntityIdIterator()      */
specifier|private
name|EntityIterator
name|entityIdIterator
init|=
literal|null
decl_stmt|;
comment|/**      * The {@link EntityScoreProvider} instance initialised based on the value      * of the {@link IndexingConstants#KEY_ENTITY_SCORE_PROVIDER} key or      *<code>null</code> if not configured.      * This variable uses lazy initialisation      * @see #getEntityScoreProvider()      */
specifier|private
name|EntityScoreProvider
name|entityScoreProvider
init|=
literal|null
decl_stmt|;
comment|/**      * The {@link ScoreNormaliser} instance initialised based on the value      * of the {@link IndexingConstants#KEY_SCORE_NORMALIZER} key or      *<code>null</code> if not configured.      * This variable uses lazy initialisation      * @see #getNormaliser()      */
specifier|private
name|ScoreNormaliser
name|scoreNormaliser
init|=
literal|null
decl_stmt|;
comment|/**      * The {@link EntityProcessor}s initialised based on the value      * of the {@link IndexingConstants#KEY_ENTITY_PROCESSOR} key or      *<code>null</code> if not configured.      * This variable uses lazy initialisation      * @see #getEntityProcessor()      */
specifier|private
name|List
argument_list|<
name|EntityProcessor
argument_list|>
name|entityProcessor
init|=
literal|null
decl_stmt|;
comment|/**      * The {@link EntityProcessor}s initialised based on the value      * of the {@link IndexingConstants#KEY_ENTITY_POST_PROCESSOR} key or      *<code>null</code> if not configured.      * This variable uses lazy initialisation      * @see #getEntityProcessor()      */
specifier|private
name|List
argument_list|<
name|EntityProcessor
argument_list|>
name|entityPostProcessor
init|=
literal|null
decl_stmt|;
comment|/**      * The {@link IndexingDestination} instance initialised based on the value      * of the {@link IndexingConstants#KEY_INDEXING_DESTINATION} key or      *<code>null</code> if not configured.      * This variable uses lazy initialisation      * @see #getIndexingDestination()      */
specifier|private
name|IndexingDestination
name|indexingDestination
init|=
literal|null
decl_stmt|;
comment|/**      * The configuration of the fields/languages included/excluded in the index      * as parsed based on the value of the       * {@link IndexingConstants#KEY_INDEX_FIELD_CONFIG} key.      */
specifier|private
name|Collection
argument_list|<
name|FieldMapping
argument_list|>
name|fieldMappings
decl_stmt|;
comment|/**      * offset to load resources via the classpath (only used for unit testing)      */
specifier|private
name|String
name|classpathResourceOffset
decl_stmt|;
specifier|private
name|NamespacePrefixService
name|namespacePrefixService
decl_stmt|;
comment|/**      * Creates an instance using {@link #DEFAULT_ROOT_PATH} (relative to the      * working directory) as {@link #getIndexingFolder()} for the indexing      */
specifier|public
name|IndexingConfig
parameter_list|()
block|{
name|this
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates an isntace using the parsed offset plus {@link #DEFAULT_ROOT_PATH}      * as {@link #getIndexingFolder()} for the indexing      * @param rootPath      */
specifier|public
name|IndexingConfig
parameter_list|(
name|String
name|rootPath
parameter_list|)
block|{
name|this
argument_list|(
name|rootPath
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Internally used for unit testing. Allows to parse an offset for loading      * the indexer configuration from the classpath. Currently a protected      * feature, but might be moved to the public API at a later point of time.      * (would allow to include multiple default configurations via the      * classpath).      * @param rootPath      * @param classpathOffset      */
specifier|protected
name|IndexingConfig
parameter_list|(
name|String
name|rootPath
parameter_list|,
name|String
name|classpathOffset
parameter_list|)
block|{
name|this
operator|.
name|classpathResourceOffset
operator|=
name|classpathOffset
expr_stmt|;
comment|//first get the root
name|File
name|root
decl_stmt|;
comment|// = new File(System.getProperty("user.dir"));
if|if
condition|(
name|rootPath
operator|!=
literal|null
condition|)
block|{
name|root
operator|=
operator|new
name|File
argument_list|(
name|rootPath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|root
operator|=
operator|new
name|File
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|root
operator|=
name|root
operator|.
name|getCanonicalFile
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to get canonical file for "
operator|+
name|root
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Indexing Working Directory: {}"
argument_list|,
name|root
operator|.
name|getAbsoluteFile
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|rootDir
operator|=
name|root
expr_stmt|;
name|File
name|configDir
init|=
name|getConfigFolder
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|configDir
operator|.
name|getAbsoluteFile
argument_list|()
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"> config directory {} does not exist"
argument_list|,
name|configDir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|configDir
operator|.
name|getAbsoluteFile
argument_list|()
operator|.
name|mkdirs
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to create configuration folder '"
operator|+
name|configDir
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|"'!"
argument_list|)
throw|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"  - created"
argument_list|)
expr_stmt|;
block|}
block|}
name|File
name|sourceDir
init|=
name|getSourceFolder
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|sourceDir
operator|.
name|getAbsoluteFile
argument_list|()
operator|.
name|exists
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"> resource folder '{} does not exist "
argument_list|,
name|sourceDir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sourceDir
operator|.
name|getAbsoluteFile
argument_list|()
operator|.
name|mkdirs
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to create resource folder '"
operator|+
name|sourceDir
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|"'!"
argument_list|)
throw|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"  - created"
argument_list|)
expr_stmt|;
block|}
block|}
name|File
name|destinationDir
init|=
name|getDestinationFolder
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|destinationDir
operator|.
name|getAbsoluteFile
argument_list|()
operator|.
name|exists
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"> destination folder '{} does not exist "
argument_list|,
name|destinationDir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|destinationDir
operator|.
name|getAbsoluteFile
argument_list|()
operator|.
name|mkdirs
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to create target folder '"
operator|+
name|destinationDir
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|"'!"
argument_list|)
throw|;
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"  - created"
argument_list|)
expr_stmt|;
block|}
block|}
name|File
name|distributionDir
init|=
name|getDistributionFolder
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|distributionDir
operator|.
name|getAbsoluteFile
argument_list|()
operator|.
name|exists
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"> distribution folder '{} does not exist "
argument_list|,
name|distributionDir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|distributionDir
operator|.
name|getAbsoluteFile
argument_list|()
operator|.
name|mkdirs
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to create distribution '"
operator|+
name|destinationDir
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|"'!"
argument_list|)
throw|;
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"  - created"
argument_list|)
expr_stmt|;
block|}
block|}
comment|//set up the root folder for the classpath
name|this
operator|.
name|classPathRootDir
operator|=
name|getConfigClasspathRootFolder
argument_list|()
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Classpath Indexing Root {}"
argument_list|,
name|classPathRootDir
argument_list|)
expr_stmt|;
comment|//read the prefixnamespace mappings
try|try
block|{
name|initNamespacePrefixMapper
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to get create NamespacePrefixMapper"
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|//check the main configuration
name|this
operator|.
name|configuration
operator|=
name|loadConfig
argument_list|(
name|INDEXING_PROPERTIES
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|Object
name|value
init|=
name|configuration
operator|.
name|get
argument_list|(
name|KEY_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Indexing Configuration '"
operator|+
name|INDEXING_PROPERTIES
operator|+
literal|"' is missing the required key "
operator|+
name|KEY_NAME
operator|+
literal|"!"
argument_list|)
throw|;
block|}
name|this
operator|.
name|name
operator|=
name|value
operator|.
name|toString
argument_list|()
expr_stmt|;
if|if
condition|(
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid Indexing Configuration '"
operator|+
name|INDEXING_PROPERTIES
operator|+
literal|"': The value for the parameter"
operator|+
name|KEY_NAME
operator|+
literal|" MUST NOT be empty!"
argument_list|)
throw|;
block|}
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|KEY_INDEX_FIELD_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
operator|||
name|value
operator|.
name|toString
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|value
operator|=
name|DEFAULT_INDEX_FIELD_CONFIG_FILE_NAME
expr_stmt|;
block|}
specifier|final
name|File
name|indexFieldConfig
init|=
name|getConfigFile
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexFieldConfig
operator|.
name|isFile
argument_list|()
condition|)
block|{
try|try
block|{
name|this
operator|.
name|fieldMappings
operator|=
name|FieldMappingUtils
operator|.
name|parseFieldMappings
argument_list|(
operator|new
name|Iterator
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
name|LineIterator
name|it
init|=
name|IOUtils
operator|.
name|lineIterator
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|indexFieldConfig
argument_list|)
argument_list|,
literal|"UTF-8"
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|it
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|next
parameter_list|()
block|{
return|return
name|it
operator|.
name|nextLine
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|,
name|getNamespacePrefixService
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to read Index Field Configuration form '"
operator|+
name|indexFieldConfig
operator|+
literal|"'!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid Indexing Configuration: "
operator|+
literal|"IndexFieldConfiguration '"
operator|+
name|indexFieldConfig
operator|+
literal|"' not found. "
operator|+
literal|"Provide the missing file or use the '"
operator|+
name|KEY_INDEX_FIELD_CONFIG
operator|+
literal|"' in the '"
operator|+
name|INDEXING_PROPERTIES
operator|+
literal|"' to configure a different one!"
argument_list|)
throw|;
block|}
block|}
specifier|public
name|NamespacePrefixService
name|getNamespacePrefixService
parameter_list|()
block|{
return|return
name|namespacePrefixService
return|;
block|}
comment|/**      * @param configDir      * @throws IOException      */
specifier|private
name|void
name|initNamespacePrefixMapper
parameter_list|()
throws|throws
name|IOException
block|{
name|File
name|nsPrefixMappings
init|=
name|getConfigFile
argument_list|(
literal|"namespaceprefix.mappings"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|nsPrefixMappings
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|FileUtils
operator|.
name|writeLines
argument_list|(
name|nsPrefixMappings
argument_list|,
literal|"UTF-8"
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"# Syntax: '{prefix}\\t{namespace}\\n"
argument_list|,
literal|"# where:"
argument_list|,
literal|"#   {prefix} ... [0..9A..Za..z-_]"
argument_list|,
literal|"#   {namespace} ... must end with '#' or '/' for URLs and ':' for URNs"
argument_list|,
literal|"# one mapping per line, multiple prefixes for the same namespace allowed"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|namespacePrefixService
operator|=
operator|new
name|StanbolNamespacePrefixService
argument_list|(
name|nsPrefixMappings
argument_list|)
expr_stmt|;
block|}
comment|/**      * Searches for a configuration file. If the configuration is not found      * within the {@link #getConfigFolder()} than it searches the Classpath for      * the configuration. If the configuration is found within the Classpath it      * is copied the the configuration folder and than opened.<p>      * The intension behind that is that the default values are provided within      * the indexer archive but that the user can modify the configuration after      * the first call.      * @param configFile the name of the configuration file      * @return      * @throws IOException      */
specifier|public
name|InputStream
name|openConfig
parameter_list|(
name|String
name|configFileName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|openResource
argument_list|(
name|CONFIG_PATH
argument_list|,
name|configFileName
argument_list|)
return|;
block|}
specifier|public
name|InputStream
name|openSource
parameter_list|(
name|String
name|sourceFileName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|openResource
argument_list|(
name|SOURCE_PATH
argument_list|,
name|sourceFileName
argument_list|)
return|;
block|}
comment|/**      * Getter for the config file with the given name. If the file/directory is       * not present within the {@link #getConfigFolder()} it is searched via the       * classpath and created (if found).      * @param configName      * @return      */
specifier|public
name|File
name|getConfigFile
parameter_list|(
name|String
name|configName
parameter_list|)
block|{
return|return
name|getResource
argument_list|(
name|CONFIG_PATH
argument_list|,
name|configName
argument_list|)
return|;
block|}
comment|/**      * Getter for the source file with the given name. If the file/directory is       * not present within the {@link #getSourceFolder()} it is searched via the       * classpath and created (if found).      * @param configName      * @return      */
specifier|public
name|File
name|getSourceFile
parameter_list|(
name|String
name|configName
parameter_list|)
block|{
return|return
name|getResource
argument_list|(
name|SOURCE_PATH
argument_list|,
name|configName
argument_list|)
return|;
block|}
specifier|private
name|InputStream
name|openResource
parameter_list|(
name|String
name|path
parameter_list|,
name|String
name|fileName
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|resource
init|=
name|getResource
argument_list|(
name|path
argument_list|,
name|fileName
argument_list|)
decl_stmt|;
name|InputStream
name|in
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|resource
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|in
operator|=
operator|new
name|FileInputStream
argument_list|(
name|resource
argument_list|)
expr_stmt|;
block|}
comment|//else not found -> return null
return|return
name|in
return|;
block|}
comment|/**      * Searches for a resource with the parsed name in the parsed directory.      * If it can not be found it tries to initialise it via the classpath.      * @param root the (relative path) to the directory containing the file.      * typically on of {@link #configDir} or {@link #sourceDir}.      * @param fileName the name of the file (file or directory)      * @return the absolute File or<code>null</code> if not found.      */
specifier|private
name|File
name|getResource
parameter_list|(
name|String
name|path
parameter_list|,
name|String
name|fileName
parameter_list|)
block|{
name|File
name|resourceDir
init|=
operator|new
name|File
argument_list|(
name|getWorkingDirectory
argument_list|()
argument_list|,
name|path
argument_list|)
decl_stmt|;
name|File
name|resource
init|=
operator|new
name|File
argument_list|(
name|resourceDir
argument_list|,
name|fileName
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"request for RDFTerm {} (folder: {})"
argument_list|,
name|fileName
argument_list|,
name|resourceDir
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource
operator|.
name|getAbsoluteFile
argument_list|()
operator|.
name|exists
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"> rquested RDFTerm present"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|copyFromClasspath
argument_list|(
operator|new
name|File
argument_list|(
name|path
argument_list|,
name|fileName
argument_list|)
argument_list|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"> rquested RDFTerm copied from Classpath "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"> rquested RDFTerm not found"
argument_list|)
expr_stmt|;
block|}
return|return
name|resource
operator|.
name|getAbsoluteFile
argument_list|()
return|;
block|}
comment|/**      * This method copies Resources from the Classpath over to the target      * resource. It supports both files and directories. In case of directories      * all sub-directories and there files are copied.<p>       * One can not use {@link ClassLoader#getResource(String)} because it does      * only support files and no directories.      * @param resource the target resource (relative path also found in the jar)      * @return<code>true</code> if the resource was found and copied.      */
specifier|private
name|boolean
name|copyFromClasspath
parameter_list|(
name|File
name|resource
parameter_list|)
block|{
name|String
name|resourcePath
decl_stmt|;
if|if
condition|(
name|classpathResourceOffset
operator|!=
literal|null
condition|)
block|{
name|String
name|rs
init|=
name|resource
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|resourcePath
operator|=
name|FilenameUtils
operator|.
name|concat
argument_list|(
name|classpathResourceOffset
argument_list|,
name|rs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|resourcePath
operator|=
name|resource
operator|.
name|getPath
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|classPathRootDir
operator|==
literal|null
condition|)
block|{
comment|//not available
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|classPathRootDir
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
comment|// loaded from directory
name|File
name|classpathResource
init|=
operator|new
name|File
argument_list|(
name|classPathRootDir
argument_list|,
name|resourcePath
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|classpathResource
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|FileUtils
operator|.
name|copyFile
argument_list|(
name|classpathResource
argument_list|,
operator|new
name|File
argument_list|(
name|getWorkingDirectory
argument_list|()
argument_list|,
name|resource
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|classpathResource
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|FileUtils
operator|.
name|copyDirectory
argument_list|(
name|classpathResource
argument_list|,
operator|new
name|File
argument_list|(
name|getWorkingDirectory
argument_list|()
argument_list|,
name|resource
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unable to copy Configuration form classpath "
operator|+
literal|"resource %s to target file %s!"
argument_list|,
name|classpathResource
argument_list|,
name|resource
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|//loaded form a jar file
name|boolean
name|found
init|=
literal|false
decl_stmt|;
name|JarFile
name|jar
init|=
literal|null
decl_stmt|;
comment|//when loading from a jar file we need Unix style separators
name|String
name|unixResourcePath
init|=
name|FilenameUtils
operator|.
name|separatorsToUnix
argument_list|(
name|resourcePath
argument_list|)
decl_stmt|;
try|try
block|{
name|jar
operator|=
operator|new
name|JarFile
argument_list|(
name|classPathRootDir
argument_list|)
expr_stmt|;
comment|//String resourceName = resource.getPath();
name|Enumeration
argument_list|<
name|JarEntry
argument_list|>
name|entries
init|=
name|jar
operator|.
name|entries
argument_list|()
decl_stmt|;
name|boolean
name|completed
init|=
literal|false
decl_stmt|;
comment|//we need to iterate over the entries because the resource might
comment|//refer to an file but missing the tailing '/'
while|while
condition|(
name|entries
operator|.
name|hasMoreElements
argument_list|()
operator|&&
operator|!
name|completed
condition|)
block|{
name|JarEntry
name|entry
init|=
name|entries
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|String
name|entryName
init|=
name|entry
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|entryName
operator|.
name|startsWith
argument_list|(
name|resourcePath
argument_list|)
operator|||
name|entryName
operator|.
name|startsWith
argument_list|(
name|unixResourcePath
argument_list|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"found entry : {}[dir={}]"
argument_list|,
name|entryName
argument_list|,
name|entry
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|entryName
operator|.
name|equals
argument_list|(
name|resourcePath
argument_list|)
operator|||
name|entryName
operator|.
name|equals
argument_list|(
name|unixResourcePath
argument_list|)
operator|)
operator|&&
operator|!
name|entry
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
comment|//found the resource and it is an file -> copy and return
name|completed
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|entry
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
comment|//copy a file
comment|//still check if the target folder exist
comment|//TODO: this depends on user.dir is root dir
name|File
name|targetFolder
init|=
operator|new
name|File
argument_list|(
name|getWorkingDirectory
argument_list|()
argument_list|,
name|FilenameUtils
operator|.
name|getPathNoEndSeparator
argument_list|(
name|entryName
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|targetFolder
operator|.
name|exists
argument_list|()
operator|||
name|targetFolder
operator|.
name|mkdirs
argument_list|()
condition|)
block|{
name|File
name|outFile
init|=
operator|new
name|File
argument_list|(
name|targetFolder
argument_list|,
name|FilenameUtils
operator|.
name|getName
argument_list|(
name|entry
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|InputStream
name|is
init|=
name|jar
operator|.
name|getInputStream
argument_list|(
name|entry
argument_list|)
decl_stmt|;
name|OutputStream
name|os
init|=
operator|new
name|FileOutputStream
argument_list|(
name|outFile
argument_list|)
decl_stmt|;
name|IOUtils
operator|.
name|copyLarge
argument_list|(
name|is
argument_list|,
name|os
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|os
argument_list|)
expr_stmt|;
comment|//found one resource
name|found
operator|=
literal|true
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"> created File {}"
argument_list|,
name|outFile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to create"
operator|+
literal|"folder "
operator|+
name|targetFolder
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|//directory
comment|//TODO: this depends on user.dir is root dir
name|File
name|targetFolder
init|=
operator|new
name|File
argument_list|(
name|entryName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|targetFolder
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|targetFolder
operator|.
name|mkdirs
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to create"
operator|+
literal|"folder "
operator|+
name|targetFolder
argument_list|)
throw|;
block|}
else|else
block|{
comment|//created a directory
name|log
operator|.
name|info
argument_list|(
literal|"> created Directory {}"
argument_list|,
name|targetFolder
argument_list|)
expr_stmt|;
name|found
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
comment|// else entry does not start with the parsed resource
block|}
comment|//end while entries
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to copy resources from"
operator|+
literal|"jar file "
operator|+
name|classPathRootDir
operator|+
literal|"!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|jar
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|jar
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|//ignore
block|}
block|}
block|}
return|return
name|found
return|;
block|}
block|}
comment|/**      * First uses the {@link Thread#currentThread() current threads} class loader      * to load the parsed resource. If not found the class loader of this class      * is used.      * @param resource the resource to load      * @return the URL for the resource or<code>null</code> if not found      */
specifier|private
specifier|static
name|URL
name|loadViaClasspath
parameter_list|(
name|String
name|resource
parameter_list|)
block|{
name|String
name|unixResource
init|=
name|FilenameUtils
operator|.
name|separatorsToUnix
argument_list|(
name|resource
argument_list|)
decl_stmt|;
name|URL
name|resourceUrl
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getContextClassLoader
argument_list|()
operator|.
name|getResource
argument_list|(
name|unixResource
argument_list|)
decl_stmt|;
if|if
condition|(
name|resourceUrl
operator|==
literal|null
condition|)
block|{
name|resourceUrl
operator|=
name|IndexingConfig
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
operator|.
name|getResource
argument_list|(
name|unixResource
argument_list|)
expr_stmt|;
block|}
return|return
name|resourceUrl
return|;
block|}
comment|/**      * Uses the Classpath to search for the File (maybe within a jar archive)      * that is the root to load the config. This is needed in cases directories      * are requested by the {@link #getResource(File, String)} methods because      * the normal {@link ClassLoader#getResource(String)} method does not work      * for directories.      * @param clazz the class used as context to find the jar file      * @return the archive the parsed class was loaded from      * @throws IOException In case the jar file can not be accessed.      */
specifier|private
name|File
name|getConfigClasspathRootFolder
parameter_list|()
block|{
comment|//use the indexing.properties file as context
comment|//STANBOL-
name|String
name|contextResource
decl_stmt|;
if|if
condition|(
name|classpathResourceOffset
operator|!=
literal|null
condition|)
block|{
name|contextResource
operator|=
name|FilenameUtils
operator|.
name|concat
argument_list|(
name|classpathResourceOffset
argument_list|,
name|CONFIG_PATH
operator|+
name|File
operator|.
name|separatorChar
operator|+
name|INDEXING_PROPERTIES
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|contextResource
operator|=
name|CONFIG_PATH
operator|+
name|File
operator|.
name|separatorChar
operator|+
name|INDEXING_PROPERTIES
expr_stmt|;
block|}
name|URL
name|contextUrl
init|=
name|loadViaClasspath
argument_list|(
name|contextResource
argument_list|)
decl_stmt|;
if|if
condition|(
name|contextUrl
operator|==
literal|null
condition|)
block|{
comment|// if indexing.properties is not found via classpath
name|log
operator|.
name|info
argument_list|(
literal|"No '{}' found via classpath. Loading RDFTerm via"
operator|+
literal|"the classpath is deactivated."
argument_list|,
name|contextResource
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|String
name|resourcePath
decl_stmt|;
try|try
block|{
name|resourcePath
operator|=
operator|new
name|File
argument_list|(
name|contextUrl
operator|.
name|toURI
argument_list|()
argument_list|)
operator|.
name|getAbsolutePath
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|//if we can not convert it to an URI, try directly with the URL
comment|//URLs with jar:file:/{jarPath}!{classPath} can cause problems
comment|//so try to parse manually by using the substring from the first
comment|//'/' to (including '!')
name|String
name|urlString
decl_stmt|;
try|try
block|{
name|urlString
operator|=
name|URLDecoder
operator|.
name|decode
argument_list|(
name|contextUrl
operator|.
name|toString
argument_list|()
argument_list|,
literal|"UTF-8"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|e1
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Encoding 'UTF-8' is not supported"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|int
name|slashIndex
init|=
name|urlString
operator|.
name|indexOf
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
name|int
name|exclamationIndex
init|=
name|urlString
operator|.
name|indexOf
argument_list|(
literal|'!'
argument_list|)
decl_stmt|;
if|if
condition|(
name|slashIndex
operator|>=
literal|0
operator|&&
name|exclamationIndex
operator|>
literal|0
condition|)
block|{
name|resourcePath
operator|=
name|urlString
operator|.
name|substring
argument_list|(
name|slashIndex
argument_list|,
name|exclamationIndex
operator|+
literal|1
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"manually parsed plassPath: {} from {}"
argument_list|,
name|resourcePath
argument_list|,
name|contextUrl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//looks like there is an other reason than an URL as described above
comment|//so better to throw an exception than to guess ...
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to Access Source at location "
operator|+
name|contextUrl
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|//now get the file for the root folder in the archive containing the config
name|File
name|classpathRoot
decl_stmt|;
if|if
condition|(
name|resourcePath
operator|.
name|indexOf
argument_list|(
literal|'!'
argument_list|)
operator|>
literal|0
condition|)
block|{
name|classpathRoot
operator|=
operator|new
name|File
argument_list|(
name|resourcePath
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|resourcePath
operator|.
name|indexOf
argument_list|(
literal|'!'
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|classpathRoot
operator|=
operator|new
name|File
argument_list|(
name|resourcePath
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|resourcePath
operator|.
name|length
argument_list|()
operator|-
name|contextResource
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|classpathRoot
return|;
block|}
comment|/**      * Loads an {@link Properties} configuration from the parsed file and      * returns it as Map      * @param configFile the file      * @param required if<code>true</code> an {@link IllegalArgumentException}      * will be thrown if the config was not present otherwise an empty map will      * be returned      * @return The configuration as Map      */
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|loadConfig
parameter_list|(
name|String
name|configFile
parameter_list|,
name|boolean
name|required
parameter_list|)
block|{
comment|//Uses an own implementation to parse key=value configuration
comment|//The problem with the java properties is that keys do not support
comment|//UTF-8, but some configurations might want to use URLs as keys!
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|configMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
name|InputStream
name|in
init|=
name|openConfig
argument_list|(
name|configFile
argument_list|)
decl_stmt|;
if|if
condition|(
name|in
operator|!=
literal|null
condition|)
block|{
name|LineIterator
name|lines
init|=
name|IOUtils
operator|.
name|lineIterator
argument_list|(
name|in
argument_list|,
literal|"UTF-8"
argument_list|)
decl_stmt|;
while|while
condition|(
name|lines
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|line
init|=
name|lines
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|indexOfEquals
init|=
name|line
operator|.
name|indexOf
argument_list|(
literal|'='
argument_list|)
decl_stmt|;
name|String
name|key
init|=
name|indexOfEquals
operator|>
literal|0
condition|?
name|line
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|indexOfEquals
argument_list|)
operator|.
name|trim
argument_list|()
else|:
name|line
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|!=
literal|'#'
operator|&&
name|key
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|!=
literal|'!'
condition|)
block|{
comment|//no comment
name|String
name|value
decl_stmt|;
if|if
condition|(
name|indexOfEquals
operator|>
literal|0
operator|&&
name|indexOfEquals
operator|<
name|line
operator|.
name|length
argument_list|()
operator|-
literal|1
condition|)
block|{
name|value
operator|=
name|line
operator|.
name|substring
argument_list|(
name|indexOfEquals
operator|+
literal|1
argument_list|,
name|line
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
literal|null
expr_stmt|;
block|}
name|configMap
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|// else ignore comments
block|}
comment|//else ignore empty lines
block|}
block|}
elseif|else
if|if
condition|(
name|required
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unable to find configuration file '"
operator|+
name|configFile
operator|+
literal|"'!"
argument_list|)
throw|;
block|}
else|else
block|{
comment|//-> optional and not found -> return empty map
name|log
operator|.
name|info
argument_list|(
literal|"Unable to find optional configuration {}"
argument_list|,
name|configFile
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|required
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to read configuration file '"
operator|+
name|configFile
operator|+
literal|"'!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to read configuration file '"
operator|+
name|configFile
operator|+
literal|"'!"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Old code that used java.util.Properties to load configurations!
comment|//        Properties config = new Properties();
comment|//        try {
comment|//            config.load(new FileInputStream(configFile));
comment|//        } catch (FileNotFoundException e) {
comment|//            if(required){
comment|//                throw new IllegalArgumentException(
comment|//                    "Unable to find configuration file '"+
comment|//                    configFile.getAbsolutePath()+"'!");
comment|//            }
comment|//        } catch (IOException e) {
comment|//            if(required){
comment|//                throw new IllegalStateException(
comment|//                    "Unable to read configuration file '"+
comment|//                    configFile.getAbsolutePath()+"'!",e);
comment|//            }
comment|//        }
comment|//        if(config != null){
comment|//            for(Enumeration<String> keys = (Enumeration<String>)config.propertyNames();keys.hasMoreElements();){
comment|//                String key = keys.nextElement();
comment|//                configMap.put(key, config.getProperty(key));
comment|//            }
comment|//        }
return|return
name|configMap
return|;
block|}
comment|/**      * Getter for the working direcotry of the Indexing tool. (the directory      * containing the /indexing folder). By defualt htis       * @return      */
specifier|public
specifier|final
name|File
name|getWorkingDirectory
parameter_list|()
block|{
return|return
name|rootDir
return|;
block|}
comment|/**      * Getter for the root folder used for the Indexing (root/indexing)      * @return the root folder (containing the config, resources, target and dist folders)      */
specifier|public
specifier|final
name|File
name|getIndexingFolder
parameter_list|()
block|{
return|return
operator|new
name|File
argument_list|(
name|getWorkingDirectory
argument_list|()
argument_list|,
name|DEFAULT_ROOT_PATH
argument_list|)
return|;
block|}
comment|/**      * The root folder for the configuration. Guaranteed to exist.      * @return the root folder for the configuration      */
specifier|public
specifier|final
name|File
name|getConfigFolder
parameter_list|()
block|{
return|return
operator|new
name|File
argument_list|(
name|getIndexingFolder
argument_list|()
argument_list|,
name|CONFIG_FOLDER
argument_list|)
return|;
block|}
comment|/**      * The root folder containing the resources used as input for the       * indexing process. Might not exist if no resources are available      * @return the root folder for the resources      */
specifier|public
specifier|final
name|File
name|getSourceFolder
parameter_list|()
block|{
return|return
operator|new
name|File
argument_list|(
name|getIndexingFolder
argument_list|()
argument_list|,
name|SOURCE_FOLDER
argument_list|)
return|;
block|}
comment|/**      * The root folder containing the files created by the indexing process.      * Guaranteed to exist.      * @return the target folder      */
specifier|public
specifier|final
name|File
name|getDestinationFolder
parameter_list|()
block|{
return|return
operator|new
name|File
argument_list|(
name|getIndexingFolder
argument_list|()
argument_list|,
name|DESTINATION_FOLDER
argument_list|)
return|;
block|}
comment|/**      * The root folder for the distribution. Guaranteed to exist.      * @return the distribution folder      */
specifier|public
specifier|final
name|File
name|getDistributionFolder
parameter_list|()
block|{
return|return
operator|new
name|File
argument_list|(
name|getIndexingFolder
argument_list|()
argument_list|,
name|DISTRIBUTION_FOLDER
argument_list|)
return|;
block|}
comment|/**      * Getter for the name as configured by the {@link IndexingConstants#KEY_NAME}      * by the main indexing configuration.      * @return the name of this data source to index      */
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
comment|/**      * Getter for the description as configured by the {@link IndexingConstants#KEY_DESCRIPTION}      * by the main indexing configuration.      * @return the description of the data source to index or<code>null</code>      * if not defined      */
specifier|public
name|String
name|getDescription
parameter_list|()
block|{
name|Object
name|value
init|=
name|configuration
operator|.
name|get
argument_list|(
name|KEY_DESCRIPTION
argument_list|)
decl_stmt|;
return|return
name|value
operator|!=
literal|null
condition|?
name|value
operator|.
name|toString
argument_list|()
else|:
literal|null
return|;
block|}
comment|/**      * Getter for the failOnError as configured by the {@link IndexingConstants#KEY_FAIL_ON_ERROR_LOADING_RESOURCE}      * by the main indexing configuration.      * @return the boolean value of the failOnError parameter      */
specifier|public
name|boolean
name|isFailOnError
parameter_list|()
block|{
comment|//by default failOnError is false to continue execution of the indexing tool
name|boolean
name|failOnError
init|=
literal|false
decl_stmt|;
name|Object
name|value
init|=
name|configuration
operator|.
name|get
argument_list|(
name|IndexingConstants
operator|.
name|KEY_FAIL_ON_ERROR_LOADING_RESOURCE
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
operator|!
name|value
operator|.
name|toString
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|failOnError
operator|=
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|failOnError
return|;
block|}
comment|/**      * The {@link ScoreNormaliser} as configured by the {@link IndexingConstants#KEY_SCORE_NORMALIZER}      * by the main indexing configuration.      * @return the configured {@link ScoreNormaliser} or a {@link DefaultNormaliser} if      * this configuration is missing.      */
specifier|public
name|ScoreNormaliser
name|getNormaliser
parameter_list|()
block|{
if|if
condition|(
name|scoreNormaliser
operator|==
literal|null
condition|)
block|{
name|initNormaliser
argument_list|()
expr_stmt|;
block|}
return|return
name|scoreNormaliser
return|;
block|}
comment|/**      * The {@link EntityDataIterable} as configured by the {@link IndexingConstants#KEY_ENTITY_DATA_ITERABLE}      * by the main indexing configuration.      * @return the configured {@link EntityDataIterable} or a<code>null</code> if      * this configuration is not present.      */
specifier|public
name|EntityDataIterable
name|getDataIterable
parameter_list|()
block|{
if|if
condition|(
name|entityDataIterable
operator|!=
literal|null
condition|)
block|{
return|return
name|entityDataIterable
return|;
block|}
elseif|else
if|if
condition|(
name|configuration
operator|.
name|containsKey
argument_list|(
name|KEY_ENTITY_DATA_ITERABLE
argument_list|)
condition|)
block|{
name|ConfigEntry
name|config
init|=
name|parseConfigEntry
argument_list|(
name|configuration
operator|.
name|get
argument_list|(
name|KEY_ENTITY_DATA_ITERABLE
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|entityDataIterable
operator|=
operator|(
name|EntityDataIterable
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|config
operator|.
name|getClassName
argument_list|()
argument_list|)
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid EntityDataIterable configuration '"
operator|+
name|config
operator|.
name|getConfigString
argument_list|()
operator|+
literal|"'!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|//add the configuration
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|configMap
init|=
name|getComponentConfig
argument_list|(
name|config
argument_list|,
name|entityDataIterable
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|//add also the directly provided parameters
name|configMap
operator|.
name|putAll
argument_list|(
name|config
operator|.
name|getParams
argument_list|()
argument_list|)
expr_stmt|;
name|entityDataIterable
operator|.
name|setConfiguration
argument_list|(
name|configMap
argument_list|)
expr_stmt|;
return|return
name|entityDataIterable
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|public
name|EntityIterator
name|getEntityIdIterator
parameter_list|()
block|{
if|if
condition|(
name|entityIdIterator
operator|!=
literal|null
condition|)
block|{
return|return
name|entityIdIterator
return|;
block|}
elseif|else
if|if
condition|(
name|configuration
operator|.
name|containsKey
argument_list|(
name|KEY_ENTITY_ID_ITERATOR
argument_list|)
condition|)
block|{
name|ConfigEntry
name|config
init|=
name|parseConfigEntry
argument_list|(
name|configuration
operator|.
name|get
argument_list|(
name|KEY_ENTITY_ID_ITERATOR
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|entityIdIterator
operator|=
operator|(
name|EntityIterator
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|config
operator|.
name|getClassName
argument_list|()
argument_list|)
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid EntityIterator configuration '"
operator|+
name|config
operator|.
name|getConfigString
argument_list|()
operator|+
literal|"'!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|//add the configuration
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|configMap
init|=
name|getComponentConfig
argument_list|(
name|config
argument_list|,
name|entityIdIterator
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|//add also the directly provided parameters
name|configMap
operator|.
name|putAll
argument_list|(
name|config
operator|.
name|getParams
argument_list|()
argument_list|)
expr_stmt|;
name|entityIdIterator
operator|.
name|setConfiguration
argument_list|(
name|configMap
argument_list|)
expr_stmt|;
return|return
name|entityIdIterator
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|public
name|EntityDataProvider
name|getEntityDataProvider
parameter_list|()
block|{
if|if
condition|(
name|entityDataProvider
operator|!=
literal|null
condition|)
block|{
return|return
name|entityDataProvider
return|;
block|}
elseif|else
if|if
condition|(
name|configuration
operator|.
name|containsKey
argument_list|(
name|KEY_ENTITY_DATA_PROVIDER
argument_list|)
condition|)
block|{
name|ConfigEntry
name|config
init|=
name|parseConfigEntry
argument_list|(
name|configuration
operator|.
name|get
argument_list|(
name|KEY_ENTITY_DATA_PROVIDER
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|entityDataProvider
operator|=
operator|(
name|EntityDataProvider
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|config
operator|.
name|getClassName
argument_list|()
argument_list|)
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid EntityDataProvider configuration '"
operator|+
name|config
operator|.
name|getConfigString
argument_list|()
operator|+
literal|"'!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|//add the configuration
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|configMap
init|=
name|getComponentConfig
argument_list|(
name|config
argument_list|,
name|entityDataProvider
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|//add also the directly provided parameters
name|configMap
operator|.
name|putAll
argument_list|(
name|config
operator|.
name|getParams
argument_list|()
argument_list|)
expr_stmt|;
name|entityDataProvider
operator|.
name|setConfiguration
argument_list|(
name|configMap
argument_list|)
expr_stmt|;
return|return
name|entityDataProvider
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|public
name|EntityScoreProvider
name|getEntityScoreProvider
parameter_list|()
block|{
if|if
condition|(
name|entityScoreProvider
operator|!=
literal|null
condition|)
block|{
return|return
name|entityScoreProvider
return|;
block|}
elseif|else
if|if
condition|(
name|configuration
operator|.
name|containsKey
argument_list|(
name|KEY_ENTITY_SCORE_PROVIDER
argument_list|)
condition|)
block|{
name|ConfigEntry
name|config
init|=
name|parseConfigEntry
argument_list|(
name|configuration
operator|.
name|get
argument_list|(
name|KEY_ENTITY_SCORE_PROVIDER
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|entityScoreProvider
operator|=
operator|(
name|EntityScoreProvider
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|config
operator|.
name|getClassName
argument_list|()
argument_list|)
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid EntityScoreProvider configuration '"
operator|+
name|config
operator|.
name|getConfigString
argument_list|()
operator|+
literal|"'!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|//add the configuration
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|configMap
init|=
name|getComponentConfig
argument_list|(
name|config
argument_list|,
name|entityScoreProvider
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|//add also the directly provided parameters
name|configMap
operator|.
name|putAll
argument_list|(
name|config
operator|.
name|getParams
argument_list|()
argument_list|)
expr_stmt|;
name|entityScoreProvider
operator|.
name|setConfiguration
argument_list|(
name|configMap
argument_list|)
expr_stmt|;
return|return
name|entityScoreProvider
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**      * The fields and languages included/excluded in the created index.<p>      * NOTE: Currently this uses the {@link FieldMapping} class was initially      * defined to be used as configuration for the {@link FieldMapper}. In      * future this might change to an Interface that is more tailored to      * defining the fields and languages included/excluded in the index and does      * not allow to define mappings and data type conversions as the current one      * @return      */
specifier|public
name|Collection
argument_list|<
name|FieldMapping
argument_list|>
name|getIndexFieldConfiguration
parameter_list|()
block|{
return|return
name|fieldMappings
return|;
block|}
comment|/**      * Getter for the list of {@link EntityProcessor}s or<code>null</code> if      * none are configured.      * @return      */
specifier|public
name|List
argument_list|<
name|EntityProcessor
argument_list|>
name|getEntityProcessors
parameter_list|()
block|{
if|if
condition|(
name|entityProcessor
operator|!=
literal|null
condition|)
block|{
return|return
name|entityProcessor
return|;
block|}
elseif|else
if|if
condition|(
name|configuration
operator|.
name|containsKey
argument_list|(
name|KEY_ENTITY_PROCESSOR
argument_list|)
condition|)
block|{
name|List
argument_list|<
name|ConfigEntry
argument_list|>
name|configs
init|=
name|parseConfigEntries
argument_list|(
name|configuration
operator|.
name|get
argument_list|(
name|KEY_ENTITY_PROCESSOR
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|EntityProcessor
argument_list|>
name|processorList
init|=
operator|new
name|ArrayList
argument_list|<
name|EntityProcessor
argument_list|>
argument_list|(
name|configs
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|ConfigEntry
name|config
range|:
name|configs
control|)
block|{
name|EntityProcessor
name|processor
decl_stmt|;
try|try
block|{
name|processor
operator|=
operator|(
name|EntityProcessor
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|config
operator|.
name|getClassName
argument_list|()
argument_list|)
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid EntityProcessor configuration '"
operator|+
name|config
operator|.
name|getConfigString
argument_list|()
operator|+
literal|"'!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|//add the configuration
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|configMap
init|=
name|getComponentConfig
argument_list|(
name|config
argument_list|,
name|processor
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|//add also the directly provided parameters
name|configMap
operator|.
name|putAll
argument_list|(
name|config
operator|.
name|getParams
argument_list|()
argument_list|)
expr_stmt|;
name|processor
operator|.
name|setConfiguration
argument_list|(
name|configMap
argument_list|)
expr_stmt|;
name|processorList
operator|.
name|add
argument_list|(
name|processor
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|processorList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//do not set empty lists
name|entityProcessor
operator|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|processorList
argument_list|)
expr_stmt|;
block|}
return|return
name|entityProcessor
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Getter for the {@link EntityProcessor}s configured to be used for      * post-processing or<code>null</code> if none.      * @return      */
specifier|public
name|List
argument_list|<
name|EntityProcessor
argument_list|>
name|getEntityPostProcessors
parameter_list|()
block|{
if|if
condition|(
name|entityPostProcessor
operator|!=
literal|null
condition|)
block|{
return|return
name|entityPostProcessor
return|;
block|}
elseif|else
if|if
condition|(
name|configuration
operator|.
name|containsKey
argument_list|(
name|KEY_ENTITY_POST_PROCESSOR
argument_list|)
condition|)
block|{
name|List
argument_list|<
name|ConfigEntry
argument_list|>
name|configs
init|=
name|parseConfigEntries
argument_list|(
name|configuration
operator|.
name|get
argument_list|(
name|KEY_ENTITY_POST_PROCESSOR
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|EntityProcessor
argument_list|>
name|postProcessorList
init|=
operator|new
name|ArrayList
argument_list|<
name|EntityProcessor
argument_list|>
argument_list|(
name|configs
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|ConfigEntry
name|config
range|:
name|configs
control|)
block|{
name|EntityProcessor
name|postProcessor
decl_stmt|;
try|try
block|{
name|postProcessor
operator|=
operator|(
name|EntityProcessor
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|config
operator|.
name|getClassName
argument_list|()
argument_list|)
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid EntityProcessor configuration '"
operator|+
name|config
operator|.
name|getConfigString
argument_list|()
operator|+
literal|"' for post-processing!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|//add the configuration
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|configMap
init|=
name|getComponentConfig
argument_list|(
name|config
argument_list|,
name|postProcessor
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|//add also the directly provided parameters
name|configMap
operator|.
name|putAll
argument_list|(
name|config
operator|.
name|getParams
argument_list|()
argument_list|)
expr_stmt|;
name|postProcessor
operator|.
name|setConfiguration
argument_list|(
name|configMap
argument_list|)
expr_stmt|;
name|postProcessorList
operator|.
name|add
argument_list|(
name|postProcessor
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|postProcessorList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//do not set empty lists
name|entityPostProcessor
operator|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|postProcessorList
argument_list|)
expr_stmt|;
block|}
return|return
name|entityPostProcessor
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|public
name|IndexingDestination
name|getIndexingDestination
parameter_list|()
block|{
if|if
condition|(
name|indexingDestination
operator|!=
literal|null
condition|)
block|{
return|return
name|indexingDestination
return|;
block|}
elseif|else
if|if
condition|(
name|configuration
operator|.
name|containsKey
argument_list|(
name|KEY_INDEXING_DESTINATION
argument_list|)
condition|)
block|{
name|ConfigEntry
name|config
init|=
name|parseConfigEntry
argument_list|(
name|configuration
operator|.
name|get
argument_list|(
name|KEY_INDEXING_DESTINATION
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|indexingDestination
operator|=
operator|(
name|IndexingDestination
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|config
operator|.
name|getClassName
argument_list|()
argument_list|)
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid IndexingDestination configuration '"
operator|+
name|config
operator|.
name|getConfigString
argument_list|()
operator|+
literal|"'!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|//add the configuration
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|configMap
init|=
name|getComponentConfig
argument_list|(
name|config
argument_list|,
name|indexingDestination
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|//add also the directly provided parameters
name|configMap
operator|.
name|putAll
argument_list|(
name|config
operator|.
name|getParams
argument_list|()
argument_list|)
expr_stmt|;
name|indexingDestination
operator|.
name|setConfiguration
argument_list|(
name|configMap
argument_list|)
expr_stmt|;
return|return
name|indexingDestination
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|public
name|File
name|getIndexedEntitiesIdsFile
parameter_list|()
block|{
name|Object
name|value
init|=
name|configuration
operator|.
name|get
argument_list|(
name|IndexingConstants
operator|.
name|KEX_INDEXED_ENTITIES_FILE
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|File
argument_list|(
name|getDestinationFolder
argument_list|()
argument_list|,
name|DEFAULT_INDEXED_ENTITIES_ID_FILE_NAME
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|.
name|toString
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
comment|//deactivate this feature;
block|}
else|else
block|{
return|return
operator|new
name|File
argument_list|(
name|getDestinationFolder
argument_list|()
argument_list|,
name|value
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
block|}
specifier|private
name|void
name|initNormaliser
parameter_list|()
block|{
name|Object
name|value
init|=
name|configuration
operator|.
name|get
argument_list|(
name|IndexingConstants
operator|.
name|KEY_SCORE_NORMALIZER
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|scoreNormaliser
operator|=
operator|new
name|DefaultNormaliser
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ScoreNormaliser
name|normaliser
init|=
literal|null
decl_stmt|;
name|ScoreNormaliser
name|last
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|ConfigEntry
argument_list|>
name|configs
init|=
name|parseConfigEntries
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|configs
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|last
operator|=
name|normaliser
expr_stmt|;
name|normaliser
operator|=
literal|null
expr_stmt|;
name|ConfigEntry
name|config
init|=
name|configs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
try|try
block|{
name|normaliser
operator|=
operator|(
name|ScoreNormaliser
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|config
operator|.
name|getClassName
argument_list|()
argument_list|)
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid Normaliser configuration '"
operator|+
name|config
operator|.
name|getConfigString
argument_list|()
operator|+
literal|"'!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|normaliserConfig
init|=
name|getComponentConfig
argument_list|(
name|config
argument_list|,
name|normaliser
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|,
name|config
operator|.
name|getParams
argument_list|()
operator|.
name|containsKey
argument_list|(
name|CONFIG_PARAM
argument_list|)
argument_list|)
decl_stmt|;
comment|//add also the directly provided parameters
name|normaliserConfig
operator|.
name|putAll
argument_list|(
name|config
operator|.
name|getParams
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|!=
literal|null
condition|)
block|{
name|normaliserConfig
operator|.
name|put
argument_list|(
name|ScoreNormaliser
operator|.
name|CHAINED_SCORE_NORMALISER
argument_list|,
name|last
argument_list|)
expr_stmt|;
block|}
name|normaliser
operator|.
name|setConfiguration
argument_list|(
name|normaliserConfig
argument_list|)
expr_stmt|;
block|}
comment|//set the normaliser!
name|this
operator|.
name|scoreNormaliser
operator|=
name|normaliser
expr_stmt|;
block|}
block|}
comment|/**      * Loads a configuration based on the value of the {@link #CONFIG_PARAM}      * parameter of the parsed {@link ConfigEntry}.      * @param configEntry      * @param defaultName      * @return      */
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|getComponentConfig
parameter_list|(
name|ConfigEntry
name|configEntry
parameter_list|,
name|String
name|defaultName
parameter_list|,
name|boolean
name|required
parameter_list|)
block|{
comment|//Removed support for parsing the relative path to the config file
comment|//because it was not used! (String relConfigPath was the first param)
comment|//        File configDir;
comment|//        if(relConfigPath == null || relConfigPath.isEmpty()){
comment|//            configDir = this.configDir;
comment|//        } else {
comment|//            configDir = new File(this.configDir,relConfigPath);
comment|//        }
comment|//        //test also if relConfigPath = null, because also the root might not exist!
comment|//        if(!configDir.isDirectory()){
comment|//            if(required){
comment|//                throw new IllegalArgumentException("The Configuration Directory '"+
comment|//                    configDir+"' does not exist (or ist not a directory)!");
comment|//            } else {
comment|//                return new HashMap<String,Object>();
comment|//            }
comment|//        }
comment|//if the CONFIG_PARAM is present in the config we assume that a config is required
name|String
name|name
init|=
name|configEntry
operator|.
name|getParams
argument_list|()
operator|.
name|get
argument_list|(
name|CONFIG_PARAM
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|config
init|=
name|loadConfigFile
argument_list|(
name|name
operator|==
literal|null
condition|?
name|defaultName
else|:
name|name
argument_list|,
name|required
argument_list|)
decl_stmt|;
comment|//we need to also add the key used to get (this) indexing config
name|config
operator|.
name|put
argument_list|(
name|KEY_INDEXING_CONFIG
argument_list|,
name|this
argument_list|)
expr_stmt|;
return|return
name|config
return|;
block|}
comment|/**      * Loads the config with the given name from the parsed directory and throwing      * an {@link IllegalArgumentException} if the configuration is required but      * not found      * @param name the name (".properties" is appended if missing)      * @param configDir the directory to look for the config      * @param required if this config is required or optional      * @return the key value mappings as map      */
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|loadConfigFile
parameter_list|(
name|String
name|name
parameter_list|,
name|boolean
name|required
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|loadedConfig
decl_stmt|;
name|name
operator|=
name|name
operator|.
name|endsWith
argument_list|(
literal|".properties"
argument_list|)
condition|?
name|name
else|:
name|name
operator|+
literal|".properties"
expr_stmt|;
name|loadedConfig
operator|=
name|loadConfig
argument_list|(
name|name
argument_list|,
name|required
argument_list|)
expr_stmt|;
return|return
name|loadedConfig
return|;
block|}
specifier|private
name|ConfigEntry
name|parseConfigEntry
parameter_list|(
name|String
name|config
parameter_list|)
block|{
return|return
operator|new
name|ConfigEntry
argument_list|(
name|config
argument_list|)
return|;
block|}
specifier|private
name|List
argument_list|<
name|ConfigEntry
argument_list|>
name|parseConfigEntries
parameter_list|(
name|String
name|config
parameter_list|)
block|{
name|List
argument_list|<
name|ConfigEntry
argument_list|>
name|configs
init|=
operator|new
name|ArrayList
argument_list|<
name|ConfigEntry
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|configPart
range|:
name|config
operator|.
name|split
argument_list|(
literal|";"
argument_list|)
control|)
block|{
name|configs
operator|.
name|add
argument_list|(
name|parseConfigEntry
argument_list|(
name|configPart
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|configs
return|;
block|}
specifier|private
specifier|final
class|class
name|ConfigEntry
block|{
specifier|private
name|String
name|configString
decl_stmt|;
specifier|private
name|String
name|className
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|params
decl_stmt|;
specifier|private
name|ConfigEntry
parameter_list|(
name|String
name|config
parameter_list|)
block|{
name|configString
operator|=
name|config
expr_stmt|;
name|String
index|[]
name|parts
init|=
name|config
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
name|className
operator|=
name|parts
index|[
literal|0
index|]
expr_stmt|;
name|params
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
expr_stmt|;
if|if
condition|(
name|parts
operator|.
name|length
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|parts
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
index|[]
name|param
init|=
name|parts
index|[
name|i
index|]
operator|.
name|split
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
comment|//TODO: maybe use also "=" there
name|String
name|value
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|param
operator|.
name|length
operator|>
literal|1
condition|)
block|{
name|value
operator|=
name|parts
index|[
name|i
index|]
operator|.
name|substring
argument_list|(
name|parts
index|[
name|i
index|]
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|params
operator|.
name|put
argument_list|(
name|param
index|[
literal|0
index|]
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
specifier|final
name|String
name|getConfigString
parameter_list|()
block|{
return|return
name|configString
return|;
block|}
specifier|public
specifier|final
name|String
name|getClassName
parameter_list|()
block|{
return|return
name|className
return|;
block|}
specifier|public
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getParams
parameter_list|()
block|{
return|return
name|params
return|;
block|}
block|}
comment|/**      * Can be used to look for a config within the configuration directory      * of the {@link IndexingConfig}.      * @param string the name of the configuration (".properties" is appended if      * missing)      * @param required if this is an required or optional configuration.      * @return the key value mappings as map      * @throws IllegalArgumentException if the configuration was not found and      *<code>true</code> was parsed for required      */
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|getConfig
parameter_list|(
name|String
name|name
parameter_list|,
name|boolean
name|required
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
return|return
name|loadConfigFile
argument_list|(
name|name
argument_list|,
name|required
argument_list|)
return|;
block|}
comment|/**      * Getter for configured properties directly by the key. Typically used      * to get Properties as defined by the {@link SiteConfiguration} interface      * @param key the key of the property      * @return the value or<code>null</code> if not present. Might also return      *<code>null</code> in case the value<code>null</code> is set for the      * requested property.      */
specifier|public
name|Object
name|getProperty
parameter_list|(
name|String
name|key
parameter_list|)
block|{
return|return
name|configuration
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
block|}
end_class

end_unit

