begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|source
operator|.
name|jenatdb
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|core
operator|.
name|model
operator|.
name|InMemoryValueFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|EntityDataIterable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|EntityDataIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|EntityDataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|IndexingComponent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|config
operator|.
name|IndexingConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|source
operator|.
name|ResourceLoader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|source
operator|.
name|ResourceState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Reference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Representation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|ValueFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|datatypes
operator|.
name|BaseDatatype
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|datatypes
operator|.
name|DatatypeFormatException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|datatypes
operator|.
name|RDFDatatype
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|datatypes
operator|.
name|xsd
operator|.
name|XSDDateTime
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|datatypes
operator|.
name|xsd
operator|.
name|XSDDuration
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|graph
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|graph
operator|.
name|Triple
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|graph
operator|.
name|impl
operator|.
name|LiteralLabel
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|query
operator|.
name|Query
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|query
operator|.
name|QueryExecutionFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|query
operator|.
name|QueryFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|query
operator|.
name|QuerySolution
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|query
operator|.
name|ResultSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|query
operator|.
name|Syntax
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|rdf
operator|.
name|model
operator|.
name|RDFNode
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|sparql
operator|.
name|core
operator|.
name|Var
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|sparql
operator|.
name|engine
operator|.
name|binding
operator|.
name|Binding
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|tdb
operator|.
name|TDBFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|tdb
operator|.
name|base
operator|.
name|file
operator|.
name|Location
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|tdb
operator|.
name|store
operator|.
name|DatasetGraphTDB
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|util
operator|.
name|iterator
operator|.
name|ExtendedIterator
import|;
end_import

begin_comment
comment|/**  * Implementation of an {@link IndexingComponent} for Entity data that provides   * the possibility to both:<ol>  *<li>randomly access entity data via the {@link EntityDataProvider} interface  *<li>iterate over all entities in this store via the {@link EntityDataIterator}  * interface.  *</ol>  *   * @author Rupert Westenthaler  *  */
end_comment

begin_class
specifier|public
class|class
name|RdfIndexingSource
implements|implements
name|EntityDataIterable
implements|,
name|EntityDataProvider
block|{
comment|/**      * The Parameter used to configure the source folder(s) relative to the      * {@link IndexingConfig#getSourceFolder()}. The ',' (comma) is used as      * separator to parsed multiple sources.      */
specifier|public
specifier|static
specifier|final
name|String
name|PARAM_SOURCE_FILE_OR_FOLDER
init|=
literal|"source"
decl_stmt|;
comment|/**      * Parameter used to configure the name of the directory used to store the      * RDF model (a Jena TDB dataset). The default name is      * {@link #DEFAULT_MODEL_DIRECTORY}      */
specifier|public
specifier|static
specifier|final
name|String
name|PARAM_MODEL_DIRECTORY
init|=
literal|"model"
decl_stmt|;
comment|/**      * The Parameter that can be used to deactivate the importing of sources.      * If this parameter is set to<code>false</code> the values configured for      * {@link #PARAM_IMPORT_SOURCE} are ignored. The default value is      *<code>true</code>      */
specifier|public
specifier|static
specifier|final
name|String
name|PARAM_IMPORT_SOURCE
init|=
literal|"import"
decl_stmt|;
comment|/**      * The default directory name used to search for RDF files to be imported      */
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_SOURCE_FOLDER_NAME
init|=
literal|"rdf"
decl_stmt|;
comment|/**      * The default name of the folder used to initialise the       * {@link DatasetGraphTDB Jena TDB dataset}.      */
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_MODEL_DIRECTORY
init|=
literal|"tdb"
decl_stmt|;
comment|//protected to allow internal classes direct access (without hidden getter/
comment|//setter added by the compiler that decrease performance)
specifier|protected
specifier|final
specifier|static
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|RdfIndexingSource
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * The RDF data      */
specifier|private
name|DatasetGraphTDB
name|indexingDataset
decl_stmt|;
comment|/**      * The valueFactory used to create {@link Representation}s, {@link Reference}s      * and {@link Text} instances.      */
specifier|private
name|ValueFactory
name|vf
decl_stmt|;
specifier|private
name|ResourceLoader
name|loader
decl_stmt|;
comment|/**      * Default Constructor relaying on that {@link #setConfiguration(Map)} is      * called afterwards to provide the configuration!      */
specifier|public
name|RdfIndexingSource
parameter_list|()
block|{
name|this
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Internally used to initialise a {@link ValueFactory}      * @param valueFactory      */
specifier|private
name|RdfIndexingSource
parameter_list|(
name|ValueFactory
name|valueFactory
parameter_list|)
block|{
if|if
condition|(
name|valueFactory
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|vf
operator|=
name|InMemoryValueFactory
operator|.
name|getInstance
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|vf
operator|=
name|valueFactory
expr_stmt|;
block|}
block|}
comment|/**      * Constructs an instance based on the provided parameter      * @param modelLocation the directory for the RDF model. MUST NOT be NULL      * however the parsed {@link File} needs not to exist.      * @param sourceFileOrDirectory the source file or directory containing the      * file(s) to import. Parse<code>null</code> if no RDF files need to be       * imported      * @param valueFactory The {@link ValueFactory} used to create instances      * or<code>null</code> to use the default implementation.      */
specifier|public
name|RdfIndexingSource
parameter_list|(
name|File
name|modelLocation
parameter_list|,
name|File
name|sourceFileOrDirectory
parameter_list|,
name|ValueFactory
name|valueFactory
parameter_list|)
block|{
if|if
condition|(
name|modelLocation
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed model location MUST NOT be NULL!"
argument_list|)
throw|;
block|}
comment|//init the store
name|this
operator|.
name|indexingDataset
operator|=
name|createRdfModel
argument_list|(
name|modelLocation
argument_list|)
expr_stmt|;
name|this
operator|.
name|loader
operator|=
operator|new
name|ResourceLoader
argument_list|(
operator|new
name|RdfResourceImporter
argument_list|(
name|indexingDataset
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|loader
operator|.
name|addResource
argument_list|(
name|sourceFileOrDirectory
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setConfiguration
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|config
parameter_list|)
block|{
name|IndexingConfig
name|indexingConfig
init|=
operator|(
name|IndexingConfig
operator|)
name|config
operator|.
name|get
argument_list|(
name|IndexingConfig
operator|.
name|KEY_INDEXING_CONFIG
argument_list|)
decl_stmt|;
comment|//first init the RDF Model
name|Object
name|value
init|=
name|config
operator|.
name|get
argument_list|(
name|PARAM_MODEL_DIRECTORY
argument_list|)
decl_stmt|;
name|File
name|modelLocation
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|modelLocation
operator|=
operator|new
name|File
argument_list|(
name|indexingConfig
operator|.
name|getSourceFolder
argument_list|()
argument_list|,
name|DEFAULT_MODEL_DIRECTORY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|modelLocation
operator|=
operator|new
name|File
argument_list|(
name|indexingConfig
operator|.
name|getSourceFolder
argument_list|()
argument_list|,
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|indexingDataset
operator|=
name|createRdfModel
argument_list|(
name|modelLocation
argument_list|)
expr_stmt|;
comment|//second we need to check if we need to import RDF files to the RDF model
comment|//create the ResourceLoader
name|this
operator|.
name|loader
operator|=
operator|new
name|ResourceLoader
argument_list|(
operator|new
name|RdfResourceImporter
argument_list|(
name|indexingDataset
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|//check if importing is deactivated
name|boolean
name|importSource
init|=
literal|true
decl_stmt|;
comment|//default is true
name|value
operator|=
name|config
operator|.
name|get
argument_list|(
name|PARAM_IMPORT_SOURCE
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|importSource
operator|=
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|importSource
condition|)
block|{
comment|// if we need to import ... check the source config
name|log
operator|.
name|info
argument_list|(
literal|"Importing RDF data from:"
argument_list|)
expr_stmt|;
name|value
operator|=
name|config
operator|.
name|get
argument_list|(
name|PARAM_SOURCE_FILE_OR_FOLDER
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
comment|//if not set use the default
name|value
operator|=
name|DEFAULT_SOURCE_FOLDER_NAME
expr_stmt|;
block|}
for|for
control|(
name|String
name|source
range|:
name|value
operator|.
name|toString
argument_list|()
operator|.
name|split
argument_list|(
literal|","
argument_list|)
control|)
block|{
name|File
name|sourceFileOrDirectory
init|=
name|indexingConfig
operator|.
name|getSourceFile
argument_list|(
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|sourceFileOrDirectory
operator|.
name|exists
argument_list|()
condition|)
block|{
comment|//register the configured source with the ResourceLoader
name|this
operator|.
name|loader
operator|.
name|addResource
argument_list|(
name|sourceFileOrDirectory
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to find RDF source {} within the indexing Source folder "
argument_list|,
name|source
argument_list|,
name|indexingConfig
operator|.
name|getSourceFolder
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|log
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
for|for
control|(
name|String
name|registeredSource
range|:
name|loader
operator|.
name|getResources
argument_list|(
name|ResourceState
operator|.
name|REGISTERED
argument_list|)
control|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"> "
operator|+
name|registeredSource
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Importing RDF data deactivated by parameer {}={}"
operator|+
name|PARAM_IMPORT_SOURCE
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * @param modelLocation      */
specifier|private
name|DatasetGraphTDB
name|createRdfModel
parameter_list|(
name|File
name|modelLocation
parameter_list|)
block|{
if|if
condition|(
name|modelLocation
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|modelLocation
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The configured RDF model directory "
operator|+
name|modelLocation
operator|+
literal|"exists but is not a Directory"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
operator|!
name|modelLocation
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|modelLocation
operator|.
name|mkdirs
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unable to create the configured RDF model directory "
operator|+
name|modelLocation
operator|+
literal|"!"
argument_list|)
throw|;
block|}
block|}
name|Location
name|location
init|=
operator|new
name|Location
argument_list|(
name|modelLocation
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|TDBFactory
operator|.
name|createDatasetGraph
argument_list|(
name|location
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|needsInitialisation
parameter_list|()
block|{
comment|//if there are resources with the state REGISTERED we need an initialisation
return|return
operator|!
name|loader
operator|.
name|getResources
argument_list|(
name|ResourceState
operator|.
name|REGISTERED
argument_list|)
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|initialise
parameter_list|()
block|{
name|loader
operator|.
name|loadResources
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
block|{
name|loader
operator|=
literal|null
expr_stmt|;
name|indexingDataset
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|EntityDataIterator
name|entityDataIterator
parameter_list|()
block|{
name|String
name|enityVar
init|=
literal|"s"
decl_stmt|;
name|String
name|fieldVar
init|=
literal|"p"
decl_stmt|;
name|String
name|valueVar
init|=
literal|"o"
decl_stmt|;
name|StringBuilder
name|qb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|qb
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"SELECT ?%s ?%s ?%s \n"
argument_list|,
name|enityVar
argument_list|,
name|fieldVar
argument_list|,
name|valueVar
argument_list|)
argument_list|)
expr_stmt|;
comment|//for the select
name|qb
operator|.
name|append
argument_list|(
literal|"{ \n"
argument_list|)
expr_stmt|;
name|qb
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"    ?%s ?%s ?%s . \n"
argument_list|,
name|enityVar
argument_list|,
name|fieldVar
argument_list|,
name|valueVar
argument_list|)
argument_list|)
expr_stmt|;
comment|//for the where
name|qb
operator|.
name|append
argument_list|(
literal|"} \n"
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"EntityDataIterator Query: \n"
operator|+
name|qb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|Query
name|q
init|=
name|QueryFactory
operator|.
name|create
argument_list|(
name|qb
operator|.
name|toString
argument_list|()
argument_list|,
name|Syntax
operator|.
name|syntaxARQ
argument_list|)
decl_stmt|;
return|return
operator|new
name|RdfEntityIterator
argument_list|(
name|QueryExecutionFactory
operator|.
name|create
argument_list|(
name|q
argument_list|,
name|indexingDataset
operator|.
name|toDataset
argument_list|()
argument_list|)
operator|.
name|execSelect
argument_list|()
argument_list|,
name|enityVar
argument_list|,
name|fieldVar
argument_list|,
name|valueVar
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Representation
name|getEntityData
parameter_list|(
name|String
name|id
parameter_list|)
block|{
name|Node
name|resource
init|=
name|Node
operator|.
name|createURI
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|Representation
name|source
init|=
name|vf
operator|.
name|createRepresentation
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|ExtendedIterator
argument_list|<
name|Triple
argument_list|>
name|outgoing
init|=
name|indexingDataset
operator|.
name|getDefaultGraph
argument_list|()
operator|.
name|find
argument_list|(
name|resource
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|boolean
name|found
init|=
name|outgoing
operator|.
name|hasNext
argument_list|()
decl_stmt|;
while|while
condition|(
name|outgoing
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|//iterate over the statements for that resource
name|Triple
name|statement
init|=
name|outgoing
operator|.
name|next
argument_list|()
decl_stmt|;
name|Node
name|predicate
init|=
name|statement
operator|.
name|getPredicate
argument_list|()
decl_stmt|;
if|if
condition|(
name|predicate
operator|==
literal|null
operator|||
operator|!
name|predicate
operator|.
name|isURI
argument_list|()
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Ignore field {} for resource {} because it is null or not an URI!"
argument_list|,
name|predicate
argument_list|,
name|resource
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|field
init|=
name|predicate
operator|.
name|getURI
argument_list|()
decl_stmt|;
name|Node
name|value
init|=
name|statement
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|processValue
argument_list|(
name|value
argument_list|,
name|source
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
comment|//end else predicate != null
block|}
comment|//end iteration over resource triple
if|if
condition|(
name|found
condition|)
block|{
return|return
name|source
return|;
comment|//log.info("Resource: \n"+ModelUtils.getRepresentationInfo(source));
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"No Statements found for Entity {}!"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Processes a {@link Node} and adds the according value to the parsed      * Representation.      * @param value The node to convert to an value for the Representation      * @param source the representation (MUST NOT be<code>null</code>      * @param field the field (MUST NOT be<code>null</code>)      */
specifier|private
name|void
name|processValue
parameter_list|(
name|Node
name|value
parameter_list|,
name|Representation
name|source
parameter_list|,
name|String
name|field
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Encountered NULL value for field {} and entity {}"
argument_list|,
name|field
argument_list|,
name|source
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|.
name|isURI
argument_list|()
condition|)
block|{
comment|//add a reference
name|source
operator|.
name|addReference
argument_list|(
name|field
argument_list|,
name|value
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|.
name|isLiteral
argument_list|()
condition|)
block|{
comment|//add a value or a text depending on the dataType
name|LiteralLabel
name|ll
init|=
name|value
operator|.
name|getLiteral
argument_list|()
decl_stmt|;
comment|//            log.debug("LL: lexical {} | value {} | dataType {} | language {}",
comment|//                new Object[]{ll.getLexicalForm(),ll.getValue(),ll.getDatatype(),ll.language()});
comment|//if the dataType == null , than we can expect a plain literal
name|RDFDatatype
name|dataType
init|=
name|ll
operator|.
name|getDatatype
argument_list|()
decl_stmt|;
if|if
condition|(
name|dataType
operator|!=
literal|null
condition|)
block|{
comment|//add a value
name|Object
name|literalValue
decl_stmt|;
try|try
block|{
name|literalValue
operator|=
name|ll
operator|.
name|getValue
argument_list|()
expr_stmt|;
if|if
condition|(
name|literalValue
operator|instanceof
name|BaseDatatype
operator|.
name|TypedValue
condition|)
block|{
comment|//used for unknown data types
comment|// -> in such cases yust use the lecial type
name|String
name|lexicalValue
init|=
operator|(
operator|(
name|BaseDatatype
operator|.
name|TypedValue
operator|)
name|literalValue
operator|)
operator|.
name|lexicalValue
decl_stmt|;
if|if
condition|(
name|lexicalValue
operator|!=
literal|null
operator|&&
operator|!
name|lexicalValue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|source
operator|.
name|add
argument_list|(
name|field
argument_list|,
name|lexicalValue
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|literalValue
operator|instanceof
name|XSDDateTime
condition|)
block|{
name|source
operator|.
name|add
argument_list|(
name|field
argument_list|,
operator|(
operator|(
name|XSDDateTime
operator|)
name|literalValue
operator|)
operator|.
name|asCalendar
argument_list|()
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
comment|//Entityhub uses the time
block|}
elseif|else
if|if
condition|(
name|literalValue
operator|instanceof
name|XSDDuration
condition|)
block|{
name|String
name|duration
init|=
name|literalValue
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|duration
operator|!=
literal|null
operator|&&
operator|!
name|duration
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|source
operator|.
name|add
argument_list|(
name|field
argument_list|,
name|literalValue
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|source
operator|.
name|add
argument_list|(
name|field
argument_list|,
name|literalValue
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|DatatypeFormatException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|" Unable to convert {} to {} -> use lecicalForm"
argument_list|,
name|ll
operator|.
name|getLexicalForm
argument_list|()
argument_list|,
name|ll
operator|.
name|getDatatype
argument_list|()
argument_list|)
expr_stmt|;
name|literalValue
operator|=
name|ll
operator|.
name|getLexicalForm
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//add a text
name|String
name|lexicalForm
init|=
name|ll
operator|.
name|getLexicalForm
argument_list|()
decl_stmt|;
if|if
condition|(
name|lexicalForm
operator|!=
literal|null
operator|&&
operator|!
name|lexicalForm
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|String
name|language
init|=
name|ll
operator|.
name|language
argument_list|()
decl_stmt|;
if|if
condition|(
name|language
operator|!=
literal|null
operator|&&
name|language
operator|.
name|length
argument_list|()
operator|<
literal|1
condition|)
block|{
name|language
operator|=
literal|null
expr_stmt|;
block|}
name|source
operator|.
name|addNaturalText
argument_list|(
name|field
argument_list|,
name|lexicalForm
argument_list|,
name|language
argument_list|)
expr_stmt|;
block|}
comment|//else ignore empty literals
block|}
comment|// "" is parsed if there is no language
block|}
else|else
block|{
if|if
condition|(
name|value
operator|.
name|isBlank
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"ignoreing blank node value {} for field {} and Resource {}!"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|value
block|,
name|field
block|,
name|source
operator|.
name|getId
argument_list|()
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"ignoreing value {} for field {} and Resource {} because it is of an unsupported type!"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|value
block|,
name|field
block|,
name|source
operator|.
name|getId
argument_list|()
block|}
argument_list|)
expr_stmt|;
block|}
block|}
comment|//end different value node type
block|}
comment|/**      * Implementation of the iterator over the entities stored in a      * {@link RdfIndexingSource}. This Iterator is based on query      * {@link ResultSet}. It uses the low level SPARQL API because this allows      * to use the same code to create values for Representations      * @author Rupert Westenthaler      *      */
specifier|public
specifier|final
class|class
name|RdfEntityIterator
implements|implements
name|EntityDataIterator
block|{
comment|/**          * Variable used to          */
specifier|final
name|Var
name|entityVar
decl_stmt|;
specifier|final
name|Var
name|fieldVar
decl_stmt|;
specifier|final
name|Var
name|valueVar
decl_stmt|;
comment|/**          * The result set containing all triples in the form of<code>          * "entity -&gt; field -&gt; value"</code>          */
specifier|private
specifier|final
name|ResultSet
name|resultSet
decl_stmt|;
comment|/**          * The {@link Node} representing the current entity or<code>null</code>          * if the iterator is newly created.<p>          * {@link Node#isURI()} is guaranteed to return<code>true</code> and          * {@link Node#getURI()} is guaranteed to return the id for the entity          */
specifier|private
name|Node
name|currentEntity
init|=
literal|null
decl_stmt|;
comment|/**          * The {@link Node} for the next Entity in the iteration or<code>null</code>          * in case there are no further or the iterator is newly created (in that          * case {@link #currentEntity} will be also<code>null</code>)<p>          * {@link Node#isURI()} is guaranteed to return<code>true</code> and          * {@link Node#getURI()} is guaranteed to return the id for the entity          */
specifier|private
name|Node
name|nextEntity
init|=
literal|null
decl_stmt|;
comment|/**          * The Representation of the current Element. Only available after a          * call to {@link #getRepresentation()}          */
specifier|private
name|Representation
name|currentRepresentation
init|=
literal|null
decl_stmt|;
comment|/**          * Holds all<code>field,value"</code> pairs of the current Entity.          * Elements at even positions represent<code>fields</code> and elements           * at uneven positions represent<code>values</code>.          */
specifier|private
name|List
argument_list|<
name|Node
argument_list|>
name|data
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
comment|/**          * The next (not consumed) solution of the query.           */
specifier|private
name|Binding
name|nextBinding
init|=
literal|null
decl_stmt|;
specifier|protected
name|RdfEntityIterator
parameter_list|(
name|ResultSet
name|resultSet
parameter_list|,
name|String
name|entityVar
parameter_list|,
name|String
name|fieldVar
parameter_list|,
name|String
name|valueVar
parameter_list|)
block|{
if|if
condition|(
name|resultSet
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed ResultSet MUST NOT be NULL!"
argument_list|)
throw|;
block|}
comment|//check if the ResultSet provides the required variables to perform the query
name|List
argument_list|<
name|String
argument_list|>
name|vars
init|=
name|resultSet
operator|.
name|getResultVars
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|vars
operator|.
name|contains
argument_list|(
name|entityVar
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed ResultSet is missing the required"
operator|+
literal|"Variable \""
operator|+
name|entityVar
operator|+
literal|"\" representing the Entity!"
argument_list|)
throw|;
block|}
else|else
block|{
name|this
operator|.
name|entityVar
operator|=
name|Var
operator|.
name|alloc
argument_list|(
name|entityVar
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|vars
operator|.
name|contains
argument_list|(
name|fieldVar
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed ResultSet is missing the required"
operator|+
literal|"Variable \""
operator|+
name|fieldVar
operator|+
literal|"\" representing the Field of an Entity!"
argument_list|)
throw|;
block|}
else|else
block|{
name|this
operator|.
name|fieldVar
operator|=
name|Var
operator|.
name|alloc
argument_list|(
name|fieldVar
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|vars
operator|.
name|contains
argument_list|(
name|valueVar
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed ResultSet is missing the required"
operator|+
literal|"Variable \""
operator|+
name|valueVar
operator|+
literal|"\" representing the Value of a Field of an Entity!"
argument_list|)
throw|;
block|}
else|else
block|{
name|this
operator|.
name|valueVar
operator|=
name|Var
operator|.
name|alloc
argument_list|(
name|valueVar
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|resultSet
operator|=
name|resultSet
expr_stmt|;
comment|//this will read until the first binding of the first Entity is found
name|initFirst
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|initFirst
parameter_list|()
block|{
if|if
condition|(
name|currentEntity
operator|==
literal|null
operator|&&
name|nextEntity
operator|==
literal|null
condition|)
block|{
comment|//only for the first call
comment|//consume binding until the first valid entity starts
while|while
condition|(
name|nextEntity
operator|==
literal|null
operator|&&
name|resultSet
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Binding
name|firstValid
init|=
name|resultSet
operator|.
name|nextBinding
argument_list|()
decl_stmt|;
name|Node
name|entityNode
init|=
name|firstValid
operator|.
name|get
argument_list|(
name|entityVar
argument_list|)
decl_stmt|;
if|if
condition|(
name|entityNode
operator|.
name|isURI
argument_list|()
condition|)
block|{
comment|//only uri nodes are valid
comment|//store it temporarily in nextBinding
name|nextBinding
operator|=
name|firstValid
expr_stmt|;
comment|//store it as next (first) entity
name|nextEntity
operator|=
name|entityNode
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Current Entity %s is not a URI Node -> ignored"
argument_list|,
name|entityNode
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"This Mehtod MUST be only used for Initialisation!"
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
block|{
name|data
operator|.
name|clear
argument_list|()
expr_stmt|;
name|data
operator|=
literal|null
expr_stmt|;
name|currentEntity
operator|=
literal|null
expr_stmt|;
name|currentRepresentation
operator|=
literal|null
expr_stmt|;
comment|//Looks like it is not possible to close a resultSet
block|}
annotation|@
name|Override
specifier|public
name|Representation
name|getRepresentation
parameter_list|()
block|{
comment|//current Entity will be null if
comment|//  - next() was never called
comment|//  - the end of the iteration was reached
if|if
condition|(
name|currentEntity
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|currentRepresentation
operator|==
literal|null
condition|)
block|{
name|currentRepresentation
operator|=
name|createRepresentation
argument_list|()
expr_stmt|;
block|}
return|return
name|currentRepresentation
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|resultSet
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|next
parameter_list|()
block|{
return|return
name|getNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Removal of Entities is not supported by this Implementation!"
argument_list|)
throw|;
block|}
comment|/**          * Iterates over all {@link QuerySolution} of the {@link #resultSet}          * that do have {@link #currentEntity} as           * {@link RdfIndexingSource#VARIABLE_NAME_ENTITY VARIABLE_NAME_ENTITY}.          * NOTES:<ul>          *<li>This method also initialises the {@link #data} and sets the           * {@link #nextBinding} to the first solution of the next entity.<br>          *<li>That means also, that it would iterate over additional           * {@link RdfIndexingSource#VARIABLE_NAME_ENTITY VARIABLE_NAME_ENTITY}          * values that are not URIResources ( in cases          * {@link RDFNode#isURIResource()} returns<code>false</code>)          *<li>This method is also used to initialise the first Entity          * @return the URI of the current entity          */
specifier|private
name|String
name|getNext
parameter_list|()
block|{
comment|//check for more elements
if|if
condition|(
operator|!
name|resultSet
operator|.
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|(
literal|"No more Entities available"
argument_list|)
throw|;
block|}
comment|//clean up data of the previous entity
name|this
operator|.
name|data
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|//remove data of the previous entity
name|this
operator|.
name|currentRepresentation
operator|=
literal|null
expr_stmt|;
comment|//and the representation
name|this
operator|.
name|currentEntity
operator|=
name|nextEntity
expr_stmt|;
comment|//set the nextEntity to the current
comment|//and process the first binding already consumed from the resultSet
comment|//by calling this method for the previous Entity
if|if
condition|(
name|nextBinding
operator|!=
literal|null
condition|)
block|{
comment|//will be null for the first Entity
name|processSolution
argument_list|(
name|nextBinding
argument_list|)
expr_stmt|;
block|}
comment|//now get all the other Solutions for the current entity
name|boolean
name|next
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|next
operator|&&
name|resultSet
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Binding
name|binding
init|=
name|resultSet
operator|.
name|nextBinding
argument_list|()
decl_stmt|;
name|Node
name|entityNode
init|=
name|binding
operator|.
name|get
argument_list|(
name|entityVar
argument_list|)
decl_stmt|;
if|if
condition|(
name|entityNode
operator|.
name|isURI
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|entityNode
operator|.
name|equals
argument_list|(
name|currentEntity
argument_list|)
condition|)
block|{
comment|//start of next Entity
name|this
operator|.
name|nextEntity
operator|=
name|entityNode
expr_stmt|;
comment|//store the node for the next entity
name|this
operator|.
name|nextBinding
operator|=
name|binding
expr_stmt|;
comment|//store the first binding of the next entity
comment|//we are done for this entity -> exit the loop
name|next
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|processSolution
argument_list|(
name|binding
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Current Entity %s is not a URI Node -> ignored"
argument_list|,
name|entityNode
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|next
condition|)
block|{
comment|// exit the loop but still no new entity ... that means
name|nextEntity
operator|=
literal|null
expr_stmt|;
comment|//there are no more entities
name|nextBinding
operator|=
literal|null
expr_stmt|;
comment|// and there are also no more solutions
block|}
return|return
name|currentEntity
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**          * Processes a {@link Binding} by storing the {@link Node}s for the           * variables {@link #fieldVar} and {@link #valueVar} to {@link #data}.          * This method ensures that both values are not<code>null</code> and          * that the {@link Node} representing the field is an URI (          * returns<code>true</code> for {@link Node#isURI()})          * @param binding the binding to process          */
specifier|private
name|void
name|processSolution
parameter_list|(
name|Binding
name|binding
parameter_list|)
block|{
name|Node
name|field
init|=
name|binding
operator|.
name|get
argument_list|(
name|fieldVar
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|!=
literal|null
operator|&&
name|field
operator|.
name|isURI
argument_list|()
condition|)
block|{
name|Node
name|value
init|=
name|binding
operator|.
name|get
argument_list|(
name|valueVar
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
comment|//add the pair
name|data
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|data
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//This may only happen if the Query used to create the ResultSet
comment|//containing this Solution does not link the variable
comment|//VARIABLE_NAME_FIELD to properties.
name|log
operator|.
name|error
argument_list|(
literal|"Found Field {} for Entity {} that is not an URIResource"
argument_list|,
name|field
argument_list|,
name|currentEntity
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**          * Used to create the Representation the first time           * {@link #getRepresentation()} is called for the current entity. The          * information for the Representation are already stored in {@link #data}          */
specifier|private
name|Representation
name|createRepresentation
parameter_list|()
block|{
name|Representation
name|representation
init|=
name|vf
operator|.
name|createRepresentation
argument_list|(
name|currentEntity
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|Node
argument_list|>
name|it
init|=
name|data
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|//data contains field,value pairs
comment|//because of that we call two times next for
name|String
name|field
init|=
name|it
operator|.
name|next
argument_list|()
operator|.
name|getURI
argument_list|()
decl_stmt|;
comment|//the field
name|Node
name|value
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
comment|//and the value
name|processValue
argument_list|(
name|value
argument_list|,
name|representation
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
return|return
name|representation
return|;
block|}
block|}
block|}
end_class

end_unit

