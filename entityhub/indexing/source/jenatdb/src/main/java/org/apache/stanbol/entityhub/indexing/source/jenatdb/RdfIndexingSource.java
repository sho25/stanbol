begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|source
operator|.
name|jenatdb
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|source
operator|.
name|jenatdb
operator|.
name|Utils
operator|.
name|initTDBDataset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|FilenameUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|marmotta
operator|.
name|ldpath
operator|.
name|api
operator|.
name|backend
operator|.
name|RDFBackend
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|core
operator|.
name|model
operator|.
name|InMemoryValueFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|EntityDataIterable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|EntityDataIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|EntityDataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|IndexingComponent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|config
operator|.
name|IndexingConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|source
operator|.
name|ResourceLoader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|source
operator|.
name|ResourceState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Reference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Representation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|ValueFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|util
operator|.
name|ModelUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|datatypes
operator|.
name|BaseDatatype
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|datatypes
operator|.
name|DatatypeFormatException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|datatypes
operator|.
name|RDFDatatype
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|datatypes
operator|.
name|xsd
operator|.
name|XSDDateTime
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|datatypes
operator|.
name|xsd
operator|.
name|XSDDuration
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|graph
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|graph
operator|.
name|NodeFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|graph
operator|.
name|Triple
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|graph
operator|.
name|impl
operator|.
name|LiteralLabel
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|query
operator|.
name|Query
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|query
operator|.
name|QueryExecutionFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|query
operator|.
name|QueryFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|query
operator|.
name|QuerySolution
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|query
operator|.
name|ResultSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|query
operator|.
name|Syntax
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|rdf
operator|.
name|model
operator|.
name|AnonId
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|rdf
operator|.
name|model
operator|.
name|RDFNode
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|sparql
operator|.
name|core
operator|.
name|DatasetGraph
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|sparql
operator|.
name|core
operator|.
name|Var
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|sparql
operator|.
name|engine
operator|.
name|binding
operator|.
name|Binding
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|tdb
operator|.
name|store
operator|.
name|DatasetGraphTDB
import|;
end_import

begin_import
import|import
name|com
operator|.
name|hp
operator|.
name|hpl
operator|.
name|jena
operator|.
name|util
operator|.
name|iterator
operator|.
name|ExtendedIterator
import|;
end_import

begin_comment
comment|/**  * Implementation of an {@link IndexingComponent} for Entity data that provides   * the possibility to both:<ol>  *<li>randomly access entity data via the {@link EntityDataProvider} interface  *<li>iterate over all entities in this store via the {@link EntityDataIterator}  * interface.  *</ol>  *   * @author Rupert Westenthaler  *  */
end_comment

begin_class
specifier|public
class|class
name|RdfIndexingSource
extends|extends
name|AbstractTdbBackend
implements|implements
name|EntityDataIterable
implements|,
name|EntityDataProvider
implements|,
name|RDFBackend
argument_list|<
name|Node
argument_list|>
block|{
comment|/**      * The Parameter used to configure the source folder(s) relative to the      * {@link IndexingConfig#getSourceFolder()}. The ',' (comma) is used as      * separator to parsed multiple sources.      */
specifier|public
specifier|static
specifier|final
name|String
name|PARAM_SOURCE_FILE_OR_FOLDER
init|=
literal|"source"
decl_stmt|;
comment|/**      * The directory where successfully imported files are copied to      */
specifier|public
specifier|static
specifier|final
name|String
name|PARAM_IMPORTED_FOLDER
init|=
literal|"imported"
decl_stmt|;
comment|/**      * Allows to enable/disable the indexing of Bnodes (see       *<a href="https://issues.apache.org/jira/browse/STANBOL-765">STANBOL-765</a>      * for details).      */
specifier|private
specifier|static
specifier|final
name|String
name|PARAM_BNODE_STATE
init|=
literal|"bnode"
decl_stmt|;
comment|/**      * If present, this Parameter allows to convert RDF BlankNodes to dereferable      * URIs by using {bnode-prefix}{bnode-id} (see       *<a href="https://issues.apache.org/jira/browse/STANBOL-765">STANBOL-765</a>      * for details)      */
specifier|public
specifier|static
specifier|final
name|String
name|PARAM_BNODE_PREFIX
init|=
literal|"bnode-prefix"
decl_stmt|;
comment|/**      * The Parameter that can be used to deactivate the importing of sources.      * If this parameter is set to<code>false</code> the values configured for      * {@link #PARAM_IMPORT_SOURCE} are ignored. The default value is      *<code>true</code>      */
specifier|public
specifier|static
specifier|final
name|String
name|PARAM_IMPORT_SOURCE
init|=
literal|"import"
decl_stmt|;
comment|/**      * Allows to configure a {@link RdfImportFilter} (full qualified class name).      * If present it gets the full configuration set for this component parsed.      * This means that the import filter can be configured by the same       * configuration as this component.      */
specifier|public
specifier|static
specifier|final
name|String
name|PARAM_IMPORT_FILTER
init|=
literal|"import-filter"
decl_stmt|;
comment|/**      * The default directory name used to search for RDF files to be imported      */
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_SOURCE_FOLDER_NAME
init|=
literal|"rdfdata"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_IMPORTED_FOLDER_NAME
init|=
literal|"imported"
decl_stmt|;
comment|//protected to allow internal classes direct access (without hidden getter/
comment|//setter added by the compiler that decrease performance)
specifier|protected
specifier|final
specifier|static
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|RdfIndexingSource
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * The RDF data      */
specifier|private
name|DatasetGraphTDB
name|indexingDataset
decl_stmt|;
comment|/**      * The valueFactory used to create {@link Representation}s, {@link Reference}s      * and {@link Text} instances.      */
specifier|private
name|ValueFactory
name|vf
decl_stmt|;
specifier|private
name|ResourceLoader
name|loader
decl_stmt|;
specifier|protected
name|String
name|bnodePrefix
decl_stmt|;
comment|//protected to allow direct access in inner classes
comment|/**      * used for logging a single WARN level entry on the first ignored BlankNode      */
specifier|private
name|boolean
name|bnodeIgnored
init|=
literal|false
decl_stmt|;
specifier|private
name|RdfImportFilter
name|importFilter
decl_stmt|;
comment|/**      * Default Constructor relaying on that {@link #setConfiguration(Map)} is      * called afterwards to provide the configuration!      */
specifier|public
name|RdfIndexingSource
parameter_list|()
block|{
name|this
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Internally used to initialise a {@link ValueFactory}      * @param valueFactory      */
specifier|private
name|RdfIndexingSource
parameter_list|(
name|ValueFactory
name|valueFactory
parameter_list|)
block|{
if|if
condition|(
name|valueFactory
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|vf
operator|=
name|InMemoryValueFactory
operator|.
name|getInstance
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|vf
operator|=
name|valueFactory
expr_stmt|;
block|}
block|}
comment|/**      * Constructs an instance based on the provided parameter      * @param modelLocation the directory for the RDF model. MUST NOT be NULL      * however the parsed {@link File} needs not to exist.      * @param sourceFileOrDirectory the source file or directory containing the      * file(s) to import. Parse<code>null</code> if no RDF files need to be       * imported      * @param valueFactory The {@link ValueFactory} used to create instances      * or<code>null</code> to use the default implementation.      * @param importFilter Optionally an importFilter used for filtering some      * triples read from the RDF source files.      */
specifier|public
name|RdfIndexingSource
parameter_list|(
name|File
name|modelLocation
parameter_list|,
name|File
name|sourceFileOrDirectory
parameter_list|,
name|ValueFactory
name|valueFactory
parameter_list|,
name|RdfImportFilter
name|importFilter
parameter_list|)
block|{
if|if
condition|(
name|modelLocation
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed model location MUST NOT be NULL!"
argument_list|)
throw|;
block|}
comment|//init the store
name|this
operator|.
name|indexingDataset
operator|=
name|initTDBDataset
argument_list|(
name|modelLocation
argument_list|)
expr_stmt|;
comment|//use a ResourceLoader that fails on the first invalid RDF file (STANBOL-328)
name|this
operator|.
name|loader
operator|=
operator|new
name|ResourceLoader
argument_list|(
operator|new
name|RdfResourceImporter
argument_list|(
name|indexingDataset
argument_list|,
name|importFilter
argument_list|)
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|loader
operator|.
name|addResource
argument_list|(
name|sourceFileOrDirectory
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setConfiguration
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|config
parameter_list|)
block|{
name|IndexingConfig
name|indexingConfig
init|=
operator|(
name|IndexingConfig
operator|)
name|config
operator|.
name|get
argument_list|(
name|IndexingConfig
operator|.
name|KEY_INDEXING_CONFIG
argument_list|)
decl_stmt|;
comment|//first init the RDF Model
name|this
operator|.
name|indexingDataset
operator|=
name|Utils
operator|.
name|getTDBDataset
argument_list|(
name|config
argument_list|)
expr_stmt|;
comment|//second we need to check if we need to import RDF files to the RDF model
comment|//look if we need want to use an import filter
name|Object
name|value
init|=
name|config
operator|.
name|get
argument_list|(
name|PARAM_IMPORT_FILTER
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"No RDF Import Filter configured"
argument_list|)
expr_stmt|;
name|importFilter
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|String
index|[]
name|filterNames
init|=
name|value
operator|.
name|toString
argument_list|()
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|RdfImportFilter
argument_list|>
name|filters
init|=
operator|new
name|ArrayList
argument_list|<
name|RdfImportFilter
argument_list|>
argument_list|()
decl_stmt|;
name|ClassLoader
name|cl
init|=
name|indexingConfig
operator|.
name|getClass
argument_list|()
operator|.
name|getClassLoader
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|filterName
range|:
name|filterNames
control|)
block|{
name|filterName
operator|=
name|filterName
operator|.
name|trim
argument_list|()
expr_stmt|;
try|try
block|{
name|Class
argument_list|<
name|?
extends|extends
name|RdfImportFilter
argument_list|>
name|importFilterClass
init|=
name|cl
operator|.
name|loadClass
argument_list|(
name|filterName
argument_list|)
operator|.
name|asSubclass
argument_list|(
name|RdfImportFilter
operator|.
name|class
argument_list|)
decl_stmt|;
name|RdfImportFilter
name|filter
init|=
name|importFilterClass
operator|.
name|newInstance
argument_list|()
decl_stmt|;
name|filter
operator|.
name|setConfiguration
argument_list|(
name|config
argument_list|)
expr_stmt|;
name|filters
operator|.
name|add
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Use RDF ImportFilter {} (type: {})"
argument_list|,
name|importFilter
argument_list|,
name|importFilterClass
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Configured RdfImportFilter '"
operator|+
name|filterName
operator|+
literal|"' not found"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InstantiationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Configured RdfImportFilter '"
operator|+
name|filterName
operator|+
literal|"' can not be instantiated"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Configured RdfImportFilter '"
operator|+
name|filterName
operator|+
literal|"' can not be created"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|filters
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|this
operator|.
name|importFilter
operator|=
literal|null
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|filters
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|this
operator|.
name|importFilter
operator|=
name|filters
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|importFilter
operator|=
operator|new
name|UnionImportFilter
argument_list|(
name|filters
operator|.
name|toArray
argument_list|(
operator|new
name|RdfImportFilter
index|[
name|filters
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|boolean
name|failOnError
init|=
name|indexingConfig
operator|.
name|isFailOnError
argument_list|()
decl_stmt|;
comment|//create the ResourceLoader
name|this
operator|.
name|loader
operator|=
operator|new
name|ResourceLoader
argument_list|(
operator|new
name|RdfResourceImporter
argument_list|(
name|indexingDataset
argument_list|,
name|importFilter
argument_list|)
argument_list|,
name|failOnError
argument_list|)
expr_stmt|;
name|value
operator|=
name|config
operator|.
name|get
argument_list|(
name|PARAM_IMPORTED_FOLDER
argument_list|)
expr_stmt|;
name|String
name|importedFolderName
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
operator|!
name|value
operator|.
name|toString
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|importedFolderName
operator|=
name|value
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|importedFolderName
operator|=
name|DEFAULT_IMPORTED_FOLDER_NAME
expr_stmt|;
block|}
name|File
name|importedFolder
init|=
operator|new
name|File
argument_list|(
name|indexingConfig
operator|.
name|getSourceFolder
argument_list|()
argument_list|,
name|importedFolderName
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Imported RDF File Folder: {}"
argument_list|,
name|importedFolder
argument_list|)
expr_stmt|;
name|this
operator|.
name|loader
operator|.
name|setImportedDir
argument_list|(
name|importedFolder
argument_list|)
expr_stmt|;
comment|//check if importing is deactivated
name|boolean
name|importSource
init|=
literal|true
decl_stmt|;
comment|//default is true
name|value
operator|=
name|config
operator|.
name|get
argument_list|(
name|PARAM_IMPORT_SOURCE
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|importSource
operator|=
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|importSource
condition|)
block|{
comment|// if we need to import ... check the source config
name|log
operator|.
name|info
argument_list|(
literal|"Importing RDF data from:"
argument_list|)
expr_stmt|;
name|value
operator|=
name|config
operator|.
name|get
argument_list|(
name|PARAM_SOURCE_FILE_OR_FOLDER
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
comment|//if not set use the default
name|value
operator|=
name|DEFAULT_SOURCE_FOLDER_NAME
expr_stmt|;
block|}
for|for
control|(
name|String
name|source
range|:
name|value
operator|.
name|toString
argument_list|()
operator|.
name|split
argument_list|(
literal|","
argument_list|)
control|)
block|{
name|File
name|sourceFileOrDirectory
init|=
name|indexingConfig
operator|.
name|getSourceFile
argument_list|(
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|sourceFileOrDirectory
operator|.
name|exists
argument_list|()
condition|)
block|{
comment|//register the configured source with the ResourceLoader
name|this
operator|.
name|loader
operator|.
name|addResource
argument_list|(
name|sourceFileOrDirectory
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|FilenameUtils
operator|.
name|getExtension
argument_list|(
name|source
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//non existent directory -> create
comment|//This is typically the case if this method is called to
comment|//initialise the default configuration. So we will try
comment|//to create the directory users need to copy the source
comment|//RDF files.
if|if
condition|(
operator|!
name|sourceFileOrDirectory
operator|.
name|mkdirs
argument_list|()
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to create directory {} configured to improt RDF data from. "
operator|+
literal|"You will need to create this directory manually before copying the"
operator|+
literal|"RDF files into it."
argument_list|,
name|sourceFileOrDirectory
argument_list|)
expr_stmt|;
comment|//this would not be necessary because the directory will
comment|//be empty - however I like to be consistent and have
comment|//all configured and existent files& dirs added the the
comment|//resource loader
name|this
operator|.
name|loader
operator|.
name|addResource
argument_list|(
name|sourceFileOrDirectory
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to find RDF source {} within the indexing Source folder "
argument_list|,
name|source
argument_list|,
name|indexingConfig
operator|.
name|getSourceFolder
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|log
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
for|for
control|(
name|String
name|registeredSource
range|:
name|loader
operator|.
name|getResources
argument_list|(
name|ResourceState
operator|.
name|REGISTERED
argument_list|)
control|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"> "
operator|+
name|registeredSource
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Importing RDF data deactivated by parameer {}={}"
operator|+
name|PARAM_IMPORT_SOURCE
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|//STANBOL-765: parsed bnode-prefix from parsed configuration.
name|value
operator|=
name|config
operator|.
name|get
argument_list|(
name|PARAM_BNODE_STATE
argument_list|)
expr_stmt|;
specifier|final
name|Boolean
name|bnodeState
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|bnodeState
operator|=
name|value
operator|instanceof
name|Boolean
condition|?
operator|(
name|Boolean
operator|)
name|value
else|:
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|config
operator|.
name|containsKey
argument_list|(
name|PARAM_BNODE_STATE
argument_list|)
condition|)
block|{
comment|//support key without value
name|bnodeState
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|bnodeState
operator|=
literal|null
expr_stmt|;
comment|//undefined
block|}
if|if
condition|(
name|bnodeState
operator|==
literal|null
operator|||
name|bnodeState
condition|)
block|{
comment|//null or enabled -> consider prefix
name|value
operator|=
name|config
operator|.
name|get
argument_list|(
name|PARAM_BNODE_PREFIX
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
try|try
block|{
operator|new
name|URI
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The configured "
operator|+
name|PARAM_BNODE_PREFIX
operator|+
literal|"='"
operator|+
name|value
operator|.
name|toString
argument_list|()
operator|+
literal|"' MUST BE a valid URI!"
argument_list|)
throw|;
block|}
name|bnodePrefix
operator|=
name|value
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bnodeState
operator|!=
literal|null
condition|)
block|{
comment|//use default prefix if bnodeState is true
name|bnodePrefix
operator|=
name|String
operator|.
name|format
argument_list|(
literal|"urn:bnode:%s:"
argument_list|,
name|indexingConfig
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// else bnodeState == null and no custom prefix -> disable by default
block|}
if|if
condition|(
name|bnodePrefix
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Indexing of Bnodes enabled (prefix: {}"
argument_list|,
name|bnodePrefix
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Indexing of Bnodes disabled"
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|needsInitialisation
parameter_list|()
block|{
return|return
operator|(
name|importFilter
operator|!=
literal|null
operator|&&
name|importFilter
operator|.
name|needsInitialisation
argument_list|()
operator|)
operator|||
operator|!
name|loader
operator|.
name|getResources
argument_list|(
name|ResourceState
operator|.
name|REGISTERED
argument_list|)
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|initialise
parameter_list|()
block|{
if|if
condition|(
name|importFilter
operator|!=
literal|null
operator|&&
name|importFilter
operator|.
name|needsInitialisation
argument_list|()
condition|)
block|{
name|importFilter
operator|.
name|initialise
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|loader
operator|.
name|getResources
argument_list|(
name|ResourceState
operator|.
name|REGISTERED
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|loader
operator|.
name|loadResources
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
block|{
name|loader
operator|=
literal|null
expr_stmt|;
name|indexingDataset
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|importFilter
operator|!=
literal|null
condition|)
block|{
name|importFilter
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|debug
parameter_list|()
block|{
name|String
name|entityVar
init|=
literal|"s"
decl_stmt|;
name|String
name|fieldVar
init|=
literal|"p"
decl_stmt|;
name|String
name|valueVar
init|=
literal|"o"
decl_stmt|;
name|StringBuilder
name|qb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|qb
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"SELECT ?%s ?%s ?%s \n"
argument_list|,
name|entityVar
argument_list|,
name|fieldVar
argument_list|,
name|valueVar
argument_list|)
argument_list|)
expr_stmt|;
comment|//for the select
name|qb
operator|.
name|append
argument_list|(
literal|"{ \n"
argument_list|)
expr_stmt|;
name|qb
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"    ?%s ?%s ?%s . \n"
argument_list|,
name|entityVar
argument_list|,
name|fieldVar
argument_list|,
name|valueVar
argument_list|)
argument_list|)
expr_stmt|;
comment|//for the where
name|qb
operator|.
name|append
argument_list|(
literal|"} \n"
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"EntityDataIterator Query: \n"
operator|+
name|qb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|Query
name|q
init|=
name|QueryFactory
operator|.
name|create
argument_list|(
name|qb
operator|.
name|toString
argument_list|()
argument_list|,
name|Syntax
operator|.
name|syntaxARQ
argument_list|)
decl_stmt|;
name|ResultSet
name|rs
init|=
name|QueryExecutionFactory
operator|.
name|create
argument_list|(
name|q
argument_list|,
name|indexingDataset
operator|.
name|toDataset
argument_list|()
argument_list|)
operator|.
name|execSelect
argument_list|()
decl_stmt|;
name|Var
name|s
init|=
name|Var
operator|.
name|alloc
argument_list|(
name|entityVar
argument_list|)
decl_stmt|;
name|Var
name|p
init|=
name|Var
operator|.
name|alloc
argument_list|(
name|fieldVar
argument_list|)
decl_stmt|;
name|Var
name|o
init|=
name|Var
operator|.
name|alloc
argument_list|(
name|valueVar
argument_list|)
decl_stmt|;
while|while
condition|(
name|rs
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Binding
name|b
init|=
name|rs
operator|.
name|nextBinding
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"{} {} {}"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|b
operator|.
name|get
argument_list|(
name|s
argument_list|)
block|,
name|b
operator|.
name|get
argument_list|(
name|p
argument_list|)
block|,
name|b
operator|.
name|get
argument_list|(
name|o
argument_list|)
block|}
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|EntityDataIterator
name|entityDataIterator
parameter_list|()
block|{
name|String
name|entityVar
init|=
literal|"s"
decl_stmt|;
name|String
name|fieldVar
init|=
literal|"p"
decl_stmt|;
name|String
name|valueVar
init|=
literal|"o"
decl_stmt|;
name|StringBuilder
name|qb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|qb
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"SELECT ?%s ?%s ?%s \n"
argument_list|,
name|entityVar
argument_list|,
name|fieldVar
argument_list|,
name|valueVar
argument_list|)
argument_list|)
expr_stmt|;
comment|//for the select
name|qb
operator|.
name|append
argument_list|(
literal|"{ \n"
argument_list|)
expr_stmt|;
name|qb
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"    ?%s ?%s ?%s . \n"
argument_list|,
name|entityVar
argument_list|,
name|fieldVar
argument_list|,
name|valueVar
argument_list|)
argument_list|)
expr_stmt|;
comment|//for the where
name|qb
operator|.
name|append
argument_list|(
literal|"} \n"
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"EntityDataIterator Query: \n"
operator|+
name|qb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|Query
name|q
init|=
name|QueryFactory
operator|.
name|create
argument_list|(
name|qb
operator|.
name|toString
argument_list|()
argument_list|,
name|Syntax
operator|.
name|syntaxARQ
argument_list|)
decl_stmt|;
return|return
operator|new
name|RdfEntityIterator
argument_list|(
name|QueryExecutionFactory
operator|.
name|create
argument_list|(
name|q
argument_list|,
name|indexingDataset
operator|.
name|toDataset
argument_list|()
argument_list|)
operator|.
name|execSelect
argument_list|()
argument_list|,
name|entityVar
argument_list|,
name|fieldVar
argument_list|,
name|valueVar
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Representation
name|getEntityData
parameter_list|(
name|String
name|id
parameter_list|)
block|{
specifier|final
name|Node
name|resource
decl_stmt|;
comment|//STANBOL-765: check if the parsed id represents an bnode
if|if
condition|(
name|bnodePrefix
operator|!=
literal|null
operator|&&
name|id
operator|.
name|startsWith
argument_list|(
name|bnodePrefix
argument_list|)
condition|)
block|{
name|resource
operator|=
name|NodeFactory
operator|.
name|createAnon
argument_list|(
name|AnonId
operator|.
name|create
argument_list|(
name|id
operator|.
name|substring
argument_list|(
name|bnodePrefix
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|resource
operator|=
name|NodeFactory
operator|.
name|createURI
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
name|Representation
name|source
init|=
name|vf
operator|.
name|createRepresentation
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|boolean
name|found
decl_stmt|;
name|ExtendedIterator
argument_list|<
name|Triple
argument_list|>
name|outgoing
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// There may still be exceptions while reading triples
name|outgoing
operator|=
name|indexingDataset
operator|.
name|getDefaultGraph
argument_list|()
operator|.
name|find
argument_list|(
name|resource
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|found
operator|=
name|outgoing
operator|.
name|hasNext
argument_list|()
expr_stmt|;
while|while
condition|(
name|outgoing
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|//iterate over the statements for that resource
name|Triple
name|statement
init|=
name|outgoing
operator|.
name|next
argument_list|()
decl_stmt|;
name|Node
name|predicate
init|=
name|statement
operator|.
name|getPredicate
argument_list|()
decl_stmt|;
if|if
condition|(
name|predicate
operator|==
literal|null
operator|||
operator|!
name|predicate
operator|.
name|isURI
argument_list|()
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Ignore field {} for resource {} because it is null or not an URI!"
argument_list|,
name|predicate
argument_list|,
name|resource
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|field
init|=
name|predicate
operator|.
name|getURI
argument_list|()
decl_stmt|;
name|Node
name|value
init|=
name|statement
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|processValue
argument_list|(
name|value
argument_list|,
name|source
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
comment|//end else predicate != null
block|}
comment|//end iteration over resource triple
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to retrieve entity data for Entity '"
operator|+
name|id
operator|+
literal|"'"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|found
operator|=
literal|false
expr_stmt|;
try|try
block|{
if|if
condition|(
name|outgoing
operator|!=
literal|null
condition|)
block|{
name|outgoing
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e1
parameter_list|)
block|{
comment|/* ignore */
block|}
block|}
if|if
condition|(
name|found
condition|)
block|{
if|if
condition|(
name|log
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"RDFTerm: \n{}"
argument_list|,
name|ModelUtils
operator|.
name|getRepresentationInfo
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|source
return|;
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"No Statements found for id {} (Node: {})!"
argument_list|,
name|id
argument_list|,
name|resource
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Getter for the Jena TDB {@link DatasetGraph} used as source      * @return the indexingDataset      */
specifier|public
specifier|final
name|DatasetGraphTDB
name|getIndexingDataset
parameter_list|()
block|{
return|return
name|indexingDataset
return|;
block|}
comment|/**      * Processes a {@link Node} and adds the according value to the parsed      * Representation.      * @param value The node to convert to an value for the Representation      * @param source the representation (MUST NOT be<code>null</code>      * @param field the field (MUST NOT be<code>null</code>)      */
specifier|private
name|void
name|processValue
parameter_list|(
name|Node
name|value
parameter_list|,
name|Representation
name|source
parameter_list|,
name|String
name|field
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Encountered NULL value for field {} and entity {}"
argument_list|,
name|field
argument_list|,
name|source
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|.
name|isURI
argument_list|()
condition|)
block|{
comment|//add a reference
name|source
operator|.
name|addReference
argument_list|(
name|field
argument_list|,
name|value
operator|.
name|getURI
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|.
name|isLiteral
argument_list|()
condition|)
block|{
comment|//add a value or a text depending on the dataType
name|LiteralLabel
name|ll
init|=
name|value
operator|.
name|getLiteral
argument_list|()
decl_stmt|;
comment|//            log.debug("LL: lexical {} | value {} | dataType {} | language {}",
comment|//                new Object[]{ll.getLexicalForm(),ll.getValue(),ll.getDatatype(),ll.language()});
comment|//if the dataType == null , than we can expect a plain literal
name|RDFDatatype
name|dataType
init|=
name|ll
operator|.
name|getDatatype
argument_list|()
decl_stmt|;
if|if
condition|(
name|dataType
operator|!=
literal|null
condition|)
block|{
comment|//add a value
name|Object
name|literalValue
decl_stmt|;
try|try
block|{
name|literalValue
operator|=
name|ll
operator|.
name|getValue
argument_list|()
expr_stmt|;
if|if
condition|(
name|literalValue
operator|instanceof
name|BaseDatatype
operator|.
name|TypedValue
condition|)
block|{
comment|//used for unknown data types
comment|// -> in such cases just use the lexical type
name|String
name|lexicalValue
init|=
operator|(
operator|(
name|BaseDatatype
operator|.
name|TypedValue
operator|)
name|literalValue
operator|)
operator|.
name|lexicalValue
decl_stmt|;
if|if
condition|(
name|lexicalValue
operator|!=
literal|null
operator|&&
operator|!
name|lexicalValue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|source
operator|.
name|add
argument_list|(
name|field
argument_list|,
name|lexicalValue
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|literalValue
operator|instanceof
name|XSDDateTime
condition|)
block|{
name|source
operator|.
name|add
argument_list|(
name|field
argument_list|,
operator|(
operator|(
name|XSDDateTime
operator|)
name|literalValue
operator|)
operator|.
name|asCalendar
argument_list|()
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
comment|//Entityhub uses the time
block|}
elseif|else
if|if
condition|(
name|literalValue
operator|instanceof
name|XSDDuration
condition|)
block|{
name|String
name|duration
init|=
name|literalValue
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|duration
operator|!=
literal|null
operator|&&
operator|!
name|duration
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|source
operator|.
name|add
argument_list|(
name|field
argument_list|,
name|literalValue
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|ll
operator|.
name|getLexicalForm
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|source
operator|.
name|add
argument_list|(
name|field
argument_list|,
name|literalValue
argument_list|)
expr_stmt|;
block|}
comment|//else ignore literals that are empty
block|}
catch|catch
parameter_list|(
name|DatatypeFormatException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|" Unable to convert {} to {} -> use lecicalForm"
argument_list|,
name|ll
operator|.
name|getLexicalForm
argument_list|()
argument_list|,
name|ll
operator|.
name|getDatatype
argument_list|()
argument_list|)
expr_stmt|;
name|literalValue
operator|=
name|ll
operator|.
name|getLexicalForm
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//add a text
name|String
name|lexicalForm
init|=
name|ll
operator|.
name|getLexicalForm
argument_list|()
decl_stmt|;
if|if
condition|(
name|lexicalForm
operator|!=
literal|null
operator|&&
operator|!
name|lexicalForm
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|String
name|language
init|=
name|ll
operator|.
name|language
argument_list|()
decl_stmt|;
if|if
condition|(
name|language
operator|!=
literal|null
operator|&&
name|language
operator|.
name|length
argument_list|()
operator|<
literal|1
condition|)
block|{
name|language
operator|=
literal|null
expr_stmt|;
block|}
name|source
operator|.
name|addNaturalText
argument_list|(
name|field
argument_list|,
name|lexicalForm
argument_list|,
name|language
argument_list|)
expr_stmt|;
block|}
comment|//else ignore empty literals
block|}
comment|// "" is parsed if there is no language
block|}
elseif|else
if|if
condition|(
name|value
operator|.
name|isBlank
argument_list|()
condition|)
block|{
if|if
condition|(
name|bnodePrefix
operator|!=
literal|null
condition|)
block|{
comment|//STANBOL-765: convert Bnodes to URIs
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|bnodePrefix
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|value
operator|.
name|getBlankNodeId
argument_list|()
operator|.
name|getLabelString
argument_list|()
argument_list|)
expr_stmt|;
name|source
operator|.
name|addReference
argument_list|(
name|field
argument_list|,
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logIgnoredBnode
argument_list|(
name|log
argument_list|,
name|source
argument_list|,
name|field
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"ignoreing value {} for field {} and RDFTerm {} because it is of an unsupported type!"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|value
block|,
name|field
block|,
name|source
operator|.
name|getId
argument_list|()
block|}
argument_list|)
expr_stmt|;
block|}
comment|//end different value node type
block|}
comment|/**      * Logs that a BlankNode was ignored (only the first time). Also debugs the      * ignored triple.      * @param log the logger to use      * @param s subject      * @param p predicate      * @param o object      */
specifier|protected
name|void
name|logIgnoredBnode
parameter_list|(
name|Logger
name|log
parameter_list|,
name|Object
name|s
parameter_list|,
name|Object
name|p
parameter_list|,
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
name|bnodeIgnored
condition|)
block|{
name|bnodeIgnored
operator|=
literal|true
expr_stmt|;
name|log
operator|.
name|warn
argument_list|(
literal|"The Indexed RDF Data do contain Blank Nodes. Those are "
operator|+
literal|"ignored unless the '{}' parameter is set to valid URI. "
operator|+
literal|"If this parameter is set Bnodes are converted to URIs by "
operator|+
literal|"using {bnode-prefix}{bnodeId} (see STANBOL-765)"
argument_list|,
name|PARAM_BNODE_PREFIX
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|debug
argument_list|(
literal|"ignoreing blank node value(s) for Triple {},{},{}!"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|s
block|,
name|p
block|,
name|o
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**      * Implementation of the iterator over the entities stored in a      * {@link RdfIndexingSource}. This Iterator is based on query      * {@link ResultSet}. It uses the low level SPARQL API because this allows      * to use the same code to create values for Representations      * @author Rupert Westenthaler      *      */
specifier|public
specifier|final
class|class
name|RdfEntityIterator
implements|implements
name|EntityDataIterator
block|{
comment|/**          * Variable used to          */
specifier|final
name|Var
name|entityVar
decl_stmt|;
specifier|final
name|Var
name|fieldVar
decl_stmt|;
specifier|final
name|Var
name|valueVar
decl_stmt|;
comment|/**          * The result set containing all triples in the form of<code>          * "entity -&gt; field -&gt; value"</code>          */
specifier|private
specifier|final
name|ResultSet
name|resultSet
decl_stmt|;
comment|/**          * The {@link Node} representing the current entity or<code>null</code>          * if the iterator is newly created.<p>          * {@link Node#isURI()} is guaranteed to return<code>true</code> and          * {@link Node#getURI()} is guaranteed to return the id for the entity          */
specifier|private
name|Node
name|currentEntity
init|=
literal|null
decl_stmt|;
comment|/**          * The {@link Node} for the next Entity in the iteration or<code>null</code>          * in case there are no further or the iterator is newly created (in that          * case {@link #currentEntity} will be also<code>null</code>)<p>          * {@link Node#isURI()} is guaranteed to return<code>true</code> and          * {@link Node#getURI()} is guaranteed to return the id for the entity          */
specifier|private
name|Node
name|nextEntity
init|=
literal|null
decl_stmt|;
comment|/**          * The Representation of the current Element. Only available after a          * call to {@link #getRepresentation()}          */
specifier|private
name|Representation
name|currentRepresentation
init|=
literal|null
decl_stmt|;
comment|/**          * Holds all<code>field,value"</code> pairs of the current Entity.          * Elements at even positions represent<code>fields</code> and elements           * at uneven positions represent<code>values</code>.          */
specifier|private
name|List
argument_list|<
name|Node
argument_list|>
name|data
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
comment|/**          * The next (not consumed) solution of the query.           */
specifier|private
name|Binding
name|nextBinding
init|=
literal|null
decl_stmt|;
specifier|protected
name|RdfEntityIterator
parameter_list|(
name|ResultSet
name|resultSet
parameter_list|,
name|String
name|entityVar
parameter_list|,
name|String
name|fieldVar
parameter_list|,
name|String
name|valueVar
parameter_list|)
block|{
if|if
condition|(
name|resultSet
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed ResultSet MUST NOT be NULL!"
argument_list|)
throw|;
block|}
comment|//check if the ResultSet provides the required variables to perform the query
name|List
argument_list|<
name|String
argument_list|>
name|vars
init|=
name|resultSet
operator|.
name|getResultVars
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|vars
operator|.
name|contains
argument_list|(
name|entityVar
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed ResultSet is missing the required"
operator|+
literal|"Variable \""
operator|+
name|entityVar
operator|+
literal|"\" representing the Entity!"
argument_list|)
throw|;
block|}
else|else
block|{
name|this
operator|.
name|entityVar
operator|=
name|Var
operator|.
name|alloc
argument_list|(
name|entityVar
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|vars
operator|.
name|contains
argument_list|(
name|fieldVar
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed ResultSet is missing the required"
operator|+
literal|"Variable \""
operator|+
name|fieldVar
operator|+
literal|"\" representing the Field of an Entity!"
argument_list|)
throw|;
block|}
else|else
block|{
name|this
operator|.
name|fieldVar
operator|=
name|Var
operator|.
name|alloc
argument_list|(
name|fieldVar
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|vars
operator|.
name|contains
argument_list|(
name|valueVar
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed ResultSet is missing the required"
operator|+
literal|"Variable \""
operator|+
name|valueVar
operator|+
literal|"\" representing the Value of a Field of an Entity!"
argument_list|)
throw|;
block|}
else|else
block|{
name|this
operator|.
name|valueVar
operator|=
name|Var
operator|.
name|alloc
argument_list|(
name|valueVar
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|resultSet
operator|=
name|resultSet
expr_stmt|;
comment|//this will read until the first binding of the first Entity is found
name|initFirst
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|initFirst
parameter_list|()
block|{
if|if
condition|(
name|currentEntity
operator|==
literal|null
operator|&&
name|nextEntity
operator|==
literal|null
condition|)
block|{
comment|//only for the first call
comment|//consume binding until the first valid entity starts
while|while
condition|(
name|nextEntity
operator|==
literal|null
operator|&&
name|resultSet
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Binding
name|firstValid
init|=
name|resultSet
operator|.
name|nextBinding
argument_list|()
decl_stmt|;
name|Node
name|entityNode
init|=
name|firstValid
operator|.
name|get
argument_list|(
name|entityVar
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|entityNode
operator|.
name|isURI
argument_list|()
operator|&&
operator|!
name|entityNode
operator|.
name|toString
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
operator|||
name|entityNode
operator|.
name|isBlank
argument_list|()
operator|&&
name|bnodePrefix
operator|!=
literal|null
condition|)
block|{
comment|//store it temporarily in nextBinding
name|nextBinding
operator|=
name|firstValid
expr_stmt|;
comment|//store it as next (first) entity
name|nextEntity
operator|=
name|entityNode
expr_stmt|;
block|}
else|else
block|{
name|logIgnoredBnode
argument_list|(
name|log
argument_list|,
name|entityNode
argument_list|,
name|firstValid
operator|.
name|get
argument_list|(
name|fieldVar
argument_list|)
argument_list|,
name|firstValid
operator|.
name|get
argument_list|(
name|valueVar
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"This Mehtod MUST be only used for Initialisation!"
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
block|{
name|data
operator|.
name|clear
argument_list|()
expr_stmt|;
name|data
operator|=
literal|null
expr_stmt|;
name|currentEntity
operator|=
literal|null
expr_stmt|;
name|currentRepresentation
operator|=
literal|null
expr_stmt|;
comment|//Looks like it is not possible to close a resultSet
block|}
annotation|@
name|Override
specifier|public
name|Representation
name|getRepresentation
parameter_list|()
block|{
comment|//current Entity will be null if
comment|//  - next() was never called
comment|//  - the end of the iteration was reached
if|if
condition|(
name|currentEntity
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|currentRepresentation
operator|==
literal|null
condition|)
block|{
name|currentRepresentation
operator|=
name|createRepresentation
argument_list|()
expr_stmt|;
block|}
return|return
name|currentRepresentation
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|resultSet
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|next
parameter_list|()
block|{
return|return
name|getNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Removal of Entities is not supported by this Implementation!"
argument_list|)
throw|;
block|}
comment|/**          * Iterates over all {@link QuerySolution} of the {@link #resultSet}          * that do have {@link #currentEntity} as           * {@link RdfIndexingSource#VARIABLE_NAME_ENTITY VARIABLE_NAME_ENTITY}.          * NOTES:<ul>          *<li>This method also initialises the {@link #data} and sets the           * {@link #nextBinding} to the first solution of the next entity.<br>          *<li>That means also, that it would iterate over additional           * {@link RdfIndexingSource#VARIABLE_NAME_ENTITY VARIABLE_NAME_ENTITY}          * values that are not URIResources ( in cases          * {@link RDFNode#isURIResource()} returns<code>false</code>)          *<li>This method is also used to initialise the first Entity          * @return the URI of the current entity          */
specifier|private
name|String
name|getNext
parameter_list|()
block|{
comment|//check for more elements
if|if
condition|(
operator|!
name|resultSet
operator|.
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|(
literal|"No more Entities available"
argument_list|)
throw|;
block|}
comment|//clean up data of the previous entity
name|this
operator|.
name|data
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|//remove data of the previous entity
name|this
operator|.
name|currentRepresentation
operator|=
literal|null
expr_stmt|;
comment|//and the representation
name|this
operator|.
name|currentEntity
operator|=
name|nextEntity
expr_stmt|;
comment|//set the nextEntity to the current
comment|//and process the first binding already consumed from the resultSet
comment|//by calling this method for the previous Entity
if|if
condition|(
name|nextBinding
operator|!=
literal|null
condition|)
block|{
comment|//will be null for the first Entity
name|processSolution
argument_list|(
name|nextBinding
argument_list|)
expr_stmt|;
block|}
comment|//now get all the other Solutions for the current entity
name|boolean
name|next
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|next
operator|&&
name|resultSet
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Binding
name|binding
init|=
name|resultSet
operator|.
name|nextBinding
argument_list|()
decl_stmt|;
name|Node
name|entityNode
init|=
name|binding
operator|.
name|get
argument_list|(
name|entityVar
argument_list|)
decl_stmt|;
comment|//NOTES:
comment|// * for URIs we need to check for empty URIs!
comment|// * STANBOL-765: added support for BlankNodes
if|if
condition|(
operator|(
name|entityNode
operator|.
name|isURI
argument_list|()
operator|&&
operator|!
name|entityNode
operator|.
name|toString
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
operator|||
name|entityNode
operator|.
name|isBlank
argument_list|()
operator|&&
name|bnodePrefix
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|entityNode
operator|.
name|equals
argument_list|(
name|currentEntity
argument_list|)
condition|)
block|{
comment|//start of next Entity
name|this
operator|.
name|nextEntity
operator|=
name|entityNode
expr_stmt|;
comment|//store the node for the next entity
name|this
operator|.
name|nextBinding
operator|=
name|binding
expr_stmt|;
comment|//store the first binding of the next entity
comment|//we are done for this entity -> exit the loop
name|next
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|processSolution
argument_list|(
name|binding
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|logIgnoredBnode
argument_list|(
name|log
argument_list|,
name|entityNode
argument_list|,
name|binding
operator|.
name|get
argument_list|(
name|fieldVar
argument_list|)
argument_list|,
name|binding
operator|.
name|get
argument_list|(
name|valueVar
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|next
condition|)
block|{
comment|// exit the loop but still no new entity ... that means
name|nextEntity
operator|=
literal|null
expr_stmt|;
comment|//there are no more entities
name|nextBinding
operator|=
literal|null
expr_stmt|;
comment|// and there are also no more solutions
block|}
comment|//STANBOL-765: if current is a Bnode add the bnode-prefix
return|return
name|currentEntity
operator|.
name|isBlank
argument_list|()
condition|?
operator|new
name|StringBuilder
argument_list|(
name|bnodePrefix
argument_list|)
operator|.
name|append
argument_list|(
name|currentEntity
operator|.
name|getBlankNodeId
argument_list|()
operator|.
name|getLabelString
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
else|:
name|currentEntity
operator|.
name|getURI
argument_list|()
return|;
block|}
comment|/**          * Processes a {@link Binding} by storing the {@link Node}s for the           * variables {@link #fieldVar} and {@link #valueVar} to {@link #data}.          * This method ensures that both values are not<code>null</code> and          * that the {@link Node} representing the field is an URI (          * returns<code>true</code> for {@link Node#isURI()}).          * @param binding the binding to process          */
specifier|private
name|void
name|processSolution
parameter_list|(
name|Binding
name|binding
parameter_list|)
block|{
name|Node
name|field
init|=
name|binding
operator|.
name|get
argument_list|(
name|fieldVar
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|!=
literal|null
operator|&&
name|field
operator|.
name|isURI
argument_list|()
condition|)
block|{
comment|//property MUST BE an URI
name|Node
name|value
init|=
name|binding
operator|.
name|get
argument_list|(
name|valueVar
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
comment|//add the pair
name|data
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|data
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//This may only happen if the Query used to create the ResultSet
comment|//containing this Solution does not link the variable
comment|//VARIABLE_NAME_FIELD to properties.
name|log
operator|.
name|error
argument_list|(
literal|"Found Field {} for Entity {} that is not an URIResource"
argument_list|,
name|field
argument_list|,
name|currentEntity
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**          * Used to create the Representation the first time           * {@link #getRepresentation()} is called for the current entity. The          * information for the Representation are already stored in {@link #data}          */
specifier|private
name|Representation
name|createRepresentation
parameter_list|()
block|{
specifier|final
name|String
name|uri
decl_stmt|;
if|if
condition|(
name|currentEntity
operator|.
name|isBlank
argument_list|()
condition|)
block|{
comment|//STANBOL-765: support bNodes
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|bnodePrefix
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|currentEntity
operator|.
name|getBlankNodeId
argument_list|()
operator|.
name|getLabelString
argument_list|()
argument_list|)
expr_stmt|;
name|uri
operator|=
name|sb
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|uri
operator|=
name|currentEntity
operator|.
name|getURI
argument_list|()
expr_stmt|;
block|}
name|Representation
name|representation
init|=
name|vf
operator|.
name|createRepresentation
argument_list|(
name|uri
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|Node
argument_list|>
name|it
init|=
name|data
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|//data contains field,value pairs
comment|//because of that we call two times next for
name|String
name|field
init|=
name|it
operator|.
name|next
argument_list|()
operator|.
name|getURI
argument_list|()
decl_stmt|;
comment|//the field
name|Node
name|value
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
comment|//and the value
name|processValue
argument_list|(
name|value
argument_list|,
name|representation
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
return|return
name|representation
return|;
block|}
block|}
comment|/* ----------------------------------------------------------------------      *     RDF Backend implementation      * ----------------------------------------------------------------------      */
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|Node
argument_list|>
name|listObjects
parameter_list|(
name|Node
name|subject
parameter_list|,
name|Node
name|property
parameter_list|)
block|{
name|Collection
argument_list|<
name|Node
argument_list|>
name|nodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|bnodePrefix
operator|!=
literal|null
operator|&&
name|subject
operator|.
name|isURI
argument_list|()
operator|&&
name|subject
operator|.
name|getURI
argument_list|()
operator|.
name|startsWith
argument_list|(
name|bnodePrefix
argument_list|)
condition|)
block|{
name|subject
operator|=
name|NodeFactory
operator|.
name|createAnon
argument_list|(
operator|new
name|AnonId
argument_list|(
name|subject
operator|.
name|getURI
argument_list|()
operator|.
name|substring
argument_list|(
name|bnodePrefix
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ExtendedIterator
argument_list|<
name|Triple
argument_list|>
name|it
init|=
name|indexingDataset
operator|.
name|getDefaultGraph
argument_list|()
operator|.
name|find
argument_list|(
name|subject
argument_list|,
name|property
argument_list|,
literal|null
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|//STANBOL-765: we need also to transform bnodes to URIs for the
comment|//RDFBackend implementation
name|Node
name|object
init|=
name|it
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|bnodePrefix
operator|!=
literal|null
operator|&&
name|object
operator|.
name|isBlank
argument_list|()
condition|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|bnodePrefix
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|object
operator|.
name|getBlankNodeId
argument_list|()
operator|.
name|getLabelString
argument_list|()
argument_list|)
expr_stmt|;
name|object
operator|=
name|NodeFactory
operator|.
name|createURI
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|nodes
operator|.
name|add
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
name|it
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|nodes
return|;
block|}
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|Node
argument_list|>
name|listSubjects
parameter_list|(
name|Node
name|property
parameter_list|,
name|Node
name|object
parameter_list|)
block|{
name|Collection
argument_list|<
name|Node
argument_list|>
name|nodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|bnodePrefix
operator|!=
literal|null
operator|&&
name|object
operator|.
name|isURI
argument_list|()
operator|&&
name|object
operator|.
name|getURI
argument_list|()
operator|.
name|startsWith
argument_list|(
name|bnodePrefix
argument_list|)
condition|)
block|{
name|object
operator|=
name|NodeFactory
operator|.
name|createAnon
argument_list|(
operator|new
name|AnonId
argument_list|(
name|object
operator|.
name|getURI
argument_list|()
operator|.
name|substring
argument_list|(
name|bnodePrefix
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ExtendedIterator
argument_list|<
name|Triple
argument_list|>
name|it
init|=
name|indexingDataset
operator|.
name|getDefaultGraph
argument_list|()
operator|.
name|find
argument_list|(
literal|null
argument_list|,
name|property
argument_list|,
name|object
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Node
name|subject
init|=
name|it
operator|.
name|next
argument_list|()
operator|.
name|getSubject
argument_list|()
decl_stmt|;
comment|//STANBOL-765: we need also to transform bnodes to URIs for the
comment|//RDFBackend implementation
if|if
condition|(
name|bnodePrefix
operator|!=
literal|null
operator|&&
name|subject
operator|.
name|isBlank
argument_list|()
condition|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|bnodePrefix
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|subject
operator|.
name|getBlankNodeId
argument_list|()
operator|.
name|getLabelString
argument_list|()
argument_list|)
expr_stmt|;
name|subject
operator|=
name|NodeFactory
operator|.
name|createURI
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|nodes
operator|.
name|add
argument_list|(
name|subject
argument_list|)
expr_stmt|;
block|}
name|it
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|nodes
return|;
block|}
comment|/**      * Since STANBOL-765 BlankNodes are converted to URIs if a {@link #bnodePrefix}      * is configured. This also means that one needs to expect calls to the      * {@link RDFBackend} interface with transformed Nodes.<p>      * This method ensures that if someone requests an uri {@link Node} for a      * URI that represents a transformed Bnode (when the URI starts with       * {@link #bnodePrefix}) that the according bnode {@link Node} is created      * @param node the node      * @return      */
annotation|@
name|Override
specifier|public
name|Node
name|createURI
parameter_list|(
name|String
name|uri
parameter_list|)
block|{
if|if
condition|(
name|bnodePrefix
operator|!=
literal|null
operator|&&
name|uri
operator|.
name|startsWith
argument_list|(
name|bnodePrefix
argument_list|)
condition|)
block|{
return|return
name|NodeFactory
operator|.
name|createAnon
argument_list|(
name|AnonId
operator|.
name|create
argument_list|(
name|uri
operator|.
name|substring
argument_list|(
name|bnodePrefix
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|super
operator|.
name|createURI
argument_list|(
name|uri
argument_list|)
return|;
block|}
block|}
comment|/**      * used in case multiple {@link RdfImportFilter}s are configured.      * @author Rupert Westenthaler      *      */
specifier|private
class|class
name|UnionImportFilter
implements|implements
name|RdfImportFilter
block|{
name|RdfImportFilter
index|[]
name|filters
decl_stmt|;
name|UnionImportFilter
parameter_list|(
name|RdfImportFilter
index|[]
name|filters
parameter_list|)
block|{
name|this
operator|.
name|filters
operator|=
name|filters
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setConfiguration
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|config
parameter_list|)
block|{}
annotation|@
name|Override
specifier|public
name|boolean
name|needsInitialisation
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|initialise
parameter_list|()
block|{}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
block|{}
annotation|@
name|Override
specifier|public
name|boolean
name|accept
parameter_list|(
name|Node
name|s
parameter_list|,
name|Node
name|p
parameter_list|,
name|Node
name|o
parameter_list|)
block|{
name|boolean
name|state
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|state
operator|&&
name|i
operator|<
name|filters
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|state
operator|=
name|filters
index|[
name|i
index|]
operator|.
name|accept
argument_list|(
name|s
argument_list|,
name|p
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
return|return
name|state
return|;
block|}
block|}
block|}
end_class

end_unit

