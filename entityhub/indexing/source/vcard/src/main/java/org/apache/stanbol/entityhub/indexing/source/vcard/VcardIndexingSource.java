begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|source
operator|.
name|vcard
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|source
operator|.
name|vcard
operator|.
name|OntologyMappings
operator|.
name|ADR_COUNTRY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|source
operator|.
name|vcard
operator|.
name|OntologyMappings
operator|.
name|ADR_EXTENDED
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|source
operator|.
name|vcard
operator|.
name|OntologyMappings
operator|.
name|ADR_LOCALITY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|source
operator|.
name|vcard
operator|.
name|OntologyMappings
operator|.
name|ADR_POSTAL_CODE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|source
operator|.
name|vcard
operator|.
name|OntologyMappings
operator|.
name|ADR_POST_OFFICE_ADDRESS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|source
operator|.
name|vcard
operator|.
name|OntologyMappings
operator|.
name|ADR_REGION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|source
operator|.
name|vcard
operator|.
name|OntologyMappings
operator|.
name|ADR_STREET
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|source
operator|.
name|vcard
operator|.
name|OntologyMappings
operator|.
name|N_ADDITIONAL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|source
operator|.
name|vcard
operator|.
name|OntologyMappings
operator|.
name|N_FAMILY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|source
operator|.
name|vcard
operator|.
name|OntologyMappings
operator|.
name|N_GIVEN
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|source
operator|.
name|vcard
operator|.
name|OntologyMappings
operator|.
name|N_PREFIX
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|source
operator|.
name|vcard
operator|.
name|OntologyMappings
operator|.
name|N_SUFFIX
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|source
operator|.
name|vcard
operator|.
name|OntologyMappings
operator|.
name|RDF_TYPE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|source
operator|.
name|vcard
operator|.
name|OntologyMappings
operator|.
name|VCARD_ORGANIZATION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|source
operator|.
name|vcard
operator|.
name|OntologyMappings
operator|.
name|VCARD_PERSON
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilenameFilter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStreamWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Writer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URLEncoder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|net
operator|.
name|fortuna
operator|.
name|ical4j
operator|.
name|data
operator|.
name|ParserException
import|;
end_import

begin_import
import|import
name|net
operator|.
name|fortuna
operator|.
name|ical4j
operator|.
name|vcard
operator|.
name|Parameter
import|;
end_import

begin_import
import|import
name|net
operator|.
name|fortuna
operator|.
name|ical4j
operator|.
name|vcard
operator|.
name|Property
import|;
end_import

begin_import
import|import
name|net
operator|.
name|fortuna
operator|.
name|ical4j
operator|.
name|vcard
operator|.
name|VCard
import|;
end_import

begin_import
import|import
name|net
operator|.
name|fortuna
operator|.
name|ical4j
operator|.
name|vcard
operator|.
name|VCardBuilder
import|;
end_import

begin_import
import|import
name|net
operator|.
name|fortuna
operator|.
name|ical4j
operator|.
name|vcard
operator|.
name|VCardFileFilter
import|;
end_import

begin_import
import|import
name|net
operator|.
name|fortuna
operator|.
name|ical4j
operator|.
name|vcard
operator|.
name|property
operator|.
name|Address
import|;
end_import

begin_import
import|import
name|net
operator|.
name|fortuna
operator|.
name|ical4j
operator|.
name|vcard
operator|.
name|property
operator|.
name|N
import|;
end_import

begin_import
import|import
name|net
operator|.
name|fortuna
operator|.
name|ical4j
operator|.
name|vcard
operator|.
name|property
operator|.
name|Org
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|FileUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|FilenameUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|core
operator|.
name|model
operator|.
name|InMemoryValueFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|EntityDataIterable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|EntityDataIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|config
operator|.
name|IndexingConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|source
operator|.
name|ResourceImporter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|source
operator|.
name|ResourceLoader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|core
operator|.
name|source
operator|.
name|ResourceState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|indexing
operator|.
name|source
operator|.
name|vcard
operator|.
name|OntologyMappings
operator|.
name|Mapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|defaults
operator|.
name|NamespaceEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Representation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|ValueFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|util
operator|.
name|ModelUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|edu
operator|.
name|emory
operator|.
name|mathcs
operator|.
name|backport
operator|.
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|edu
operator|.
name|emory
operator|.
name|mathcs
operator|.
name|backport
operator|.
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_class
specifier|public
class|class
name|VcardIndexingSource
implements|implements
name|EntityDataIterable
implements|,
name|ResourceImporter
block|{
specifier|protected
specifier|static
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|VcardIndexingSource
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * The prefix used to create Entities      */
specifier|private
name|String
name|prefix
decl_stmt|;
specifier|private
name|char
name|typeSeperatorChar
init|=
literal|'/'
decl_stmt|;
specifier|private
name|ResourceLoader
name|loader
decl_stmt|;
comment|/**      * The charset used to read the vcard file(s) in the source folder      */
specifier|private
name|Charset
name|charset
init|=
literal|null
decl_stmt|;
comment|/**      * The default Charset ("utf-8"). This is also used to write the vcard files      * within the destination directory.      */
specifier|public
specifier|static
specifier|final
name|Charset
name|DEFAULT_CHARSET
init|=
name|Charset
operator|.
name|forName
argument_list|(
literal|"UTF8"
argument_list|)
decl_stmt|;
comment|/**      * Parameter that allows users to define the encoding of the vcard files      * to import (the {@link #DEFAULT_CHARSET default encoding} is set to      * "utf-8"      */
specifier|public
specifier|static
specifier|final
name|String
name|PARAM_CHARSET
init|=
literal|"encoding"
decl_stmt|;
comment|/**      * The Parameter used to configure the source folder(s) relative to the      * {@link IndexingConfig#getSourceFolder()}. The ',' (comma) is used as      * separator to parsed multiple sources.      */
specifier|public
specifier|static
specifier|final
name|String
name|PARAM_SOURCE_FILE_OR_FOLDER
init|=
literal|"source"
decl_stmt|;
comment|/**      * The default directory name used to search for vcard files to be imported      */
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_SOURCE_FOLDER_NAME
init|=
literal|"vcard"
decl_stmt|;
comment|/**      * The prefix used vCard entities      */
specifier|public
specifier|static
specifier|final
name|String
name|PARAM_PREFIX
init|=
literal|"prefix"
decl_stmt|;
comment|/**      * Used to import vcard files from the       * {@link IndexingConfig#getSourceFolder() source}/      * {@link #PARAM_SOURCE_FILE_OR_FOLDER vcard} folder.      */
specifier|protected
name|ResourceImporter
name|importer
decl_stmt|;
comment|/**      * Folder within the destination directory to temporary copy all the      * vCard files to import.      */
specifier|private
name|File
name|vcardFileImportFolder
decl_stmt|;
comment|/**      * List of the files that need to be imported. Initialised in {@link #initialise()}      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
name|List
argument_list|<
name|File
argument_list|>
name|vcardFiles
init|=
name|Collections
operator|.
name|emptyList
argument_list|()
decl_stmt|;
comment|/**      * Used to create {@link Representation} instances      */
specifier|private
name|ValueFactory
name|vf
init|=
name|InMemoryValueFactory
operator|.
name|getInstance
argument_list|()
decl_stmt|;
comment|/**      * The vcard -&gt; ontology mappings      * TODO make configurable as soon as there are multiple mappings available      */
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Mapping
argument_list|>
name|mappings
init|=
name|OntologyMappings
operator|.
name|schemaOrgMappings
decl_stmt|;
specifier|public
name|VcardIndexingSource
parameter_list|()
block|{
comment|//set relaxed parsing to TRUE
name|System
operator|.
name|setProperty
argument_list|(
literal|"ical4j.parsing.relaxed"
argument_list|,
name|Boolean
operator|.
name|TRUE
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|EntityDataIterator
name|entityDataIterator
parameter_list|()
block|{
return|return
operator|new
name|VCardIterator
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
block|{
name|this
operator|.
name|importer
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|needsInitialisation
parameter_list|()
block|{
comment|//if there are resources with the state REGISTERED we need an initialisation
return|return
operator|!
name|loader
operator|.
name|getResources
argument_list|(
name|ResourceState
operator|.
name|REGISTERED
argument_list|)
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|initialise
parameter_list|()
block|{
comment|//this will call #importResource(..) for all files in the directories
comment|//configured by the #PARAM_SOURCE_FILE_OR_FOLDER
name|loader
operator|.
name|loadResources
argument_list|()
expr_stmt|;
comment|//create the lists
name|vcardFiles
operator|=
name|Arrays
operator|.
name|asList
argument_list|(
name|vcardFileImportFolder
operator|.
name|listFiles
argument_list|(
operator|(
name|FilenameFilter
operator|)
name|VCardFileFilter
operator|.
name|INSTANCE
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setConfiguration
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|config
parameter_list|)
block|{
comment|//init fields
name|IndexingConfig
name|indexingConfig
init|=
operator|(
name|IndexingConfig
operator|)
name|config
operator|.
name|get
argument_list|(
name|IndexingConfig
operator|.
name|KEY_INDEXING_CONFIG
argument_list|)
decl_stmt|;
name|loader
operator|=
operator|new
name|ResourceLoader
argument_list|(
name|this
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|//vcard files are imported from a special folder in the destination dir.
comment|//this folder needs to be deleted/(re-)created first.
name|vcardFileImportFolder
operator|=
operator|new
name|File
argument_list|(
name|indexingConfig
operator|.
name|getDestinationFolder
argument_list|()
argument_list|,
literal|"vcard"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vcardFileImportFolder
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
name|vcardFileImportFolder
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
try|try
block|{
name|FileUtils
operator|.
name|deleteDirectory
argument_list|(
name|vcardFileImportFolder
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to delete Folder "
operator|+
name|vcardFileImportFolder
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" containing the vCard files from a"
operator|+
literal|"previouse indexing! Please remove this folder manually."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|vcardFileImportFolder
operator|.
name|delete
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to delete File "
operator|+
name|vcardFileImportFolder
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" containing the vCard data from a"
operator|+
literal|"previouse indexing! Please remove this File manually."
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|!
name|vcardFileImportFolder
operator|.
name|mkdirs
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to delete Folder "
operator|+
name|vcardFileImportFolder
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" containing the vCard files from a"
operator|+
literal|"previouse indexing! Please remove this folder manually."
argument_list|)
throw|;
block|}
comment|//load config
name|Object
name|value
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"load vcard resources from :"
argument_list|)
expr_stmt|;
name|value
operator|=
name|config
operator|.
name|get
argument_list|(
name|PARAM_SOURCE_FILE_OR_FOLDER
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
comment|//if not set use the default
name|value
operator|=
name|DEFAULT_SOURCE_FOLDER_NAME
expr_stmt|;
block|}
for|for
control|(
name|String
name|source
range|:
name|value
operator|.
name|toString
argument_list|()
operator|.
name|split
argument_list|(
literal|","
argument_list|)
control|)
block|{
name|File
name|sourceFileOrDirectory
init|=
name|indexingConfig
operator|.
name|getSourceFile
argument_list|(
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|sourceFileOrDirectory
operator|.
name|exists
argument_list|()
condition|)
block|{
comment|//register the configured source with the ResourceLoader
name|this
operator|.
name|loader
operator|.
name|addResource
argument_list|(
name|sourceFileOrDirectory
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|FilenameUtils
operator|.
name|getExtension
argument_list|(
name|source
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//non existent directory -> create
comment|//This is typically the case if this method is called to
comment|//initialise the default configuration. So we will try
comment|//to create the directory users need to copy the source
comment|//RDF files.
if|if
condition|(
operator|!
name|sourceFileOrDirectory
operator|.
name|mkdirs
argument_list|()
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to create directory {} configured to improt source data from. "
operator|+
literal|"You will need to create this directory manually before copying the"
operator|+
literal|"Source files into it."
argument_list|,
name|sourceFileOrDirectory
argument_list|)
expr_stmt|;
comment|//this would not be necessary because the directory will
comment|//be empty - however I like to be consistent and have
comment|//all configured and existent files& dirs added the the
comment|//resource loader
name|this
operator|.
name|loader
operator|.
name|addResource
argument_list|(
name|sourceFileOrDirectory
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to find vcard source {} within the indexing Source folder "
argument_list|,
name|source
argument_list|,
name|indexingConfig
operator|.
name|getSourceFolder
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
for|for
control|(
name|String
name|registeredSource
range|:
name|loader
operator|.
name|getResources
argument_list|(
name|ResourceState
operator|.
name|REGISTERED
argument_list|)
control|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"> "
operator|+
name|registeredSource
argument_list|)
expr_stmt|;
block|}
block|}
comment|//parse the encoding
name|value
operator|=
name|config
operator|.
name|get
argument_list|(
name|PARAM_CHARSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|String
name|encoding
init|=
name|value
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|encoding
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//use plattform encoding if empty
name|charset
operator|=
name|Charset
operator|.
name|defaultCharset
argument_list|()
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|charset
operator|=
name|Charset
operator|.
name|forName
argument_list|(
name|encoding
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"The configured encoding '"
operator|+
name|encoding
operator|+
literal|"' is not supported by this Plattform"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
else|else
block|{
comment|//use plattorm encoding if missing
name|charset
operator|=
name|Charset
operator|.
name|defaultCharset
argument_list|()
expr_stmt|;
block|}
comment|//parse the prefix
name|value
operator|=
name|config
operator|.
name|get
argument_list|(
name|PARAM_PREFIX
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
operator|||
name|value
operator|.
name|toString
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Teh configuration is missing the required parameter 'prefix'!"
argument_list|)
throw|;
block|}
else|else
block|{
name|prefix
operator|=
name|value
operator|.
name|toString
argument_list|()
expr_stmt|;
comment|//set the typeSeperatorChar based on the kind of parsed prefix
if|if
condition|(
name|prefix
operator|.
name|endsWith
argument_list|(
literal|"#"
argument_list|)
condition|)
block|{
name|typeSeperatorChar
operator|=
literal|'.'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prefix
operator|.
name|endsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
block|{
name|typeSeperatorChar
operator|=
literal|'/'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prefix
operator|.
name|endsWith
argument_list|(
literal|":"
argument_list|)
condition|)
block|{
name|typeSeperatorChar
operator|=
literal|':'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prefix
operator|.
name|startsWith
argument_list|(
literal|"urn:"
argument_list|)
condition|)
block|{
comment|//maybe an urn without an tailing ':'
name|prefix
operator|=
name|prefix
operator|+
literal|':'
expr_stmt|;
name|typeSeperatorChar
operator|=
literal|':'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prefix
operator|.
name|indexOf
argument_list|(
literal|"://"
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|//maybe an url without an tailing '/' or '#'
name|prefix
operator|=
name|prefix
operator|+
literal|'/'
expr_stmt|;
block|}
comment|//else ... no idea what kind of prefix ... use the default '/'
block|}
block|}
comment|/**      * This only copies vCard files to the {@link #vcardFileImportFolder} within the      * {@link IndexingConfig#getDestinationFolder()}.<p>      * In addition if a specific {@link #charset} is configured for the      * vcard files to import this also changes the encoding to the      * {@link #DEFAULT_CHARSET} (utf-8). This can help users to investigate and      * correct file encoding related issues.      * @see org.apache.stanbol.entityhub.indexing.core.source.ResourceImporter#importResource(java.io.InputStream, java.lang.String)      */
annotation|@
name|Override
specifier|public
name|ResourceState
name|importResource
parameter_list|(
name|InputStream
name|is
parameter_list|,
name|String
name|resourceName
parameter_list|)
throws|throws
name|IOException
block|{
comment|//only copies the file to tmp files in the
if|if
condition|(
name|resourceName
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|!=
literal|'.'
operator|&&
name|VCardFileFilter
operator|.
name|INSTANCE
operator|.
name|accept
argument_list|(
operator|new
name|File
argument_list|(
name|resourceName
argument_list|)
argument_list|)
condition|)
block|{
comment|//copy the file to the destination directory
comment|//1. get the file name used in the destination
name|String
name|name
init|=
name|FilenameUtils
operator|.
name|getName
argument_list|(
name|resourceName
argument_list|)
decl_stmt|;
name|String
name|baseName
init|=
name|FilenameUtils
operator|.
name|getBaseName
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|String
name|extension
init|=
name|FilenameUtils
operator|.
name|getExtension
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|File
name|outFile
init|=
operator|new
name|File
argument_list|(
name|vcardFileImportFolder
argument_list|,
name|name
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|outFile
operator|.
name|exists
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|outFile
operator|=
operator|new
name|File
argument_list|(
name|vcardFileImportFolder
argument_list|,
name|String
operator|.
name|format
argument_list|(
literal|"%s_%s.%s"
argument_list|,
name|baseName
argument_list|,
name|i
argument_list|,
name|extension
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//check the encoding to ensure that in the destination all files use
comment|// DEFAULT_CHARSET (utf-8)
if|if
condition|(
name|charset
operator|==
literal|null
operator|||
name|charset
operator|.
name|equals
argument_list|(
name|DEFAULT_CHARSET
argument_list|)
condition|)
block|{
comment|// no recoding -> copy bytes
name|OutputStream
name|os
init|=
operator|new
name|FileOutputStream
argument_list|(
name|outFile
argument_list|)
decl_stmt|;
name|IOUtils
operator|.
name|copy
argument_list|(
name|is
argument_list|,
name|os
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//recode
name|Reader
name|r
init|=
operator|new
name|InputStreamReader
argument_list|(
name|is
argument_list|,
name|charset
argument_list|)
decl_stmt|;
name|Writer
name|w
init|=
operator|new
name|OutputStreamWriter
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|outFile
argument_list|)
argument_list|,
name|DEFAULT_CHARSET
argument_list|)
decl_stmt|;
name|IOUtils
operator|.
name|copy
argument_list|(
name|r
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
return|return
name|ResourceState
operator|.
name|LOADED
return|;
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Resource {} ignored: Not an Vcard file."
argument_list|,
name|resourceName
argument_list|)
expr_stmt|;
return|return
name|ResourceState
operator|.
name|IGNORED
return|;
block|}
block|}
specifier|private
class|class
name|VCardIterator
implements|implements
name|EntityDataIterator
block|{
name|Map
argument_list|<
name|EntityType
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|>
name|entityMap
decl_stmt|;
name|Iterator
argument_list|<
name|File
argument_list|>
name|files
init|=
name|vcardFiles
operator|.
name|iterator
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Iterator
argument_list|<
name|VCard
argument_list|>
name|vcards
init|=
name|Collections
operator|.
name|emptyList
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Iterator
argument_list|<
name|Representation
argument_list|>
name|representations
init|=
name|Collections
operator|.
name|emptyList
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Representation
name|nextRepresentation
init|=
literal|null
decl_stmt|;
name|Representation
name|currentRepresentation
init|=
literal|null
decl_stmt|;
specifier|private
name|VCardIterator
parameter_list|()
block|{
name|entityMap
operator|=
operator|new
name|EnumMap
argument_list|<
name|EntityType
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|>
argument_list|(
name|EntityType
operator|.
name|class
argument_list|)
expr_stmt|;
name|entityMap
operator|.
name|put
argument_list|(
name|EntityType
operator|.
name|organization
argument_list|,
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|entityMap
operator|.
name|put
argument_list|(
name|EntityType
operator|.
name|person
argument_list|,
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**          * Parses all {@link VCard} object of the next {@link #files file};          */
specifier|private
name|Iterator
argument_list|<
name|VCard
argument_list|>
name|parseNext
parameter_list|(
name|File
name|file
parameter_list|)
block|{
name|Reader
name|r
decl_stmt|;
try|try
block|{
name|r
operator|=
operator|new
name|InputStreamReader
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|file
argument_list|)
argument_list|,
name|DEFAULT_CHARSET
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"vcard import file "
operator|+
name|file
operator|+
literal|"not found - maybe deleted during import?"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|VCardBuilder
name|parser
init|=
operator|new
name|VCardBuilder
argument_list|(
name|r
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|parser
operator|.
name|buildAll
argument_list|()
operator|.
name|iterator
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to read vcard file "
operator|+
name|file
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|ParserException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to parse vcard file "
operator|+
name|file
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Representation
name|getRepresentation
parameter_list|()
block|{
return|return
name|currentRepresentation
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
comment|//Iterate while there are still representations, vCards or files
while|while
condition|(
name|nextRepresentation
operator|==
literal|null
operator|&&
operator|(
name|representations
operator|.
name|hasNext
argument_list|()
operator|||
name|vcards
operator|.
name|hasNext
argument_list|()
operator|||
name|files
operator|.
name|hasNext
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|representations
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|//if more representations
name|nextRepresentation
operator|=
name|representations
operator|.
name|next
argument_list|()
expr_stmt|;
comment|//set next
block|}
else|else
block|{
comment|//else process the next vCard object
name|VCard
name|nextVcard
init|=
literal|null
decl_stmt|;
comment|//Iterate while there are still more vCards or files
while|while
condition|(
name|nextVcard
operator|==
literal|null
operator|&&
operator|(
name|vcards
operator|.
name|hasNext
argument_list|()
operator|||
name|files
operator|.
name|hasNext
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|vcards
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|//if there are more vCards
name|nextVcard
operator|=
name|vcards
operator|.
name|next
argument_list|()
expr_stmt|;
comment|//get next
block|}
else|else
block|{
comment|//parse the next file
comment|//NOTE: we do not need to check for file.hasNext,
comment|//because this was already implicitly checked by the
comment|//outer most while loop
name|vcards
operator|=
name|parseNext
argument_list|(
name|files
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nextVcard
operator|!=
literal|null
condition|)
block|{
name|representations
operator|=
name|processVcard
argument_list|(
name|nextVcard
argument_list|,
name|mappings
argument_list|,
name|entityMap
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|nextRepresentation
operator|!=
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|next
parameter_list|()
block|{
if|if
condition|(
name|nextRepresentation
operator|==
literal|null
operator|&&
operator|!
name|hasNext
argument_list|()
condition|)
block|{
comment|//try to get the next
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|currentRepresentation
operator|=
name|nextRepresentation
expr_stmt|;
name|nextRepresentation
operator|=
literal|null
expr_stmt|;
return|return
name|currentRepresentation
operator|.
name|getId
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"removal is not supported"
argument_list|)
throw|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
block|{
comment|//set to empty iterators instead of null. Otherwise I would need
comment|//to check for null in all the other methods
name|files
operator|=
name|Collections
operator|.
name|emptyList
argument_list|()
operator|.
name|iterator
argument_list|()
expr_stmt|;
name|representations
operator|=
name|Collections
operator|.
name|emptyList
argument_list|()
operator|.
name|iterator
argument_list|()
expr_stmt|;
name|vcards
operator|=
name|Collections
operator|.
name|emptyList
argument_list|()
operator|.
name|iterator
argument_list|()
expr_stmt|;
name|nextRepresentation
operator|=
literal|null
expr_stmt|;
name|currentRepresentation
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**      * Vcard objects can represent persons (FN is defined) or organisations      * (no 'FN' but an 'ORG' element)      * @author Rupert Westenthaler      *      */
specifier|private
enum|enum
name|EntityType
block|{
name|person
block|,
name|organization
block|}
comment|/**      * Converts a vCard object to Representations.      * @param vCard the vCard object to process      * @param mappings the Mappings to use      * @param entityMap the Map holding the ids of already processed vCards. This      * is used to avoid id conflicts      * @return Iterator over the processed Representation      */
specifier|protected
name|Iterator
argument_list|<
name|Representation
argument_list|>
name|processVcard
parameter_list|(
name|VCard
name|vCard
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Mapping
argument_list|>
name|mappings
parameter_list|,
name|Map
argument_list|<
name|EntityType
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|>
name|entityMap
parameter_list|)
block|{
comment|//NOTE: this is protected to allow direct access from the VCardIterator
name|String
name|name
init|=
literal|null
decl_stmt|;
name|EntityType
name|entityType
init|=
literal|null
decl_stmt|;
name|Property
name|nameProperty
init|=
name|vCard
operator|.
name|getProperty
argument_list|(
name|Property
operator|.
name|Id
operator|.
name|FN
argument_list|)
decl_stmt|;
if|if
condition|(
name|nameProperty
operator|!=
literal|null
operator|&&
name|nameProperty
operator|.
name|getValue
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|nameProperty
operator|.
name|getValue
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|entityType
operator|=
name|EntityType
operator|.
name|person
expr_stmt|;
name|name
operator|=
name|nameProperty
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|//FN name -> maybe a ORG was exported
name|Property
name|orgProperty
init|=
name|vCard
operator|.
name|getProperty
argument_list|(
name|Property
operator|.
name|Id
operator|.
name|ORG
argument_list|)
decl_stmt|;
if|if
condition|(
name|orgProperty
operator|!=
literal|null
operator|&&
operator|(
operator|(
name|Org
operator|)
name|orgProperty
operator|)
operator|.
name|getValues
argument_list|()
operator|!=
literal|null
operator|&&
operator|(
operator|(
name|Org
operator|)
name|orgProperty
operator|)
operator|.
name|getValues
argument_list|()
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|entityType
operator|=
name|EntityType
operator|.
name|organization
expr_stmt|;
name|name
operator|=
operator|(
operator|(
name|Org
operator|)
name|orgProperty
operator|)
operator|.
name|getValues
argument_list|()
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|entityType
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to index vCard object without values for FN or ORG parameter (vCard: {})"
argument_list|,
name|vCard
argument_list|)
expr_stmt|;
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
operator|.
name|iterator
argument_list|()
return|;
block|}
name|String
name|id
init|=
literal|null
decl_stmt|;
name|Property
name|uid
init|=
name|vCard
operator|.
name|getProperty
argument_list|(
name|Property
operator|.
name|Id
operator|.
name|UID
argument_list|)
decl_stmt|;
if|if
condition|(
name|uid
operator|!=
literal|null
condition|)
block|{
name|id
operator|=
name|uid
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|id
operator|=
name|name
expr_stmt|;
block|}
name|id
operator|=
name|entityByName
argument_list|(
name|entityMap
argument_list|,
name|entityType
argument_list|,
name|name
argument_list|,
name|id
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|//we have a name and an id (local name of the URI/URN)
comment|// ... now parse the vCard
name|Representation
name|rep
init|=
name|vf
operator|.
name|createRepresentation
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Representation
argument_list|>
name|representations
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Representation
argument_list|>
argument_list|()
decl_stmt|;
name|representations
operator|.
name|put
argument_list|(
name|rep
operator|.
name|getId
argument_list|()
argument_list|,
name|rep
argument_list|)
expr_stmt|;
comment|//add the type
name|Mapping
name|typeMapping
init|=
name|mappings
operator|.
name|get
argument_list|(
name|entityType
operator|==
name|EntityType
operator|.
name|person
condition|?
name|VCARD_PERSON
else|:
name|VCARD_ORGANIZATION
argument_list|)
decl_stmt|;
if|if
condition|(
name|typeMapping
operator|!=
literal|null
condition|)
block|{
name|rep
operator|.
name|add
argument_list|(
name|NamespaceEnum
operator|.
name|rdf
operator|+
literal|"type"
argument_list|,
name|typeMapping
operator|.
name|uri
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|debug
argument_list|(
literal|"vCard [type: {} | name: '{}' | id: '{}']"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|entityType
block|,
name|name
block|,
name|rep
operator|.
name|getId
argument_list|()
block|}
argument_list|)
expr_stmt|;
for|for
control|(
name|Property
name|property
range|:
name|vCard
operator|.
name|getProperties
argument_list|()
control|)
block|{
name|Property
operator|.
name|Id
name|propertyId
init|=
name|property
operator|.
name|getId
argument_list|()
decl_stmt|;
name|String
name|propName
init|=
name|propertyId
operator|.
name|getPropertyName
argument_list|()
decl_stmt|;
if|if
condition|(
name|mappings
operator|.
name|containsKey
argument_list|(
name|propName
argument_list|)
condition|)
block|{
comment|//there is a mapping for this property
comment|//the Representation to write the Information of the current Property
name|Representation
name|current
decl_stmt|;
comment|//the Map with the mappings to be used for processing the current
comment|//Property
name|Map
argument_list|<
name|String
argument_list|,
name|Mapping
argument_list|>
name|currentMappings
decl_stmt|;
name|Mapping
name|mapping
init|=
name|mappings
operator|.
name|get
argument_list|(
name|propName
argument_list|)
decl_stmt|;
comment|//May be null!!
if|if
condition|(
name|mapping
operator|==
literal|null
operator|||
name|mapping
operator|.
name|subMappings
operator|==
literal|null
condition|)
block|{
name|current
operator|=
name|rep
expr_stmt|;
comment|//add to the base Representation
name|currentMappings
operator|=
name|mappings
expr_stmt|;
comment|//and use the parsed mappings
block|}
else|else
block|{
name|current
operator|=
literal|null
expr_stmt|;
comment|//indicates we need to create a new Representation
name|currentMappings
operator|=
name|mapping
operator|.
name|subMappings
expr_stmt|;
comment|//and use the sub mappings
block|}
switch|switch
condition|(
name|propertyId
condition|)
block|{
case|case
name|N
case|:
name|N
name|n
init|=
operator|(
name|N
operator|)
name|property
decl_stmt|;
name|String
name|given
init|=
name|n
operator|.
name|getGivenName
argument_list|()
decl_stmt|;
name|String
name|family
init|=
name|n
operator|.
name|getFamilyName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|given
operator|==
literal|null
operator|||
name|given
operator|.
name|isEmpty
argument_list|()
operator|)
operator|&&
operator|(
name|family
operator|==
literal|null
operator|||
name|family
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"'N' property '{}'does not define given nor family name -> ignored"
argument_list|,
name|n
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|current
operator|==
literal|null
condition|)
block|{
comment|//create new Representation
name|current
operator|=
name|createSubRepresentation
argument_list|(
name|rep
argument_list|,
literal|".name"
argument_list|,
name|representations
operator|.
name|keySet
argument_list|()
argument_list|,
name|mapping
argument_list|)
expr_stmt|;
name|representations
operator|.
name|put
argument_list|(
name|current
operator|.
name|getId
argument_list|()
argument_list|,
name|current
argument_list|)
expr_stmt|;
block|}
name|Mapping
name|subPropertyMapping
init|=
name|currentMappings
operator|.
name|get
argument_list|(
name|N_GIVEN
argument_list|)
decl_stmt|;
if|if
condition|(
name|subPropertyMapping
operator|!=
literal|null
operator|&&
name|given
operator|!=
literal|null
operator|&&
operator|!
name|given
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|current
operator|.
name|addNaturalText
argument_list|(
name|subPropertyMapping
operator|.
name|uri
argument_list|,
name|StringUtils
operator|.
name|chomp
argument_list|(
name|given
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|subPropertyMapping
operator|=
name|currentMappings
operator|.
name|get
argument_list|(
name|N_FAMILY
argument_list|)
expr_stmt|;
if|if
condition|(
name|subPropertyMapping
operator|!=
literal|null
operator|&
name|family
operator|!=
literal|null
operator|&&
operator|!
name|family
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|current
operator|.
name|addNaturalText
argument_list|(
name|subPropertyMapping
operator|.
name|uri
argument_list|,
name|StringUtils
operator|.
name|chomp
argument_list|(
name|family
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|String
index|[]
name|additional
init|=
name|n
operator|.
name|getAdditionalNames
argument_list|()
decl_stmt|;
name|subPropertyMapping
operator|=
name|currentMappings
operator|.
name|get
argument_list|(
name|N_ADDITIONAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|subPropertyMapping
operator|!=
literal|null
operator|&
name|additional
operator|!=
literal|null
operator|&&
name|additional
operator|.
name|length
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|String
name|value
range|:
name|additional
control|)
block|{
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
operator|!
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|current
operator|.
name|addNaturalText
argument_list|(
name|subPropertyMapping
operator|.
name|uri
argument_list|,
name|StringUtils
operator|.
name|chomp
argument_list|(
name|value
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|String
index|[]
name|prefixes
init|=
name|n
operator|.
name|getPrefixes
argument_list|()
decl_stmt|;
name|subPropertyMapping
operator|=
name|currentMappings
operator|.
name|get
argument_list|(
name|N_PREFIX
argument_list|)
expr_stmt|;
if|if
condition|(
name|subPropertyMapping
operator|!=
literal|null
operator|&
name|prefixes
operator|!=
literal|null
operator|&&
name|prefixes
operator|.
name|length
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|String
name|value
range|:
name|prefixes
control|)
block|{
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
operator|!
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|current
operator|.
name|addNaturalText
argument_list|(
name|subPropertyMapping
operator|.
name|uri
argument_list|,
name|StringUtils
operator|.
name|chomp
argument_list|(
name|value
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|String
index|[]
name|suffixes
init|=
name|n
operator|.
name|getSuffixes
argument_list|()
decl_stmt|;
name|subPropertyMapping
operator|=
name|currentMappings
operator|.
name|get
argument_list|(
name|N_SUFFIX
argument_list|)
expr_stmt|;
if|if
condition|(
name|subPropertyMapping
operator|!=
literal|null
operator|&
name|suffixes
operator|!=
literal|null
operator|&&
name|suffixes
operator|.
name|length
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|String
name|value
range|:
name|suffixes
control|)
block|{
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
operator|!
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|current
operator|.
name|addNaturalText
argument_list|(
name|subPropertyMapping
operator|.
name|uri
argument_list|,
name|StringUtils
operator|.
name|chomp
argument_list|(
name|value
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
break|break;
case|case
name|ADR
case|:
name|Address
name|address
init|=
operator|(
name|Address
operator|)
name|property
decl_stmt|;
if|if
condition|(
name|address
operator|.
name|getValue
argument_list|()
operator|!=
literal|null
operator|&&
comment|//check of the value does not only contain seperators (',')
operator|!
name|address
operator|.
name|getValue
argument_list|()
operator|.
name|replace
argument_list|(
literal|';'
argument_list|,
literal|' '
argument_list|)
operator|.
name|trim
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|current
operator|==
literal|null
condition|)
block|{
comment|//create new Representation
name|current
operator|=
name|createSubRepresentation
argument_list|(
name|rep
argument_list|,
literal|".adr"
argument_list|,
name|representations
operator|.
name|keySet
argument_list|()
argument_list|,
name|mapping
argument_list|)
expr_stmt|;
name|representations
operator|.
name|put
argument_list|(
name|current
operator|.
name|getId
argument_list|()
argument_list|,
name|current
argument_list|)
expr_stmt|;
block|}
name|Mapping
name|subPropertyMapping
init|=
name|currentMappings
operator|.
name|get
argument_list|(
name|ADR_POST_OFFICE_ADDRESS
argument_list|)
decl_stmt|;
name|String
name|value
init|=
name|address
operator|.
name|getPoBox
argument_list|()
decl_stmt|;
if|if
condition|(
name|subPropertyMapping
operator|!=
literal|null
operator|&&
name|value
operator|!=
literal|null
operator|&&
operator|!
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//add string -> this is no natural language text
name|current
operator|.
name|add
argument_list|(
name|subPropertyMapping
operator|.
name|uri
argument_list|,
name|StringUtils
operator|.
name|chomp
argument_list|(
name|value
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|address
operator|.
name|getExtended
argument_list|()
expr_stmt|;
name|subPropertyMapping
operator|=
name|currentMappings
operator|.
name|get
argument_list|(
name|ADR_EXTENDED
argument_list|)
expr_stmt|;
if|if
condition|(
name|subPropertyMapping
operator|!=
literal|null
operator|&&
name|value
operator|!=
literal|null
operator|&&
operator|!
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|current
operator|.
name|addNaturalText
argument_list|(
name|subPropertyMapping
operator|.
name|uri
argument_list|,
name|StringUtils
operator|.
name|chomp
argument_list|(
name|value
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|address
operator|.
name|getStreet
argument_list|()
expr_stmt|;
name|subPropertyMapping
operator|=
name|currentMappings
operator|.
name|get
argument_list|(
name|ADR_STREET
argument_list|)
expr_stmt|;
if|if
condition|(
name|subPropertyMapping
operator|!=
literal|null
operator|&&
name|value
operator|!=
literal|null
operator|&&
operator|!
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|current
operator|.
name|addNaturalText
argument_list|(
name|subPropertyMapping
operator|.
name|uri
argument_list|,
name|StringUtils
operator|.
name|chomp
argument_list|(
name|value
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|address
operator|.
name|getLocality
argument_list|()
expr_stmt|;
name|subPropertyMapping
operator|=
name|currentMappings
operator|.
name|get
argument_list|(
name|ADR_LOCALITY
argument_list|)
expr_stmt|;
if|if
condition|(
name|subPropertyMapping
operator|!=
literal|null
operator|&&
name|value
operator|!=
literal|null
operator|&&
operator|!
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|current
operator|.
name|addNaturalText
argument_list|(
name|subPropertyMapping
operator|.
name|uri
argument_list|,
name|StringUtils
operator|.
name|chomp
argument_list|(
name|value
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|address
operator|.
name|getRegion
argument_list|()
expr_stmt|;
name|subPropertyMapping
operator|=
name|currentMappings
operator|.
name|get
argument_list|(
name|ADR_REGION
argument_list|)
expr_stmt|;
if|if
condition|(
name|subPropertyMapping
operator|!=
literal|null
operator|&&
name|value
operator|!=
literal|null
operator|&&
operator|!
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|current
operator|.
name|addNaturalText
argument_list|(
name|subPropertyMapping
operator|.
name|uri
argument_list|,
name|StringUtils
operator|.
name|chomp
argument_list|(
name|value
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|address
operator|.
name|getPostcode
argument_list|()
expr_stmt|;
name|subPropertyMapping
operator|=
name|currentMappings
operator|.
name|get
argument_list|(
name|ADR_POSTAL_CODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|subPropertyMapping
operator|!=
literal|null
operator|&&
name|value
operator|!=
literal|null
operator|&&
operator|!
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// add string -> this is no natural language text
name|current
operator|.
name|add
argument_list|(
name|subPropertyMapping
operator|.
name|uri
argument_list|,
name|StringUtils
operator|.
name|chomp
argument_list|(
name|value
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|address
operator|.
name|getCountry
argument_list|()
expr_stmt|;
name|subPropertyMapping
operator|=
name|currentMappings
operator|.
name|get
argument_list|(
name|ADR_COUNTRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|subPropertyMapping
operator|!=
literal|null
operator|&&
name|value
operator|!=
literal|null
operator|&&
operator|!
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// add string -> based on the standard this should be the two letter code
name|current
operator|.
name|add
argument_list|(
name|subPropertyMapping
operator|.
name|uri
argument_list|,
name|StringUtils
operator|.
name|chomp
argument_list|(
name|value
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|//else empty ADR field -> ignore
break|break;
case|case
name|ORG
case|:
name|Org
name|org
init|=
operator|(
name|Org
operator|)
name|property
decl_stmt|;
name|String
index|[]
name|unitHierarchy
init|=
name|org
operator|.
name|getValues
argument_list|()
decl_stmt|;
name|Mapping
name|orgNameMapping
init|=
name|currentMappings
operator|.
name|get
argument_list|(
name|OntologyMappings
operator|.
name|ORG_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|unitHierarchy
operator|.
name|length
operator|>
literal|0
operator|&&
name|orgNameMapping
operator|!=
literal|null
operator|&&
name|unitHierarchy
index|[
literal|0
index|]
operator|!=
literal|null
operator|&&
name|unitHierarchy
index|[
literal|0
index|]
operator|.
name|trim
argument_list|()
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|String
name|orgName
init|=
name|unitHierarchy
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|current
operator|==
literal|null
condition|)
block|{
comment|//create new Representation for the Organisation
comment|//Note: this is an Entity and no sub-Resource!
name|String
name|orgEntityId
init|=
name|entityByName
argument_list|(
name|entityMap
argument_list|,
name|EntityType
operator|.
name|organization
argument_list|,
name|orgName
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|orgEntityId
operator|==
literal|null
condition|)
block|{
comment|//create new Entity for this Organization
name|orgEntityId
operator|=
name|entityByName
argument_list|(
name|entityMap
argument_list|,
name|EntityType
operator|.
name|organization
argument_list|,
name|orgName
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|current
operator|=
name|vf
operator|.
name|createRepresentation
argument_list|(
name|orgEntityId
argument_list|)
expr_stmt|;
name|initSubRepresentation
argument_list|(
name|current
argument_list|,
name|rep
argument_list|,
name|mapping
argument_list|)
expr_stmt|;
name|representations
operator|.
name|put
argument_list|(
name|current
operator|.
name|getId
argument_list|()
argument_list|,
name|current
argument_list|)
expr_stmt|;
name|current
operator|.
name|addNaturalText
argument_list|(
name|orgNameMapping
operator|.
name|uri
argument_list|,
name|StringUtils
operator|.
name|chomp
argument_list|(
name|orgName
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
comment|//TODO: inverse relation form the ORG to the
comment|// Person can not be supported without caching
comment|// organisations. Therefore delete this relation for now
if|if
condition|(
name|mapping
operator|.
name|invUri
operator|!=
literal|null
condition|)
block|{
name|current
operator|.
name|removeAll
argument_list|(
name|mapping
operator|.
name|invUri
argument_list|)
expr_stmt|;
block|}
comment|//TODO: Organisation units are not supported
block|}
else|else
block|{
name|rep
operator|.
name|addReference
argument_list|(
name|mapping
operator|.
name|uri
argument_list|,
name|orgEntityId
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
default|default:
if|if
condition|(
name|current
operator|!=
literal|null
operator|&&
name|mapping
operator|!=
literal|null
condition|)
block|{
name|String
name|value
init|=
name|property
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|value
operator|=
name|StringUtils
operator|.
name|chomp
argument_list|(
name|property
operator|.
name|getValue
argument_list|()
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to index empty value for property {} of vCard {}"
argument_list|,
name|property
operator|.
name|getId
argument_list|()
operator|.
name|getPropertyName
argument_list|()
argument_list|,
name|rep
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|current
operator|.
name|addNaturalText
argument_list|(
name|mapping
operator|.
name|uri
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mapping
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Sub-Resources are not supported for Property {} (mapping to {} ignored)!"
argument_list|,
name|propName
argument_list|,
name|mapping
argument_list|)
expr_stmt|;
block|}
comment|//else no mapping defined
break|break;
block|}
name|String
name|value
init|=
name|property
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|" - {}: {}"
argument_list|,
name|propertyId
operator|.
name|getPropertyName
argument_list|()
argument_list|,
name|value
argument_list|)
expr_stmt|;
for|for
control|(
name|Parameter
name|param
range|:
name|property
operator|.
name|getParameters
argument_list|()
control|)
block|{
name|Parameter
operator|.
name|Id
name|paramId
init|=
name|param
operator|.
name|getId
argument_list|()
decl_stmt|;
name|String
name|paramValue
init|=
name|param
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"   {}:{}"
argument_list|,
name|paramId
operator|.
name|getPname
argument_list|()
argument_list|,
name|paramValue
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"No mapping for Property {} with value {}"
argument_list|,
name|propertyId
argument_list|,
name|property
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|log
operator|.
name|debug
argument_list|(
literal|"> Mapped Data;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
for|for
control|(
name|Representation
name|tmp
range|:
name|representations
operator|.
name|values
argument_list|()
control|)
block|{
name|log
operator|.
name|info
argument_list|(
name|ModelUtils
operator|.
name|getRepresentationInfo
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|log
operator|.
name|debug
argument_list|(
literal|"--- end ---"
argument_list|)
expr_stmt|;
return|return
name|representations
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
return|;
block|}
comment|/**      * @param entityMap the map with all the Entity name -&gt; id mappings      * @param entityType the type of the entity to search      * @param name the name of the Entity      * @param id optionally an id other than the name otherwise the name is used      * @param create if<code>true</code> is parsed a new Entity is created even      * if a entity with the same name already exists      * @return the id of the created or found Entity      */
specifier|private
name|String
name|entityByName
parameter_list|(
name|Map
argument_list|<
name|EntityType
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|>
name|entityMap
parameter_list|,
name|EntityType
name|entityType
parameter_list|,
name|String
name|name
parameter_list|,
name|String
name|id
parameter_list|,
name|boolean
name|create
parameter_list|)
block|{
if|if
condition|(
name|id
operator|==
literal|null
condition|)
block|{
name|id
operator|=
name|name
expr_stmt|;
block|}
comment|//lookup the existing entities of that type and name
name|Set
argument_list|<
name|String
argument_list|>
name|entities
init|=
name|entityMap
operator|.
name|get
argument_list|(
name|entityType
argument_list|)
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|entities
operator|==
literal|null
condition|)
block|{
comment|//if none -> we will create one in this method
name|entities
operator|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|//use lower size to save memory
name|entityMap
operator|.
name|get
argument_list|(
name|entityType
argument_list|)
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|entities
argument_list|)
expr_stmt|;
block|}
comment|//make ids only to use ASKII chars and no white spaces
name|id
operator|=
name|id
operator|.
name|replace
argument_list|(
literal|' '
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
try|try
block|{
comment|// encode special chars
comment|//TODO: replace that by ASKII folding
name|id
operator|=
name|URLEncoder
operator|.
name|encode
argument_list|(
name|id
argument_list|,
literal|"utf8"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"This Plattform does not support 'utf8' encoding :("
argument_list|)
throw|;
block|}
comment|//add prefixes and so on
name|id
operator|=
name|prefix
operator|+
name|entityType
operator|+
name|typeSeperatorChar
operator|+
name|id
expr_stmt|;
comment|//now we have the id
if|if
condition|(
operator|!
name|create
condition|)
block|{
comment|//NOTE: this would always return the first Entity if multiple Entities
comment|// would have been created by using the ceckId method.
return|return
name|entities
operator|.
name|contains
argument_list|(
name|id
argument_list|)
condition|?
name|id
else|:
literal|null
return|;
block|}
else|else
block|{
comment|//we need to create a new entity
name|id
operator|=
name|checkId
argument_list|(
name|id
argument_list|,
name|entities
argument_list|)
expr_stmt|;
name|entities
operator|.
name|add
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return
name|id
return|;
block|}
block|}
comment|/**      * Create a sub-representation by considering the base {@link Representation},      * IDs already taken by other sub representations. The Id addon the caller      * would like to add to the id of the base representation. In addition it      * adds the relation between the base and the sub-representation as well as      * the type and the inverse links to the sub-representation.      * @param base the base (parent) representation      * @param addon the string addon to the id of the base      * @param takenIds set of IDs that are already taken      * @param mapping the mapping used to get the information needed to correctly      * initialise the sub-relation      */
specifier|private
name|Representation
name|createSubRepresentation
parameter_list|(
name|Representation
name|base
parameter_list|,
name|String
name|addon
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|takenIds
parameter_list|,
name|Mapping
name|mapping
parameter_list|)
block|{
name|Representation
name|current
init|=
name|vf
operator|.
name|createRepresentation
argument_list|(
name|checkId
argument_list|(
name|base
operator|.
name|getId
argument_list|()
operator|+
name|addon
argument_list|,
name|takenIds
argument_list|)
argument_list|)
decl_stmt|;
name|initSubRepresentation
argument_list|(
name|current
argument_list|,
name|base
argument_list|,
name|mapping
argument_list|)
expr_stmt|;
return|return
name|current
return|;
block|}
comment|/**      * Initialise the parsed sub-representation by adds the relation between       * the base and the sub-representation as well as      * the rdf:type of the sub-relation and the inverse link if the sub- to the      * base representation.      * @param toInit The representation to initialise      * @param base the parent representation      * @param mapping the mapping       */
specifier|private
name|void
name|initSubRepresentation
parameter_list|(
name|Representation
name|toInit
parameter_list|,
name|Representation
name|base
parameter_list|,
name|Mapping
name|mapping
parameter_list|)
block|{
name|Mapping
name|typeMapping
init|=
name|mapping
operator|.
name|subMappings
operator|.
name|get
argument_list|(
name|RDF_TYPE
argument_list|)
decl_stmt|;
if|if
condition|(
name|typeMapping
operator|!=
literal|null
condition|)
block|{
name|toInit
operator|.
name|addReference
argument_list|(
name|NamespaceEnum
operator|.
name|rdf
operator|+
literal|"type"
argument_list|,
name|typeMapping
operator|.
name|uri
argument_list|)
expr_stmt|;
block|}
name|base
operator|.
name|addReference
argument_list|(
name|mapping
operator|.
name|uri
argument_list|,
name|toInit
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapping
operator|.
name|invUri
operator|!=
literal|null
condition|)
block|{
name|toInit
operator|.
name|addReference
argument_list|(
name|mapping
operator|.
name|invUri
argument_list|,
name|base
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Adds "-{i}" to the end of the parsed ID until it does no longer conflict      * with already taken IDs      * @param id the id      * @param taken already taken IDs      * @return a id based on the parsed one that does not conflict with already      * taken once.       */
specifier|private
name|String
name|checkId
parameter_list|(
name|String
name|id
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|taken
parameter_list|)
block|{
name|String
name|test
init|=
literal|null
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|taken
operator|.
name|contains
argument_list|(
name|i
operator|==
literal|0
condition|?
name|id
else|:
name|test
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|test
operator|=
name|id
operator|+
literal|'-'
operator|+
name|i
expr_stmt|;
block|}
if|if
condition|(
name|test
operator|!=
literal|null
condition|)
block|{
name|id
operator|=
name|test
expr_stmt|;
block|}
return|return
name|id
return|;
block|}
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|VcardIndexingSource
name|instance
init|=
operator|new
name|VcardIndexingSource
argument_list|()
decl_stmt|;
name|instance
operator|.
name|prefix
operator|=
literal|"http://test.org/"
expr_stmt|;
name|VCardBuilder
name|parser
init|=
operator|new
name|VCardBuilder
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
operator|new
name|FileInputStream
argument_list|(
operator|new
name|File
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|,
literal|"utf8"
argument_list|)
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|EntityType
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|>
name|entityMap
init|=
operator|new
name|EnumMap
argument_list|<
name|EntityType
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|>
argument_list|(
name|EntityType
operator|.
name|class
argument_list|)
decl_stmt|;
name|entityMap
operator|.
name|put
argument_list|(
name|EntityType
operator|.
name|organization
argument_list|,
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|entityMap
operator|.
name|put
argument_list|(
name|EntityType
operator|.
name|person
argument_list|,
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|VCard
name|vcard
range|:
name|parser
operator|.
name|buildAll
argument_list|()
control|)
block|{
name|instance
operator|.
name|processVcard
argument_list|(
name|vcard
argument_list|,
name|OntologyMappings
operator|.
name|schemaOrgMappings
argument_list|,
name|entityMap
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

