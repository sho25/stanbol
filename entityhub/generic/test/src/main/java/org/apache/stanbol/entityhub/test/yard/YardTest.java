begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|test
operator|.
name|yard
package|;
end_package

begin_import
import|import static
name|junit
operator|.
name|framework
operator|.
name|Assert
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|test
operator|.
name|Utils
operator|.
name|asCollection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Representation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|yard
operator|.
name|Yard
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|yard
operator|.
name|YardException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|AfterClass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_class
specifier|public
specifier|abstract
class|class
name|YardTest
block|{
comment|/**      * Getter for the {@link Yard} instance to be tested      * @return the {@link Yard} instance to be tested      */
specifier|protected
specifier|abstract
name|Yard
name|getYard
parameter_list|()
function_decl|;
comment|/**      * Stores all the IDs of Representations created by the create(..) methods.      * This collection is used to clean up the store after all the unit tests       * are executed.      */
specifier|protected
specifier|static
name|Collection
argument_list|<
name|String
argument_list|>
name|representationIds
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|protected
name|Representation
name|create
parameter_list|()
throws|throws
name|YardException
block|{
name|Representation
name|r
init|=
name|getYard
argument_list|()
operator|.
name|create
argument_list|()
decl_stmt|;
name|representationIds
operator|.
name|add
argument_list|(
name|r
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
specifier|protected
name|Representation
name|create
parameter_list|(
name|String
name|id
parameter_list|,
name|boolean
name|store
parameter_list|)
throws|throws
name|YardException
block|{
name|Representation
name|r
decl_stmt|;
if|if
condition|(
name|store
condition|)
block|{
name|r
operator|=
name|getYard
argument_list|()
operator|.
name|create
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|id
operator|!=
literal|null
operator|&&
operator|!
name|id
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|r
operator|=
name|getYard
argument_list|()
operator|.
name|getValueFactory
argument_list|()
operator|.
name|createRepresentation
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"If store is FALSE the id MUST NOT be NULL nor EMPTY!"
argument_list|)
throw|;
block|}
name|representationIds
operator|.
name|add
argument_list|(
name|r
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testGetValueFactory
parameter_list|()
block|{
name|assertNotNull
argument_list|(
literal|"The ValueFactory MUST NOT be NULL"
argument_list|,
name|getYard
argument_list|()
operator|.
name|getValueFactory
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testGetQueryFactory
parameter_list|()
block|{
name|assertNotNull
argument_list|(
literal|"The QueryFactory MUST NOT be NULL"
argument_list|,
name|getYard
argument_list|()
operator|.
name|getQueryFactory
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testYardId
parameter_list|()
block|{
name|assertNotNull
argument_list|(
literal|"The ID of the Yard MUST NOT be NULL"
argument_list|,
name|getYard
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testYardName
parameter_list|()
block|{
name|assertNotNull
argument_list|(
literal|"The Name of the Yard MUST NOT be NULL"
argument_list|,
name|getYard
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"The Name of the Yard MUST NOT be an empty String"
argument_list|,
name|getYard
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDefaultCreate
parameter_list|()
throws|throws
name|YardException
block|{
name|Yard
name|yard
init|=
name|getYard
argument_list|()
decl_stmt|;
name|Representation
name|test
init|=
name|yard
operator|.
name|create
argument_list|()
decl_stmt|;
name|assertNotNull
argument_list|(
name|test
argument_list|)
expr_stmt|;
name|Representation
name|test2
init|=
name|yard
operator|.
name|create
argument_list|()
decl_stmt|;
name|assertNotNull
argument_list|(
name|test2
argument_list|)
expr_stmt|;
name|assertNotSame
argument_list|(
name|test
argument_list|,
name|test2
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"Two Representation created with create() MUST NOT be equals"
argument_list|,
name|test
operator|.
name|equals
argument_list|(
name|test2
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCreateWithNull
parameter_list|()
throws|throws
name|YardException
block|{
name|Yard
name|yard
init|=
name|getYard
argument_list|()
decl_stmt|;
name|Representation
name|test
init|=
name|yard
operator|.
name|create
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"Parsing NULL to create(String) MUST create a valid Representation"
argument_list|,
name|test
argument_list|)
expr_stmt|;
name|representationIds
operator|.
name|add
argument_list|(
name|test
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
comment|//add id to cleanup list
name|Representation
name|test2
init|=
name|yard
operator|.
name|create
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"Parsing NULL to create(String) MUST create a valid Representation"
argument_list|,
name|test2
argument_list|)
expr_stmt|;
name|representationIds
operator|.
name|add
argument_list|(
name|test2
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
comment|//add id to cleanup list
name|assertNotSame
argument_list|(
name|test
argument_list|,
name|test2
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"Two Representation created with create(null) MUST NOT be equals"
argument_list|,
name|test
operator|.
name|equals
argument_list|(
name|test2
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
argument_list|(
name|expected
operator|=
name|IllegalArgumentException
operator|.
name|class
argument_list|)
specifier|public
name|void
name|testCreateWithEmptyString
parameter_list|()
throws|throws
name|YardException
block|{
name|getYard
argument_list|()
operator|.
name|create
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|//throws an IllegalArgumentException
block|}
annotation|@
name|Test
argument_list|(
name|expected
operator|=
name|IllegalArgumentException
operator|.
name|class
argument_list|)
specifier|public
name|void
name|testCreateWithExistingId
parameter_list|()
throws|throws
name|YardException
block|{
name|Yard
name|yard
init|=
name|getYard
argument_list|()
decl_stmt|;
name|Representation
name|test
init|=
name|create
argument_list|()
decl_stmt|;
name|assertNotNull
argument_list|(
name|test
argument_list|)
expr_stmt|;
name|yard
operator|.
name|create
argument_list|(
name|test
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
comment|//throws an IllegalArgumentException
block|}
annotation|@
name|Test
argument_list|(
name|expected
operator|=
name|NullPointerException
operator|.
name|class
argument_list|)
specifier|public
name|void
name|testIsRepresentationWithNull
parameter_list|()
throws|throws
name|YardException
block|{
name|getYard
argument_list|()
operator|.
name|isRepresentation
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
argument_list|(
name|expected
operator|=
name|IllegalArgumentException
operator|.
name|class
argument_list|)
specifier|public
name|void
name|testIsRepresentationWithEmptyString
parameter_list|()
throws|throws
name|YardException
block|{
name|getYard
argument_list|()
operator|.
name|isRepresentation
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
argument_list|(
name|expected
operator|=
name|NullPointerException
operator|.
name|class
argument_list|)
specifier|public
name|void
name|testStoreRepresentationWithNull
parameter_list|()
throws|throws
name|YardException
block|{
name|getYard
argument_list|()
operator|.
name|store
argument_list|(
operator|(
name|Representation
operator|)
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
argument_list|(
name|expected
operator|=
name|NullPointerException
operator|.
name|class
argument_list|)
specifier|public
name|void
name|testStoreRepresentationsWithNull
parameter_list|()
throws|throws
name|YardException
block|{
name|getYard
argument_list|()
operator|.
name|store
argument_list|(
operator|(
name|Iterable
argument_list|<
name|Representation
argument_list|>
operator|)
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testStoreRepresentation
parameter_list|()
throws|throws
name|YardException
block|{
comment|//NOTE: this does not test if the updated view of the representation is
comment|//      stored, but only that the store method works for representations
comment|//      that are already in the Yard AND representations that are not yet
comment|//      present within the yard
name|String
name|testId
init|=
literal|"urn:yard.test.testStoreRepresentation:representation.id1"
decl_stmt|;
name|String
name|testId2
init|=
literal|"urn:yard.test.testStoreRepresentation:representation.id2"
decl_stmt|;
name|Yard
name|yard
init|=
name|getYard
argument_list|()
decl_stmt|;
name|Representation
name|test
init|=
name|create
argument_list|(
name|testId
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|Representation
name|added
init|=
name|yard
operator|.
name|store
argument_list|(
name|test
argument_list|)
decl_stmt|;
comment|// this adds the representation
name|assertEquals
argument_list|(
name|test
argument_list|,
name|added
argument_list|)
expr_stmt|;
name|Representation
name|test2
init|=
name|create
argument_list|(
name|testId2
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|//this creates and adds the representation
comment|//now test that the representation can also be updated
name|added
operator|=
name|yard
operator|.
name|store
argument_list|(
name|test2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|test2
argument_list|,
name|added
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testStoreRepresentations
parameter_list|()
throws|throws
name|YardException
block|{
comment|//NOTE: this does not test if the updated view of the representation is
comment|//      stored, but only that the store method works for representations
comment|//      that are already in the Yard AND representations that are not yet
comment|//      present within the yard
name|String
name|testId
init|=
literal|"urn:yard.test.testStoreRepresentations:representation.id1"
decl_stmt|;
name|String
name|testId2
init|=
literal|"urn:yard.test.testStoreRepresentations:representation.id2"
decl_stmt|;
name|String
name|field
init|=
literal|"urn:the.field:used.for.this.Test"
decl_stmt|;
name|Yard
name|yard
init|=
name|getYard
argument_list|()
decl_stmt|;
name|Representation
name|test
init|=
name|create
argument_list|(
name|testId
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|Representation
name|test2
init|=
name|create
argument_list|(
name|testId2
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|//this creates and adds the representation
comment|//now add both and mix Representations that are already present in the yard
comment|//with an other that is not yet present in the yard
comment|//change the representations to be sure to force an update even if the
comment|//implementation checks for changes before updating a representation
name|test2
operator|.
name|add
argument_list|(
name|field
argument_list|,
literal|"test value 2"
argument_list|)
expr_stmt|;
name|Iterable
argument_list|<
name|Representation
argument_list|>
name|addedIterable
init|=
name|yard
operator|.
name|store
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|test
argument_list|,
name|test2
argument_list|)
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|addedIterable
argument_list|)
expr_stmt|;
name|Collection
argument_list|<
name|Representation
argument_list|>
name|added
init|=
name|asCollection
argument_list|(
name|addedIterable
operator|.
name|iterator
argument_list|()
argument_list|)
decl_stmt|;
comment|//test that both the parsed Representations where stored (updated& created)
name|assertTrue
argument_list|(
name|added
operator|.
name|remove
argument_list|(
name|test
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|added
operator|.
name|remove
argument_list|(
name|test2
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|added
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testStoreRepresentationsWithNullElement
parameter_list|()
throws|throws
name|YardException
block|{
name|String
name|testId
init|=
literal|"urn:yard.test.testStoreRepresentationsWithNullElement:representation.id"
decl_stmt|;
name|Yard
name|yard
init|=
name|getYard
argument_list|()
decl_stmt|;
name|Representation
name|test
init|=
name|create
argument_list|(
name|testId
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|Iterable
argument_list|<
name|Representation
argument_list|>
name|added
init|=
name|yard
operator|.
name|store
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|test
argument_list|,
literal|null
argument_list|)
argument_list|)
decl_stmt|;
comment|//now test that only the valid representation was added and the null
comment|//value was ignored
name|assertNotNull
argument_list|(
name|added
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|Representation
argument_list|>
name|addedIt
init|=
name|added
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|addedIt
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|test
argument_list|,
name|addedIt
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|addedIt
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
argument_list|(
name|expected
operator|=
name|NullPointerException
operator|.
name|class
argument_list|)
specifier|public
name|void
name|testGetRepresentationWithNull
parameter_list|()
throws|throws
name|YardException
block|{
name|getYard
argument_list|()
operator|.
name|getRepresentation
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
argument_list|(
name|expected
operator|=
name|IllegalArgumentException
operator|.
name|class
argument_list|)
specifier|public
name|void
name|testGetRepresentationWithEmptyString
parameter_list|()
throws|throws
name|YardException
block|{
name|getYard
argument_list|()
operator|.
name|getRepresentation
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testGetNonExistantRepresentation
parameter_list|()
throws|throws
name|YardException
block|{
name|String
name|id
init|=
literal|"urn:yard.test.testGetNonExistantRepresentation:representation.id"
decl_stmt|;
name|assertNull
argument_list|(
name|getYard
argument_list|()
operator|.
name|getRepresentation
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * This tests that {@link Representation} retrieved from the Yard do not      * influence other {@link Representation} instances for the same ID. It is      * important, that when different {@link Representation} instances are      * returned to different caller, that these do not influence each other.<p>      * It also tests, that any update to the {@link Representation} as managed      * by the {@link Yard} does also not influence {@link Representation}      * instances that where created before the change.      * @throws YardException      */
annotation|@
name|Test
specifier|public
name|void
name|testGetRepresentation
parameter_list|()
throws|throws
name|YardException
block|{
name|String
name|id
init|=
literal|"urn:yard.test.testGetRepresentation.id"
decl_stmt|;
name|Yard
name|yard
init|=
name|getYard
argument_list|()
decl_stmt|;
name|String
name|field
init|=
literal|"urn:the.field:used.for.this.Test"
decl_stmt|;
name|String
name|value1
init|=
literal|"this is a test"
decl_stmt|;
comment|//Representations created via the yard need to be created (as empty
comment|//representation within the yard
name|Representation
name|test
init|=
name|create
argument_list|(
name|id
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|//retrieve the representation from the store
name|Representation
name|retrieved
init|=
name|yard
operator|.
name|getRepresentation
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|retrieved
argument_list|)
expr_stmt|;
comment|//they MUST NOT be the same, but the MUST be equals
comment|//Note:
comment|//the fact that two representations with the same id are equals is tested
comment|//by the unit tests for the representation interface
name|assertEquals
argument_list|(
name|test
argument_list|,
name|retrieved
argument_list|)
expr_stmt|;
name|assertNotSame
argument_list|(
literal|"getRepresentation MUST return an new instance for each "
operator|+
literal|"call, so that changes in one return instance do not influence "
operator|+
literal|"an other returned instance!"
argument_list|,
name|test
argument_list|,
name|retrieved
argument_list|)
expr_stmt|;
comment|//now add a property to the original one
name|test
operator|.
name|add
argument_list|(
name|field
argument_list|,
name|value1
argument_list|)
expr_stmt|;
comment|//and check that the retrieved does not have the value
name|assertFalse
argument_list|(
name|retrieved
operator|.
name|get
argument_list|(
name|field
argument_list|)
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
comment|//now store the representation and check that updated are not reflected
comment|//within the retrieved one
name|yard
operator|.
name|store
argument_list|(
name|test
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|retrieved
operator|.
name|get
argument_list|(
name|field
argument_list|)
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
comment|//now retrieve again an representation
name|retrieved
operator|=
literal|null
expr_stmt|;
name|retrieved
operator|=
name|yard
operator|.
name|getRepresentation
argument_list|(
name|id
argument_list|)
expr_stmt|;
comment|//now the Representation MUST HAVE the new field
name|assertTrue
argument_list|(
name|retrieved
operator|.
name|get
argument_list|(
name|field
argument_list|)
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|value1
argument_list|,
name|retrieved
operator|.
name|getFirst
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
comment|//finally retrieve a second and perform the change test again
name|Representation
name|retrieved2
init|=
name|yard
operator|.
name|getRepresentation
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|retrieved
operator|.
name|removeAll
argument_list|(
name|field
argument_list|)
expr_stmt|;
comment|//check the value is still in retrieved2
name|assertTrue
argument_list|(
name|retrieved2
operator|.
name|get
argument_list|(
name|field
argument_list|)
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|value1
argument_list|,
name|retrieved2
operator|.
name|getFirst
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testIsRepresentation
parameter_list|()
throws|throws
name|YardException
block|{
name|String
name|id
init|=
literal|"urn:yard.test.testIsRepresentation:representation.id"
decl_stmt|;
name|Yard
name|yard
init|=
name|getYard
argument_list|()
decl_stmt|;
comment|//Representations created via the yard need to be created (as empty
comment|//representation within the yard
name|Representation
name|test
init|=
name|create
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|yard
operator|.
name|isRepresentation
argument_list|(
name|test
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|//Representations created via the ValueFactory MUST NOT be added to the
comment|//Yard
name|Representation
name|test2
init|=
name|create
argument_list|(
name|id
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|yard
operator|.
name|isRepresentation
argument_list|(
name|test2
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|//now store test2 and test again
name|yard
operator|.
name|store
argument_list|(
name|test2
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|yard
operator|.
name|isRepresentation
argument_list|(
name|test2
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|//now remove test and test again
name|yard
operator|.
name|remove
argument_list|(
name|test
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|yard
operator|.
name|isRepresentation
argument_list|(
name|test
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|yard
operator|.
name|remove
argument_list|(
name|test2
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|yard
operator|.
name|isRepresentation
argument_list|(
name|test2
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
argument_list|(
name|expected
operator|=
name|NullPointerException
operator|.
name|class
argument_list|)
specifier|public
name|void
name|testUpdateRepresentationWithNull
parameter_list|()
throws|throws
name|YardException
block|{
name|getYard
argument_list|()
operator|.
name|update
argument_list|(
operator|(
name|Representation
operator|)
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
argument_list|(
name|expected
operator|=
name|IllegalArgumentException
operator|.
name|class
argument_list|)
specifier|public
name|void
name|testUpdateRepresentationWithNonPresent
parameter_list|()
throws|throws
name|YardException
block|{
name|String
name|id
init|=
literal|"urn:yard.test.testUpdateRepresentationWithNonPresent:representation.id"
decl_stmt|;
name|Representation
name|test
init|=
name|create
argument_list|(
name|id
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|getYard
argument_list|()
operator|.
name|update
argument_list|(
name|test
argument_list|)
expr_stmt|;
comment|//throws an Exception because test is not part of the yard
block|}
annotation|@
name|Test
argument_list|(
name|expected
operator|=
name|NullPointerException
operator|.
name|class
argument_list|)
specifier|public
name|void
name|testUpdateRepresentationsWithNull
parameter_list|()
throws|throws
name|YardException
block|{
name|getYard
argument_list|()
operator|.
name|update
argument_list|(
operator|(
name|Iterable
argument_list|<
name|Representation
argument_list|>
operator|)
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testUpdateRepresentations
parameter_list|()
throws|throws
name|YardException
block|{
comment|//NOTE: this does not test if the updated view of the representation is
comment|//      stored, but only that the update method works correctly
name|Yard
name|yard
init|=
name|getYard
argument_list|()
decl_stmt|;
name|String
name|id1
init|=
literal|"urn:yard.test.testUpdateRepresentations:representation.id1"
decl_stmt|;
name|String
name|id2
init|=
literal|"urn:yard.test.testUpdateRepresentations:representation.id2"
decl_stmt|;
name|String
name|field
init|=
literal|"urn:the.field:used.for.this.Test"
decl_stmt|;
name|Representation
name|test1
init|=
name|create
argument_list|(
name|id1
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|Representation
name|test2
init|=
name|create
argument_list|(
name|id2
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|//change the representations to be sure to force an update even if the
comment|//implementation checks for changes before updating a representation
name|test1
operator|.
name|add
argument_list|(
name|field
argument_list|,
literal|"test value 1"
argument_list|)
expr_stmt|;
name|test2
operator|.
name|add
argument_list|(
name|field
argument_list|,
literal|"test value 2"
argument_list|)
expr_stmt|;
name|Iterable
argument_list|<
name|Representation
argument_list|>
name|updatedIterable
init|=
name|yard
operator|.
name|update
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|test1
argument_list|,
name|test2
argument_list|)
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|updatedIterable
argument_list|)
expr_stmt|;
name|Collection
argument_list|<
name|Representation
argument_list|>
name|updated
init|=
name|asCollection
argument_list|(
name|updatedIterable
operator|.
name|iterator
argument_list|()
argument_list|)
decl_stmt|;
comment|//test that both the parsed Representations where stored (updated& created)
name|assertTrue
argument_list|(
name|updated
operator|.
name|remove
argument_list|(
name|test1
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|updated
operator|.
name|remove
argument_list|(
name|test2
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|updated
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * When updating multiple null values need to be ignored.      * @throws YardException      */
annotation|@
name|Test
specifier|public
name|void
name|testUpdateRepresentationsWithNullElement
parameter_list|()
throws|throws
name|YardException
block|{
comment|//NOTE: this does not test if the updated view of the representation is
comment|//      stored, but only that the update method works correctly
name|Yard
name|yard
init|=
name|getYard
argument_list|()
decl_stmt|;
name|String
name|id1
init|=
literal|"urn:yard.test.testUpdateRepresentationsWithNullElement:representation.id"
decl_stmt|;
name|String
name|field
init|=
literal|"urn:the.field:used.for.this.Test"
decl_stmt|;
name|Representation
name|test1
init|=
name|create
argument_list|(
name|id1
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|//change the representations to be sure to force an update even if the
comment|//implementation checks for changes before updating a representation
name|test1
operator|.
name|add
argument_list|(
name|field
argument_list|,
literal|"test value 1"
argument_list|)
expr_stmt|;
name|Iterable
argument_list|<
name|Representation
argument_list|>
name|updated
init|=
name|yard
operator|.
name|update
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|test1
argument_list|,
literal|null
argument_list|)
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|updated
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|Representation
argument_list|>
name|updatedIt
init|=
name|updated
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|updatedIt
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|test1
argument_list|,
name|updatedIt
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|updatedIt
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * When updating multiple non present representations need to be ignored.      * @throws YardException      */
annotation|@
name|Test
specifier|public
name|void
name|testUpdateRepresentationsWithNonPresent
parameter_list|()
throws|throws
name|YardException
block|{
comment|//NOTE: this does not test if the updated view of the representation is
comment|//      stored, but only that the update method works correctly
name|Yard
name|yard
init|=
name|getYard
argument_list|()
decl_stmt|;
name|String
name|id1
init|=
literal|"urn:yard.test.testUpdateRepresentationsWithNonPresent:representation.id1"
decl_stmt|;
name|String
name|id2
init|=
literal|"urn:yard.test.testUpdateRepresentationsWithNonPresent:representation.id2"
decl_stmt|;
name|String
name|field
init|=
literal|"urn:the.field:used.for.this.Test"
decl_stmt|;
name|Representation
name|test1
init|=
name|create
argument_list|(
name|id1
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|//change the representations to be sure to force an update even if the
comment|//implementation checks for changes before updating a representation
name|test1
operator|.
name|add
argument_list|(
name|field
argument_list|,
literal|"test value 1"
argument_list|)
expr_stmt|;
comment|//create a 2nd Representation by using the ValueFactory (will not add it
comment|//to the yard!)
name|Representation
name|test2
init|=
name|create
argument_list|(
name|id2
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|//now test1 is present and test2 is not.
name|Iterable
argument_list|<
name|Representation
argument_list|>
name|updated
init|=
name|yard
operator|.
name|update
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|test1
argument_list|,
name|test2
argument_list|)
argument_list|)
decl_stmt|;
comment|//We expect that only test1 is updated and test2 is ignored
name|assertNotNull
argument_list|(
name|updated
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|Representation
argument_list|>
name|updatedIt
init|=
name|updated
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|updatedIt
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|test1
argument_list|,
name|updatedIt
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|updatedIt
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
argument_list|(
name|expected
operator|=
name|NullPointerException
operator|.
name|class
argument_list|)
specifier|public
name|void
name|testRemoveRepresentationWithNull
parameter_list|()
throws|throws
name|YardException
block|{
name|getYard
argument_list|()
operator|.
name|remove
argument_list|(
operator|(
name|String
operator|)
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Tests two things:<ol>      *<li> if representations are removed form the yard      *<li> if the representation instance is still valid after it is removed      *</ol>      * The second is very important, because Representations might still be      * used by other components after they are remove from the store they      * where created in      * @throws YardException      */
annotation|@
name|Test
specifier|public
name|void
name|testRemoveRepresentation
parameter_list|()
throws|throws
name|YardException
block|{
comment|//NOTE: This test needs not to use the create(..) method, because we
comment|//remove the created representation form the store anyway as part of the
comment|//test
name|String
name|id
init|=
literal|"urn:yard.test.tesrRemoveRepresentation:representation.id"
decl_stmt|;
name|String
name|field
init|=
literal|"urn:the.field:used.for.this.Test"
decl_stmt|;
name|String
name|testValue
init|=
literal|"This is a test"
decl_stmt|;
name|Yard
name|yard
init|=
name|getYard
argument_list|()
decl_stmt|;
name|Representation
name|test
init|=
name|yard
operator|.
name|getValueFactory
argument_list|()
operator|.
name|createRepresentation
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|test
operator|.
name|add
argument_list|(
name|field
argument_list|,
name|testValue
argument_list|)
expr_stmt|;
name|yard
operator|.
name|store
argument_list|(
name|test
argument_list|)
expr_stmt|;
comment|//store the representation
name|assertTrue
argument_list|(
name|yard
operator|.
name|isRepresentation
argument_list|(
name|test
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|//test if stored
name|test
operator|=
literal|null
expr_stmt|;
comment|//free the initial
comment|//create the instance form the store to test (2)
name|test
operator|=
name|yard
operator|.
name|getRepresentation
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|id
argument_list|,
name|test
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
comment|//only to be sure ...
name|yard
operator|.
name|remove
argument_list|(
name|test
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
comment|//test (1) - the remove
name|assertFalse
argument_list|(
name|yard
operator|.
name|isRepresentation
argument_list|(
name|test
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|//test if removed
comment|//test if the test object is not destroyed by removing the representation
comment|//it represents form the store (2)
name|assertEquals
argument_list|(
name|testValue
argument_list|,
name|test
operator|.
name|getFirst
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
argument_list|(
name|expected
operator|=
name|NullPointerException
operator|.
name|class
argument_list|)
specifier|public
name|void
name|testRemoveRepresentationsWithNull
parameter_list|()
throws|throws
name|YardException
block|{
name|getYard
argument_list|()
operator|.
name|remove
argument_list|(
operator|(
name|Iterable
argument_list|<
name|String
argument_list|>
operator|)
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Tests that multiple Representations are removed.       * @throws YardException      */
annotation|@
name|Test
specifier|public
name|void
name|testRemoveRepresentations
parameter_list|()
throws|throws
name|YardException
block|{
comment|//NOTE: This test needs not to use the create(..) method, because we
comment|//remove the created representation form the store anyway as part of the
comment|//test
name|String
name|id
init|=
literal|"urn:yard.test.testRemoveRepresentationsWithNullValue:representation.id1"
decl_stmt|;
name|String
name|id2
init|=
literal|"urn:yard.test.testRemoveRepresentationsWithNullValue:representation.id2"
decl_stmt|;
name|String
name|field
init|=
literal|"urn:the.field:used.for.this.Test"
decl_stmt|;
name|String
name|testValue
init|=
literal|"This is a test"
decl_stmt|;
name|Yard
name|yard
init|=
name|getYard
argument_list|()
decl_stmt|;
comment|//use both ways to add the two Representations (should make no differences,
comment|//but one never can know ...
name|Representation
name|test1
init|=
name|yard
operator|.
name|create
argument_list|(
name|id
argument_list|)
decl_stmt|;
comment|//create and add
name|Representation
name|test2
init|=
name|yard
operator|.
name|getValueFactory
argument_list|()
operator|.
name|createRepresentation
argument_list|(
name|id2
argument_list|)
decl_stmt|;
comment|//create
name|test2
operator|.
name|add
argument_list|(
name|field
argument_list|,
name|testValue
argument_list|)
expr_stmt|;
comment|//add value
name|yard
operator|.
name|store
argument_list|(
name|test2
argument_list|)
expr_stmt|;
comment|//store
name|assertTrue
argument_list|(
name|yard
operator|.
name|isRepresentation
argument_list|(
name|test1
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|//test if stored
name|assertTrue
argument_list|(
name|yard
operator|.
name|isRepresentation
argument_list|(
name|test2
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|yard
operator|.
name|remove
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|test1
operator|.
name|getId
argument_list|()
argument_list|,
name|test2
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|//remove
name|assertFalse
argument_list|(
name|yard
operator|.
name|isRepresentation
argument_list|(
name|test1
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|//test if removed
name|assertFalse
argument_list|(
name|yard
operator|.
name|isRepresentation
argument_list|(
name|test2
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Tests if<code>null</code> values within the Iterable are ignored and do      * not cause an Exception      * @throws YardException      */
annotation|@
name|Test
specifier|public
name|void
name|testRemoveRepresentationsWithNullValue
parameter_list|()
throws|throws
name|YardException
block|{
comment|//NOTE: This test needs not to use the create(..) method, because we
comment|//remove the created representation form the store anyway as part of the
comment|//test
name|String
name|id
init|=
literal|"urn:yard.test.testRemoveRepresentationsWithNullValue:representation.id"
decl_stmt|;
name|Yard
name|yard
init|=
name|getYard
argument_list|()
decl_stmt|;
name|Representation
name|test
init|=
name|yard
operator|.
name|create
argument_list|(
name|id
argument_list|)
decl_stmt|;
comment|//create and add
name|assertTrue
argument_list|(
name|yard
operator|.
name|isRepresentation
argument_list|(
name|test
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|yard
operator|.
name|remove
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|test
operator|.
name|getId
argument_list|()
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|yard
operator|.
name|isRepresentation
argument_list|(
name|test
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Tests that {@link Representation} IDs that are not stored by the yard are      * ignored by the multiple remove method      * @throws YardException      */
annotation|@
name|Test
specifier|public
name|void
name|testRemoveRepresentationsWithNonStoredValue
parameter_list|()
throws|throws
name|YardException
block|{
comment|//NOTE: This test needs not to use the create(..) method, because we
comment|//remove the created representation form the store anyway as part of the
comment|//test
name|String
name|id
init|=
literal|"urn:yard.test.testRemoveRepresentationsWithNullValue:representation.stored"
decl_stmt|;
name|String
name|id2
init|=
literal|"urn:yard.test.testRemoveRepresentationsWithNullValue:representation.notStored"
decl_stmt|;
name|Yard
name|yard
init|=
name|getYard
argument_list|()
decl_stmt|;
name|Representation
name|test
init|=
name|yard
operator|.
name|create
argument_list|(
name|id
argument_list|)
decl_stmt|;
comment|//create and add
name|assertTrue
argument_list|(
name|yard
operator|.
name|isRepresentation
argument_list|(
name|test
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|yard
operator|.
name|remove
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|test
operator|.
name|getId
argument_list|()
argument_list|,
name|id2
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|yard
operator|.
name|isRepresentation
argument_list|(
name|test
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|yard
operator|.
name|isRepresentation
argument_list|(
name|id2
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * The {@link Representation} as stored in the Yard MUST NOT change if the      * source {@link Representation} stored to the {@link Yard} or an      * Representation retrieved from the Yard is changed. Only the      * {@link Yard#store(Representation))} and the {@link Yard#update(Representation)}      * methods are allowed to synchronised the Representation within the Yard with      * the state (changes) of the parsed value.      * @throws YardException      */
annotation|@
name|Test
specifier|public
name|void
name|testChangeRepresentation
parameter_list|()
throws|throws
name|YardException
block|{
name|String
name|id
init|=
literal|"urn:yard.test.testChangeRepresentation:representation.id"
decl_stmt|;
name|String
name|field
init|=
literal|"urn:the.field:used.for.this.Test"
decl_stmt|;
name|String
name|testValue
init|=
literal|"This is a test"
decl_stmt|;
name|Yard
name|yard
init|=
name|getYard
argument_list|()
decl_stmt|;
comment|//use the ValueFactory to create the representation to ensure that this
comment|//instance has nothing to do with the store
name|Representation
name|test
init|=
name|create
argument_list|(
name|id
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|//now store the empty Representation
name|yard
operator|.
name|store
argument_list|(
name|test
argument_list|)
expr_stmt|;
comment|//now add a values
name|test
operator|.
name|add
argument_list|(
name|field
argument_list|,
name|testValue
argument_list|)
expr_stmt|;
comment|//now get the representation from the yard
name|Representation
name|stored
init|=
name|yard
operator|.
name|getRepresentation
argument_list|(
name|id
argument_list|)
decl_stmt|;
comment|//test if the stored version does not contain the value
name|assertFalse
argument_list|(
name|stored
operator|.
name|get
argument_list|(
name|field
argument_list|)
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|stored
operator|=
literal|null
expr_stmt|;
comment|//now store the updated version
name|yard
operator|.
name|store
argument_list|(
name|test
argument_list|)
expr_stmt|;
comment|//now check that the updated value is stored
name|stored
operator|=
name|yard
operator|.
name|getRepresentation
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|testValue
argument_list|,
name|stored
operator|.
name|getFirst
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
comment|//now we need to test if modifications of an Representation returned
name|test
operator|=
name|stored
expr_stmt|;
name|stored
operator|=
literal|null
expr_stmt|;
name|String
name|testValue2
init|=
literal|"This is an ohter test value"
decl_stmt|;
name|test
operator|.
name|add
argument_list|(
name|field
argument_list|,
name|testValue2
argument_list|)
expr_stmt|;
comment|//now get the representation from the yard and check that it still has
comment|//only one value
name|stored
operator|=
name|yard
operator|.
name|getRepresentation
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|Collection
argument_list|<
name|Object
argument_list|>
name|values
init|=
name|asCollection
argument_list|(
name|stored
operator|.
name|get
argument_list|(
name|field
argument_list|)
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|values
operator|.
name|remove
argument_list|(
name|testValue
argument_list|)
argument_list|)
expr_stmt|;
comment|//test that it contains the value
name|assertTrue
argument_list|(
name|values
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
comment|//and that there is only this value
name|values
operator|=
literal|null
expr_stmt|;
comment|//now update the stored version with the new state
name|stored
operator|=
literal|null
expr_stmt|;
name|stored
operator|=
name|yard
operator|.
name|update
argument_list|(
name|test
argument_list|)
expr_stmt|;
name|values
operator|=
name|asCollection
argument_list|(
name|stored
operator|.
name|get
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|values
operator|.
name|remove
argument_list|(
name|testValue
argument_list|)
argument_list|)
expr_stmt|;
comment|//test that it contains the original
name|assertTrue
argument_list|(
name|values
operator|.
name|remove
argument_list|(
name|testValue2
argument_list|)
argument_list|)
expr_stmt|;
comment|//test that it contains the 2nd value
name|assertTrue
argument_list|(
name|values
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
comment|//and that there are only these two values
name|values
operator|=
literal|null
expr_stmt|;
block|}
block|}
end_class

end_unit

