begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|core
operator|.
name|mapping
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|defaults
operator|.
name|DataTypeEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|mapping
operator|.
name|FieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|mapping
operator|.
name|FieldMapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Representation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|TextConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|ValueConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|Constraint
operator|.
name|ConstraintType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|util
operator|.
name|PatternUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * This is only an intermediate solution just to have the functionality.  * This needs to be refactored! This is something similar to a semantic lifting  * work flow that could used schema translation, reasoning ...<p>  * The goal is to build a simple Module that supports basics things (like the  * stuff provided by this implementation) and that allow other implementations  * to do the advanced stuff.<p>  * Currently I hope, that when the functionality is in place it is easier to  * see what a good design for this part of the Entityhub would be.  * TODO: refactoring (see above comment)  * @author Rupert Westenthaler  *  */
end_comment

begin_class
specifier|public
class|class
name|DefaultFieldMapperImpl
implements|implements
name|FieldMapper
block|{
specifier|private
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|DefaultFieldMapperImpl
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|FieldMapping
argument_list|>
name|mappings
decl_stmt|;
comment|//    private final Map<String,Collection<FieldMapping>> ignoreFieldMap;
comment|//    private final Map<Pattern,Collection<FieldMapping>> ignoreWildcardMap;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|FieldMapping
argument_list|>
argument_list|>
name|fieldMap
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|Pattern
argument_list|,
name|Set
argument_list|<
name|FieldMapping
argument_list|>
argument_list|>
name|wildcardMap
decl_stmt|;
specifier|private
name|Collection
argument_list|<
name|FieldMapping
argument_list|>
name|unmodMappings
decl_stmt|;
name|ValueConverterFactory
name|valueConverter
decl_stmt|;
comment|//private Map<String,FieldMapping> mappings = Collections.synchronizedMap(new HashMap<String, FieldMapping>());
specifier|public
name|DefaultFieldMapperImpl
parameter_list|(
name|ValueConverterFactory
name|valueConverter
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|mappings
operator|=
operator|new
name|HashSet
argument_list|<
name|FieldMapping
argument_list|>
argument_list|()
expr_stmt|;
name|unmodMappings
operator|=
name|Collections
operator|.
name|unmodifiableCollection
argument_list|(
name|mappings
argument_list|)
expr_stmt|;
name|fieldMap
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|FieldMapping
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|wildcardMap
operator|=
operator|new
name|HashMap
argument_list|<
name|Pattern
argument_list|,
name|Set
argument_list|<
name|FieldMapping
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
if|if
condition|(
name|valueConverter
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed ValueConverterFactory MUST NOT be NULL"
argument_list|)
throw|;
block|}
name|this
operator|.
name|valueConverter
operator|=
name|valueConverter
expr_stmt|;
comment|//        ignoreFieldMap = new HashMap<String, Collection<FieldMapping>>();
comment|//        ignoreWildcardMap = new HashMap<Pattern, Collection<FieldMapping>>();
block|}
comment|/**      * Internally used by clone      * @param fieldMap      * @param wildcardMap      */
specifier|private
name|DefaultFieldMapperImpl
parameter_list|(
name|ValueConverterFactory
name|valueConverter
parameter_list|,
name|Set
argument_list|<
name|FieldMapping
argument_list|>
name|mappings
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|FieldMapping
argument_list|>
argument_list|>
name|fieldMap
parameter_list|,
name|Map
argument_list|<
name|Pattern
argument_list|,
name|Set
argument_list|<
name|FieldMapping
argument_list|>
argument_list|>
name|wildcardMap
parameter_list|)
block|{
name|this
argument_list|(
name|valueConverter
argument_list|)
expr_stmt|;
name|this
operator|.
name|mappings
operator|.
name|addAll
argument_list|(
name|mappings
argument_list|)
expr_stmt|;
name|this
operator|.
name|fieldMap
operator|.
name|putAll
argument_list|(
name|fieldMap
argument_list|)
expr_stmt|;
name|this
operator|.
name|wildcardMap
operator|.
name|putAll
argument_list|(
name|wildcardMap
argument_list|)
expr_stmt|;
block|}
comment|/**      * Getter for all the defined Mappings for a given field name      * @param field the name of the field      * @return all the active Mappings      */
specifier|protected
name|List
argument_list|<
name|FieldMapping
argument_list|>
name|getMappings
parameter_list|(
name|String
name|field
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|FieldMapping
argument_list|>
name|mappings
init|=
operator|new
name|ArrayList
argument_list|<
name|FieldMapping
argument_list|>
argument_list|()
decl_stmt|;
comment|//first search the fieldMappings
name|Collection
argument_list|<
name|FieldMapping
argument_list|>
name|tmp
init|=
name|fieldMap
operator|.
name|get
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|!=
literal|null
condition|)
block|{
name|mappings
operator|.
name|addAll
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|//now iterate over the Wildcard Mappings
for|for
control|(
name|Entry
argument_list|<
name|Pattern
argument_list|,
name|Set
argument_list|<
name|FieldMapping
argument_list|>
argument_list|>
name|entry
range|:
name|wildcardMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|matcher
argument_list|(
name|field
argument_list|)
operator|.
name|find
argument_list|()
condition|)
block|{
name|mappings
operator|.
name|addAll
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|mappings
argument_list|,
name|FieldMappingUtils
operator|.
name|FIELD_MAPPING_COMPARATOR
argument_list|)
expr_stmt|;
return|return
name|mappings
return|;
block|}
comment|/* (non-Javadoc)      * @see org.apache.stanbol.entityhub.servicesapi.mapping.FieldMapper#addMapping(org.apache.stanbol.entityhub.servicesapi.mapping.FieldMapping)      */
specifier|public
name|void
name|addMapping
parameter_list|(
name|FieldMapping
name|mapping
parameter_list|)
block|{
if|if
condition|(
name|mapping
operator|==
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|mappings
operator|.
name|add
argument_list|(
name|mapping
argument_list|)
condition|)
block|{
if|if
condition|(
name|mapping
operator|.
name|usesWildcard
argument_list|()
condition|)
block|{
name|Pattern
name|fieldPattern
init|=
name|mapping
operator|.
name|getRegexPattern
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|wildcardMap
init|)
block|{
name|Set
argument_list|<
name|FieldMapping
argument_list|>
name|fieldPatternMappings
init|=
name|wildcardMap
operator|.
name|get
argument_list|(
name|fieldPattern
argument_list|)
decl_stmt|;
if|if
condition|(
name|fieldPatternMappings
operator|==
literal|null
condition|)
block|{
name|fieldPatternMappings
operator|=
operator|new
name|HashSet
argument_list|<
name|FieldMapping
argument_list|>
argument_list|()
expr_stmt|;
comment|//new TreeSet<FieldMapping>(FieldMappingUtils.FIELD_MAPPING_COMPARATOR);
name|wildcardMap
operator|.
name|put
argument_list|(
name|fieldPattern
argument_list|,
name|fieldPatternMappings
argument_list|)
expr_stmt|;
block|}
name|fieldPatternMappings
operator|.
name|add
argument_list|(
name|mapping
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|String
name|fieldName
init|=
name|mapping
operator|.
name|getFieldPattern
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|fieldMap
init|)
block|{
name|Set
argument_list|<
name|FieldMapping
argument_list|>
name|fieldPatternMappings
init|=
name|fieldMap
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|fieldPatternMappings
operator|==
literal|null
condition|)
block|{
name|fieldPatternMappings
operator|=
operator|new
name|HashSet
argument_list|<
name|FieldMapping
argument_list|>
argument_list|()
expr_stmt|;
comment|//new TreeSet<FieldMapping>(FieldMappingUtils.FIELD_MAPPING_COMPARATOR);
name|fieldMap
operator|.
name|put
argument_list|(
name|fieldName
argument_list|,
name|fieldPatternMappings
argument_list|)
expr_stmt|;
block|}
name|fieldPatternMappings
operator|.
name|add
argument_list|(
name|mapping
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//else already present -> nothing todo
block|}
specifier|public
name|Collection
argument_list|<
name|FieldMapping
argument_list|>
name|getMappings
parameter_list|()
block|{
return|return
name|unmodMappings
return|;
block|}
comment|//    private static String getPrefix(String fieldPattern){
comment|//        return fieldPattern.split("[\\?\\*]")[0];
comment|//    }
comment|/* (non-Javadoc)      * @see org.apache.stanbol.entityhub.servicesapi.mapping.FieldMapper#removeFieldMapping(org.apache.stanbol.entityhub.servicesapi.mapping.FieldMapping)      */
specifier|public
name|void
name|removeFieldMapping
parameter_list|(
name|FieldMapping
name|mapping
parameter_list|)
block|{
if|if
condition|(
name|mapping
operator|==
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|mappings
operator|.
name|remove
argument_list|(
name|mapping
argument_list|)
condition|)
block|{
if|if
condition|(
name|mapping
operator|.
name|usesWildcard
argument_list|()
condition|)
block|{
name|Pattern
name|fieldPattern
init|=
name|mapping
operator|.
name|getRegexPattern
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|wildcardMap
init|)
block|{
name|Collection
argument_list|<
name|FieldMapping
argument_list|>
name|fieldPatternMappings
init|=
name|wildcardMap
operator|.
name|get
argument_list|(
name|fieldPattern
argument_list|)
decl_stmt|;
if|if
condition|(
name|fieldPatternMappings
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|fieldPatternMappings
operator|.
name|remove
argument_list|(
name|mapping
argument_list|)
operator|&&
name|fieldPatternMappings
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//clean up the prefix if last value is removed
name|wildcardMap
operator|.
name|remove
argument_list|(
name|fieldPattern
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|String
name|fieldPattern
init|=
name|mapping
operator|.
name|getFieldPattern
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|fieldMap
init|)
block|{
name|Collection
argument_list|<
name|FieldMapping
argument_list|>
name|fieldPatternMappings
init|=
name|fieldMap
operator|.
name|get
argument_list|(
name|fieldPattern
argument_list|)
decl_stmt|;
if|if
condition|(
name|fieldPatternMappings
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|fieldPatternMappings
operator|.
name|remove
argument_list|(
name|mapping
argument_list|)
operator|&&
name|fieldPatternMappings
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//clean up the prefix if last value is removed
name|fieldMap
operator|.
name|remove
argument_list|(
name|fieldPattern
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|//else nothing todo
block|}
comment|/**      * Removes the FieldMapping based on the fieldPattern      * @param fieldPattern the field pattern      */
specifier|public
name|void
name|removeFieldMapping
parameter_list|(
name|String
name|fieldPattern
parameter_list|)
block|{
if|if
condition|(
name|fieldPattern
operator|==
literal|null
operator|||
name|fieldPattern
operator|.
name|length
argument_list|()
operator|<
literal|1
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|PatternUtils
operator|.
name|usesWildCard
argument_list|(
name|fieldPattern
argument_list|)
condition|)
block|{
name|Pattern
name|pattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|PatternUtils
operator|.
name|wildcardToRegex
argument_list|(
name|fieldPattern
argument_list|,
literal|true
argument_list|)
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|wildcardMap
init|)
block|{
name|wildcardMap
operator|.
name|remove
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
synchronized|synchronized
init|(
name|fieldMap
init|)
block|{
name|fieldMap
operator|.
name|remove
argument_list|(
name|fieldPattern
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* (non-Javadoc)      * @see org.apache.stanbol.entityhub.servicesapi.mapping.FieldMapper#applyMappings(org.apache.stanbol.entityhub.servicesapi.model.Representation, org.apache.stanbol.entityhub.servicesapi.model.Representation)      */
specifier|public
name|Representation
name|applyMappings
parameter_list|(
name|Representation
name|source
parameter_list|,
name|Representation
name|target
parameter_list|)
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|fields
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|String
argument_list|>
name|fieldIt
init|=
name|source
operator|.
name|getFieldNames
argument_list|()
init|;
name|fieldIt
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|fields
operator|.
name|add
argument_list|(
name|fieldIt
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|String
name|field
range|:
name|fields
control|)
block|{
comment|//            log.info("> process field: "+field);
comment|//get the active Mappings
name|List
argument_list|<
name|FieldMapping
argument_list|>
name|activeMappings
init|=
name|getMappings
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|activeMappings
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//get all the values (store them in an Collection, because we need them more than once)
name|Collection
argument_list|<
name|Object
argument_list|>
name|values
init|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|Object
argument_list|>
name|valueIt
init|=
name|source
operator|.
name|get
argument_list|(
name|field
argument_list|)
init|;
name|valueIt
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|values
operator|.
name|add
argument_list|(
name|valueIt
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//only to be sure, that this is not changed by Filters!
name|values
operator|=
name|Collections
operator|.
name|unmodifiableCollection
argument_list|(
name|values
argument_list|)
expr_stmt|;
comment|/*                  * (1) Before working with the values first analyse the active                  * mappings and filters. Two things                  * a) Init Wildcard Filters:                  *    Language filters set on namespaces are executed on all field                  *    mappings that define no language filter                  * b) calculate the mapped fields. Possible there are no mappings                  *    left. Than we need not to process all the values                  */
name|Set
argument_list|<
name|String
argument_list|>
name|targetFields
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|TextConstraint
name|globalFilter
init|=
literal|null
decl_stmt|;
name|Collection
argument_list|<
name|Object
argument_list|>
name|globalFiltered
init|=
literal|null
decl_stmt|;
comment|/*                  * NOTE: the mappings are sorted in the way, that the most                  *   prominent one will be at index 0. The wildcard "*" will                  *   be always the last.                  *   So we need to parse backwards because than more prominent                  *   things will overwrite and win!                  */
for|for
control|(
name|int
name|i
init|=
name|activeMappings
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|FieldMapping
name|mapping
init|=
name|activeMappings
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|mapping
operator|.
name|usesWildcard
argument_list|()
comment|//if wildcard
operator|&&
operator|!
name|mapping
operator|.
name|ignoreField
argument_list|()
operator|&&
comment|//and not ignore
name|mapping
operator|.
name|getFilter
argument_list|()
operator|!=
literal|null
operator|&&
comment|//and a filter is present
name|mapping
operator|.
name|getFilter
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|ConstraintType
operator|.
name|text
condition|)
block|{
comment|//and of type text
comment|//set the global text filter.
comment|//NOTE: the active mappings are sorted in that way, that
comment|//      the most specific one is set last
name|globalFilter
operator|=
operator|(
name|TextConstraint
operator|)
name|mapping
operator|.
name|getFilter
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|String
name|targetField
range|:
name|mapping
operator|.
name|getMappings
argument_list|()
control|)
block|{
if|if
condition|(
name|mapping
operator|.
name|ignoreField
argument_list|()
condition|)
block|{
name|targetFields
operator|.
name|remove
argument_list|(
name|targetField
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|targetFields
operator|.
name|add
argument_list|(
name|targetField
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//                log.info("    o targets: "+targetFields);
comment|//                log.info("    o global text filter: "+globalFilter);
if|if
condition|(
name|globalFilter
operator|!=
literal|null
condition|)
block|{
name|globalFiltered
operator|=
operator|new
name|HashSet
argument_list|<
name|Object
argument_list|>
argument_list|(
name|values
argument_list|)
expr_stmt|;
comment|//parse false ass third argument, because we need not to filter
comment|//non-Text values for wildcard filter!
name|processFilter
argument_list|(
name|globalFilter
argument_list|,
name|globalFiltered
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|//now process the mappings
for|for
control|(
name|FieldMapping
name|mapping
range|:
name|activeMappings
control|)
block|{
if|if
condition|(
operator|!
name|mapping
operator|.
name|ignoreField
argument_list|()
operator|&&
operator|!
name|Collections
operator|.
name|disjoint
argument_list|(
name|targetFields
argument_list|,
name|mapping
operator|.
name|getMappings
argument_list|()
argument_list|)
condition|)
block|{
name|processMapping
argument_list|(
name|mapping
argument_list|,
name|field
argument_list|,
name|values
argument_list|,
name|globalFiltered
argument_list|,
name|targetFields
argument_list|,
name|target
argument_list|)
expr_stmt|;
comment|//                    } else if(!mapping.ignoreField()) {
comment|//                        log.info(String.format("<< ignore mapping %s ",mapping));
comment|//                    } else {
comment|//                        log.info(String.format("<< %s ",mapping));
block|}
block|}
block|}
block|}
comment|/*          * TODO: return a "MappingReport"          * All mapping activities should be documented and stored with the          * MappedEntity as MappingActivity!          */
return|return
name|target
return|;
block|}
comment|/**      *      * @param mapping      * @param field      * @param values      * @param globalFiltered      * @param targets      */
specifier|private
name|void
name|processMapping
parameter_list|(
name|FieldMapping
name|mapping
parameter_list|,
name|String
name|field
parameter_list|,
name|Collection
argument_list|<
name|Object
argument_list|>
name|values
parameter_list|,
name|Collection
argument_list|<
name|Object
argument_list|>
name|globalFiltered
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|activeTargets
parameter_list|,
name|Representation
name|targetRepresentation
parameter_list|)
block|{
comment|//parsed mappings are all !ignore and some mappings are active
name|Collection
argument_list|<
name|Object
argument_list|>
name|filtered
decl_stmt|;
comment|//this collection will be modified by the filters later on
if|if
condition|(
name|globalFiltered
operator|==
literal|null
operator|||
comment|//if no global filter is present and therefore globalFiltered == null or
comment|//there is a more special text filter defined in this mapping
name|mapping
operator|.
name|getFilter
argument_list|()
operator|!=
literal|null
operator|&&
name|mapping
operator|.
name|getFilter
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|ConstraintType
operator|.
name|text
condition|)
block|{
name|filtered
operator|=
operator|new
name|HashSet
argument_list|<
name|Object
argument_list|>
argument_list|(
name|values
argument_list|)
expr_stmt|;
comment|//start with all values
block|}
else|else
block|{
comment|//start with the values filtered by the global filter
name|filtered
operator|=
operator|new
name|HashSet
argument_list|<
name|Object
argument_list|>
argument_list|(
name|globalFiltered
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mapping
operator|.
name|getFilter
argument_list|()
operator|!=
literal|null
condition|)
block|{
switch|switch
condition|(
name|mapping
operator|.
name|getFilter
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|value
case|:
name|ValueConstraint
name|valueConstraint
init|=
operator|(
name|ValueConstraint
operator|)
name|mapping
operator|.
name|getFilter
argument_list|()
decl_stmt|;
name|processFilter
argument_list|(
name|valueConstraint
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
break|break;
case|case
name|text
case|:
name|TextConstraint
name|textConstraint
init|=
operator|(
name|TextConstraint
operator|)
name|mapping
operator|.
name|getFilter
argument_list|()
decl_stmt|;
comment|//for wildcard mappings only filter TextValues. if the mapping is
comment|//for a specific field filter also non text values.
name|processFilter
argument_list|(
name|textConstraint
argument_list|,
name|filtered
argument_list|,
operator|!
name|mapping
operator|.
name|usesWildcard
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|log
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Filter of type %s are not supported -> select all values! (Constraint=%s)"
argument_list|,
name|mapping
operator|.
name|getFilter
argument_list|()
operator|.
name|getType
argument_list|()
argument_list|,
name|mapping
operator|.
name|getFilter
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*              * TODO: add general purpose functionality to apply Constraints.              * Currently this is done by the specific Query Implementations :(              *  - use the constraint to filter the values collection!              */
block|}
comment|//nothing to do
for|for
control|(
name|String
name|mappedField
range|:
name|mapping
operator|.
name|getMappings
argument_list|()
control|)
block|{
comment|//activeTargets still uses null for the current field
comment|// -> this is because wildcard filters can not know the actual field name
if|if
condition|(
name|activeTargets
operator|.
name|contains
argument_list|(
name|mappedField
argument_list|)
condition|)
block|{
comment|//so use null to match
if|if
condition|(
name|mappedField
operator|==
literal|null
condition|)
block|{
comment|//and than replace null with the field name
name|mappedField
operator|=
name|field
expr_stmt|;
block|}
comment|//                log.info(String.format(">> copy%s to %s&d values",
comment|//                        mappedField.equals(field)?"":" from "+field,mappedField,filtered.size()));
name|targetRepresentation
operator|.
name|add
argument_list|(
name|mappedField
argument_list|,
name|filtered
argument_list|)
expr_stmt|;
comment|//            } else {
comment|//                log.info(String.format("<< ignore%s %s",
comment|//                        mappedField.equals(field)?"":"mapping from "+field+"to",mappedField));
block|}
block|}
block|}
comment|/**      * This method filters the parsed {@link Text} values based on the languages      * parsed in the {@link TextConstraint}.      * This method modifies the parsed collection by using the      * {@link Iterator#remove()} method.      * @param textConstraint the text constraint containing the active languages      * @param values the values to filter. This method modifies this collection      * @return the modified collection to allow nested calls      */
specifier|private
name|Collection
argument_list|<
name|Object
argument_list|>
name|processFilter
parameter_list|(
name|TextConstraint
name|textConstraint
parameter_list|,
name|Collection
argument_list|<
name|Object
argument_list|>
name|values
parameter_list|,
name|boolean
name|filterNonTextValues
parameter_list|)
block|{
if|if
condition|(
name|textConstraint
operator|.
name|getText
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Filtering based on values is not implemented"
argument_list|)
expr_stmt|;
block|}
comment|/*          * TODO: If filterNonTextValues=true and acceptDefaultLanguate=true          *       we could also try to convert non-Text values to Text (by using          *       the valueConverter.          */
name|Set
argument_list|<
name|String
argument_list|>
name|langs
init|=
name|textConstraint
operator|.
name|getLanguages
argument_list|()
decl_stmt|;
name|boolean
name|acceptDefaultLanguage
init|=
name|textConstraint
operator|.
name|getLanguages
argument_list|()
operator|.
name|contains
argument_list|(
literal|null
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|Object
argument_list|>
name|it
init|=
name|values
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Object
name|value
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Text
condition|)
block|{
if|if
condition|(
operator|!
name|langs
operator|.
name|contains
argument_list|(
operator|(
operator|(
name|Text
operator|)
name|value
operator|)
operator|.
name|getLanguage
argument_list|()
argument_list|)
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
comment|//                    log.info(String.format("   - value %s(type:%s) rejected by text filter",value,value.getClass()));
comment|//                } else {
comment|//                    log.info(String.format("   + value %s(type:%s) accepted by text filter",value,value.getClass()));
block|}
block|}
elseif|else
if|if
condition|(
name|filterNonTextValues
operator|&&
name|value
operator|instanceof
name|String
condition|)
block|{
comment|//Strings only if the default language is enabled
if|if
condition|(
operator|!
name|acceptDefaultLanguage
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
comment|//                    log.info(String.format("   - value %s(type:%s) rejected by text filter",value,value.getClass()));
comment|//                } else {
comment|//                    log.info(String.format("   + value %s(type:%s) accepted by text filter",value,value.getClass()));
block|}
block|}
elseif|else
if|if
condition|(
name|filterNonTextValues
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
comment|//                log.info(String.format("   - value %s(type:%s) rejected by text filter",value,value.getClass()));
block|}
comment|//else non text value and filterNonTextValues=false -> nothing to do
block|}
return|return
name|values
return|;
block|}
comment|/**      * This method converts - or if not possible filters the parsed values based      * on the parsed constraint      * @param valueConstraint      * @param values      * @return      */
specifier|private
name|Collection
argument_list|<
name|Object
argument_list|>
name|processFilter
parameter_list|(
name|ValueConstraint
name|valueConstraint
parameter_list|,
name|Collection
argument_list|<
name|Object
argument_list|>
name|values
parameter_list|)
block|{
if|if
condition|(
name|valueConstraint
operator|.
name|getValue
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Filtering based on values is not yet implemented"
argument_list|)
expr_stmt|;
block|}
comment|//1) collect all active dataTypes
comment|//first a EnumSet for really fast containsAll ... operations
name|Set
argument_list|<
name|DataTypeEnum
argument_list|>
name|activeDataTypes
init|=
name|EnumSet
operator|.
name|noneOf
argument_list|(
name|DataTypeEnum
operator|.
name|class
argument_list|)
decl_stmt|;
comment|//second a List to keep track of the ordering of the dataTypes in the
comment|//constraint for later conversions!
name|List
argument_list|<
name|DataTypeEnum
argument_list|>
name|sortedActiveDataTypes
init|=
operator|new
name|ArrayList
argument_list|<
name|DataTypeEnum
argument_list|>
argument_list|(
name|valueConstraint
operator|.
name|getDataTypes
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|//NOTE: using a LinkedHashSet would slow down this code, because EnumSet
comment|//  gives constant processing time even for bulk operations!
for|for
control|(
name|String
name|dataTypeUri
range|:
name|valueConstraint
operator|.
name|getDataTypes
argument_list|()
control|)
block|{
name|DataTypeEnum
name|dataType
init|=
name|DataTypeEnum
operator|.
name|getDataType
argument_list|(
name|dataTypeUri
argument_list|)
decl_stmt|;
if|if
condition|(
name|dataType
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"DataType %s not supported"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|activeDataTypes
operator|.
name|add
argument_list|(
name|dataType
argument_list|)
condition|)
block|{
comment|//only of set has changed to avoid duplicates in the list
name|sortedActiveDataTypes
operator|.
name|add
argument_list|(
name|dataType
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//2) now process the values
comment|//        log.info(" --- Filter values ---");
comment|//calculating acceptable and not acceptable types needs some processing time
comment|//and usually values will be only of very less different types.
comment|//Therefore it makes sense to cache accepted and rejected types!
name|Set
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|accepted
init|=
operator|new
name|HashSet
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|rejected
init|=
operator|new
name|HashSet
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|//Set that stores rejected values. Such will be converted later on!
name|Set
argument_list|<
name|Object
argument_list|>
name|needConversion
init|=
operator|new
name|HashSet
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|Object
argument_list|>
name|it
init|=
name|values
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Object
name|value
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|accepted
operator|.
name|contains
argument_list|(
name|value
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
comment|//                log.info(String.format("   + value %s(type:%s) accepted by value filter",value,value.getClass()));
comment|//nothing to do
block|}
elseif|else
if|if
condition|(
name|rejected
operator|.
name|contains
argument_list|(
name|value
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
comment|//remove also the current value of that type
name|needConversion
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|//save as value that need to be converted
comment|//                log.info(String.format("   - value %s(type:%s) rejected by value filter",value,value.getClass()));
block|}
else|else
block|{
comment|//new class ... calculate
name|Set
argument_list|<
name|DataTypeEnum
argument_list|>
name|valueTypes
init|=
name|DataTypeEnum
operator|.
name|getAllDataTypes
argument_list|(
name|value
operator|.
name|getClass
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|valueTypes
operator|.
name|removeAll
argument_list|(
name|activeDataTypes
argument_list|)
condition|)
block|{
name|accepted
operator|.
name|add
argument_list|(
name|value
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
comment|//                    log.info(String.format("   + value %s(type:%s) accepted by value filter",value,value.getClass()));
block|}
else|else
block|{
name|rejected
operator|.
name|add
argument_list|(
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
comment|//remove the Item
name|needConversion
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|//save as value that need to be converted
comment|//                    log.info(String.format("   - value %s(type:%s) rejected by value filter",value,value.getClass()));
block|}
block|}
block|}
comment|//3) try to convert values to the active dataTypes
comment|//        log.info(" --- Try to Convert rejected values ---");
for|for
control|(
name|Object
name|value
range|:
name|needConversion
control|)
block|{
name|Object
name|converted
init|=
literal|null
decl_stmt|;
name|DataTypeEnum
name|convertedTo
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|DataTypeEnum
argument_list|>
name|dataTypes
init|=
name|sortedActiveDataTypes
operator|.
name|iterator
argument_list|()
init|;
comment|//iterate over all active dataTypes
name|converted
operator|==
literal|null
operator|&&
name|dataTypes
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
comment|//while converted still null and more dataTypes to try
name|convertedTo
operator|=
name|dataTypes
operator|.
name|next
argument_list|()
expr_stmt|;
name|converted
operator|=
name|valueConverter
operator|.
name|convert
argument_list|(
name|value
argument_list|,
name|convertedTo
operator|.
name|getUri
argument_list|()
argument_list|)
expr_stmt|;
comment|//try the conversion
block|}
if|if
condition|(
name|converted
operator|!=
literal|null
condition|)
block|{
comment|//                log.info(String.format("   + value %s(javaType=%s) successfully converted to %s(datatype=%s)",
comment|//                        value,value.getClass().getSimpleName(),converted,convertedTo.getShortName()));
name|values
operator|.
name|add
argument_list|(
name|converted
argument_list|)
expr_stmt|;
comment|//            } else {
comment|//                log.info(String.format("   - value %s(javaType=%s) could not be converted"),
comment|//                        value,value.getClass().getSimpleName());
block|}
block|}
return|return
name|values
return|;
block|}
annotation|@
name|Override
specifier|public
name|DefaultFieldMapperImpl
name|clone
parameter_list|()
block|{
return|return
operator|new
name|DefaultFieldMapperImpl
argument_list|(
name|this
operator|.
name|valueConverter
argument_list|,
name|this
operator|.
name|mappings
argument_list|,
name|this
operator|.
name|fieldMap
argument_list|,
name|this
operator|.
name|wildcardMap
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|mappings
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|o
operator|!=
literal|null
operator|&&
name|o
operator|instanceof
name|DefaultFieldMapperImpl
operator|&&
operator|(
operator|(
name|DefaultFieldMapperImpl
operator|)
name|o
operator|)
operator|.
name|mappings
operator|.
name|equals
argument_list|(
name|mappings
argument_list|)
return|;
block|}
block|}
end_class

end_unit

