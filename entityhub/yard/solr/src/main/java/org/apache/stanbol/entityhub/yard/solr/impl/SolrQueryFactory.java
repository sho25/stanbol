begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|impl
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CommonParams
operator|.
name|STREAM_BODY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|MoreLikeThisParams
operator|.
name|INTERESTING_TERMS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|MoreLikeThisParams
operator|.
name|MATCH_INCLUDE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|MoreLikeThisParams
operator|.
name|MIN_DOC_FREQ
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|MoreLikeThisParams
operator|.
name|MIN_TERM_FREQ
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|MoreLikeThisParams
operator|.
name|SIMILARITY_FIELDS
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|CommonParams
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|params
operator|.
name|MoreLikeThisParams
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|utils
operator|.
name|SolrUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|core
operator|.
name|model
operator|.
name|InMemoryValueFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|core
operator|.
name|query
operator|.
name|DefaultQueryFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|defaults
operator|.
name|SpecialFieldEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Representation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|ValueFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|rdf
operator|.
name|RdfResourceEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|Constraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|FieldQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|Query
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|RangeConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|ReferenceConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|SimilarityConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|TextConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|ValueConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|Constraint
operator|.
name|ConstraintType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|ValueConstraint
operator|.
name|MODE
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|defaults
operator|.
name|IndexDataTypeEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|impl
operator|.
name|queryencoders
operator|.
name|AssignmentEncoder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|impl
operator|.
name|queryencoders
operator|.
name|DataTypeEncoder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|impl
operator|.
name|queryencoders
operator|.
name|FieldEncoder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|impl
operator|.
name|queryencoders
operator|.
name|GeEncoder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|impl
operator|.
name|queryencoders
operator|.
name|GtEncoder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|impl
operator|.
name|queryencoders
operator|.
name|LangEncoder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|impl
operator|.
name|queryencoders
operator|.
name|LeEncoder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|impl
operator|.
name|queryencoders
operator|.
name|LtEncoder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|impl
operator|.
name|queryencoders
operator|.
name|RegexEncoder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|impl
operator|.
name|queryencoders
operator|.
name|WildcardEncoder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|model
operator|.
name|FieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|model
operator|.
name|IndexDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|model
operator|.
name|IndexField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|model
operator|.
name|IndexValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|model
operator|.
name|IndexValueFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|model
operator|.
name|NoConverterException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|query
operator|.
name|ConstraintTypePosition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|query
operator|.
name|EncodedConstraintParts
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|query
operator|.
name|IndexConstraintTypeEncoder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|query
operator|.
name|IndexConstraintTypeEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * This class is responsible of converting the queries used by Entityhub to queries that can be executed via  * the Solr RESTfull interface.  *<p>  * For this conversion the {@link IndexValueFactory} and the {@link FieldMapper} as used to index the  * documents in the index must be parsed.  *<p>  * TODO: This class currently contains the  *<ul>  *<li>general usable functionality to convert {@link Query} instances to the according representation in  * index constraints (see {@link IndexConstraintTypeEnum} and {@link IndexConstraint}  *<li>general usable functionality to combine the constraints to an tree of AND and OR constraints  *<li>SolrSpecific configuration of {@link IndexConstraintTypeEncoder}. This need to be made generic to allow  * different encoder implementations for other Document Stores  *<li>the Solr Specific encodings of the AND and OR tree  *</ul>  * Splitting such things up in several different components should make it easy to add support for other  * DocumentStores!  *   * @author Rupert Westenthaler  *   */
end_comment

begin_class
specifier|public
class|class
name|SolrQueryFactory
block|{
specifier|public
specifier|static
specifier|final
name|String
name|MLT_QUERY_TYPE
init|=
literal|"/"
operator|+
name|MoreLikeThisParams
operator|.
name|MLT
decl_stmt|;
comment|/**      * Allows to limit the maximum Numbers of Query Results for any kind of Query. For now it is set to 1024.      */
specifier|public
specifier|static
specifier|final
name|Integer
name|MAX_QUERY_RESULTS
init|=
literal|1024
decl_stmt|;
comment|/**      * The default limit of results for queries      */
specifier|public
specifier|static
specifier|final
name|Integer
name|DEFAULT_QUERY_RESULTS
init|=
literal|10
decl_stmt|;
specifier|private
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SolrQueryFactory
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|FieldMapper
name|fieldMapper
decl_stmt|;
specifier|private
specifier|final
name|IndexValueFactory
name|indexValueFactory
decl_stmt|;
specifier|private
specifier|final
name|ValueFactory
name|valueFactory
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|IndexConstraintTypeEnum
argument_list|,
name|IndexConstraintTypeEncoder
argument_list|<
name|?
argument_list|>
argument_list|>
name|constraintEncoders
decl_stmt|;
specifier|private
name|String
name|domain
decl_stmt|;
specifier|private
name|Integer
name|maxQueryResults
init|=
name|MAX_QUERY_RESULTS
decl_stmt|;
specifier|private
name|Integer
name|defaultQueryResults
init|=
name|DEFAULT_QUERY_RESULTS
decl_stmt|;
specifier|public
name|SolrQueryFactory
parameter_list|(
name|ValueFactory
name|valueFactory
parameter_list|,
name|IndexValueFactory
name|indexValueFactory
parameter_list|,
name|FieldMapper
name|fieldMapper
parameter_list|)
block|{
if|if
condition|(
name|fieldMapper
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed FieldMapper MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|indexValueFactory
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed IndexValueFactory MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|valueFactory
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed ValueFactory MUST NOT be NULL"
argument_list|)
throw|;
block|}
name|this
operator|.
name|valueFactory
operator|=
name|valueFactory
expr_stmt|;
name|this
operator|.
name|fieldMapper
operator|=
name|fieldMapper
expr_stmt|;
name|this
operator|.
name|indexValueFactory
operator|=
name|indexValueFactory
expr_stmt|;
name|this
operator|.
name|constraintEncoders
operator|=
operator|new
name|HashMap
argument_list|<
name|IndexConstraintTypeEnum
argument_list|,
name|IndexConstraintTypeEncoder
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
comment|// TODO: Make this configuration more flexible!
name|constraintEncoders
operator|.
name|put
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|LANG
argument_list|,
operator|new
name|LangEncoder
argument_list|(
name|fieldMapper
argument_list|)
argument_list|)
expr_stmt|;
name|constraintEncoders
operator|.
name|put
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|DATATYPE
argument_list|,
operator|new
name|DataTypeEncoder
argument_list|(
name|indexValueFactory
argument_list|,
name|fieldMapper
argument_list|)
argument_list|)
expr_stmt|;
name|constraintEncoders
operator|.
name|put
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|FIELD
argument_list|,
operator|new
name|FieldEncoder
argument_list|(
name|fieldMapper
argument_list|)
argument_list|)
expr_stmt|;
name|constraintEncoders
operator|.
name|put
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|EQ
argument_list|,
operator|new
name|AssignmentEncoder
argument_list|(
name|indexValueFactory
argument_list|)
argument_list|)
expr_stmt|;
name|constraintEncoders
operator|.
name|put
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|WILDCARD
argument_list|,
operator|new
name|WildcardEncoder
argument_list|(
name|indexValueFactory
argument_list|)
argument_list|)
expr_stmt|;
name|constraintEncoders
operator|.
name|put
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|REGEX
argument_list|,
operator|new
name|RegexEncoder
argument_list|(
name|indexValueFactory
argument_list|)
argument_list|)
expr_stmt|;
name|constraintEncoders
operator|.
name|put
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|GE
argument_list|,
operator|new
name|GeEncoder
argument_list|(
name|indexValueFactory
argument_list|)
argument_list|)
expr_stmt|;
name|constraintEncoders
operator|.
name|put
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|LE
argument_list|,
operator|new
name|LeEncoder
argument_list|(
name|indexValueFactory
argument_list|)
argument_list|)
expr_stmt|;
name|constraintEncoders
operator|.
name|put
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|GT
argument_list|,
operator|new
name|GtEncoder
argument_list|(
name|indexValueFactory
argument_list|)
argument_list|)
expr_stmt|;
name|constraintEncoders
operator|.
name|put
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|LT
argument_list|,
operator|new
name|LtEncoder
argument_list|(
name|indexValueFactory
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
enum|enum
name|SELECT
block|{
name|ID
block|,
name|QUERY
block|,
name|ALL
block|}
comment|/**      * Converts the field query to a SolrQuery. In addition changes the parsed      * FieldQuery (e.g. removing unsupported features, setting defaults for      * missing parameters)      * @param fieldQuery the field query (will be modified to reflect the query      * as executed)      * @param select the SELECT mode      * @return the SolrQuery      */
specifier|public
name|SolrQuery
name|parseFieldQuery
parameter_list|(
name|FieldQuery
name|fieldQuery
parameter_list|,
name|SELECT
name|select
parameter_list|)
block|{
name|SolrQuery
name|query
init|=
name|initSolrQuery
argument_list|(
name|fieldQuery
argument_list|)
decl_stmt|;
name|setSelected
argument_list|(
name|query
argument_list|,
name|fieldQuery
argument_list|,
name|select
argument_list|)
expr_stmt|;
name|StringBuilder
name|queryString
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Constraint
argument_list|>
name|processedFieldConstraints
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Constraint
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|firstConstraint
init|=
literal|true
decl_stmt|;
name|boolean
name|similarityConstraintPresent
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Constraint
argument_list|>
name|fieldConstraint
range|:
name|fieldQuery
control|)
block|{
if|if
condition|(
name|fieldConstraint
operator|.
name|getValue
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|ConstraintType
operator|.
name|similarity
condition|)
block|{
comment|// TODO: log make the FieldQuery ensure that there is no more than one instead of similarity
comment|// constraint per query
name|List
argument_list|<
name|String
argument_list|>
name|fields
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|fields
operator|.
name|add
argument_list|(
name|fieldConstraint
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|SimilarityConstraint
name|simConstraint
init|=
operator|(
name|SimilarityConstraint
operator|)
name|fieldConstraint
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|IndexValue
name|indexValue
init|=
name|indexValueFactory
operator|.
name|createIndexValue
argument_list|(
name|simConstraint
operator|.
name|getContext
argument_list|()
argument_list|)
decl_stmt|;
name|fields
operator|.
name|addAll
argument_list|(
name|simConstraint
operator|.
name|getAdditionalFields
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|similarityConstraintPresent
condition|)
block|{
name|similarityConstraintPresent
operator|=
literal|true
expr_stmt|;
comment|//similarity constraint present
comment|//add the constraint to the query
name|query
operator|.
name|setQueryType
argument_list|(
name|MLT_QUERY_TYPE
argument_list|)
expr_stmt|;
name|query
operator|.
name|set
argument_list|(
name|MATCH_INCLUDE
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|query
operator|.
name|set
argument_list|(
name|MIN_DOC_FREQ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|query
operator|.
name|set
argument_list|(
name|MIN_TERM_FREQ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|query
operator|.
name|set
argument_list|(
name|INTERESTING_TERMS
argument_list|,
literal|"details"
argument_list|)
expr_stmt|;
name|query
operator|.
name|set
argument_list|(
literal|"mlt.boost"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|//testing
name|List
argument_list|<
name|String
argument_list|>
name|indexFields
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|field
range|:
name|fields
control|)
block|{
name|IndexField
name|indexField
init|=
operator|new
name|IndexField
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|field
argument_list|)
argument_list|,
name|IndexDataTypeEnum
operator|.
name|TXT
operator|.
name|getIndexType
argument_list|()
argument_list|)
decl_stmt|;
name|indexFields
operator|.
name|addAll
argument_list|(
name|fieldMapper
operator|.
name|getFieldNames
argument_list|(
name|indexField
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|query
operator|.
name|set
argument_list|(
name|SIMILARITY_FIELDS
argument_list|,
name|indexFields
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|fields
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|query
operator|.
name|set
argument_list|(
name|STREAM_BODY
argument_list|,
name|indexValue
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|processedFieldConstraints
operator|.
name|put
argument_list|(
name|fieldConstraint
operator|.
name|getKey
argument_list|()
argument_list|,
name|fieldConstraint
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//similarity constraint already present -> ignore further
comment|//NOTE: users are informed about that by NOT including further
comment|//      similarity constraints in the query included in the
comment|//      response
name|log
operator|.
name|warn
argument_list|(
literal|"The parsed FieldQuery contains multiple Similarity constraints."
operator|+
literal|"However only a single one can be supported per query. Because of "
operator|+
literal|"this all further Similarity constraints will be ignored!"
argument_list|)
expr_stmt|;
name|log
operator|.
name|warn
argument_list|(
literal|"Ignore SimilarityConstraint:"
argument_list|)
expr_stmt|;
name|log
operator|.
name|warn
argument_list|(
literal|"> Field      : {}"
argument_list|,
name|fieldConstraint
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|warn
argument_list|(
literal|"> Context    : {}"
argument_list|,
name|simConstraint
operator|.
name|getContext
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|warn
argument_list|(
literal|"> Add Fields : {}"
argument_list|,
name|simConstraint
operator|.
name|getAdditionalFields
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|IndexConstraint
name|indexConstraint
init|=
name|createIndexConstraint
argument_list|(
name|fieldConstraint
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexConstraint
operator|.
name|isInvalid
argument_list|()
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to create IndexConstraint for Constraint {} (type: {}) and Field {} (Reosens: {})"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|fieldConstraint
operator|.
name|getValue
argument_list|()
block|,
name|fieldConstraint
operator|.
name|getValue
argument_list|()
operator|.
name|getType
argument_list|()
block|,
name|fieldConstraint
operator|.
name|getKey
argument_list|()
block|,
name|indexConstraint
operator|.
name|getInvalidMessages
argument_list|()
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|firstConstraint
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|firstConstraint
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|") AND ("
argument_list|)
expr_stmt|;
block|}
name|indexConstraint
operator|.
name|encode
argument_list|(
name|queryString
argument_list|)
expr_stmt|;
comment|//set the constraint (may be changed because of some unsupported features)
name|processedFieldConstraints
operator|.
name|put
argument_list|(
name|fieldConstraint
operator|.
name|getKey
argument_list|()
argument_list|,
name|indexConstraint
operator|.
name|getFieldQueryConstraint
argument_list|()
operator|==
literal|null
condition|?
comment|//if null
name|fieldConstraint
operator|.
name|getValue
argument_list|()
else|:
comment|//assume no change and add the parsed one
name|indexConstraint
operator|.
name|getFieldQueryConstraint
argument_list|()
argument_list|)
expr_stmt|;
comment|//add the changed version
block|}
block|}
block|}
if|if
condition|(
operator|!
name|firstConstraint
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
comment|//set the constraints as processed to the parsed query
name|fieldQuery
operator|.
name|removeAllConstraints
argument_list|()
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Constraint
argument_list|>
name|constraint
range|:
name|processedFieldConstraints
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|fieldQuery
operator|.
name|setConstraint
argument_list|(
name|constraint
operator|.
name|getKey
argument_list|()
argument_list|,
name|constraint
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|queryString
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|String
name|qs
init|=
name|queryString
operator|.
name|toString
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"QueryString: {}"
argument_list|,
name|qs
argument_list|)
expr_stmt|;
if|if
condition|(
name|MLT_QUERY_TYPE
operator|.
name|equals
argument_list|(
name|query
operator|.
name|getQueryType
argument_list|()
argument_list|)
condition|)
block|{
name|query
operator|.
name|set
argument_list|(
name|CommonParams
operator|.
name|FQ
argument_list|,
name|qs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|query
operator|.
name|setQuery
argument_list|(
name|qs
argument_list|)
expr_stmt|;
block|}
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Solr Query: {}"
argument_list|,
name|query
argument_list|)
expr_stmt|;
return|return
name|query
return|;
block|}
comment|/**      * TODO: Currently I have no Idea how to determine all the fields to be selected, because There are any      * number of possibilities for field names in the index (different data types, different languages ...).      * Therefore currently I select all fields and apply the filter when converting the {@link SolrDocument}s      * in the result to the {@link Representation}.      *<p>      * The only thing I can do is to select only the ID if an empty list is parsed as selected.      *       * @param query      * @param selected      */
specifier|private
name|void
name|setSelected
parameter_list|(
name|SolrQuery
name|query
parameter_list|,
name|FieldQuery
name|fieldQuery
parameter_list|,
name|SELECT
name|select
parameter_list|)
block|{
switch|switch
condition|(
name|select
condition|)
block|{
case|case
name|ID
case|:
name|query
operator|.
name|addField
argument_list|(
name|fieldMapper
operator|.
name|getDocumentIdField
argument_list|()
argument_list|)
expr_stmt|;
name|fieldQuery
operator|.
name|removeAllSelectedFields
argument_list|()
expr_stmt|;
break|break;
case|case
name|QUERY
case|:
if|if
condition|(
name|fieldQuery
operator|.
name|getSelectedFields
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|query
operator|.
name|addField
argument_list|(
name|fieldMapper
operator|.
name|getDocumentIdField
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|query
operator|.
name|addField
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
comment|// See to do in java doc of this method
comment|// for(String field : selected){
comment|// if(field != null&& !field.isEmpty()){
comment|// fieldMapper.getFieldNames(new IndexField(Arrays.asList(field), null, null));
comment|// }
comment|// }
block|}
break|break;
case|case
name|ALL
case|:
name|query
operator|.
name|addField
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unknown SELECT status %s! Adapt this implementation to the new value of the Enumeration"
argument_list|,
name|select
argument_list|)
argument_list|)
throw|;
block|}
comment|// add the select for the score
name|query
operator|.
name|addField
argument_list|(
literal|"score"
argument_list|)
expr_stmt|;
name|fieldQuery
operator|.
name|addSelectedField
argument_list|(
name|RdfResourceEnum
operator|.
name|resultScore
operator|.
name|getUri
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|IndexConstraint
name|createIndexConstraint
parameter_list|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Constraint
argument_list|>
name|fieldConstraint
parameter_list|)
block|{
name|IndexConstraint
name|indexConstraint
init|=
operator|new
name|IndexConstraint
argument_list|(
name|fieldConstraint
operator|.
name|getKey
argument_list|()
argument_list|,
name|fieldConstraint
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|fieldConstraint
operator|.
name|getValue
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|value
case|:
name|initValueConstraint
argument_list|(
name|indexConstraint
argument_list|)
expr_stmt|;
break|break;
case|case
name|text
case|:
name|initTextConstraint
argument_list|(
name|indexConstraint
argument_list|)
expr_stmt|;
break|break;
case|case
name|range
case|:
name|initRangeConstraint
argument_list|(
name|indexConstraint
argument_list|)
expr_stmt|;
break|break;
case|case
name|similarity
case|:
comment|// handled by the caller directly pass
break|break;
default|default:
name|indexConstraint
operator|.
name|setInvalid
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"ConstraintType %s not supported by!"
argument_list|,
name|fieldConstraint
operator|.
name|getValue
argument_list|()
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|indexConstraint
return|;
block|}
comment|/**      * @param indexConstraint      * @param rangeConstraint      */
specifier|private
name|void
name|initRangeConstraint
parameter_list|(
name|IndexConstraint
name|indexConstraint
parameter_list|)
block|{
name|RangeConstraint
name|rangeConstraint
init|=
operator|(
name|RangeConstraint
operator|)
name|indexConstraint
operator|.
name|getConstraint
argument_list|()
decl_stmt|;
comment|// we need to find the Index DataType for the range query
name|IndexDataType
name|dataType
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|rangeConstraint
operator|.
name|getLowerBound
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|dataType
operator|=
name|indexValueFactory
operator|.
name|createIndexValue
argument_list|(
name|rangeConstraint
operator|.
name|getLowerBound
argument_list|()
argument_list|)
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|rangeConstraint
operator|.
name|getUpperBound
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|IndexDataType
name|upperDataType
init|=
name|indexValueFactory
operator|.
name|createIndexValue
argument_list|(
name|rangeConstraint
operator|.
name|getUpperBound
argument_list|()
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|dataType
operator|==
literal|null
condition|)
block|{
name|dataType
operator|=
name|upperDataType
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|dataType
operator|.
name|equals
argument_list|(
name|upperDataType
argument_list|)
condition|)
block|{
name|indexConstraint
operator|.
name|setInvalid
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"A Range Query MUST use the same data type for the upper "
operator|+
literal|"and lover Bound! (lower:[value=%s|datatype=%s] | "
operator|+
literal|"upper:[value=%s|datatype=%s])"
argument_list|,
name|rangeConstraint
operator|.
name|getLowerBound
argument_list|()
argument_list|,
name|dataType
argument_list|,
name|rangeConstraint
operator|.
name|getUpperBound
argument_list|()
argument_list|,
name|upperDataType
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|dataType
operator|==
literal|null
condition|)
block|{
name|indexConstraint
operator|.
name|setInvalid
argument_list|(
literal|"A Range Constraint MUST define at least a lower or an upper bound!"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//set the DATATYPE and FIED using an IndexField
name|indexConstraint
operator|.
name|setIndexFieldConstraints
argument_list|(
operator|new
name|IndexField
argument_list|(
name|indexConstraint
operator|.
name|getPath
argument_list|()
argument_list|,
name|dataType
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//set the value range
if|if
condition|(
name|rangeConstraint
operator|.
name|isInclusive
argument_list|()
condition|)
block|{
name|indexConstraint
operator|.
name|setFieldConstraint
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|LE
argument_list|,
name|rangeConstraint
operator|.
name|getUpperBound
argument_list|()
argument_list|)
expr_stmt|;
name|indexConstraint
operator|.
name|setFieldConstraint
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|GE
argument_list|,
name|rangeConstraint
operator|.
name|getLowerBound
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indexConstraint
operator|.
name|setFieldConstraint
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|LT
argument_list|,
name|rangeConstraint
operator|.
name|getUpperBound
argument_list|()
argument_list|)
expr_stmt|;
name|indexConstraint
operator|.
name|setFieldConstraint
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|GT
argument_list|,
name|rangeConstraint
operator|.
name|getLowerBound
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * @param indexConstraint      * @param textConstraint      */
specifier|private
name|void
name|initTextConstraint
parameter_list|(
name|IndexConstraint
name|indexConstraint
parameter_list|)
block|{
name|TextConstraint
name|textConstraint
init|=
operator|(
name|TextConstraint
operator|)
name|indexConstraint
operator|.
name|getConstraint
argument_list|()
decl_stmt|;
name|ConstraintValue
name|constraintValue
init|=
operator|new
name|ConstraintValue
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|text
range|:
name|textConstraint
operator|.
name|getTexts
argument_list|()
control|)
block|{
name|constraintValue
operator|.
name|getValues
argument_list|()
operator|.
name|add
argument_list|(
name|indexValueFactory
operator|.
name|createIndexValue
argument_list|(
name|valueFactory
operator|.
name|createText
argument_list|(
name|text
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//use a index field for DataType, Languages and the Field
name|indexConstraint
operator|.
name|setIndexFieldConstraints
argument_list|(
operator|new
name|IndexField
argument_list|(
name|indexConstraint
operator|.
name|getPath
argument_list|()
argument_list|,
name|IndexDataTypeEnum
operator|.
name|TXT
operator|.
name|getIndexType
argument_list|()
argument_list|,
name|textConstraint
operator|.
name|getLanguages
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|//add the value for the constraint
switch|switch
condition|(
name|textConstraint
operator|.
name|getPatternType
argument_list|()
condition|)
block|{
case|case
name|none
case|:
name|indexConstraint
operator|.
name|setFieldConstraint
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|EQ
argument_list|,
name|constraintValue
argument_list|)
expr_stmt|;
break|break;
case|case
name|wildcard
case|:
name|indexConstraint
operator|.
name|setFieldConstraint
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|WILDCARD
argument_list|,
name|constraintValue
argument_list|)
expr_stmt|;
break|break;
case|case
name|regex
case|:
name|indexConstraint
operator|.
name|setFieldConstraint
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|REGEX
argument_list|,
name|constraintValue
argument_list|)
expr_stmt|;
break|break;
default|default:
name|indexConstraint
operator|.
name|setInvalid
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"PatterType %s not supported for Solr Index Queries!"
argument_list|,
name|textConstraint
operator|.
name|getPatternType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * @param indexConstraint      * @param refConstraint      */
specifier|private
name|void
name|initValueConstraint
parameter_list|(
name|IndexConstraint
name|indexConstraint
parameter_list|)
block|{
name|ValueConstraint
name|valueConstraint
init|=
operator|(
name|ValueConstraint
operator|)
name|indexConstraint
operator|.
name|getConstraint
argument_list|()
decl_stmt|;
if|if
condition|(
name|valueConstraint
operator|.
name|getValues
argument_list|()
operator|==
literal|null
condition|)
block|{
name|indexConstraint
operator|.
name|setInvalid
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"ValueConstraint without a value - that check only any value for "
operator|+
literal|"the parsed datatypes %s is present - can not be supported by a Solr query!"
argument_list|,
name|valueConstraint
operator|.
name|getDataTypes
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// first process the parsed dataTypes to get the supported types
name|List
argument_list|<
name|IndexDataType
argument_list|>
name|indexDataTypes
init|=
operator|new
name|ArrayList
argument_list|<
name|IndexDataType
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|acceptedDataTypes
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|valueConstraint
operator|.
name|getDataTypes
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|dataType
range|:
name|valueConstraint
operator|.
name|getDataTypes
argument_list|()
control|)
block|{
name|IndexDataTypeEnum
name|indexDataTypeEnumEntry
init|=
name|IndexDataTypeEnum
operator|.
name|forUri
argument_list|(
name|dataType
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexDataTypeEnumEntry
operator|!=
literal|null
condition|)
block|{
name|indexDataTypes
operator|.
name|add
argument_list|(
name|indexDataTypeEnumEntry
operator|.
name|getIndexType
argument_list|()
argument_list|)
expr_stmt|;
name|acceptedDataTypes
operator|.
name|add
argument_list|(
name|dataType
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// TODO: Add possibility to add warnings to indexConstraints
name|log
operator|.
name|warn
argument_list|(
literal|"A Datatype parsed for a ValueConstraint is not "
operator|+
literal|"supported and will be ignored (dataTypeUri={})"
argument_list|,
name|dataType
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//we support only a single dataType ...
comment|//  ... therefore remove additional data types from the ValueConstraint
name|IndexDataType
name|indexDataType
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|indexDataTypes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|indexDataType
operator|=
name|indexDataTypes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|indexDataTypes
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Only a single DataType is supported for ValueConstraints!"
argument_list|)
expr_stmt|;
while|while
condition|(
name|acceptedDataTypes
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|String
name|ignored
init|=
name|acceptedDataTypes
operator|.
name|remove
argument_list|(
name|acceptedDataTypes
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|log
operator|.
name|warn
argument_list|(
literal|"> ignore parsed dataType {}"
argument_list|,
name|ignored
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//else empty we will initialise based on the first parsed value!
name|ConstraintValue
name|constraintValue
init|=
operator|new
name|ConstraintValue
argument_list|(
name|valueConstraint
operator|.
name|getMode
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Object
name|value
range|:
name|valueConstraint
operator|.
name|getValues
argument_list|()
control|)
block|{
name|IndexValue
name|indexValue
decl_stmt|;
if|if
condition|(
name|indexDataType
operator|==
literal|null
condition|)
block|{
comment|// if no supported types are present
comment|// get the dataType based on the type of the value
try|try
block|{
name|indexValue
operator|=
name|indexValueFactory
operator|.
name|createIndexValue
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoConverterException
name|e
parameter_list|)
block|{
comment|// if not found use the toString() and string as type
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to create IndexValue for value {} (type: {}). Create IndexValue manually by using the first parsed IndexDataType {}"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|value
block|,
name|value
operator|.
name|getClass
argument_list|()
block|,
name|IndexDataTypeEnum
operator|.
name|STR
operator|.
name|getIndexType
argument_list|()
block|}
argument_list|)
expr_stmt|;
name|indexValue
operator|=
operator|new
name|IndexValue
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|,
name|IndexDataTypeEnum
operator|.
name|STR
operator|.
name|getIndexType
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//initialise the IndexDataType for this query based on the first parsed value
name|indexDataType
operator|=
name|indexValue
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|indexValue
operator|=
operator|new
name|IndexValue
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|,
name|indexDataType
argument_list|)
expr_stmt|;
block|}
name|constraintValue
operator|.
name|getValues
argument_list|()
operator|.
name|add
argument_list|(
name|indexValue
argument_list|)
expr_stmt|;
comment|//add the constraint
block|}
comment|//indexConstraint.setFieldConstraint(IndexConstraintTypeEnum.DATATYPE, indexDataType);
name|IndexField
name|indexField
decl_stmt|;
if|if
condition|(
name|IndexDataTypeEnum
operator|.
name|TXT
operator|.
name|getIndexType
argument_list|()
operator|.
name|equals
argument_list|(
name|indexDataType
argument_list|)
condition|)
block|{
comment|//NOTE: in case of TEXT we need also to add the language to create a valid
comment|//query!
comment|// * We take the language of the first parsed element
name|indexField
operator|=
operator|new
name|IndexField
argument_list|(
name|indexConstraint
operator|.
name|getPath
argument_list|()
argument_list|,
name|indexDataType
argument_list|,
name|constraintValue
operator|.
name|getValues
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|getLanguage
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indexField
operator|=
operator|new
name|IndexField
argument_list|(
name|indexConstraint
operator|.
name|getPath
argument_list|()
argument_list|,
name|indexDataType
argument_list|)
expr_stmt|;
block|}
comment|//set FIELD, DATATYPE and LANGUAGE constraint by using the indexField
name|indexConstraint
operator|.
name|setIndexFieldConstraints
argument_list|(
name|indexField
argument_list|)
expr_stmt|;
comment|//set the VALUE
comment|//TODO: We need to somehow pass the MODE so that the encoder knows how
comment|//      to encode the values
name|indexConstraint
operator|.
name|setFieldConstraint
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|EQ
argument_list|,
name|constraintValue
argument_list|)
expr_stmt|;
comment|//update this constraint!
if|if
condition|(
name|valueConstraint
operator|instanceof
name|ReferenceConstraint
condition|)
block|{
name|indexConstraint
operator|.
name|setFieldQueryConstraint
argument_list|(
name|valueConstraint
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indexConstraint
operator|.
name|setFieldQueryConstraint
argument_list|(
operator|new
name|ValueConstraint
argument_list|(
name|valueConstraint
operator|.
name|getValues
argument_list|()
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|indexDataType
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|SolrQuery
name|initSolrQuery
parameter_list|(
name|Query
name|entityhubQuery
parameter_list|)
block|{
name|SolrQuery
name|query
init|=
operator|new
name|SolrQuery
argument_list|()
decl_stmt|;
comment|// first add a filterquery for the domain if present
if|if
condition|(
name|domain
operator|!=
literal|null
condition|)
block|{
name|query
operator|.
name|addFilterQuery
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"%s:%s"
argument_list|,
name|fieldMapper
operator|.
name|getDocumentDomainField
argument_list|()
argument_list|,
name|SolrUtil
operator|.
name|escapeSolrSpecialChars
argument_list|(
name|domain
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// than add the offset
name|query
operator|.
name|setStart
argument_list|(
name|entityhubQuery
operator|.
name|getOffset
argument_list|()
argument_list|)
expr_stmt|;
comment|// and the limit
if|if
condition|(
name|entityhubQuery
operator|.
name|getLimit
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|entityhubQuery
operator|.
name|getLimit
argument_list|()
operator|.
name|compareTo
argument_list|(
name|MAX_QUERY_RESULTS
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|query
operator|.
name|setRows
argument_list|(
name|entityhubQuery
operator|.
name|getLimit
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Parsed Number of QueryResults {} is greater than the allowed maximum of {}!"
argument_list|,
name|entityhubQuery
operator|.
name|getLimit
argument_list|()
argument_list|,
name|MAX_QUERY_RESULTS
argument_list|)
argument_list|)
expr_stmt|;
name|entityhubQuery
operator|.
name|setLimit
argument_list|(
name|MAX_QUERY_RESULTS
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// maybe remove that to prevent to many results! But for now I would
comment|// rather like to have a default value within the FieldQuery!
comment|// e.g. set by the FieldQueryFactory when creating new queries!
name|query
operator|.
name|setRows
argument_list|(
name|DEFAULT_QUERY_RESULTS
argument_list|)
expr_stmt|;
name|entityhubQuery
operator|.
name|setLimit
argument_list|(
name|DEFAULT_QUERY_RESULTS
argument_list|)
expr_stmt|;
block|}
return|return
name|query
return|;
block|}
comment|/**      * Getter for the domain set as FilterQuery to all generated SolrQueries      *       * @return the domain or<code>null</code> if no domain is set      */
specifier|public
specifier|final
name|String
name|getDomain
parameter_list|()
block|{
return|return
name|domain
return|;
block|}
comment|/**      * Setter for the domain. If an empty string is parsed, than the domain is set to<code>null</code>,      * otherwise the parsed value is set. Parse<code>null</code> to deactivated the usage of domains      *       * @param domain      *            the domain or<code>null</code> if no domain is active      */
specifier|public
specifier|final
name|void
name|setDomain
parameter_list|(
name|String
name|domain
parameter_list|)
block|{
if|if
condition|(
name|domain
operator|!=
literal|null
operator|&&
name|domain
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|this
operator|.
name|domain
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|domain
operator|=
name|domain
expr_stmt|;
block|}
block|}
comment|/**      * getter for the maximum number of results allowed      *       * @return the maximum number of results that can be set      */
specifier|public
specifier|final
name|Integer
name|getMaxQueryResults
parameter_list|()
block|{
return|return
name|maxQueryResults
return|;
block|}
comment|/**      * Setter for the maximum number of results allowed. If<code>null</code> is parsed than the value is set      * to {@link #MAX_QUERY_RESULTS}. If a value smaller than {@link #getDefaultQueryResults()} is parsed,      * than the value is set to {@link #getDefaultQueryResults()}.      *       * @param maxQueryResults      *            The maximum number of queries allowed      */
specifier|public
specifier|final
name|void
name|setMaxQueryResults
parameter_list|(
name|Integer
name|maxQueryResults
parameter_list|)
block|{
if|if
condition|(
name|maxQueryResults
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|maxQueryResults
operator|=
name|MAX_QUERY_RESULTS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|maxQueryResults
operator|.
name|compareTo
argument_list|(
name|defaultQueryResults
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|this
operator|.
name|maxQueryResults
operator|=
name|defaultQueryResults
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|maxQueryResults
operator|=
name|maxQueryResults
expr_stmt|;
block|}
block|}
comment|/**      * Getter for the default number of query results. This is used if a parsed Query does not define the      * number of results.      *       * @return the default value for the number of query results      */
specifier|public
specifier|final
name|Integer
name|getDefaultQueryResults
parameter_list|()
block|{
return|return
name|defaultQueryResults
return|;
block|}
comment|/**      * Setter for the default number of query results. This is used if a parsed Query does not define the      * number of results. If<code>null</code> or a value<code><= 0</code>is parsed, than the value is set to      * the lower value of {@link #DEFAULT_QUERY_RESULTS} ({@value #DEFAULT_QUERY_RESULTS}) and      * {@link #getMaxQueryResults()}. If a value<code>>=</code> {@link #getMaxQueryResults()} is parsed, than      * the value is set to {@link #getMaxQueryResults()}.      *       * @param defaultQueryResults      *            the default number of results for queries      */
specifier|public
specifier|final
name|void
name|setDefaultQueryResults
parameter_list|(
name|Integer
name|defaultQueryResults
parameter_list|)
block|{
if|if
condition|(
name|defaultQueryResults
operator|==
literal|null
operator|||
name|defaultQueryResults
operator|.
name|intValue
argument_list|()
operator|<=
literal|0
condition|)
block|{
name|this
operator|.
name|defaultQueryResults
operator|=
name|Math
operator|.
name|min
argument_list|(
name|DEFAULT_QUERY_RESULTS
argument_list|,
name|maxQueryResults
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|defaultQueryResults
operator|.
name|compareTo
argument_list|(
name|maxQueryResults
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|this
operator|.
name|defaultQueryResults
operator|=
name|maxQueryResults
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|defaultQueryResults
operator|=
name|defaultQueryResults
expr_stmt|;
block|}
block|}
comment|/**      * Keeps the {@link IndexValue}s AND the {@link MODE} allowing to distinguish      * between values of an {@link Constraint} that are optional and required.<p>      * Currently only used for {@link ValueConstraint} and {@link ReferenceConstraint}      * but could be also applied to {@link TextConstraint}s      * @author Rupert Westenthaler      *      */
specifier|public
specifier|static
class|class
name|ConstraintValue
implements|implements
name|Iterable
argument_list|<
name|IndexValue
argument_list|>
block|{
specifier|private
specifier|final
name|MODE
name|mode
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|IndexValue
argument_list|>
name|values
init|=
operator|new
name|LinkedHashSet
argument_list|<
name|IndexValue
argument_list|>
argument_list|()
decl_stmt|;
specifier|public
name|ConstraintValue
parameter_list|()
block|{
name|this
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|ConstraintValue
parameter_list|(
name|MODE
name|mode
parameter_list|)
block|{
name|this
operator|.
name|mode
operator|=
name|mode
operator|==
literal|null
condition|?
name|MODE
operator|.
name|any
else|:
name|mode
expr_stmt|;
block|}
specifier|public
name|Set
argument_list|<
name|IndexValue
argument_list|>
name|getValues
parameter_list|()
block|{
return|return
name|values
return|;
block|}
specifier|public
name|MODE
name|getMode
parameter_list|()
block|{
return|return
name|mode
return|;
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|IndexValue
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|values
operator|.
name|iterator
argument_list|()
return|;
block|}
block|}
comment|/**      * Class internally used to process FieldConstraint. This class accesses the      * {@link SolrQueryFactory#constraintEncoders} map.      *       * @author Rupert Westenthaler      *       */
specifier|private
class|class
name|IndexConstraint
block|{
specifier|private
specifier|final
name|Map
argument_list|<
name|IndexConstraintTypeEnum
argument_list|,
name|Object
argument_list|>
name|fieldConstraints
init|=
operator|new
name|EnumMap
argument_list|<
name|IndexConstraintTypeEnum
argument_list|,
name|Object
argument_list|>
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|invalidMessages
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|Constraint
name|fieldQueryConstraint
decl_stmt|;
specifier|private
specifier|final
name|Constraint
name|constraint
decl_stmt|;
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|path
decl_stmt|;
specifier|public
name|IndexConstraint
parameter_list|(
name|String
name|field
parameter_list|,
name|Constraint
name|constraint
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|this
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|field
argument_list|)
argument_list|,
name|constraint
argument_list|)
expr_stmt|;
block|}
comment|/**          * Creates a Field Term for the parsed path          *           * @param path          *            the path          * @throws IllegalArgumentException          *             If the path is<code>null</code> empty.          */
specifier|public
name|IndexConstraint
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|field
parameter_list|,
name|Constraint
name|constraint
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
name|field
operator|==
literal|null
operator|||
name|field
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed path MUST NOT be NULL nor empty!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|constraint
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Constraint MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|this
operator|.
name|path
operator|=
name|field
expr_stmt|;
name|this
operator|.
name|constraint
operator|=
name|constraint
expr_stmt|;
block|}
comment|/**          * Getter for the filed of this Constraint          * @return the field          */
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getPath
parameter_list|()
block|{
return|return
name|path
return|;
block|}
comment|/**          * The constraint          * @return          */
specifier|public
name|Constraint
name|getConstraint
parameter_list|()
block|{
return|return
name|constraint
return|;
block|}
comment|/**          * Set an explanatory error message to tell that this IndexConstraint cannot be used. e.g. if the          * conversion of a {@link Constraint} to an {@link IndexConstraint} was unsuccessful.          *           * @param message          *            an message to explain why the constraint is not valid          */
specifier|public
name|void
name|setInvalid
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|this
operator|.
name|invalidMessages
operator|.
name|add
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
comment|/**          * Returns<code>true</code> if this index constraint is invalid and can not be used for the          * IndexQuery. If the state is<code>true</code> it indicates, that the conversion to a          * {@link Constraint } to an {@link IndexConstraint} was not successful!          *           * @return the state          */
specifier|public
name|boolean
name|isInvalid
parameter_list|()
block|{
return|return
operator|!
name|invalidMessages
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|/**          * Getter for the Messages why this index constraint is not valid          *           * @return the messages. An empty List if {@link #isInvalid()} returns<code>false</code>          */
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getInvalidMessages
parameter_list|()
block|{
return|return
name|invalidMessages
return|;
block|}
comment|/**          * Getter for the (possible modified against the parsed constrained)          * version of the FieldQuery {@link Constraint}          * @return the Constraint or<code>null</code> if           *<code>{@link #isInvalid()} == false</code>          */
specifier|public
specifier|final
name|Constraint
name|getFieldQueryConstraint
parameter_list|()
block|{
return|return
name|fieldQueryConstraint
return|;
block|}
comment|/**          * Getter for the (possible modified against the parsed constrained)          * version of the FieldQuery {@link Constraint}          * @param fieldQueryConstraint the constraint          */
specifier|protected
specifier|final
name|void
name|setFieldQueryConstraint
parameter_list|(
name|Constraint
name|fieldQueryConstraint
parameter_list|)
block|{
name|this
operator|.
name|fieldQueryConstraint
operator|=
name|fieldQueryConstraint
expr_stmt|;
block|}
comment|/**          * Sets the {@link IndexConstraintTypeEnum#FIELD},           * {@link IndexConstraintTypeEnum#DATATYPE},          * and {@link IndexConstraintTypeEnum#LANG} constraints based on the          * parsed indexField          * @param indexField the {@link IndexField}          * @throws IllegalArgumentException if the parsed index field is<code>null</code>          */
specifier|public
name|void
name|setIndexFieldConstraints
parameter_list|(
name|IndexField
name|indexField
parameter_list|)
block|{
if|if
condition|(
name|indexField
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed indexField MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|setFieldConstraint
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|FIELD
argument_list|,
name|indexField
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|indexField
operator|.
name|isSpecialField
argument_list|()
condition|)
block|{
name|setFieldConstraint
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|DATATYPE
argument_list|,
name|indexField
argument_list|)
expr_stmt|;
name|setFieldConstraint
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|LANG
argument_list|,
name|indexField
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**          * Sets an IndexConstraintType to a specific value          *           * @param constraintType          *            the type of the constraint          * @param value          *            the value.<code>null</code> is permitted, but usually it is not needed to add          *<code>null</code> constraints, because they are automatically added if needed (e.g. a          *            range constraint with an open lower bound)          * @throws IllegalArgumentException          *             if<code>null</code> is parsed as constraint type          */
specifier|public
name|void
name|setFieldConstraint
parameter_list|(
name|IndexConstraintTypeEnum
name|constraintType
parameter_list|,
name|Object
name|value
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
name|constraintType
operator|==
literal|null
condition|)
block|{
comment|// just returning here would also be OK, but better to find errors early by
comment|// looking at stack traces
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Parameter IndexConstraintTypeEnum MUST NOT be NULL"
argument_list|)
throw|;
block|}
name|IndexConstraintTypeEncoder
argument_list|<
name|?
argument_list|>
name|encoder
init|=
name|constraintEncoders
operator|.
name|get
argument_list|(
name|constraintType
argument_list|)
decl_stmt|;
if|if
condition|(
name|encoder
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"No Encoder for IndexConstraintType %s present!"
argument_list|,
name|constraintType
argument_list|)
argument_list|)
throw|;
block|}
comment|// accept null values and values that are supported by the encoder!
if|if
condition|(
name|value
operator|==
literal|null
operator|||
name|encoder
operator|.
name|acceptsValueType
argument_list|()
operator|.
name|isAssignableFrom
argument_list|(
name|value
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
name|this
operator|.
name|fieldConstraints
operator|.
name|put
argument_list|(
name|constraintType
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|// we need also check the dependent types!
for|for
control|(
name|IndexConstraintTypeEnum
name|dependent
range|:
name|encoder
operator|.
name|dependsOn
argument_list|()
control|)
block|{
comment|// if a dependent type is missing, add it with the default value!
if|if
condition|(
operator|!
name|fieldConstraints
operator|.
name|containsKey
argument_list|(
name|dependent
argument_list|)
condition|)
block|{
comment|// if missing, set the dependent to null (default value)
name|setFieldConstraint
argument_list|(
name|dependent
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"The Encoder %s for IndexConstraintType %s does not support values of type %s (supported Type: %s)!"
argument_list|,
name|encoder
operator|.
name|getClass
argument_list|()
argument_list|,
name|constraintType
argument_list|,
name|value
operator|.
name|getClass
argument_list|()
argument_list|,
name|encoder
operator|.
name|acceptsValueType
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|void
name|encode
parameter_list|(
name|StringBuilder
name|queryString
parameter_list|)
block|{
if|if
condition|(
name|isInvalid
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unable to encode an invalid IndexConstraint (invalid messages: %s)"
argument_list|,
name|getInvalidMessages
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
else|else
block|{
name|EncodedConstraintParts
name|encodedConstraintParts
init|=
operator|new
name|EncodedConstraintParts
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|IndexConstraintTypeEnum
argument_list|,
name|Object
argument_list|>
name|constraint
range|:
name|fieldConstraints
operator|.
name|entrySet
argument_list|()
control|)
block|{
comment|// NOTE: type checks are already performed in the setFieldConstraint method!
operator|(
operator|(
name|IndexConstraintTypeEncoder
argument_list|<
name|Object
argument_list|>
operator|)
name|constraintEncoders
operator|.
name|get
argument_list|(
name|constraint
operator|.
name|getKey
argument_list|()
argument_list|)
operator|)
operator|.
name|encode
argument_list|(
name|encodedConstraintParts
argument_list|,
name|constraint
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// now take the parts and create the constraint!
name|encodeSolrConstraint
argument_list|(
name|queryString
argument_list|,
name|encodedConstraintParts
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|StringBuilder
name|encodeSolrConstraint
parameter_list|(
name|StringBuilder
name|queryString
parameter_list|,
name|EncodedConstraintParts
name|encodedConstraintParts
parameter_list|)
block|{
comment|// list of all constraints that need to be connected with OR
name|List
argument_list|<
name|List
argument_list|<
name|StringBuilder
argument_list|>
argument_list|>
name|constraints
init|=
operator|new
name|ArrayList
argument_list|<
name|List
argument_list|<
name|StringBuilder
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Constriants: {}"
argument_list|,
name|encodedConstraintParts
argument_list|)
expr_stmt|;
comment|// init with a single constraint
name|constraints
operator|.
name|add
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|StringBuilder
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|StringBuilder
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|ConstraintTypePosition
argument_list|,
name|Set
argument_list|<
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|>
name|entry
range|:
name|encodedConstraintParts
control|)
block|{
comment|// one position may contain multiple options that need to be connected with OR
comment|//                log.info("process: pos {} ({})",entry.getKey().getPos(),entry.getKey());
name|Set
argument_list|<
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|orParts
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|int
name|constraintsSize
init|=
name|constraints
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Set
argument_list|<
name|String
argument_list|>
name|andParts
range|:
name|orParts
control|)
block|{
comment|//                    log.info("  OR {}",andParts);
name|i
operator|++
expr_stmt|;
comment|// add the and constraints to all or
if|if
condition|(
name|i
operator|==
name|orParts
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// for the last iteration, append the part to the existing constraints
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|constraintsSize
condition|;
name|j
operator|++
control|)
block|{
comment|//                            String parsedConstraint = constraints.get(j).toString();
name|encodeAndParts
argument_list|(
name|andParts
argument_list|,
name|constraints
operator|.
name|get
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
comment|//                            log.info("    appand AND {} to [{}]:{} -> {}",
comment|//                                new Object[]{andParts,j,parsedConstraint, constraints.get(j).toString()});
block|}
block|}
else|else
block|{
comment|// if there is more than one value, we need to generate new variants for
comment|// every option other than the last.
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|constraintsSize
condition|;
name|j
operator|++
control|)
block|{
comment|//we need a deep "clone" of the Constraints of index 'j'
name|List
argument_list|<
name|StringBuilder
argument_list|>
name|additional
init|=
operator|new
name|ArrayList
argument_list|<
name|StringBuilder
argument_list|>
argument_list|(
name|constraints
operator|.
name|get
argument_list|(
name|j
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|StringBuilder
name|sb
range|:
name|constraints
operator|.
name|get
argument_list|(
name|j
argument_list|)
control|)
block|{
name|additional
operator|.
name|add
argument_list|(
operator|new
name|StringBuilder
argument_list|(
name|sb
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|constraints
operator|.
name|add
argument_list|(
name|additional
argument_list|)
expr_stmt|;
comment|//                            String parsedConstraint = constraints.get(j).toString();
name|encodeAndParts
argument_list|(
name|andParts
argument_list|,
name|additional
argument_list|)
expr_stmt|;
comment|//                            log.info("    create AND {} to [{}]:{} -> {}",
comment|//                                new Object[]{andParts,j,parsedConstraint, constraints.get(j).toString()});
block|}
block|}
block|}
block|}
comment|// now combine the different options to a single query string
name|boolean
name|firstOr
init|=
literal|true
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|StringBuilder
argument_list|>
name|constraint
range|:
name|constraints
control|)
block|{
if|if
condition|(
name|constraint
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|firstOr
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|firstOr
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|") OR ("
argument_list|)
expr_stmt|;
block|}
name|boolean
name|firstAnd
init|=
literal|true
decl_stmt|;
for|for
control|(
name|StringBuilder
name|andConstraint
range|:
name|constraint
control|)
block|{
if|if
condition|(
name|andConstraint
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|firstAnd
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|firstAnd
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|" AND ("
argument_list|)
expr_stmt|;
block|}
name|queryString
operator|.
name|append
argument_list|(
name|andConstraint
argument_list|)
expr_stmt|;
name|queryString
operator|.
name|append
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// else ignore empty constraints
block|}
name|queryString
operator|.
name|append
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
return|return
name|queryString
return|;
block|}
comment|/**          * @param andParts          * @param andConstaint          */
specifier|private
name|void
name|encodeAndParts
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|andParts
parameter_list|,
name|List
argument_list|<
name|StringBuilder
argument_list|>
name|andConstaint
parameter_list|)
block|{
name|int
name|andConstaintSize
init|=
name|andConstaint
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|k
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|part
range|:
name|andParts
control|)
block|{
name|k
operator|++
expr_stmt|;
comment|// add the AND part of this constraint position with all parts of the others
if|if
condition|(
name|k
operator|==
name|andParts
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// for the last iteration, append the part to the existing constraints
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|andConstaintSize
condition|;
name|j
operator|++
control|)
block|{
name|andConstaint
operator|.
name|get
argument_list|(
name|j
argument_list|)
operator|.
name|append
argument_list|(
name|part
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// if there is more than one value, we need to generate new variants for
comment|// every option other than the last.
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|andConstaintSize
condition|;
name|j
operator|++
control|)
block|{
name|StringBuilder
name|additional
init|=
operator|new
name|StringBuilder
argument_list|(
name|andConstaint
operator|.
name|get
argument_list|(
name|j
argument_list|)
argument_list|)
decl_stmt|;
name|additional
operator|.
name|append
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|andConstaint
operator|.
name|add
argument_list|(
name|additional
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// /**
comment|// * NOTE: removed, because currently not needed. If re-added, this Method needs also
comment|// * to remove (recursively) dependent with the default value
comment|// * Removes the according index constraint if present
comment|// * @param constraintType the constraint to remove
comment|// * @throws IllegalArgumentException if<code>null</code> is parsed as constraint type
comment|// */
comment|// public void removeFieldConstraint(IndexConstraintTypeEnum constraintType) throws
comment|// IllegalArgumentException {
comment|// if(constraintType == null){
comment|// //just returning here would also be OK, but better to find errors early by
comment|// //looking at stack traces
comment|// throw new IllegalArgumentException("Parameter IndexConstraintTypeEnum MUST NOT be NULL");
comment|// }
comment|// this.fieldConstraints.remove(constraintType);
comment|// }
block|}
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|SolrQueryFactory
name|factory
init|=
operator|new
name|SolrQueryFactory
argument_list|(
name|InMemoryValueFactory
operator|.
name|getInstance
argument_list|()
argument_list|,
name|IndexValueFactory
operator|.
name|getInstance
argument_list|()
argument_list|,
operator|new
name|SolrFieldMapper
argument_list|(
literal|null
argument_list|)
argument_list|)
decl_stmt|;
name|FieldQuery
name|query
init|=
name|DefaultQueryFactory
operator|.
name|getInstance
argument_list|()
operator|.
name|createFieldQuery
argument_list|()
decl_stmt|;
comment|//        query.setConstraint("urn:field2", new TextConstraint("test","en","de"));
name|query
operator|.
name|setConstraint
argument_list|(
literal|"urn:field3"
argument_list|,
operator|new
name|TextConstraint
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|"text value"
argument_list|,
literal|"anothertest"
argument_list|,
literal|"some more values"
argument_list|)
argument_list|,
literal|"en"
argument_list|,
literal|"de"
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|query
operator|.
name|addSelectedField
argument_list|(
literal|"urn:field2a"
argument_list|)
expr_stmt|;
name|query
operator|.
name|addSelectedField
argument_list|(
literal|"urn:field3"
argument_list|)
expr_stmt|;
name|query
operator|.
name|setLimit
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|query
operator|.
name|setOffset
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|SolrQuery
name|solrQuery
init|=
name|factory
operator|.
name|parseFieldQuery
argument_list|(
name|query
argument_list|,
name|SELECT
operator|.
name|QUERY
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|solrQuery
operator|.
name|getQuery
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

