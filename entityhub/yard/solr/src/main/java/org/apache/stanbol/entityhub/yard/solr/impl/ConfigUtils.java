begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|impl
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|ArchiveEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|ArchiveInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|zip
operator|.
name|ZipArchiveEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|zip
operator|.
name|ZipFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|FileUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|embedded
operator|.
name|EmbeddedSolrServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|framework
operator|.
name|Bundle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * This Utility provides Methods that copy a configuration from a {@link Bundle}  * and copy it to a directory.<p>  * This is currently used by the {@link EmbeddedSolrPorovider} to initialise the  * internally managed {@link EmbeddedSolrServer} and/or to add additional cores.  * There are always two variants of the methods. The one taking a bundle as  * parameter is supposed to be used when running within an OSGI environment. The  * variant taking a Class object works outside of an OSGI environment.  * @author Rupert Westenthaler  *  */
end_comment

begin_class
specifier|public
specifier|final
class|class
name|ConfigUtils
block|{
specifier|private
name|ConfigUtils
parameter_list|()
block|{}
comment|/**      * The logger      */
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ConfigUtils
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * The name of the directoy used in the bundle to search for the default config      */
specifier|public
specifier|static
specifier|final
name|String
name|CONFIG_DIR
init|=
literal|"solr/conf"
decl_stmt|;
comment|/**      * The name of the root directoy used within an bundle to search for all cores      * that need to be added to an existing solr multi core configuration      */
specifier|public
specifier|static
specifier|final
name|String
name|CORE_CONFIG_DIR
init|=
literal|"solr/core"
decl_stmt|;
comment|/**      * Initialises the default configuration for the SolrYard based on data in      * the parsed bundle. The configuration will be copied to the parsed root      * directory.      * @param bundle the bundle used to load the defaultConfiguration from the      * {@link #CONFIG_DIR} (value=" {@value #CONFIG_DIR}") directory.      * @param rootDir the target directory for the configuration.       * @param override if true existing configurations are overridden.      * @return the root directory of the solr configuration (same as parsed as       * rootDir)      * @throws IOException On any IO error while coping the configuration      * @throws IllegalStateException If the parsed bundle is in the       * {@link Bundle#UNINSTALLED}      * state, the parsed rootDir does exist but is not a directory.      * @throws IllegalArgumentException If<code>null</code> is parsed as bundle       * or rootDir or if the parsed bundle does not contain the required       * information to set up an configuration       */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|//Enumeration<URL> required by OSGI specification
specifier|public
specifier|static
name|File
name|copyDefaultConfig
parameter_list|(
name|Bundle
name|bundle
parameter_list|,
name|File
name|rootDir
parameter_list|,
name|boolean
name|override
parameter_list|)
throws|throws
name|IOException
throws|,
name|IllegalStateException
throws|,
name|IllegalArgumentException
block|{
if|if
condition|(
name|bundle
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Bundle MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|rootDir
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed root directory MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|rootDir
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|rootDir
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"The parsed root directory "
operator|+
name|rootDir
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" extists but is not a directory!"
argument_list|)
throw|;
block|}
name|log
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Copy Default Config from Bundle %s to %s (override=%s)"
argument_list|,
name|bundle
operator|.
name|getSymbolicName
argument_list|()
argument_list|,
name|rootDir
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|override
argument_list|)
argument_list|)
expr_stmt|;
name|Enumeration
argument_list|<
name|URL
argument_list|>
name|resources
init|=
operator|(
name|Enumeration
argument_list|<
name|URL
argument_list|>
operator|)
name|bundle
operator|.
name|findEntries
argument_list|(
name|CONFIG_DIR
argument_list|,
literal|"*.*"
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|//TODO: check validity of config and thorw IllegalArgumentException if not valid
while|while
condition|(
name|resources
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|URL
name|resource
init|=
name|resources
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|copyResource
argument_list|(
name|rootDir
argument_list|,
name|resource
argument_list|,
name|CONFIG_DIR
argument_list|,
name|override
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|debug
argument_list|(
literal|" ... default Configuration copied to "
operator|+
name|rootDir
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|rootDir
return|;
block|}
comment|/**      * Initialises the default configuration for the SolrYard based on data in      * the parsed bundle. The configuration will be copied to the parsed root      * directory.      * @param clazzInArchive This class is used to identify the archive containing      * the default configuration. Parsing<code>null</code> causes this class to      * be used and therefore initialises the default configuration contained by      * the SolrYard bundle.      * @param rootDir the target directory for the configuration.       * @param override if true existing configurations are overridden.      * @return the root directory of the solr configuration (same as parsed as rootDir)      * @throws IOException On any IO error while coping the configuration      * @throws IllegalStateException If the parsed rootDir does exist but is not      * a directory.      * @throws IllegalArgumentException iIf<code>null</code> is parsed as       * rootDir or if the parsed bundle does not contain the required information       * to set up an configuration       */
specifier|public
specifier|static
name|File
name|copyDefaultConfig
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|clazzInArchive
parameter_list|,
name|File
name|rootDir
parameter_list|,
name|boolean
name|override
parameter_list|)
throws|throws
name|IOException
throws|,
name|IllegalStateException
throws|,
name|IllegalArgumentException
block|{
if|if
condition|(
name|rootDir
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed root directory MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|rootDir
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|rootDir
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"The parsed root directory "
operator|+
name|rootDir
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" extists but is not a directory!"
argument_list|)
throw|;
block|}
name|File
name|sourceRoot
init|=
name|getSource
argument_list|(
name|clazzInArchive
operator|!=
literal|null
condition|?
name|clazzInArchive
else|:
name|ConfigUtils
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|sourceRoot
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|ZipFile
name|archive
init|=
operator|new
name|ZipFile
argument_list|(
name|sourceRoot
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Copy Default Config from jar-file %s to %s (override=%s)"
argument_list|,
name|sourceRoot
operator|.
name|getName
argument_list|()
argument_list|,
name|rootDir
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|override
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
for|for
control|(
name|Enumeration
argument_list|<
name|ZipArchiveEntry
argument_list|>
name|entries
init|=
operator|(
name|Enumeration
argument_list|<
name|ZipArchiveEntry
argument_list|>
operator|)
name|archive
operator|.
name|getEntries
argument_list|()
init|;
name|entries
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|ZipArchiveEntry
name|entry
init|=
name|entries
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
name|CONFIG_DIR
argument_list|)
condition|)
block|{
name|copyResource
argument_list|(
name|rootDir
argument_list|,
name|archive
argument_list|,
name|entry
argument_list|,
name|CONFIG_DIR
argument_list|,
name|override
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
comment|//regardless what happens we need to close the archive!
name|ZipFile
operator|.
name|closeQuietly
argument_list|(
name|archive
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//load from file
name|File
name|source
init|=
operator|new
name|File
argument_list|(
name|sourceRoot
argument_list|,
name|CONFIG_DIR
argument_list|)
decl_stmt|;
if|if
condition|(
name|source
operator|.
name|exists
argument_list|()
operator|&&
name|source
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|FileUtils
operator|.
name|copyDirectory
argument_list|(
name|source
argument_list|,
name|rootDir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"The SolrIndex default config was not found in directory "
operator|+
name|source
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
throw|;
block|}
block|}
return|return
name|rootDir
return|;
block|}
comment|/**      * Uses the {@link ClassLoader} of the parsed {@link Class} instance to locate      * the jar file the class was loaded from.      * @param clazz the class used as context to find the jar file      * @return the archive the parsed class was loaded from      * @throws IOException In case the jar file can not be accessed.      */
specifier|private
specifier|static
name|File
name|getSource
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|classFileName
init|=
name|clazz
operator|.
name|getName
argument_list|()
operator|.
name|replace
argument_list|(
literal|'.'
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|".class"
decl_stmt|;
name|URL
name|classLocation
init|=
name|clazz
operator|.
name|getClassLoader
argument_list|()
operator|.
name|getResource
argument_list|(
name|classFileName
argument_list|)
decl_stmt|;
name|String
name|classPath
decl_stmt|;
try|try
block|{
name|classPath
operator|=
operator|new
name|File
argument_list|(
name|classLocation
operator|.
name|toURI
argument_list|()
argument_list|)
operator|.
name|getAbsolutePath
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to Access Source at location "
operator|+
name|classLocation
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|classPath
operator|.
name|indexOf
argument_list|(
literal|'!'
argument_list|)
operator|>
literal|0
condition|)
block|{
return|return
operator|new
name|File
argument_list|(
name|classPath
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|classPath
operator|.
name|indexOf
argument_list|(
literal|'!'
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|File
argument_list|(
name|classPath
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|classPath
operator|.
name|length
argument_list|()
operator|-
name|classFileName
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/**      * Copies a resource (URL of an resource within a Bundle) to a file      * @param rootDir the directory used as target      * @param resource the resource URL      * @param context the context used to search for the relative path within the URL      * @param override if resources in the target should be overridden if they already exist      * @throws IOException on any IO error      */
specifier|private
specifier|static
name|void
name|copyResource
parameter_list|(
name|File
name|rootDir
parameter_list|,
name|URL
name|resource
parameter_list|,
name|String
name|context
parameter_list|,
name|boolean
name|override
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|resourcePath
init|=
name|resource
operator|.
name|toString
argument_list|()
decl_stmt|;
name|File
name|file
init|=
name|prepairCopy
argument_list|(
name|resourcePath
argument_list|,
name|rootDir
argument_list|,
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|!=
literal|null
condition|)
block|{
name|boolean
name|overrideState
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|file
operator|.
name|exists
argument_list|()
operator|&&
name|override
condition|)
block|{
name|FileUtils
operator|.
name|deleteQuietly
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|overrideState
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|file
operator|.
name|exists
argument_list|()
condition|)
block|{
name|FileUtils
operator|.
name|copyURLToFile
argument_list|(
name|resource
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"> %s %s"
argument_list|,
name|overrideState
condition|?
literal|"override"
else|:
literal|"copy"
argument_list|,
name|file
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|//else can not cppy logging already provided
block|}
comment|/**      * Variant of the copyResource method that used an entry of an archive as      * source.      * @param rootDir the directory used as target      * @param archive the archive containing the parsed entry      * @param entry the entry to copy to the target directory      * @param context the context used to calculate the relative path of the      * resource within the target directory      * @param override if an existing resource within the target directory should      * be deleted      * @throws IOException in case of an error while reading or writing the resource      */
specifier|private
specifier|static
name|void
name|copyResource
parameter_list|(
name|File
name|rootDir
parameter_list|,
name|ZipFile
name|archive
parameter_list|,
name|ZipArchiveEntry
name|entry
parameter_list|,
name|String
name|context
parameter_list|,
name|boolean
name|override
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|file
init|=
name|prepairCopy
argument_list|(
name|entry
operator|.
name|getName
argument_list|()
argument_list|,
name|rootDir
argument_list|,
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|!=
literal|null
condition|)
block|{
name|boolean
name|overrideState
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|file
operator|.
name|exists
argument_list|()
operator|&&
name|override
condition|)
block|{
name|FileUtils
operator|.
name|deleteQuietly
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|overrideState
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|file
operator|.
name|exists
argument_list|()
condition|)
block|{
name|OutputStream
name|os
init|=
literal|null
decl_stmt|;
name|InputStream
name|is
init|=
literal|null
decl_stmt|;
try|try
block|{
name|os
operator|=
name|FileUtils
operator|.
name|openOutputStream
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|is
operator|=
name|archive
operator|.
name|getInputStream
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|copy
argument_list|(
name|is
argument_list|,
name|os
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"> %s %s"
argument_list|,
name|overrideState
condition|?
literal|"override"
else|:
literal|"copy"
argument_list|,
name|file
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//else can not cppy logging already provided
block|}
comment|/**      * Prepares the copying of a resource. The context is used to determine the      * relative path of the resource. Than missing sub-directories are created      * in the target directory. Finally the file instance representing this       * resource within the target directory is returned.       * @param resource The path to the resource. This need not be the full path.      * It must only be ensured that the parsed context is contained. e.g. the      * relative path of a resource within an archive provides enough context for      * this method to work      * @param targetDir the target directory      * @param context the context to determine the relative path of the resource      * within the target directory. The context MUST be part of the parsed      * resource name. Otherwise this method will return<code>null</code>      * @return the file representing the resource within the target directory.      * In cases the context can not be found in the parsed resource this method       * returns<code>null</code>      */
specifier|private
specifier|static
name|File
name|prepairCopy
parameter_list|(
name|String
name|resource
parameter_list|,
name|File
name|targetDir
parameter_list|,
name|String
name|context
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|context
operator|.
name|charAt
argument_list|(
name|context
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
literal|'/'
operator|)
condition|)
block|{
name|context
operator|=
name|context
operator|+
literal|'/'
expr_stmt|;
block|}
name|int
name|contextPos
init|=
name|resource
operator|.
name|lastIndexOf
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|contextPos
operator|>=
literal|0
condition|)
block|{
name|contextPos
operator|=
name|contextPos
operator|+
name|context
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Context %s not found in resource %s -> ignored!"
argument_list|,
name|context
argument_list|,
name|resource
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|String
name|relativePath
init|=
name|resource
operator|.
name|substring
argument_list|(
name|contextPos
argument_list|)
decl_stmt|;
name|String
index|[]
name|relativePathElements
init|=
name|relativePath
operator|.
name|split
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
name|File
name|parentElement
init|=
name|targetDir
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|relativePathElements
operator|.
name|length
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|File
name|pathElement
init|=
operator|new
name|File
argument_list|(
name|parentElement
argument_list|,
name|relativePathElements
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|pathElement
operator|.
name|exists
argument_list|()
condition|)
block|{
name|pathElement
operator|.
name|mkdir
argument_list|()
expr_stmt|;
block|}
name|parentElement
operator|=
name|pathElement
expr_stmt|;
block|}
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|parentElement
argument_list|,
name|relativePathElements
index|[
name|relativePathElements
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
decl_stmt|;
return|return
name|file
return|;
block|}
comment|/**      * Copy the configuration of an core.      * @param bundle The bundle used to load the core      * @param coreDir the target directory for the core      * @param coreName the core name or<code>null</code> to directly load the      * configuration as present under {@value #CONFIG_DIR} in the bundle. This      * property can be used if a bundle needs to provide multiple core      * configurations      * @param override if files in the target directory should be overridden      * @throws IOException On any IO error while coping the configuration      * @throws IllegalStateException If the parsed bundle is in the {@link Bundle#UNINSTALLED}      * state, the parsed coreDir does exist but is not a directory.      * @throws IllegalArgumentException if<code>null</code> is parsed as bundle or coreDir      * or if the parsed bundle does not contain the required information to set       * up an configuration or the parsed coreName is empty.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|//Enumeration<URL> required by OSGI specification
specifier|public
specifier|static
name|void
name|copyCore
parameter_list|(
name|Bundle
name|bundle
parameter_list|,
name|File
name|coreDir
parameter_list|,
name|String
name|coreName
parameter_list|,
name|boolean
name|override
parameter_list|)
throws|throws
name|IOException
throws|,
name|IllegalStateException
throws|,
name|IllegalArgumentException
block|{
if|if
condition|(
name|bundle
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Bundle MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|coreDir
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed core directory MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|coreDir
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|coreDir
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"The parsed core directory "
operator|+
name|coreDir
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" extists but is not a directory!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|coreName
operator|!=
literal|null
operator|&&
name|coreName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed core name MUST NOT be empty (However NULL is supported)!"
argument_list|)
throw|;
block|}
name|String
name|context
init|=
name|CORE_CONFIG_DIR
operator|+
operator|(
name|coreName
operator|!=
literal|null
condition|?
literal|'/'
operator|+
name|coreName
else|:
literal|""
operator|)
decl_stmt|;
name|Enumeration
argument_list|<
name|URL
argument_list|>
name|resources
init|=
operator|(
name|Enumeration
argument_list|<
name|URL
argument_list|>
operator|)
name|bundle
operator|.
name|findEntries
argument_list|(
name|context
argument_list|,
literal|"*.*"
argument_list|,
literal|true
argument_list|)
decl_stmt|;
while|while
condition|(
name|resources
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|URL
name|resource
init|=
name|resources
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|copyResource
argument_list|(
name|coreDir
argument_list|,
name|resource
argument_list|,
name|context
argument_list|,
name|override
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Copies a core from the parsed archive input stream to the target location      * @param ais The input stream of the archive (not closed by this method)      * @param coreDir the directory for the core      * @param coreName the name of the core (used as context when reading relative      * paths from the archive      * @param override if existing files should be overridden      * @throws IOException On any error while accessing the data of the archive      * @throws IllegalArgumentException if any of the parameter is<code>null</code>      * or if the coreDir exists but is not an directory or if the core name is      * empty      */
specifier|public
specifier|static
name|void
name|copyCore
parameter_list|(
name|ArchiveInputStream
name|ais
parameter_list|,
name|File
name|coreDir
parameter_list|,
name|String
name|coreName
parameter_list|,
name|boolean
name|override
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|ais
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed ArchiveInputStream MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|coreDir
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed core directory MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|coreDir
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|coreDir
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"The parsed core directory "
operator|+
name|coreDir
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" extists but is not a directory!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|coreName
operator|==
literal|null
operator|||
name|coreName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed core name MUST NOT be NULL or empty!"
argument_list|)
throw|;
block|}
name|ArchiveEntry
name|entry
decl_stmt|;
while|while
condition|(
operator|(
name|entry
operator|=
name|ais
operator|.
name|getNextEntry
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|entry
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|copyArchiveEntry
argument_list|(
name|ais
argument_list|,
name|entry
argument_list|,
name|coreDir
argument_list|,
name|coreName
argument_list|,
name|override
argument_list|)
expr_stmt|;
comment|/*                  * NOTE: Here we use the coreName as context (last argument to                   * prepairCopy(..)). This ensures that it matter if the archive                   * contains the data directly in the root or within an folder                   * with the name of the core.                  */
block|}
comment|//else - directories are created automatically and empty directories are not needed
block|}
block|}
comment|/**      * Copy an Entry of an Archive to the target (File) within the Core Directory      * @param ais the ArchiveInputStream      * @param entry The Entry to copy      * @param coreDir the root directory      * @param context the context used to calculate the relative path of the      * resource within the target directory      * @param override if an existing resource within the target directory should      * be deleted      * @throws IOException in case of an error while reading or writing the resource      */
specifier|private
specifier|static
name|void
name|copyArchiveEntry
parameter_list|(
name|ArchiveInputStream
name|ais
parameter_list|,
name|ArchiveEntry
name|entry
parameter_list|,
name|File
name|coreDir
parameter_list|,
name|String
name|context
parameter_list|,
name|boolean
name|override
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|file
init|=
name|prepairCopy
argument_list|(
name|entry
operator|.
name|getName
argument_list|()
argument_list|,
name|coreDir
argument_list|,
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|!=
literal|null
condition|)
block|{
name|boolean
name|overrideState
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|file
operator|.
name|exists
argument_list|()
operator|&&
name|override
condition|)
block|{
name|FileUtils
operator|.
name|deleteQuietly
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|overrideState
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|file
operator|.
name|exists
argument_list|()
condition|)
block|{
name|OutputStream
name|os
init|=
literal|null
decl_stmt|;
try|try
block|{
name|os
operator|=
name|FileUtils
operator|.
name|openOutputStream
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|copy
argument_list|(
name|ais
argument_list|,
name|os
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"> %s %s"
argument_list|,
name|overrideState
condition|?
literal|"override"
else|:
literal|"copy"
argument_list|,
name|file
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//else can not cppy logging already provided
block|}
comment|/**      * Copy the configuration of an core.      * @param clazzInArchive This class is used to identify the archive containing      * the default configuration. Parsing<code>null</code> causes this class to      * be used and therefore initialises the default core configuration contained by      * the SolrYard bundle.      * @param coreDir the target directory for the core      * @param coreName the core name or<code>null</code> to directly load the      * configuration as present under {@value #CONFIG_DIR} in the bundle. This      * property can be used if a bundle needs to provide multiple core      * configurations      * @param override if files in the target directory should be overridden      * @throws IOException On any IO error while coping the configuration      * @throws IllegalStateException If the parsed coreDir does exist but is not      * a directory.      * @throws IllegalArgumentException if<code>null</code> is parsed as coreDir      * or if the parsed bundle does not contain the required information to set       * up an configuration or the parsed coreName is empty.      */
specifier|public
specifier|static
name|void
name|copyCore
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|clazzInArchive
parameter_list|,
name|File
name|coreDir
parameter_list|,
name|String
name|coreName
parameter_list|,
name|boolean
name|override
parameter_list|)
throws|throws
name|IOException
throws|,
name|IllegalArgumentException
throws|,
name|IllegalStateException
block|{
if|if
condition|(
name|coreDir
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed core directory MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|coreDir
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|coreDir
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"The parsed core directory "
operator|+
name|coreDir
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" extists but is not a directory!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|coreName
operator|!=
literal|null
operator|&&
name|coreName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed core name MUST NOT be empty (However NULL is supported)!"
argument_list|)
throw|;
block|}
name|String
name|context
init|=
name|CORE_CONFIG_DIR
operator|+
operator|(
name|coreName
operator|!=
literal|null
condition|?
literal|'/'
operator|+
name|coreName
else|:
literal|""
operator|)
decl_stmt|;
name|File
name|sourceRoot
init|=
name|getSource
argument_list|(
name|clazzInArchive
operator|!=
literal|null
condition|?
name|clazzInArchive
else|:
name|ConfigUtils
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|sourceRoot
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|ZipFile
name|archive
init|=
operator|new
name|ZipFile
argument_list|(
name|sourceRoot
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Copy core %s config from jar-file %s to %s (override=%s)"
argument_list|,
operator|(
name|coreName
operator|==
literal|null
condition|?
literal|""
else|:
name|coreName
operator|)
argument_list|,
name|sourceRoot
operator|.
name|getName
argument_list|()
argument_list|,
name|coreDir
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|override
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
for|for
control|(
name|Enumeration
argument_list|<
name|ZipArchiveEntry
argument_list|>
name|entries
init|=
operator|(
name|Enumeration
argument_list|<
name|ZipArchiveEntry
argument_list|>
operator|)
name|archive
operator|.
name|getEntries
argument_list|()
init|;
name|entries
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|ZipArchiveEntry
name|entry
init|=
name|entries
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
name|context
argument_list|)
condition|)
block|{
name|copyResource
argument_list|(
name|coreDir
argument_list|,
name|archive
argument_list|,
name|entry
argument_list|,
name|context
argument_list|,
name|override
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
comment|//regardless what happens we need to close the archive!
name|ZipFile
operator|.
name|closeQuietly
argument_list|(
name|archive
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//load from file
name|File
name|source
init|=
operator|new
name|File
argument_list|(
name|sourceRoot
argument_list|,
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|source
operator|.
name|exists
argument_list|()
operator|&&
name|source
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|FileUtils
operator|.
name|copyDirectory
argument_list|(
name|source
argument_list|,
name|coreDir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"The SolrIndex default config was not found in directory "
operator|+
name|source
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**      * Converts a parsed String to a File instance. The parsed string can be      * formatted as file URL or as path      * @param uriOrPath the file location as URL or path      * @return the File      */
specifier|public
specifier|static
name|File
name|toFile
parameter_list|(
name|String
name|uriOrPath
parameter_list|)
block|{
name|File
name|file
init|=
literal|null
decl_stmt|;
try|try
block|{
name|URI
name|fileUri
init|=
operator|new
name|URI
argument_list|(
name|uriOrPath
argument_list|)
decl_stmt|;
name|file
operator|=
operator|new
name|File
argument_list|(
name|fileUri
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|e
parameter_list|)
block|{
comment|//not an URI -> ignore
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
comment|//this happens if it is a URI but can not be converted to a file
comment|//still we should try to work with the parsed file ...
block|}
if|if
condition|(
name|file
operator|==
literal|null
condition|)
block|{
name|file
operator|=
operator|new
name|File
argument_list|(
name|uriOrPath
argument_list|)
expr_stmt|;
block|}
return|return
name|file
return|;
block|}
block|}
end_class

end_unit

