begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|model
package|;
end_package

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Calendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|core
operator|.
name|model
operator|.
name|InMemoryValueFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Reference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|ValueFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|defaults
operator|.
name|IndexDataTypeEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|joda
operator|.
name|time
operator|.
name|DateTime
import|;
end_import

begin_import
import|import
name|org
operator|.
name|joda
operator|.
name|time
operator|.
name|DateTimeZone
import|;
end_import

begin_import
import|import
name|org
operator|.
name|joda
operator|.
name|time
operator|.
name|format
operator|.
name|DateTimeFormatter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|joda
operator|.
name|time
operator|.
name|format
operator|.
name|ISODateTimeFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * This class provides methods to convert java objects to {@link IndexValue} and  * vice versa.  *<p>  * Implementation Note: This class needs to be thread save.  *  * @author Rupert Westenthaler  */
end_comment

begin_class
specifier|public
class|class
name|IndexValueFactory
block|{
specifier|private
specifier|static
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|IndexValueFactory
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|ValueFactory
name|valueFactory
init|=
name|InMemoryValueFactory
operator|.
name|getInstance
argument_list|()
decl_stmt|;
specifier|private
specifier|static
name|IndexValueFactory
name|instance
init|=
operator|new
name|IndexValueFactory
argument_list|()
decl_stmt|;
static|static
block|{
comment|//register the default converters
name|instance
operator|.
name|registerConverter
argument_list|(
operator|new
name|BigDecimalConverter
argument_list|()
argument_list|)
expr_stmt|;
name|instance
operator|.
name|registerConverter
argument_list|(
operator|new
name|BigIntegerConverter
argument_list|()
argument_list|)
expr_stmt|;
name|instance
operator|.
name|registerConverter
argument_list|(
operator|new
name|DateConverter
argument_list|()
argument_list|)
expr_stmt|;
name|instance
operator|.
name|registerConverter
argument_list|(
operator|new
name|BooleanConverter
argument_list|()
argument_list|)
expr_stmt|;
name|instance
operator|.
name|registerConverter
argument_list|(
operator|new
name|DoubleConverter
argument_list|()
argument_list|)
expr_stmt|;
name|instance
operator|.
name|registerConverter
argument_list|(
operator|new
name|FloatConverter
argument_list|()
argument_list|)
expr_stmt|;
name|instance
operator|.
name|registerConverter
argument_list|(
operator|new
name|IntegerConverter
argument_list|()
argument_list|)
expr_stmt|;
name|instance
operator|.
name|registerConverter
argument_list|(
operator|new
name|LongConverter
argument_list|()
argument_list|)
expr_stmt|;
name|instance
operator|.
name|registerConverter
argument_list|(
operator|new
name|ReferenceConverter
argument_list|(
name|valueFactory
argument_list|)
argument_list|)
expr_stmt|;
name|instance
operator|.
name|registerConverter
argument_list|(
operator|new
name|StringConverter
argument_list|()
argument_list|)
expr_stmt|;
name|instance
operator|.
name|registerConverter
argument_list|(
operator|new
name|TextConverter
argument_list|(
name|valueFactory
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Get a<code>IndexValueFactory</code>.      *      * @return the<code>IndexValueFactory</code> instance      */
specifier|public
specifier|static
name|IndexValueFactory
name|getInstance
parameter_list|()
block|{
return|return
name|instance
return|;
block|}
comment|//TODO: add support for IndexTypeConverter
comment|//    private Map<IndexType,TypeConverter<?>> indexTypeConverters =
comment|//        new HashMap<IndexType, TypeConverter<?>>();
comment|/**      * Holds the java class to {@link TypeConverter} mapping for all converters      * registered for a Java Class.<p>      * NOTE: this implementation distinguishes between classed and interfaces,      * because for Classes a simple get lookup in the Map can be used while for      * Interfaces we need to Iterate over the entries of the Map and check with      * {@link Class#isAssignableFrom(Class)}.      */
specifier|private
name|Map
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|TypeConverter
argument_list|<
name|?
argument_list|>
argument_list|>
name|javaClassConverters
init|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|HashMap
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|TypeConverter
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|/**      * Holds the java interface to {@link TypeConverter} mappings for all      * converters registered for a Java Interface<p>      * NOTE: this implementation distinguishes between classed and interfaces,      * because for Classes a simple get lookup in the Map can be used while for      * Interfaces we need to Iterate over the entries of the Map and check with      * {@link Class#isAssignableFrom(Class)}.      */
specifier|private
name|Map
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|TypeConverter
argument_list|<
name|?
argument_list|>
argument_list|>
name|javaInterfaceConverters
init|=
operator|new
name|HashMap
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|TypeConverter
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * Registers a converter to this factory. Note that only one converter per      * java type can be registered      * @see TypeConverter#getJavaType()      * @param converter the converter to be registered      */
specifier|public
name|void
name|registerConverter
parameter_list|(
name|TypeConverter
argument_list|<
name|?
argument_list|>
name|converter
parameter_list|)
block|{
if|if
condition|(
name|converter
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|Class
argument_list|<
name|?
argument_list|>
name|javaType
init|=
name|converter
operator|.
name|getJavaType
argument_list|()
decl_stmt|;
if|if
condition|(
name|javaType
operator|.
name|isInterface
argument_list|()
condition|)
block|{
comment|//NOTE: To ensure thread save iterations over Entries of this Map
comment|//create new map instance, add to the new instance and replace reference
comment|// ... i know this is slow, but such calls are very uncommon
name|Map
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|TypeConverter
argument_list|<
name|?
argument_list|>
argument_list|>
name|javaInterfaceConverters
init|=
operator|new
name|HashMap
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|TypeConverter
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|(
name|this
operator|.
name|javaInterfaceConverters
argument_list|)
decl_stmt|;
name|javaInterfaceConverters
operator|.
name|put
argument_list|(
name|javaType
argument_list|,
name|converter
argument_list|)
expr_stmt|;
comment|//TODO: add support for IndexTypeConverter
name|this
operator|.
name|javaInterfaceConverters
operator|=
name|javaInterfaceConverters
expr_stmt|;
block|}
else|else
block|{
comment|//there are no Iterations over this Map!
name|javaClassConverters
operator|.
name|put
argument_list|(
name|javaType
argument_list|,
name|converter
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Removes the converter for the parsed java type      * @param type the java type      * @return the removed converter or<code>null</code> if none was registered      * for the parsed type.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|TypeConverter
argument_list|<
name|T
argument_list|>
name|removeConverter
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|TypeConverter
argument_list|<
name|T
argument_list|>
name|converter
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|isInterface
argument_list|()
condition|)
block|{
if|if
condition|(
name|javaInterfaceConverters
operator|.
name|containsKey
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|//create new map instance, remove to the converter and replace reference
comment|// ... i know this is slow, but such calls are very uncommon
name|Map
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|TypeConverter
argument_list|<
name|?
argument_list|>
argument_list|>
name|javaInterfaceConverters
init|=
operator|new
name|HashMap
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|TypeConverter
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|(
name|this
operator|.
name|javaInterfaceConverters
argument_list|)
decl_stmt|;
name|converter
operator|=
operator|(
name|TypeConverter
argument_list|<
name|T
argument_list|>
operator|)
name|javaInterfaceConverters
operator|.
name|remove
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|this
operator|.
name|javaInterfaceConverters
operator|=
name|javaInterfaceConverters
expr_stmt|;
block|}
else|else
block|{
name|converter
operator|=
literal|null
expr_stmt|;
block|}
block|}
else|else
block|{
name|converter
operator|=
operator|(
name|TypeConverter
argument_list|<
name|T
argument_list|>
operator|)
name|javaClassConverters
operator|.
name|remove
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
return|return
name|converter
return|;
block|}
comment|/**      * Creates the value as used to index the parsed object      *      * @param value the value to be indexed      * @return the index representation of the parsed value      * @throws NoConverterException thrown if<code>value</code> is of an invalid type      * @throws IllegalArgumentException if the parsed value is null      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|IndexValue
name|createIndexValue
parameter_list|(
name|Object
name|value
parameter_list|)
throws|throws
name|NoConverterException
throws|,
name|IllegalArgumentException
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Parameter value MUST NOT be NULL!"
argument_list|)
throw|;
block|}
comment|//first try to get the class and find a converter registered for a class
name|TypeConverter
argument_list|<
name|Object
argument_list|>
name|converter
init|=
operator|(
name|TypeConverter
argument_list|<
name|Object
argument_list|>
operator|)
name|javaClassConverters
operator|.
name|get
argument_list|(
name|value
operator|.
name|getClass
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|converter
operator|!=
literal|null
condition|)
block|{
return|return
name|converter
operator|.
name|createIndexValue
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|//if not successful we need still to search for converters registered for interfaces
for|for
control|(
name|Entry
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|TypeConverter
argument_list|<
name|?
argument_list|>
argument_list|>
name|entry
range|:
name|javaInterfaceConverters
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|isAssignableFrom
argument_list|(
name|value
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
return|return
operator|(
operator|(
name|TypeConverter
argument_list|<
name|Object
argument_list|>
operator|)
name|entry
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|createIndexValue
argument_list|(
name|value
argument_list|)
return|;
block|}
block|}
throw|throw
operator|new
name|NoConverterException
argument_list|(
name|value
operator|.
name|getClass
argument_list|()
argument_list|)
throw|;
block|}
comment|/**      * Converts a IndexValue instance to an instance of the specified class      *      * @param<T>      * @param type the<code>Class</code> of the returned object      * @param indexValue the index value instance      * @return a java object representing the value of the index value      * @throws NoConverterException thrown if<code>type</code> is unsupported      * @throws UnsupportedIndexTypeException if the {@link IndexDataType} of the parsed      *    {@link IndexValue} is not supported by the registered converter      * @throws IllegalArgumentException if any of the two parameter is<code>null</code>      */
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|createValue
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
name|IndexValue
name|indexValue
parameter_list|)
throws|throws
name|NoConverterException
throws|,
name|UnsupportedIndexTypeException
throws|,
name|IllegalArgumentException
block|{
return|return
name|createValue
argument_list|(
name|type
argument_list|,
name|indexValue
operator|.
name|getType
argument_list|()
argument_list|,
name|indexValue
operator|.
name|getType
argument_list|()
argument_list|,
name|indexValue
operator|.
name|getLanguage
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Converts a IndexValue instance to an instance of the specified class      *      * @param<T>      * @param javaType the requested java type      * @param indexType the index type      * @param indexValue the value in the index      * @param language the language of the value in the index      * @return a java object representing the value of the index value      * @throws NoConverterException thrown if<code>type</code> is unsupported      * @throws UnsupportedIndexTypeException if the {@link IndexDataType} of the parsed      *    {@link IndexValue} is not supported by the registered converter      * @throws IllegalArgumentException if any of the two parameter is<code>null</code>      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|createValue
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|javaType
parameter_list|,
name|IndexDataType
name|indexType
parameter_list|,
name|Object
name|indexValue
parameter_list|,
name|String
name|language
parameter_list|)
throws|throws
name|NoConverterException
throws|,
name|UnsupportedIndexTypeException
throws|,
name|IllegalArgumentException
block|{
if|if
condition|(
name|javaType
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Parameter Class<T> type MUST NOT be NULL"
argument_list|)
throw|;
block|}
if|if
condition|(
name|indexValue
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Parameter IndexValue MUST NOT be NULL"
argument_list|)
throw|;
block|}
comment|//search interface converter map if the parsed type is an interface
name|TypeConverter
argument_list|<
name|T
argument_list|>
name|converter
init|=
call|(
name|TypeConverter
argument_list|<
name|T
argument_list|>
call|)
argument_list|(
name|javaType
operator|.
name|isInterface
argument_list|()
condition|?
name|javaInterfaceConverters
operator|.
name|get
argument_list|(
name|javaType
argument_list|)
else|:
name|javaClassConverters
operator|.
name|get
argument_list|(
name|javaType
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|converter
operator|!=
literal|null
condition|)
block|{
return|return
name|converter
operator|.
name|createObject
argument_list|(
name|indexType
argument_list|,
name|indexValue
argument_list|,
name|language
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|NoConverterException
argument_list|(
name|javaType
argument_list|)
throw|;
block|}
block|}
comment|//TODO: add support for IndexTypeConverter
comment|//    /**
comment|//     * Converts a IndexValue instance to an java object. The type of the java
comment|//     * object.
comment|//     * @param indexValue the index value instance
comment|//     * @return a java object representing the value of the index value
comment|//     * @throws NoConverterException if no converter for the index value is registered
comment|//     */
comment|//    public Object createObject(IndexValue indexValue) throws NoConverterException {
comment|//
comment|//    }
comment|/*      * ==== Internal Classes for the default converter Implementations ====      */
specifier|public
specifier|static
class|class
name|DateConverter
implements|implements
name|TypeConverter
argument_list|<
name|Date
argument_list|>
block|{
specifier|private
specifier|static
specifier|final
name|DateTimeFormatter
name|XML_DATE_TIME_FORMAT
init|=
name|ISODateTimeFormat
operator|.
name|dateTime
argument_list|()
operator|.
name|withZone
argument_list|(
name|DateTimeZone
operator|.
name|UTC
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|DateTimeFormatter
name|XML_DATE_TIME_FORMAT_noMillis
init|=
name|ISODateTimeFormat
operator|.
name|dateTimeNoMillis
argument_list|()
operator|.
name|withZone
argument_list|(
name|DateTimeZone
operator|.
name|UTC
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|IndexDataType
name|INDEX_TYPE
init|=
name|IndexDataTypeEnum
operator|.
name|DATE
operator|.
name|getIndexType
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|IndexValue
name|createIndexValue
parameter_list|(
name|Date
name|value
parameter_list|)
block|{
return|return
operator|new
name|IndexValue
argument_list|(
name|XML_DATE_TIME_FORMAT
operator|.
name|print
argument_list|(
name|value
operator|.
name|getTime
argument_list|()
argument_list|)
argument_list|,
name|INDEX_TYPE
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Date
name|createObject
parameter_list|(
name|IndexValue
name|indexValue
parameter_list|)
block|{
if|if
condition|(
name|indexValue
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|createObject
argument_list|(
name|indexValue
operator|.
name|getType
argument_list|()
argument_list|,
name|indexValue
argument_list|,
name|indexValue
operator|.
name|getLanguage
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Class
argument_list|<
name|Date
argument_list|>
name|getJavaType
parameter_list|()
block|{
return|return
name|Date
operator|.
name|class
return|;
block|}
annotation|@
name|Override
specifier|public
name|IndexDataType
name|getIndexType
parameter_list|()
block|{
return|return
name|INDEX_TYPE
return|;
block|}
annotation|@
name|Override
specifier|public
name|Date
name|createObject
parameter_list|(
name|IndexDataType
name|type
parameter_list|,
name|Object
name|value
parameter_list|,
name|String
name|lang
parameter_list|)
throws|throws
name|UnsupportedIndexTypeException
throws|,
name|UnsupportedValueException
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|type
operator|==
literal|null
operator|||
operator|!
name|type
operator|.
name|equals
argument_list|(
name|INDEX_TYPE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|UnsupportedIndexTypeException
argument_list|(
name|this
argument_list|,
name|type
argument_list|)
throw|;
block|}
if|if
condition|(
name|value
operator|instanceof
name|Date
condition|)
block|{
return|return
operator|(
name|Date
operator|)
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Calendar
condition|)
block|{
return|return
operator|(
operator|(
name|Calendar
operator|)
name|value
operator|)
operator|.
name|getTime
argument_list|()
return|;
block|}
else|else
block|{
name|DateTime
name|date
decl_stmt|;
try|try
block|{
comment|//NOTE: Solr only support UTC ... so we need to change the Timezone
name|date
operator|=
name|XML_DATE_TIME_FORMAT
operator|.
name|parseDateTime
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
try|try
block|{
name|date
operator|=
name|XML_DATE_TIME_FORMAT_noMillis
operator|.
name|parseDateTime
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e1
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to parse Date/Time for Value "
operator|+
name|value
operator|.
name|toString
argument_list|()
operator|+
literal|" (use ISO date format (milliseconds optional))! -> no Date Mapping added!"
argument_list|,
name|e1
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|UnsupportedValueException
argument_list|(
name|this
argument_list|,
name|type
argument_list|,
name|value
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|date
operator|.
name|toDate
argument_list|()
return|;
block|}
block|}
block|}
specifier|public
specifier|static
class|class
name|BooleanConverter
implements|implements
name|TypeConverter
argument_list|<
name|Boolean
argument_list|>
block|{
specifier|public
specifier|static
specifier|final
name|IndexDataType
name|INDEX_TYPE
init|=
name|IndexDataTypeEnum
operator|.
name|BOOLEAN
operator|.
name|getIndexType
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|IndexValue
name|createIndexValue
parameter_list|(
name|Boolean
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|IndexValue
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|,
name|INDEX_TYPE
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|createObject
parameter_list|(
name|IndexValue
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|createObject
argument_list|(
name|value
operator|.
name|getType
argument_list|()
argument_list|,
name|value
operator|.
name|getValue
argument_list|()
argument_list|,
name|value
operator|.
name|getLanguage
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Class
argument_list|<
name|Boolean
argument_list|>
name|getJavaType
parameter_list|()
block|{
return|return
name|Boolean
operator|.
name|class
return|;
block|}
annotation|@
name|Override
specifier|public
name|IndexDataType
name|getIndexType
parameter_list|()
block|{
return|return
name|INDEX_TYPE
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|createObject
parameter_list|(
name|IndexDataType
name|type
parameter_list|,
name|Object
name|value
parameter_list|,
name|String
name|lang
parameter_list|)
throws|throws
name|UnsupportedIndexTypeException
throws|,
name|UnsupportedValueException
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|type
operator|==
literal|null
operator|||
operator|!
name|type
operator|.
name|equals
argument_list|(
name|INDEX_TYPE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|UnsupportedIndexTypeException
argument_list|(
name|this
argument_list|,
name|type
argument_list|)
throw|;
block|}
if|if
condition|(
name|value
operator|instanceof
name|Boolean
condition|)
block|{
return|return
operator|(
name|Boolean
operator|)
name|value
return|;
block|}
else|else
block|{
return|return
name|Boolean
operator|.
name|valueOf
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
specifier|public
specifier|static
class|class
name|StringConverter
implements|implements
name|TypeConverter
argument_list|<
name|String
argument_list|>
block|{
specifier|public
specifier|static
specifier|final
name|IndexDataType
name|INDEX_TYPE
init|=
name|IndexDataTypeEnum
operator|.
name|STR
operator|.
name|getIndexType
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|acceptAllIndexTypes
decl_stmt|;
specifier|public
specifier|final
name|boolean
name|isAcceptAllIndexTypes
parameter_list|()
block|{
return|return
name|acceptAllIndexTypes
return|;
block|}
specifier|public
specifier|final
name|void
name|setAcceptAllIndexTypes
parameter_list|(
name|boolean
name|acceptAllIndexTypes
parameter_list|)
block|{
name|this
operator|.
name|acceptAllIndexTypes
operator|=
name|acceptAllIndexTypes
expr_stmt|;
block|}
specifier|public
name|StringConverter
parameter_list|()
block|{
name|this
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|public
name|StringConverter
parameter_list|(
name|boolean
name|acceptAllIndexTypes
parameter_list|)
block|{
name|this
operator|.
name|acceptAllIndexTypes
operator|=
name|acceptAllIndexTypes
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|IndexValue
name|createIndexValue
parameter_list|(
name|String
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|IndexValue
argument_list|(
name|value
argument_list|,
name|INDEX_TYPE
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|createObject
parameter_list|(
name|IndexValue
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|//for now accept any IndexValue regardless of type
comment|//            if(!value.getType().equals(INDEX_TYPE)){
comment|//                new UnsupportedIndexTypeException(this, value);
comment|//            }
return|return
name|value
operator|.
name|getValue
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Class
argument_list|<
name|String
argument_list|>
name|getJavaType
parameter_list|()
block|{
return|return
name|String
operator|.
name|class
return|;
block|}
annotation|@
name|Override
specifier|public
name|IndexDataType
name|getIndexType
parameter_list|()
block|{
return|return
name|INDEX_TYPE
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|createObject
parameter_list|(
name|IndexDataType
name|type
parameter_list|,
name|Object
name|value
parameter_list|,
name|String
name|lang
parameter_list|)
throws|throws
name|UnsupportedIndexTypeException
throws|,
name|UnsupportedValueException
block|{
return|return
name|value
operator|!=
literal|null
condition|?
name|value
operator|.
name|toString
argument_list|()
else|:
literal|null
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|IntegerConverter
implements|implements
name|TypeConverter
argument_list|<
name|Integer
argument_list|>
block|{
specifier|public
specifier|static
specifier|final
name|IndexDataType
name|INDEX_TYPE
init|=
name|IndexDataTypeEnum
operator|.
name|INT
operator|.
name|getIndexType
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|acceptLong
decl_stmt|;
specifier|public
specifier|final
name|boolean
name|isAcceptLong
parameter_list|()
block|{
return|return
name|acceptLong
return|;
block|}
specifier|public
specifier|final
name|void
name|setAcceptLong
parameter_list|(
name|boolean
name|acceptLong
parameter_list|)
block|{
name|this
operator|.
name|acceptLong
operator|=
name|acceptLong
expr_stmt|;
block|}
specifier|public
name|IntegerConverter
parameter_list|()
block|{
name|this
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|public
name|IntegerConverter
parameter_list|(
name|boolean
name|acceptLongIndexType
parameter_list|)
block|{
name|this
operator|.
name|acceptLong
operator|=
name|acceptLongIndexType
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|IndexValue
name|createIndexValue
parameter_list|(
name|Integer
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|IndexValue
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|,
name|INDEX_TYPE
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Integer
name|createObject
parameter_list|(
name|IndexValue
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|createObject
argument_list|(
name|value
operator|.
name|getType
argument_list|()
argument_list|,
name|value
operator|.
name|getValue
argument_list|()
argument_list|,
name|value
operator|.
name|getLanguage
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Class
argument_list|<
name|Integer
argument_list|>
name|getJavaType
parameter_list|()
block|{
comment|// TODO Auto-generated method stub
return|return
name|Integer
operator|.
name|class
return|;
block|}
annotation|@
name|Override
specifier|public
name|IndexDataType
name|getIndexType
parameter_list|()
block|{
return|return
name|INDEX_TYPE
return|;
block|}
annotation|@
name|Override
specifier|public
name|Integer
name|createObject
parameter_list|(
name|IndexDataType
name|type
parameter_list|,
name|Object
name|value
parameter_list|,
name|String
name|lang
parameter_list|)
throws|throws
name|UnsupportedIndexTypeException
throws|,
name|UnsupportedValueException
block|{
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnsupportedIndexTypeException
argument_list|(
name|this
argument_list|,
name|type
argument_list|)
throw|;
block|}
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
name|INDEX_TYPE
argument_list|)
condition|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Integer
condition|)
block|{
return|return
operator|(
name|Integer
operator|)
name|value
return|;
block|}
else|else
block|{
try|try
block|{
return|return
operator|new
name|Integer
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedValueException
argument_list|(
name|this
argument_list|,
name|type
argument_list|,
name|value
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|acceptLong
operator|&&
name|type
operator|.
name|equals
argument_list|(
name|IndexDataTypeEnum
operator|.
name|LONG
operator|.
name|getIndexType
argument_list|()
argument_list|)
condition|)
block|{
name|long
name|longValue
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Long
condition|)
block|{
name|longValue
operator|=
operator|(
operator|(
name|Long
operator|)
name|value
operator|)
operator|.
name|longValue
argument_list|()
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|longValue
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedValueException
argument_list|(
name|this
argument_list|,
name|type
argument_list|,
name|value
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|Integer
operator|.
name|MAX_VALUE
operator|>=
name|longValue
operator|&&
name|Integer
operator|.
name|MIN_VALUE
operator|<=
name|longValue
condition|)
block|{
return|return
operator|new
name|Integer
argument_list|(
operator|(
name|int
operator|)
name|longValue
argument_list|)
return|;
block|}
else|else
block|{
comment|//parsed long value outside of the int range
throw|throw
operator|new
name|UnsupportedValueException
argument_list|(
name|this
argument_list|,
name|type
argument_list|,
name|value
argument_list|,
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to convert LONG Value to Integer, because the value is outside of the Integer Range!"
argument_list|)
argument_list|)
throw|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|UnsupportedIndexTypeException
argument_list|(
name|this
argument_list|,
name|type
argument_list|)
throw|;
block|}
block|}
block|}
specifier|public
specifier|static
class|class
name|LongConverter
implements|implements
name|TypeConverter
argument_list|<
name|Long
argument_list|>
block|{
specifier|public
specifier|static
specifier|final
name|IndexDataType
name|LONG_TYPE
init|=
name|IndexDataTypeEnum
operator|.
name|LONG
operator|.
name|getIndexType
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|IndexDataType
name|INT_TYPE
init|=
name|IndexDataTypeEnum
operator|.
name|INT
operator|.
name|getIndexType
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|IndexValue
name|createIndexValue
parameter_list|(
name|Long
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|IndexValue
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|,
name|LONG_TYPE
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Long
name|createObject
parameter_list|(
name|IndexValue
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|createObject
argument_list|(
name|value
operator|.
name|getType
argument_list|()
argument_list|,
name|value
operator|.
name|getValue
argument_list|()
argument_list|,
name|value
operator|.
name|getLanguage
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Class
argument_list|<
name|Long
argument_list|>
name|getJavaType
parameter_list|()
block|{
return|return
name|Long
operator|.
name|class
return|;
block|}
annotation|@
name|Override
specifier|public
name|IndexDataType
name|getIndexType
parameter_list|()
block|{
return|return
name|LONG_TYPE
return|;
block|}
annotation|@
name|Override
specifier|public
name|Long
name|createObject
parameter_list|(
name|IndexDataType
name|type
parameter_list|,
name|Object
name|value
parameter_list|,
name|String
name|lang
parameter_list|)
throws|throws
name|UnsupportedIndexTypeException
throws|,
name|UnsupportedValueException
block|{
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnsupportedIndexTypeException
argument_list|(
name|this
argument_list|,
name|type
argument_list|)
throw|;
block|}
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
name|LONG_TYPE
argument_list|)
operator|||
name|type
operator|.
name|equals
argument_list|(
name|INT_TYPE
argument_list|)
condition|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|Long
operator|)
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Integer
condition|)
block|{
return|return
operator|(
operator|(
name|Integer
operator|)
name|value
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
try|try
block|{
return|return
operator|new
name|Long
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedValueException
argument_list|(
name|this
argument_list|,
name|type
argument_list|,
name|value
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|UnsupportedIndexTypeException
argument_list|(
name|this
argument_list|,
name|type
argument_list|)
throw|;
block|}
block|}
block|}
specifier|public
specifier|static
class|class
name|DoubleConverter
implements|implements
name|TypeConverter
argument_list|<
name|Double
argument_list|>
block|{
specifier|public
specifier|static
specifier|final
name|IndexDataType
name|INDEX_TYPE
init|=
name|IndexDataTypeEnum
operator|.
name|DOUBLE
operator|.
name|getIndexType
argument_list|()
decl_stmt|;
specifier|private
specifier|static
name|Set
argument_list|<
name|IndexDataType
argument_list|>
name|SUPPORTED
init|=
operator|new
name|HashSet
argument_list|<
name|IndexDataType
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|IndexDataTypeEnum
operator|.
name|FLOAT
operator|.
name|getIndexType
argument_list|()
argument_list|,
name|IndexDataTypeEnum
operator|.
name|INT
operator|.
name|getIndexType
argument_list|()
argument_list|,
name|IndexDataTypeEnum
operator|.
name|LONG
operator|.
name|getIndexType
argument_list|()
argument_list|,
name|INDEX_TYPE
argument_list|)
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|IndexValue
name|createIndexValue
parameter_list|(
name|Double
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|IndexValue
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|,
name|INDEX_TYPE
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Double
name|createObject
parameter_list|(
name|IndexValue
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|createObject
argument_list|(
name|value
operator|.
name|getType
argument_list|()
argument_list|,
name|value
operator|.
name|getValue
argument_list|()
argument_list|,
name|value
operator|.
name|getLanguage
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Class
argument_list|<
name|Double
argument_list|>
name|getJavaType
parameter_list|()
block|{
return|return
name|Double
operator|.
name|class
return|;
block|}
annotation|@
name|Override
specifier|public
name|IndexDataType
name|getIndexType
parameter_list|()
block|{
return|return
name|INDEX_TYPE
return|;
block|}
annotation|@
name|Override
specifier|public
name|Double
name|createObject
parameter_list|(
name|IndexDataType
name|type
parameter_list|,
name|Object
name|value
parameter_list|,
name|String
name|lang
parameter_list|)
throws|throws
name|UnsupportedIndexTypeException
throws|,
name|UnsupportedValueException
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|SUPPORTED
operator|.
name|contains
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
name|Double
operator|)
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Float
operator|)
name|value
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
else|else
block|{
try|try
block|{
return|return
operator|new
name|Double
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedValueException
argument_list|(
name|this
argument_list|,
name|type
argument_list|,
name|value
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|UnsupportedIndexTypeException
argument_list|(
name|this
argument_list|,
name|type
argument_list|)
throw|;
block|}
block|}
block|}
specifier|public
specifier|static
class|class
name|FloatConverter
implements|implements
name|TypeConverter
argument_list|<
name|Float
argument_list|>
block|{
specifier|public
specifier|static
specifier|final
name|IndexDataType
name|INDEX_TYPE
init|=
name|IndexDataTypeEnum
operator|.
name|FLOAT
operator|.
name|getIndexType
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Collection
argument_list|<
name|IndexDataType
argument_list|>
name|DOUBLE_LONG_TYPES
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|IndexDataTypeEnum
operator|.
name|LONG
operator|.
name|getIndexType
argument_list|()
argument_list|,
name|IndexDataTypeEnum
operator|.
name|DOUBLE
operator|.
name|getIndexType
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|IndexDataType
argument_list|>
name|supported
init|=
name|Collections
operator|.
name|synchronizedSet
argument_list|(
operator|new
name|HashSet
argument_list|<
name|IndexDataType
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
specifier|public
name|FloatConverter
parameter_list|()
block|{
name|this
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|public
name|FloatConverter
parameter_list|(
name|boolean
name|acceptDoubleAndLongIndexType
parameter_list|)
block|{
name|supported
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|IndexDataTypeEnum
operator|.
name|INT
operator|.
name|getIndexType
argument_list|()
argument_list|,
name|INDEX_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|setAcceptDoubleAndLongIndexTypes
argument_list|(
name|acceptDoubleAndLongIndexType
argument_list|)
expr_stmt|;
block|}
specifier|public
name|boolean
name|isAcceptDoubleAndLongIndexTypes
parameter_list|()
block|{
return|return
name|supported
operator|.
name|containsAll
argument_list|(
name|DOUBLE_LONG_TYPES
argument_list|)
return|;
block|}
specifier|public
name|void
name|setAcceptDoubleAndLongIndexTypes
parameter_list|(
name|boolean
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
condition|)
block|{
name|supported
operator|.
name|addAll
argument_list|(
name|DOUBLE_LONG_TYPES
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|supported
operator|.
name|removeAll
argument_list|(
name|DOUBLE_LONG_TYPES
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|IndexValue
name|createIndexValue
parameter_list|(
name|Float
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|IndexValue
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|,
name|INDEX_TYPE
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Float
name|createObject
parameter_list|(
name|IndexValue
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|createObject
argument_list|(
name|value
operator|.
name|getType
argument_list|()
argument_list|,
name|value
operator|.
name|getValue
argument_list|()
argument_list|,
name|value
operator|.
name|getLanguage
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Class
argument_list|<
name|Float
argument_list|>
name|getJavaType
parameter_list|()
block|{
return|return
name|Float
operator|.
name|class
return|;
block|}
annotation|@
name|Override
specifier|public
name|IndexDataType
name|getIndexType
parameter_list|()
block|{
return|return
name|INDEX_TYPE
return|;
block|}
annotation|@
name|Override
specifier|public
name|Float
name|createObject
parameter_list|(
name|IndexDataType
name|type
parameter_list|,
name|Object
name|value
parameter_list|,
name|String
name|lang
parameter_list|)
throws|throws
name|UnsupportedIndexTypeException
throws|,
name|UnsupportedValueException
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|supported
operator|.
name|contains
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|Float
operator|)
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Double
operator|)
name|value
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
else|else
block|{
try|try
block|{
return|return
operator|new
name|Float
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedValueException
argument_list|(
name|this
argument_list|,
name|type
argument_list|,
name|value
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|UnsupportedIndexTypeException
argument_list|(
name|this
argument_list|,
name|type
argument_list|)
throw|;
block|}
block|}
block|}
specifier|public
specifier|static
class|class
name|BigIntegerConverter
implements|implements
name|TypeConverter
argument_list|<
name|BigInteger
argument_list|>
block|{
specifier|public
specifier|static
specifier|final
name|IndexDataType
name|INDEX_TYPE
init|=
name|IndexDataTypeEnum
operator|.
name|LONG
operator|.
name|getIndexType
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|IndexDataType
name|INT_TYPE
init|=
name|IndexDataTypeEnum
operator|.
name|INT
operator|.
name|getIndexType
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|IndexValue
name|createIndexValue
parameter_list|(
name|BigInteger
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|IndexValue
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|,
name|INDEX_TYPE
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|BigInteger
name|createObject
parameter_list|(
name|IndexValue
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|createObject
argument_list|(
name|value
operator|.
name|getType
argument_list|()
argument_list|,
name|value
operator|.
name|getValue
argument_list|()
argument_list|,
name|value
operator|.
name|getLanguage
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Class
argument_list|<
name|BigInteger
argument_list|>
name|getJavaType
parameter_list|()
block|{
return|return
name|BigInteger
operator|.
name|class
return|;
block|}
annotation|@
name|Override
specifier|public
name|IndexDataType
name|getIndexType
parameter_list|()
block|{
return|return
name|INDEX_TYPE
return|;
block|}
annotation|@
name|Override
specifier|public
name|BigInteger
name|createObject
parameter_list|(
name|IndexDataType
name|type
parameter_list|,
name|Object
name|value
parameter_list|,
name|String
name|lang
parameter_list|)
throws|throws
name|UnsupportedIndexTypeException
throws|,
name|UnsupportedValueException
block|{
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnsupportedIndexTypeException
argument_list|(
name|this
argument_list|,
name|type
argument_list|)
throw|;
block|}
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
name|INDEX_TYPE
argument_list|)
operator|||
name|type
operator|.
name|equals
argument_list|(
name|INT_TYPE
argument_list|)
condition|)
block|{
try|try
block|{
return|return
operator|new
name|BigInteger
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedValueException
argument_list|(
name|this
argument_list|,
name|type
argument_list|,
name|value
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|UnsupportedIndexTypeException
argument_list|(
name|this
argument_list|,
name|type
argument_list|)
throw|;
block|}
block|}
block|}
specifier|public
specifier|static
class|class
name|BigDecimalConverter
implements|implements
name|TypeConverter
argument_list|<
name|BigDecimal
argument_list|>
block|{
specifier|public
specifier|static
specifier|final
name|IndexDataType
name|INDEX_TYPE
init|=
name|IndexDataTypeEnum
operator|.
name|DOUBLE
operator|.
name|getIndexType
argument_list|()
decl_stmt|;
specifier|private
specifier|static
name|Set
argument_list|<
name|IndexDataType
argument_list|>
name|SUPPORTED
init|=
operator|new
name|HashSet
argument_list|<
name|IndexDataType
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|IndexDataTypeEnum
operator|.
name|FLOAT
operator|.
name|getIndexType
argument_list|()
argument_list|,
name|IndexDataTypeEnum
operator|.
name|INT
operator|.
name|getIndexType
argument_list|()
argument_list|,
name|IndexDataTypeEnum
operator|.
name|LONG
operator|.
name|getIndexType
argument_list|()
argument_list|,
name|INDEX_TYPE
argument_list|)
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|IndexValue
name|createIndexValue
parameter_list|(
name|BigDecimal
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|IndexValue
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|,
name|INDEX_TYPE
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|BigDecimal
name|createObject
parameter_list|(
name|IndexValue
name|value
parameter_list|)
block|{
return|return
name|createObject
argument_list|(
name|value
operator|.
name|getType
argument_list|()
argument_list|,
name|value
operator|.
name|getValue
argument_list|()
argument_list|,
name|value
operator|.
name|getLanguage
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|BigDecimal
name|createObject
parameter_list|(
name|IndexDataType
name|type
parameter_list|,
name|Object
name|value
parameter_list|,
name|String
name|lang
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|SUPPORTED
operator|.
name|contains
argument_list|(
name|type
argument_list|)
condition|)
block|{
try|try
block|{
return|return
operator|new
name|BigDecimal
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedValueException
argument_list|(
name|this
argument_list|,
name|type
argument_list|,
name|value
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|UnsupportedIndexTypeException
argument_list|(
name|type
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Class
argument_list|<
name|BigDecimal
argument_list|>
name|getJavaType
parameter_list|()
block|{
return|return
name|BigDecimal
operator|.
name|class
return|;
block|}
annotation|@
name|Override
specifier|public
name|IndexDataType
name|getIndexType
parameter_list|()
block|{
return|return
name|INDEX_TYPE
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|TextConverter
implements|implements
name|TypeConverter
argument_list|<
name|Text
argument_list|>
block|{
specifier|public
specifier|static
specifier|final
name|IndexDataType
name|INDEX_TYPE
init|=
name|IndexDataTypeEnum
operator|.
name|TXT
operator|.
name|getIndexType
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|IndexDataType
name|STRING_TYPE
init|=
name|IndexDataTypeEnum
operator|.
name|STR
operator|.
name|getIndexType
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|ValueFactory
name|valueFactory
decl_stmt|;
specifier|public
name|TextConverter
parameter_list|(
name|ValueFactory
name|valueFactory
parameter_list|)
block|{
if|if
condition|(
name|valueFactory
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Parameter ValueFactory MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|this
operator|.
name|valueFactory
operator|=
name|valueFactory
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|IndexValue
name|createIndexValue
parameter_list|(
name|Text
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|IndexValue
argument_list|(
name|value
operator|.
name|getText
argument_list|()
argument_list|,
name|INDEX_TYPE
argument_list|,
name|value
operator|.
name|getLanguage
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Text
name|createObject
parameter_list|(
name|IndexValue
name|value
parameter_list|)
throws|throws
name|UnsupportedIndexTypeException
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|createObject
argument_list|(
name|value
operator|.
name|getType
argument_list|()
argument_list|,
name|value
operator|.
name|getValue
argument_list|()
argument_list|,
name|value
operator|.
name|getLanguage
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Class
argument_list|<
name|Text
argument_list|>
name|getJavaType
parameter_list|()
block|{
return|return
name|Text
operator|.
name|class
return|;
block|}
annotation|@
name|Override
specifier|public
name|IndexDataType
name|getIndexType
parameter_list|()
block|{
return|return
name|INDEX_TYPE
return|;
block|}
annotation|@
name|Override
specifier|public
name|Text
name|createObject
parameter_list|(
name|IndexDataType
name|type
parameter_list|,
name|Object
name|value
parameter_list|,
name|String
name|lang
parameter_list|)
throws|throws
name|UnsupportedIndexTypeException
throws|,
name|UnsupportedValueException
block|{
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnsupportedIndexTypeException
argument_list|(
name|this
argument_list|,
name|type
argument_list|)
throw|;
block|}
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
name|INDEX_TYPE
argument_list|)
operator|||
name|type
operator|.
name|equals
argument_list|(
name|STRING_TYPE
argument_list|)
condition|)
block|{
return|return
name|valueFactory
operator|.
name|createText
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|,
name|lang
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|UnsupportedIndexTypeException
argument_list|(
name|this
argument_list|,
name|type
argument_list|)
throw|;
block|}
block|}
block|}
specifier|public
specifier|static
class|class
name|ReferenceConverter
implements|implements
name|TypeConverter
argument_list|<
name|Reference
argument_list|>
block|{
specifier|public
specifier|static
specifier|final
name|IndexDataType
name|INDEX_TYPE
init|=
name|IndexDataTypeEnum
operator|.
name|REF
operator|.
name|getIndexType
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|ValueFactory
name|valueFactory
decl_stmt|;
specifier|public
name|ReferenceConverter
parameter_list|(
name|ValueFactory
name|valueFactory
parameter_list|)
block|{
if|if
condition|(
name|valueFactory
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Parameter ValueFactory MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|this
operator|.
name|valueFactory
operator|=
name|valueFactory
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|IndexValue
name|createIndexValue
parameter_list|(
name|Reference
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|IndexValue
argument_list|(
name|value
operator|.
name|getReference
argument_list|()
argument_list|,
name|INDEX_TYPE
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Reference
name|createObject
parameter_list|(
name|IndexValue
name|value
parameter_list|)
throws|throws
name|UnsupportedIndexTypeException
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|createObject
argument_list|(
name|value
operator|.
name|getType
argument_list|()
argument_list|,
name|value
operator|.
name|getValue
argument_list|()
argument_list|,
name|value
operator|.
name|getLanguage
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Class
argument_list|<
name|Reference
argument_list|>
name|getJavaType
parameter_list|()
block|{
return|return
name|Reference
operator|.
name|class
return|;
block|}
annotation|@
name|Override
specifier|public
name|IndexDataType
name|getIndexType
parameter_list|()
block|{
return|return
name|INDEX_TYPE
return|;
block|}
annotation|@
name|Override
specifier|public
name|Reference
name|createObject
parameter_list|(
name|IndexDataType
name|type
parameter_list|,
name|Object
name|value
parameter_list|,
name|String
name|lang
parameter_list|)
throws|throws
name|UnsupportedIndexTypeException
throws|,
name|UnsupportedValueException
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|type
operator|!=
literal|null
operator|&&
name|type
operator|.
name|equals
argument_list|(
name|INDEX_TYPE
argument_list|)
condition|)
block|{
return|return
name|valueFactory
operator|.
name|createReference
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|UnsupportedIndexTypeException
argument_list|(
name|this
argument_list|,
name|type
argument_list|)
throw|;
block|}
block|}
block|}
block|}
end_class

end_unit

