begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|impl
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|defaults
operator|.
name|SolrConst
operator|.
name|DEPENDENT_DOCUMENT_FIELD
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|defaults
operator|.
name|SolrConst
operator|.
name|DOCUMENT_ID_FIELD
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|defaults
operator|.
name|SolrConst
operator|.
name|DOMAIN_FIELD
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|defaults
operator|.
name|SolrConst
operator|.
name|FULL_TEXT_FIELD
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|defaults
operator|.
name|SolrConst
operator|.
name|PATH_SEPERATOR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|defaults
operator|.
name|SolrConst
operator|.
name|REFERRED_DOCUMENT_FIELD
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|defaults
operator|.
name|SolrConst
operator|.
name|SPECIAL_CONFIG_FIELD
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|AccessController
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedActionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrServerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|response
operator|.
name|QueryResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrInputDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|namespaceprefix
operator|.
name|NamespacePrefixService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|utils
operator|.
name|SolrUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|defaults
operator|.
name|NamespaceEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|defaults
operator|.
name|SpecialFieldEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|rdf
operator|.
name|RdfResourceEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|util
operator|.
name|ModelUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|defaults
operator|.
name|IndexDataTypeEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|defaults
operator|.
name|SolrConst
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|model
operator|.
name|FieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|model
operator|.
name|IndexField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|model
operator|.
name|IndexValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Implementation of the FieldMapper for a Solr Index.  *   * @author Rupert Westenthaler  *   */
end_comment

begin_class
specifier|public
class|class
name|SolrFieldMapper
implements|implements
name|FieldMapper
block|{
specifier|private
specifier|static
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SolrFieldMapper
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * Char used to separate the prefix from the local name of uri's      */
specifier|private
specifier|static
specifier|final
name|char
name|NAMESPACE_PREFIX_SEPERATOR_CHAR
init|=
literal|':'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|LANG_MERGER_PREFIX
init|=
literal|""
operator|+
name|SolrConst
operator|.
name|SPECIAL_FIELD_PREFIX
operator|+
name|SolrConst
operator|.
name|MERGER_INDICATOR
operator|+
name|SolrConst
operator|.
name|LANG_INDICATOR
decl_stmt|;
comment|/**      * The size of the LRU cache for FieldName to IndexField as well as IndexField to collection of FieldNames      * mappings.      *<p>      * Note that both caches may have a maximum of elements as configured by this property.      */
specifier|private
specifier|static
specifier|final
name|int
name|LRU_MAPPINGS_CACHE_SIZE
init|=
literal|1024
decl_stmt|;
comment|/**      * The IndexField for the Solr score. This field is mapped to the field      * {@link RdfResourceEnum#resultScore} and uses {@link IndexDataTypeEnum#FLOAT}      */
specifier|private
specifier|static
specifier|final
name|IndexField
name|scoreField
init|=
operator|new
name|IndexField
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|RdfResourceEnum
operator|.
name|resultScore
operator|.
name|getUri
argument_list|()
argument_list|)
argument_list|,
name|IndexDataTypeEnum
operator|.
name|FLOAT
operator|.
name|getIndexType
argument_list|()
argument_list|)
decl_stmt|;
comment|/**      * The Solr Server of this FieldMapper      */
specifier|protected
specifier|final
name|SolrServer
name|server
decl_stmt|;
comment|/**      * Internally used as LRU Cache with {@link SolrFieldMapper#LRU_MAPPINGS_CACHE_SIZE} elements. This      * subclass of {@link LinkedHashMap} overrides the {@link LinkedHashMap#removeEldestEntry(Entry)} as      * suggested by the java doc. It also uses the constructor that activates the ordering based on access      * time rather tan insertion time.      *       * @author Rupert Westenthaler      *       * @param<K>      *            generic type of the key      * @param<V>      *            generic type of the value      */
specifier|private
specifier|static
specifier|final
class|class
name|LRU
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|LinkedHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
specifier|public
name|LRU
parameter_list|()
block|{
name|super
argument_list|(
literal|16
argument_list|,
literal|0.75f
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// access order!
block|}
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
annotation|@
name|Override
specifier|protected
name|boolean
name|removeEldestEntry
parameter_list|(
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|eldest
parameter_list|)
block|{
return|return
name|size
argument_list|()
operator|>
name|LRU_MAPPINGS_CACHE_SIZE
return|;
block|}
block|}
comment|/**      * The assumption is, that only a handful of {@link IndexField}s are used very often.      *<p>      * So it makes sense to keep some mappings within a cache rather than calculating them again and again.      *       * @see LinkedHashMap#      */
specifier|private
specifier|final
name|Map
argument_list|<
name|IndexField
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|indexFieldMappings
init|=
comment|//STANBOL-669: LRU chaches MUST BE synchronized!
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|LRU
argument_list|<
name|IndexField
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|/**      * The assumption is, that only a handful of fields appear in index documents. So it makes sense to keep      * some mappings within a cache rather than calculating them again and again.      */
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|IndexField
argument_list|>
name|fieldMappings
init|=
comment|//STANBOL-669: LRU chaches MUST BE synchronized!
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|LRU
argument_list|<
name|String
argument_list|,
name|IndexField
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
name|NamespacePrefixService
name|nsPrefixService
decl_stmt|;
specifier|public
name|SolrFieldMapper
parameter_list|(
name|SolrServer
name|server
parameter_list|,
name|NamespacePrefixService
name|nps
parameter_list|)
block|{
if|if
condition|(
name|server
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"NULL parsed as SolrServer: Loading and Saving of the Namespace Prefix Settings will be deactivated!"
argument_list|)
expr_stmt|;
name|log
operator|.
name|warn
argument_list|(
literal|"  This is OK for Unit Test but should not happen in productive use!"
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|nsPrefixService
operator|=
name|nps
expr_stmt|;
name|this
operator|.
name|server
operator|=
name|server
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|IndexField
name|getField
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
if|if
condition|(
name|fieldName
operator|==
literal|null
operator|||
name|fieldName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field name MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|IndexField
name|field
init|=
name|fieldMappings
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|getDocumentIdField
argument_list|()
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|)
operator|||
name|fieldName
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
name|SolrConst
operator|.
name|SPECIAL_FIELD_PREFIX
condition|)
block|{
comment|// in case of special field or the document ID, return null ->
comment|// meaning, that this index document field does not represent
comment|// an logical IndexField and should be ignored
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|SolrConst
operator|.
name|SCORE_FIELD
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
return|return
name|scoreField
return|;
block|}
comment|// parse the prefix and suffix
name|String
index|[]
name|tokens
init|=
name|fieldName
operator|.
name|split
argument_list|(
name|Character
operator|.
name|toString
argument_list|(
name|SolrConst
operator|.
name|PATH_SEPERATOR
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|numTokens
init|=
name|tokens
operator|.
name|length
decl_stmt|;
name|int
name|pathElements
init|=
name|numTokens
decl_stmt|;
name|String
name|prefix
init|=
literal|null
decl_stmt|;
name|String
name|suffix
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|tokens
operator|.
name|length
operator|>=
literal|2
condition|)
block|{
name|prefix
operator|=
name|tokens
index|[
literal|0
index|]
expr_stmt|;
name|pathElements
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|tokens
operator|.
name|length
operator|>=
literal|3
condition|)
block|{
name|suffix
operator|=
name|tokens
index|[
name|numTokens
operator|-
literal|1
index|]
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|pathElements
operator|--
expr_stmt|;
block|}
comment|// parse the path
name|String
index|[]
name|path
init|=
operator|new
name|String
index|[
name|pathElements
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|tokens
argument_list|,
name|prefix
operator|==
literal|null
condition|?
literal|0
else|:
literal|1
argument_list|,
name|path
argument_list|,
literal|0
argument_list|,
name|pathElements
argument_list|)
expr_stmt|;
name|tokens
operator|=
literal|null
expr_stmt|;
comment|// process the parsed data
name|field
operator|=
name|parseIndexField
argument_list|(
name|prefix
argument_list|,
name|suffix
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|!=
literal|null
condition|)
block|{
name|fieldMappings
operator|.
name|put
argument_list|(
name|fieldName
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|field
return|;
block|}
comment|/**      * This method does the dirty work of parsing the different parts of the field in the SolrDocument to the      * logical field as used by the semantic indexing API. This method assumes the following encoding      *<code><pre>      *   .        ... path separator      *   _        ... special field indicator      *   __       ... escaped special field      *   !        ... merger - collected values of other fields.      *                Such fields do not have an mapping to logical IndexFields.      *                All mergers are created by copyField configurations within the      *                Solr Schema configuration      *   @        ... '@' indicates a field in a given language      *     _@.&lt;field&gt;: A value for a field with no language defined      *     _@en.&lt;field&gt;: A value for a field in English      *     _!@.&lt;field&gt;: Contains all labels regardless of language      *     _!@en.&lt;field&gt;: Contains all labels of languages that start with "en"      *&lt;prefix&gt; ... indicates an dataType that used this prefix      *     _str.&lt;field&gt;: A string field (containing no language)      *     _ref.&lt;field&gt;: A reference (similar to xsd:anyURI)      *     _bool.&lt;field&gt;: A boolean value      *       * NOTE: Prefixes/Suffixes can be used to define a hierarchy of data types      * e.g. use Prefixes for dataTypes:      *   _n   ... any kind of numeric value      *   _ni  ... any kind of integer value (BigInteger)      *   _nib ... a byte      *   _nii ... a integer      *   _nil ... a long      *   _nd  ... a decimal value      *   _ndf ... float      *   _ndd ... double      *   _s   ... any kind of string value      *   _si  ... an string based ID      *   _sr  ... a reference      * e.g. use Suffixes for semantic meanings      *   ._ct ... a tag      *   ._cr ... a category using a reference to an entity ID (xsd:anyURI)      *   ._ci ... a categorisation using an local id (e.g 2 letter country codes)      *       *  one can now create Solr copyField commands to support searches spanning      *  over multiple types      *  _!n  ... search for any kind of numbers      *  _!ni ... search for any kind of integers      *  _!s  ... search in all kind of string values      *  _!sc ... search for all categories of this document      *       *</pre><code>      *       * @param prefix      * @param suffix      * @param pathElements      * @return      */
specifier|private
name|IndexField
name|parseIndexField
parameter_list|(
specifier|final
name|String
name|prefix
parameter_list|,
specifier|final
name|String
name|suffix
parameter_list|,
specifier|final
name|String
index|[]
name|pathElements
parameter_list|)
block|{
specifier|final
name|String
name|language
decl_stmt|;
name|boolean
name|isLanguage
init|=
literal|false
decl_stmt|;
specifier|final
name|String
name|dataTypePrefix
decl_stmt|;
comment|// first use the prefix to parse the language
comment|// -> note that the prefix might also be used for the data type!
if|if
condition|(
name|prefix
operator|!=
literal|null
operator|&&
operator|!
name|prefix
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|prefix
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
name|SolrConst
operator|.
name|LANG_INDICATOR
condition|)
block|{
name|isLanguage
operator|=
literal|true
expr_stmt|;
comment|// it is a language prefix!
comment|// set dataTypePrefix to null
name|dataTypePrefix
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|prefix
operator|.
name|length
argument_list|()
operator|>
literal|1
condition|)
block|{
name|language
operator|=
name|prefix
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// it is a language prefix, but for the default language!
name|language
operator|=
literal|null
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// it is no language prefix
name|language
operator|=
literal|null
expr_stmt|;
name|isLanguage
operator|=
literal|false
expr_stmt|;
name|dataTypePrefix
operator|=
name|prefix
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// no prefix at all
comment|// set no-language and the dataType prefix to null;
name|isLanguage
operator|=
literal|false
expr_stmt|;
name|language
operator|=
literal|null
expr_stmt|;
name|dataTypePrefix
operator|=
literal|null
expr_stmt|;
block|}
comment|// now parse the indexDataType!
name|IndexDataTypeEnum
name|dataTypeEnumEntry
init|=
name|IndexDataTypeEnum
operator|.
name|forPrefixSuffix
argument_list|(
name|dataTypePrefix
argument_list|,
name|suffix
argument_list|)
decl_stmt|;
if|if
condition|(
name|dataTypeEnumEntry
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"No IndexDataType registered for prefix: %s and suffix: %s -> unable to process path %s"
argument_list|,
name|dataTypePrefix
argument_list|,
name|suffix
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|pathElements
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
comment|// we might also throw an exception at this point
block|}
comment|// parse the path
name|List
argument_list|<
name|String
argument_list|>
name|path
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|pathElements
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|pathElement
range|:
name|pathElements
control|)
block|{
if|if
condition|(
name|pathElement
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
name|SolrConst
operator|.
name|SPECIAL_FIELD_PREFIX
condition|)
block|{
if|if
condition|(
name|pathElement
operator|.
name|charAt
argument_list|(
literal|1
argument_list|)
operator|==
name|SolrConst
operator|.
name|SPECIAL_FIELD_PREFIX
condition|)
block|{
name|path
operator|.
name|add
argument_list|(
name|getFullFieldName
argument_list|(
name|pathElement
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Found special field \"%s\" within the path \"%s\" -> Special fields are only allowed as prefix and suffix!"
argument_list|,
name|pathElement
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|pathElements
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|String
name|fullName
init|=
name|getFullFieldName
argument_list|(
name|pathElement
argument_list|)
decl_stmt|;
if|if
condition|(
name|fullName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unable to map PathElement %s to it's full Name (path=%s)!"
argument_list|,
name|pathElement
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|pathElements
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
else|else
block|{
name|path
operator|.
name|add
argument_list|(
name|fullName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|isLanguage
condition|)
block|{
return|return
operator|new
name|IndexField
argument_list|(
name|path
argument_list|,
name|dataTypeEnumEntry
operator|.
name|getIndexType
argument_list|()
argument_list|,
name|language
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|IndexField
argument_list|(
name|path
argument_list|,
name|dataTypeEnumEntry
operator|.
name|getIndexType
argument_list|()
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|getFieldNames
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|path
parameter_list|,
name|IndexValue
name|indexValue
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|IndexField
name|field
decl_stmt|;
if|if
condition|(
name|indexValue
operator|.
name|hasLanguage
argument_list|()
condition|)
block|{
name|field
operator|=
operator|new
name|IndexField
argument_list|(
name|path
argument_list|,
name|indexValue
operator|.
name|getType
argument_list|()
argument_list|,
name|indexValue
operator|.
name|getLanguage
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|field
operator|=
operator|new
name|IndexField
argument_list|(
name|path
argument_list|,
name|indexValue
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|getFieldNames
argument_list|(
name|field
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|getQueryFieldNames
parameter_list|(
name|IndexField
name|indexField
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|fields
init|=
name|getFieldNames
argument_list|(
name|indexField
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|indexField
operator|.
name|getLanguages
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|indexField
operator|.
name|getLanguages
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
operator|&&
name|IndexDataTypeEnum
operator|.
name|forIndexType
argument_list|(
name|indexField
operator|.
name|getDataType
argument_list|()
argument_list|)
operator|.
name|isLanguageType
argument_list|()
condition|)
block|{
return|return
name|fields
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|fields
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
return|;
comment|//cut of the field with all languages
block|}
else|else
block|{
return|return
name|fields
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getFieldNames
parameter_list|(
name|IndexField
name|indexField
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
name|indexField
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed IndexField name MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
init|=
name|indexFieldMappings
operator|.
name|get
argument_list|(
name|indexField
argument_list|)
decl_stmt|;
if|if
condition|(
name|fieldNames
operator|==
literal|null
condition|)
block|{
name|SpecialFieldEnum
name|specialField
init|=
name|indexField
operator|.
name|getSpecialField
argument_list|()
decl_stmt|;
comment|//check for special field;
if|if
condition|(
name|specialField
operator|!=
literal|null
condition|)
block|{
switch|switch
condition|(
name|specialField
condition|)
block|{
case|case
name|fullText
case|:
name|fieldNames
operator|=
name|Collections
operator|.
name|singletonList
argument_list|(
name|getFullTextSearchField
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|references
case|:
name|fieldNames
operator|=
name|Collections
operator|.
name|singletonList
argument_list|(
name|getReferredDocumentField
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unsupported Special Field '"
operator|+
name|specialField
operator|.
name|getUri
argument_list|()
operator|+
literal|"! Please report this to the "
operator|+
literal|"Stanbol Developer Mailing list or create an according"
operator|+
literal|"JIRA issue at https://issues.apache.org/jira/browse/STANBOL!"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|fieldNames
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|//typically only 1 or 2 values
name|IndexDataTypeEnum
name|dataTypeConfig
init|=
name|IndexDataTypeEnum
operator|.
name|forIndexType
argument_list|(
name|indexField
operator|.
name|getDataType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|dataTypeConfig
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"No Config found for the parsed IndexDataType %s"
argument_list|,
name|indexField
operator|.
name|getDataType
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
comment|// Three things need to be done
comment|// 1) Encode the Path
name|String
name|pathName
init|=
name|encodePathName
argument_list|(
name|indexField
argument_list|)
decl_stmt|;
comment|// 2) Encode the DataType
name|fieldNames
operator|.
name|addAll
argument_list|(
name|encodeDataType
argument_list|(
name|pathName
argument_list|,
name|dataTypeConfig
argument_list|)
argument_list|)
expr_stmt|;
comment|// 3) Encode the Languages
if|if
condition|(
name|indexField
operator|.
name|hasLanguage
argument_list|()
condition|)
block|{
name|fieldNames
operator|.
name|addAll
argument_list|(
name|encodeLanguages
argument_list|(
name|pathName
argument_list|,
name|indexField
operator|.
name|getLanguages
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// 4) add the language merger field (in case the dataType represent natural
comment|// language texts)
if|if
condition|(
name|dataTypeConfig
operator|.
name|isLanguageType
argument_list|()
condition|)
block|{
name|fieldNames
operator|.
name|add
argument_list|(
name|SolrConst
operator|.
name|LANG_MERGER_FIELD
operator|+
name|pathName
argument_list|)
expr_stmt|;
block|}
block|}
comment|// cache the mappings
name|indexFieldMappings
operator|.
name|put
argument_list|(
name|indexField
argument_list|,
name|fieldNames
argument_list|)
expr_stmt|;
block|}
return|return
name|fieldNames
return|;
block|}
comment|/**      * Getter for the string used to index a the parsed path. This method replaces the URI's of all elements      * within the path with<code>prefix+NAMESPACE_PREFIX_SEPERATOR_CHAR+localName</code>. In addition it      * places the<code>PATH_SEPERATOR</code> char between the elements.      *<p>      * NOTES:<ul>      *<li>This Method assumes that no empty or<code>null</code> elements are      *  containted in the parsed list.      *<li>This Method supports special encoding of fields registered in the      *  {@link SpecialFieldEnum}. However those fields are only allowed to be      *  used in paths with the length<code>1</code>.       *  An {@link IllegalArgumentException} is thrown if a special field is used      *  in a longer path.      *</ul>      * @param path      *            the path to encode      * @return the path name      * @throws IllegalArgumentException if<code>null</code> or an empty list is      * parsed as path or a special field is used in a path with a length&gt; 1      * @throws IllegalStateException if an unknown {@link SpecialFieldEnum      * special field} is encountered.      */
specifier|private
name|String
name|encodePathName
parameter_list|(
name|IndexField
name|indexField
parameter_list|)
block|{
name|SpecialFieldEnum
name|specialField
init|=
name|indexField
operator|.
name|getSpecialField
argument_list|()
decl_stmt|;
if|if
condition|(
name|specialField
operator|!=
literal|null
condition|)
block|{
comment|//handel special fields
switch|switch
condition|(
name|specialField
condition|)
block|{
case|case
name|fullText
case|:
return|return
name|getFullTextSearchField
argument_list|()
return|;
case|case
name|references
case|:
return|return
name|getReferredDocumentField
argument_list|()
return|;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unsupported Special Field '"
operator|+
name|specialField
operator|.
name|getUri
argument_list|()
operator|+
literal|"'! Please report this to"
operator|+
literal|"the Apache Stanbol Developer Mailing List!"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|//normal field
name|StringBuilder
name|pathName
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
comment|// Now Iterate over the Path
name|pathName
operator|.
name|append
argument_list|(
name|PATH_SEPERATOR
argument_list|)
expr_stmt|;
comment|// add the leading PathSeperator
name|Iterator
argument_list|<
name|String
argument_list|>
name|fields
init|=
name|indexField
operator|.
name|getPath
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|fields
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|field
init|=
name|fields
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
index|[]
name|namespaceLocalName
init|=
name|ModelUtils
operator|.
name|getNamespaceLocalName
argument_list|(
name|field
argument_list|)
decl_stmt|;
comment|// QName qName = getQName(field);
if|if
condition|(
name|namespaceLocalName
index|[
literal|0
index|]
operator|!=
literal|null
operator|&&
operator|!
name|namespaceLocalName
index|[
literal|0
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|pathName
operator|.
name|append
argument_list|(
name|getPrefix
argument_list|(
name|namespaceLocalName
index|[
literal|0
index|]
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// second the local name
name|pathName
operator|.
name|append
argument_list|(
name|NAMESPACE_PREFIX_SEPERATOR_CHAR
argument_list|)
expr_stmt|;
block|}
name|pathName
operator|.
name|append
argument_list|(
name|namespaceLocalName
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|// third add Path Separator if there are additional Elements
if|if
condition|(
name|fields
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|pathName
operator|.
name|append
argument_list|(
name|PATH_SEPERATOR
argument_list|)
expr_stmt|;
block|}
block|}
name|pathName
operator|.
name|append
argument_list|(
name|PATH_SEPERATOR
argument_list|)
expr_stmt|;
comment|// add the tailing PathSeperator
return|return
name|pathName
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|encodePath
parameter_list|(
name|IndexField
name|indexField
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
return|return
name|encodePathName
argument_list|(
name|indexField
argument_list|)
return|;
block|}
comment|/**      * Encodes the datatype by adding the prefix and the suffix to the parsed path name. If no prefix nor      * suffix is defined for the parsed data type, than this method returns an empty collection (indicating      * that no encoding is necessary)      *       * @param pathName      *            the path name to add the prefix and the suffix.      * @param dataType      *            the dataType to encode.      * @return The fields representing the encoded dataType for the parsed field.      */
specifier|private
name|Collection
argument_list|<
name|String
argument_list|>
name|encodeDataType
parameter_list|(
name|String
name|pathName
parameter_list|,
name|IndexDataTypeEnum
name|dataType
parameter_list|)
block|{
name|String
index|[]
name|prefixSuffix
init|=
name|encodeDataType
argument_list|(
name|dataType
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|prefixSuffix
index|[
literal|0
index|]
operator|==
literal|null
operator|||
name|prefixSuffix
index|[
literal|0
index|]
operator|.
name|isEmpty
argument_list|()
operator|)
operator|&&
operator|(
name|prefixSuffix
index|[
literal|1
index|]
operator|==
literal|null
operator|||
name|prefixSuffix
index|[
literal|1
index|]
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
comment|// no prefix nor suffix defined -> return empty collection
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
else|else
block|{
comment|// return prefix+fieldName+suffix
return|return
name|Collections
operator|.
name|singleton
argument_list|(
operator|(
name|prefixSuffix
index|[
literal|0
index|]
operator|!=
literal|null
condition|?
name|prefixSuffix
index|[
literal|0
index|]
else|:
literal|""
operator|)
operator|+
name|pathName
operator|+
operator|(
name|prefixSuffix
index|[
literal|1
index|]
operator|!=
literal|null
condition|?
name|prefixSuffix
index|[
literal|1
index|]
else|:
literal|""
operator|)
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
index|[]
name|encodeDataType
parameter_list|(
name|IndexField
name|indexField
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|IndexDataTypeEnum
name|dataTypeConfig
init|=
name|IndexDataTypeEnum
operator|.
name|forIndexType
argument_list|(
name|indexField
operator|.
name|getDataType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|dataTypeConfig
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"No Config found for the parsed IndexDataType %s"
argument_list|,
name|indexField
operator|.
name|getDataType
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|encodeDataType
argument_list|(
name|dataTypeConfig
argument_list|)
return|;
block|}
specifier|private
name|String
index|[]
name|encodeDataType
parameter_list|(
name|IndexDataTypeEnum
name|dataType
parameter_list|)
block|{
name|String
index|[]
name|prefixSuffix
init|=
operator|new
name|String
index|[]
block|{
literal|null
block|,
literal|null
block|}
decl_stmt|;
if|if
condition|(
name|dataType
operator|.
name|getPrefix
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|dataType
operator|.
name|getPrefix
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|prefixSuffix
index|[
literal|0
index|]
operator|=
name|dataType
operator|.
name|getPrefix
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dataType
operator|.
name|getSuffix
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|dataType
operator|.
name|getSuffix
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|prefixSuffix
index|[
literal|1
index|]
operator|=
name|dataType
operator|.
name|getSuffix
argument_list|()
expr_stmt|;
block|}
return|return
name|prefixSuffix
return|;
block|}
comment|/**      * Encodes the prefixes for the parsed languages and returns the according field names for the languages.      *<p>      * Languages are encoded using the {@link SolrConst#LANG_INDICATOR} and the parsed language as field      * prefix.      *<p>      * Note that this implementation adds dataTypes that are marked as natural language text values ( all      * dataTypes where<code>{@link IndexDataTypeEnum#isLanguageType()} == true</code>) to the special      * {@link SolrConst#LANG_MERGER_FIELD}. This can be used to search for values of an field in any language.      *<p>      * In addition to that the default schema.xml also defines a copyField command that puts natural language      * values of all fields into the default search field "_text".      *<p>      * The collection returned by this method does not include      *<code>"{@link SolrConst#LANG_MERGER_FIELD}"+feildName</code>!      *       * @param fieldName      *            the string representing the field without encoded languages      * @param languages      *            the languages.      * @return      */
specifier|private
name|Collection
argument_list|<
name|String
argument_list|>
name|encodeLanguages
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|languages
parameter_list|)
block|{
if|if
condition|(
name|languages
operator|==
literal|null
operator|||
name|languages
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// no language
return|return
name|Collections
operator|.
name|singleton
argument_list|(
name|fieldName
argument_list|)
return|;
comment|// just return the field
block|}
else|else
block|{
comment|// I assume that this will be the case in most of the calls
name|Collection
argument_list|<
name|String
argument_list|>
name|fieldNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|languages
operator|.
name|size
argument_list|()
operator|*
literal|2
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|prefix
range|:
name|encodeLanguages
argument_list|(
name|languages
argument_list|)
control|)
block|{
name|fieldNames
operator|.
name|add
argument_list|(
name|prefix
operator|+
name|fieldName
argument_list|)
expr_stmt|;
block|}
return|return
name|fieldNames
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|encodeLanguages
parameter_list|(
name|IndexField
name|indexField
parameter_list|)
block|{
return|return
name|encodeLanguages
argument_list|(
name|indexField
operator|.
name|getLanguages
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Internally used instead of {@link #encodeLanguages(String...)}      *       * @param languages      *            the languages      * @return the prefixes      * @see FieldMapper#encodeLanguages(String...)      */
specifier|private
name|Collection
argument_list|<
name|String
argument_list|>
name|encodeLanguages
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|languages
parameter_list|)
block|{
if|if
condition|(
name|languages
operator|==
literal|null
operator|||
name|languages
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// no language
return|return
name|Collections
operator|.
name|emptySet
argument_list|()
return|;
comment|// just return the field
block|}
elseif|else
if|if
condition|(
name|languages
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
return|return
name|Collections
operator|.
name|singleton
argument_list|(
name|encodeLanguage
argument_list|(
name|languages
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|langPrefixes
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|lang
range|:
name|languages
control|)
block|{
name|langPrefixes
operator|.
name|add
argument_list|(
name|encodeLanguage
argument_list|(
name|lang
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|langPrefixes
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|getLanguageMergerField
parameter_list|(
name|String
name|lang
parameter_list|)
block|{
return|return
name|LANG_MERGER_PREFIX
operator|+
operator|(
name|lang
operator|!=
literal|null
condition|?
name|lang
else|:
literal|""
operator|)
return|;
block|}
comment|/**      * Encodes the language prefixes of for the parsed language      *       * @param lang      *            the language      * @return the field with the encoded language      */
specifier|private
name|String
name|encodeLanguage
parameter_list|(
name|String
name|lang
parameter_list|)
block|{
name|StringBuilder
name|langField
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|langField
operator|.
name|append
argument_list|(
name|SolrConst
operator|.
name|LANG_INDICATOR
argument_list|)
expr_stmt|;
if|if
condition|(
name|lang
operator|!=
literal|null
condition|)
block|{
name|langField
operator|.
name|append
argument_list|(
name|lang
argument_list|)
expr_stmt|;
block|}
return|return
name|langField
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/*--------------------------------------------------------------------------      * The remaining (boring) methods that provide static field names for      * special fields.      * -------------------------------------------------------------------------      */
annotation|@
name|Override
specifier|public
name|String
name|getDocumentIdField
parameter_list|()
block|{
return|return
name|DOCUMENT_ID_FIELD
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getReferredDocumentField
parameter_list|()
block|{
return|return
name|REFERRED_DOCUMENT_FIELD
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getDependentDocumentField
parameter_list|()
block|{
return|return
name|DEPENDENT_DOCUMENT_FIELD
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getFullTextSearchField
parameter_list|()
block|{
return|return
name|FULL_TEXT_FIELD
return|;
block|}
comment|/*--------------------------------------------------------------------------      * Helper Methods to store/read the Mapping Config within the index.      * TODO: Move this to an own class e.g. IndexConfig or something like that      * -------------------------------------------------------------------------      */
specifier|private
name|int
name|defaultNsPrefixNumber
init|=
literal|1
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|DEFAULT_NS_PREFIX_STRING
init|=
literal|"ns"
decl_stmt|;
comment|// private static final char NAMESPACE_PREFIX_SEPERATOR_CHAR = ':';
comment|/**      * Do never access this Map directly! Use {@link #getNamespaceMap()}!      */
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|__namespaceMap
init|=
literal|null
decl_stmt|;
comment|/**      * Getter for the namespace to prefix mapping      *       * @return the map holding the namespace to prefix mappings      */
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getNamespaceMap
parameter_list|()
block|{
name|prefixNamespaceMappingsLock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|m
init|=
name|__namespaceMap
decl_stmt|;
name|prefixNamespaceMappingsLock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|null
condition|)
block|{
name|prefixNamespaceMappingsLock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|m
operator|=
name|__namespaceMap
expr_stmt|;
comment|//might be concurrently be initialised
if|if
condition|(
name|m
operator|==
literal|null
condition|)
block|{
name|loadNamespaceConfig
argument_list|()
expr_stmt|;
name|m
operator|=
name|__namespaceMap
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|prefixNamespaceMappingsLock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|m
return|;
block|}
comment|/**      * Do never access this Map directly! Use {@link #getPrefixMap()}!      */
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|__prefixMap
init|=
literal|null
decl_stmt|;
comment|/**      * used as lock during loading of the namespace<-> prefix mappings      * (fixes STANBOL-668)      */
specifier|private
name|ReentrantReadWriteLock
name|prefixNamespaceMappingsLock
init|=
operator|new
name|ReentrantReadWriteLock
argument_list|()
decl_stmt|;
comment|/**      * Getter for the prefix to namespace mappings      *       * @return the map holding the prefix to namespace mappings      */
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getPrefixMap
parameter_list|()
block|{
name|prefixNamespaceMappingsLock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|m
init|=
name|__prefixMap
decl_stmt|;
name|prefixNamespaceMappingsLock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|null
condition|)
block|{
name|prefixNamespaceMappingsLock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|m
operator|=
name|__prefixMap
expr_stmt|;
comment|//might be concurrently be initialised
if|if
condition|(
name|m
operator|==
literal|null
condition|)
block|{
name|loadNamespaceConfig
argument_list|()
expr_stmt|;
name|m
operator|=
name|__prefixMap
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|prefixNamespaceMappingsLock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|m
return|;
block|}
comment|/**      * Getter for the full name based on the short name. The short name is defined as the prefix followed by      * the {@link #NAMESPACE_PREFIX_SEPERATOR_CHAR} and the local name of the field. The returned field name      * is defined as the namespace followed by the local name.      *<p>      * If the parsed short field name does not contain the {@link #NAMESPACE_PREFIX_SEPERATOR_CHAR} this      * method returns the parsed String.      *<p>      * The local name may contain the {@link #NAMESPACE_PREFIX_SEPERATOR_CHAR}      * {@link #NAMESPACE_PREFIX_SEPERATOR_CHAR}'. The prefix MUST NOT contain this char, because      * {@link String#indexOf(int)} is used to split prefix and local name.      *       * @param shortFieldName      *            the short name      * @return the full name      * @throws IllegalArgumentException      *             if<code>null</code> is parsed as shortFieldName      * @throws IllegalStateException      *             if the found prefix is not contained in the configuration      */
specifier|protected
specifier|final
name|String
name|getFullFieldName
parameter_list|(
name|String
name|shortFieldName
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|IllegalStateException
block|{
if|if
condition|(
name|shortFieldName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Parameter shortFieldName MUST NOT be NULL"
argument_list|)
throw|;
block|}
name|int
name|seperatorIndex
init|=
name|shortFieldName
operator|.
name|indexOf
argument_list|(
name|NAMESPACE_PREFIX_SEPERATOR_CHAR
argument_list|)
decl_stmt|;
if|if
condition|(
name|seperatorIndex
operator|>=
literal|0
condition|)
block|{
name|String
name|prefix
init|=
name|shortFieldName
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|seperatorIndex
argument_list|)
decl_stmt|;
comment|// seperatorIndex does not include
comment|// the separator char
name|String
name|namespace
init|=
name|getNamespace
argument_list|(
name|prefix
argument_list|)
decl_stmt|;
if|if
condition|(
name|namespace
operator|!=
literal|null
condition|)
block|{
return|return
name|namespace
operator|+
name|shortFieldName
operator|.
name|substring
argument_list|(
name|seperatorIndex
operator|+
literal|1
argument_list|)
return|;
block|}
else|else
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Unknown prefix {} used by Field {}"
argument_list|,
name|prefix
argument_list|,
name|shortFieldName
argument_list|)
expr_stmt|;
name|log
operator|.
name|error
argument_list|(
literal|"known prefixes: {}"
argument_list|,
name|getPrefixMap
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unknown prefix "
operator|+
name|prefix
operator|+
literal|" (parsed from field "
operator|+
name|shortFieldName
operator|+
literal|")!"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
return|return
name|shortFieldName
return|;
block|}
block|}
specifier|protected
specifier|final
name|String
name|getNamespace
parameter_list|(
name|String
name|prefix
parameter_list|)
block|{
if|if
condition|(
name|prefix
operator|.
name|equals
argument_list|(
literal|"urn"
argument_list|)
condition|)
block|{
comment|// than the parsed URI is something like "urn:my.test.uuid-123"
comment|// -> this is no real prefix, but an urn with only one ':'
comment|// we need to return "urn:" as namespace!
return|return
literal|"urn:"
return|;
block|}
else|else
block|{
comment|// else we have an real namespace -> use the current mappings!
return|return
name|getPrefixMap
argument_list|()
operator|.
name|get
argument_list|(
name|prefix
argument_list|)
return|;
block|}
block|}
specifier|protected
specifier|final
name|String
name|addNamespace
parameter_list|(
name|String
name|namespace
parameter_list|)
block|{
return|return
name|getPrefix
argument_list|(
name|namespace
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|protected
specifier|final
name|String
name|getPrefix
parameter_list|(
name|String
name|namespace
parameter_list|)
block|{
return|return
name|getPrefix
argument_list|(
name|namespace
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|protected
specifier|final
name|String
name|getPrefix
parameter_list|(
name|String
name|namespace
parameter_list|,
name|boolean
name|create
parameter_list|)
block|{
if|if
condition|(
name|namespace
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|namespaceMap
init|=
name|getNamespaceMap
argument_list|()
decl_stmt|;
name|String
name|prefix
init|=
name|namespaceMap
operator|.
name|get
argument_list|(
name|namespace
argument_list|)
decl_stmt|;
if|if
condition|(
name|prefix
operator|!=
literal|null
condition|)
block|{
return|return
name|prefix
return|;
block|}
elseif|else
if|if
condition|(
name|create
condition|)
block|{
comment|// only if not present and prefix is true
name|prefixNamespaceMappingsLock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|//try again to get the prefix ... there might be a concurrent change
name|prefix
operator|=
name|getNamespaceMap
argument_list|()
operator|.
name|get
argument_list|(
name|namespace
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
operator|!=
literal|null
condition|)
block|{
comment|//added by an other thread
return|return
name|prefix
return|;
comment|//nothing else to do
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|prefixMap
init|=
name|getPrefixMap
argument_list|()
decl_stmt|;
name|String
name|defaultprefix
decl_stmt|;
if|if
condition|(
name|nsPrefixService
operator|!=
literal|null
condition|)
block|{
name|defaultprefix
operator|=
name|nsPrefixService
operator|.
name|getPrefix
argument_list|(
name|namespace
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NamespaceEnum
name|defaultMapping
init|=
name|NamespaceEnum
operator|.
name|forNamespace
argument_list|(
name|namespace
argument_list|)
decl_stmt|;
name|defaultprefix
operator|=
name|defaultMapping
operator|!=
literal|null
condition|?
name|defaultMapping
operator|.
name|getPrefix
argument_list|()
else|:
literal|null
expr_stmt|;
block|}
comment|/*                  * NOTE: we need to check here also if the default prefix is not yet taken, because the Solr                  * Index used to store the prefixes might be older than the latest change within the                  * NamespaceEnum. Therefore there might be cases where a default prefix configured by this                  * Enum is already assigned to a different namespace within the Solr index! In such cases, we                  * need to create a new prefix for this namespace                  */
if|if
condition|(
name|defaultprefix
operator|!=
literal|null
operator|&&
operator|!
name|prefixMap
operator|.
name|containsKey
argument_list|(
name|defaultprefix
argument_list|)
condition|)
block|{
name|prefix
operator|=
name|defaultprefix
expr_stmt|;
block|}
else|else
block|{
comment|// need to generate a default mapping
name|prefix
operator|=
name|createPrefix
argument_list|(
name|prefixMap
argument_list|)
expr_stmt|;
block|}
comment|//add an namespace
name|log
operator|.
name|debug
argument_list|(
literal|"add namespace prefix '{}' for '{}'"
argument_list|,
name|prefix
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
name|prefixMap
operator|.
name|put
argument_list|(
name|prefix
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
name|namespaceMap
operator|.
name|put
argument_list|(
name|namespace
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
comment|// save the configuration and parse true to make  sure the
comment|//namespaces are committed to the Solr Server
name|saveNamespaceConfig
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|prefixNamespaceMappingsLock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|prefix
return|;
comment|// may return null if !create
block|}
specifier|private
name|String
name|createPrefix
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|prefixMap
parameter_list|)
block|{
name|String
name|defaultPrefix
decl_stmt|;
do|do
block|{
comment|// as long an prefix is not any of the default prefixes or one of the prefixes defined by
comment|// NamespaceEnum
name|defaultNsPrefixNumber
operator|++
expr_stmt|;
name|defaultPrefix
operator|=
name|DEFAULT_NS_PREFIX_STRING
operator|+
name|defaultNsPrefixNumber
expr_stmt|;
block|}
do|while
condition|(
name|prefixMap
operator|.
name|containsKey
argument_list|(
name|defaultPrefix
argument_list|)
operator|||
name|NamespaceEnum
operator|.
name|forPrefix
argument_list|(
name|defaultPrefix
argument_list|)
operator|!=
literal|null
operator|||
operator|(
name|nsPrefixService
operator|!=
literal|null
operator|&&
name|nsPrefixService
operator|.
name|getNamespace
argument_list|(
name|defaultPrefix
argument_list|)
operator|!=
literal|null
operator|)
condition|)
do|;
return|return
name|defaultPrefix
return|;
block|}
comment|/**      * Leads the prefix to namespace mappings from the configured Solr server and inits the two mapps holding      * the prefix&lt;-&gt; namespace mappings.<p>      * Needs to be called under a write lock on {@link #prefixNamespaceMappingsLock}      */
specifier|private
name|void
name|loadNamespaceConfig
parameter_list|()
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"loadNamespaceConfig for {}"
argument_list|,
name|server
argument_list|)
expr_stmt|;
if|if
condition|(
name|__prefixMap
operator|!=
literal|null
operator|||
name|__namespaceMap
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"LoadNamespaceConfig called while mapping maps are NOT NULL!"
argument_list|)
expr_stmt|;
block|}
name|__prefixMap
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|__namespaceMap
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|SolrDocument
name|config
init|=
literal|null
decl_stmt|;
try|try
block|{
name|config
operator|=
name|getSolrDocument
argument_list|(
name|FieldMapper
operator|.
name|URI
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Unable to load PathField Config from Index. (may be OK for the first run!)"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Unable to load PathField Config from Index. (may be OK for the first run!)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|config
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"No PathFieldMapping Configuration present. Start with an empty mapping"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|String
name|fieldName
range|:
name|config
operator|.
name|getFieldNames
argument_list|()
control|)
block|{
name|String
index|[]
name|configFieldElements
init|=
name|fieldName
operator|.
name|split
argument_list|(
name|Character
operator|.
name|toString
argument_list|(
name|SolrConst
operator|.
name|PATH_SEPERATOR
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|SPECIAL_CONFIG_FIELD
operator|.
name|equals
argument_list|(
name|configFieldElements
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|SPECIAL_CONFIG_FIELD
operator|.
name|length
argument_list|()
operator|>
literal|1
condition|)
block|{
name|String
name|prefix
init|=
name|configFieldElements
index|[
literal|1
index|]
decl_stmt|;
name|Object
name|value
init|=
name|config
operator|.
name|getFirstValue
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|__namespaceMap
operator|.
name|containsKey
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"found two prefixes ("
operator|+
name|__namespaceMap
operator|.
name|get
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
operator|+
literal|" and "
operator|+
name|prefix
operator|+
literal|") for Namespace "
operator|+
name|value
operator|.
name|toString
argument_list|()
operator|+
literal|" keep the first one"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"> prefix: "
operator|+
name|prefix
operator|+
literal|" value: "
operator|+
name|value
argument_list|)
expr_stmt|;
name|__prefixMap
operator|.
name|put
argument_list|(
name|prefix
argument_list|,
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|__namespaceMap
operator|.
name|put
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
comment|// check for default NS
if|if
condition|(
name|prefix
operator|.
name|startsWith
argument_list|(
name|DEFAULT_NS_PREFIX_STRING
argument_list|)
condition|)
block|{
name|String
name|prefixNumber
init|=
name|prefix
operator|.
name|substring
argument_list|(
name|DEFAULT_NS_PREFIX_STRING
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|int
name|num
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|prefixNumber
argument_list|)
decl_stmt|;
if|if
condition|(
name|num
operator|>
name|defaultNsPrefixNumber
condition|)
block|{
name|defaultNsPrefixNumber
operator|=
name|num
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to parse Integer for Number part of default prefix "
operator|+
name|prefix
operator|+
literal|" (this is OK if by accident an other Namespace prefix starts with '"
operator|+
name|DEFAULT_NS_PREFIX_STRING
operator|+
literal|"')"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"No value for prefix "
operator|+
name|prefix
operator|+
literal|" found in the Configuration (Field Name: "
operator|+
name|fieldName
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"encountered wrong Formatted Config field "
operator|+
name|fieldName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
specifier|private
name|String
name|getConfigFieldName
parameter_list|(
name|String
name|configName
parameter_list|)
block|{
return|return
name|SPECIAL_CONFIG_FIELD
operator|+
name|PATH_SEPERATOR
operator|+
name|configName
return|;
block|}
comment|/**      * Saves the current configuration to the index! This does NOT commit the      * changes!      */
specifier|public
name|void
name|saveNamespaceConfig
parameter_list|(
specifier|final
name|boolean
name|commit
parameter_list|)
block|{
if|if
condition|(
name|server
operator|!=
literal|null
condition|)
block|{
name|prefixNamespaceMappingsLock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"saveNamespaceConfig on {}"
argument_list|,
name|server
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|prefixMap
init|=
name|getPrefixMap
argument_list|()
decl_stmt|;
specifier|final
name|SolrInputDocument
name|inputDoc
init|=
operator|new
name|SolrInputDocument
argument_list|()
decl_stmt|;
name|inputDoc
operator|.
name|addField
argument_list|(
name|getDocumentIdField
argument_list|()
argument_list|,
name|FieldMapper
operator|.
name|URI
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|prefixMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"> {}: {}"
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|inputDoc
operator|.
name|addField
argument_list|(
name|getConfigFieldName
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
specifier|public
name|Object
name|run
parameter_list|()
throws|throws
name|IOException
throws|,
name|SolrServerException
block|{
name|server
operator|.
name|add
argument_list|(
name|inputDoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit
condition|)
block|{
name|server
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PrivilegedActionException
name|pae
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Unable save Configuration to SolrProvider"
argument_list|,
name|pae
operator|.
name|getException
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|prefixNamespaceMappingsLock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to save NamespaceCondig because no SolrServer is set"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Getter for a SolrDocument based on the ID. Used to load the config from the index.      *       * @param inputDoc      *            the document to store      */
specifier|protected
name|SolrDocument
name|getSolrDocument
parameter_list|(
name|String
name|uri
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
if|if
condition|(
name|server
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|SolrQuery
name|solrQuery
init|=
operator|new
name|SolrQuery
argument_list|()
decl_stmt|;
name|solrQuery
operator|.
name|addField
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
comment|// select all fields
name|solrQuery
operator|.
name|setRows
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// we query for the id, there is only one result
name|String
name|queryString
init|=
name|String
operator|.
name|format
argument_list|(
literal|"%s:%s"
argument_list|,
name|this
operator|.
name|getDocumentIdField
argument_list|()
argument_list|,
name|SolrUtil
operator|.
name|escapeSolrSpecialChars
argument_list|(
name|uri
argument_list|)
argument_list|)
decl_stmt|;
name|solrQuery
operator|.
name|setQuery
argument_list|(
name|queryString
argument_list|)
expr_stmt|;
name|QueryResponse
name|queryResponse
decl_stmt|;
try|try
block|{
name|queryResponse
operator|=
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|QueryResponse
argument_list|>
argument_list|()
block|{
specifier|public
name|QueryResponse
name|run
parameter_list|()
throws|throws
name|IOException
throws|,
name|SolrServerException
block|{
return|return
name|server
operator|.
name|query
argument_list|(
name|solrQuery
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PrivilegedActionException
name|pae
parameter_list|)
block|{
name|Exception
name|e
init|=
name|pae
operator|.
name|getException
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|SolrServerException
condition|)
block|{
throw|throw
operator|(
name|SolrServerException
operator|)
name|e
throw|;
block|}
elseif|else
if|if
condition|(
name|e
operator|instanceof
name|IOException
condition|)
block|{
throw|throw
operator|(
name|IOException
operator|)
name|e
throw|;
block|}
else|else
block|{
throw|throw
name|RuntimeException
operator|.
name|class
operator|.
name|cast
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|queryResponse
operator|.
name|getResults
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|queryResponse
operator|.
name|getResults
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|getDocumentDomainField
parameter_list|()
block|{
return|return
name|DOMAIN_FIELD
return|;
block|}
block|}
end_class

end_unit

