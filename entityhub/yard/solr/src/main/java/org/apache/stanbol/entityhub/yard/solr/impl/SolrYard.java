begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|impl
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Dictionary
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ServiceLoader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReadWriteLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Activate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Component
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|ConfigurationPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Deactivate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Property
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Reference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|ReferenceCardinality
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|ReferencePolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|ReferenceStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Service
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrServerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrRequest
operator|.
name|METHOD
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|impl
operator|.
name|CommonsHttpSolrServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|request
operator|.
name|UpdateRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|response
operator|.
name|QueryResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrInputDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrCore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|IndexReference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|RegisteredSolrServerTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|managed
operator|.
name|IndexMetadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|managed
operator|.
name|ManagedSolrServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|managed
operator|.
name|standalone
operator|.
name|StandaloneEmbeddedSolrServerProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|utils
operator|.
name|SolrUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|utils
operator|.
name|StreamQueryRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|core
operator|.
name|model
operator|.
name|InMemoryValueFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|core
operator|.
name|query
operator|.
name|DefaultQueryFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|core
operator|.
name|query
operator|.
name|QueryResultListImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|core
operator|.
name|utils
operator|.
name|AdaptingIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|core
operator|.
name|yard
operator|.
name|AbstractYard
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Representation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|rdf
operator|.
name|RdfResourceEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|Constraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|FieldQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|QueryResultList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|yard
operator|.
name|Yard
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|yard
operator|.
name|YardException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|defaults
operator|.
name|IndexDataTypeEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|impl
operator|.
name|SolrQueryFactory
operator|.
name|SELECT
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|model
operator|.
name|FieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|model
operator|.
name|IndexField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|model
operator|.
name|IndexValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|model
operator|.
name|IndexValueFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|query
operator|.
name|IndexConstraintTypeEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|framework
operator|.
name|InvalidSyntaxException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|service
operator|.
name|cm
operator|.
name|ConfigurationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|service
operator|.
name|component
operator|.
name|ComponentContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|SAXException
import|;
end_import

begin_comment
comment|/**  * Implementation of the {@link Yard} interface based on a Solr Server.  *<p>  * This Yard implementation supports to store data of multiple yard instances within the same Solr index. The  * {@link FieldMapper#getDocumentDomainField()} with the value of the Yard ID ({@link #getId()}) is used to  * mark documents stored by the different Yards using the same Index. Queries are also restricted to documents  * stored by the actual Yard by adding a<a  * href="http://wiki.apache.org/solr/CommonQueryParameters#fq">FilterQuery</a>  *<code>fq=fieldMapper.getDocumentDomainField()+":"+getId()</code> to all queries. This feature can be  * activated by setting the {@link #MULTI_YARD_INDEX_LAYOUT} in the configuration. However this requires, that  * the documents in the index are already marked with the ID of the Yard. So setting this property makes  * usually only sense when the Solr index do not contain any data.  *<p>  * Also note, that the different Yards using the same index MUST NOT store Representations with the same ID.  * If that happens, that the Yard writing the Representation last will win and the Representation will be  * deleted for the other Yard!  *<p>  * The SolrJ library is used for the communication with the SolrServer.  *<p>  * TODO: There is still some refactoring needed, because a lot of the code within this bundle is more generic  * and usable regardless what kind of "document based" store is used. Currently the Solr specific stuff is in  * the impl and the default packages. All the other classes are intended to be generally useful. However there  * might be still some unwanted dependencies.  *<p>  * TODO: It would be possible to support for multi cores (see http://wiki.apache.org/solr/CoreAdmin for more  * Information)<br>  * However it is not possible to create cores on the fly (at least not directly; one would need to create  * first the needed directories and than call CREATE via the CoreAdmin). As soon as Solr is directly started  * via OSGI and we do know the Solr home, than it would be possible to implement "on the fly" generation of  * new cores. this would also allow a configuration where - as default - a new core is created automatically  * on the integrated Solr Server for any configured SolrYard.  *   * @author Rupert Westenthaler  *   */
end_comment

begin_class
annotation|@
name|Component
argument_list|(
name|metatype
operator|=
literal|true
argument_list|,
name|immediate
operator|=
literal|true
argument_list|,
name|configurationFactory
operator|=
literal|true
argument_list|,
name|policy
operator|=
name|ConfigurationPolicy
operator|.
name|REQUIRE
argument_list|,
name|specVersion
operator|=
literal|"1.1"
argument_list|)
annotation|@
name|Service
annotation|@
name|Properties
argument_list|(
name|value
operator|=
block|{
comment|// NOTE: Added propertied from AbstractYard to fix ordering!
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|Yard
operator|.
name|ID
argument_list|)
block|,
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|Yard
operator|.
name|NAME
argument_list|)
block|,
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|Yard
operator|.
name|DESCRIPTION
argument_list|)
block|,
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|AbstractYard
operator|.
name|DEFAULT_QUERY_RESULT_NUMBER
argument_list|,
name|intValue
operator|=
operator|-
literal|1
argument_list|)
block|,
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|AbstractYard
operator|.
name|MAX_QUERY_RESULT_NUMBER
argument_list|,
name|intValue
operator|=
operator|-
literal|1
argument_list|)
block|,
comment|// BEGIN SolrYard specific Properties
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|SolrYard
operator|.
name|SOLR_SERVER_LOCATION
argument_list|)
block|,
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|SolrYard
operator|.
name|MULTI_YARD_INDEX_LAYOUT
argument_list|,
name|boolValue
operator|=
literal|false
argument_list|)
block|,
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|SolrYard
operator|.
name|MAX_BOOLEAN_CLAUSES
argument_list|,
name|intValue
operator|=
name|SolrYard
operator|.
name|defaultMaxBooleanClauses
argument_list|)
block|}
argument_list|)
specifier|public
class|class
name|SolrYard
extends|extends
name|AbstractYard
implements|implements
name|Yard
block|{
comment|/**      * The key used to configure the URL for the SolrServer      */
specifier|public
specifier|static
specifier|final
name|String
name|SOLR_SERVER_LOCATION
init|=
literal|"org.apache.stanbol.entityhub.yard.solr.solrUri"
decl_stmt|;
comment|/**      * The key used to configure if data of multiple Yards are stored within the same index (      *<code>default=false</code>)      */
specifier|public
specifier|static
specifier|final
name|String
name|MULTI_YARD_INDEX_LAYOUT
init|=
literal|"org.apache.stanbol.entityhub.yard.solr.multiYardIndexLayout"
decl_stmt|;
comment|/**      * The maximum boolean clauses as configured in the solrconfig.xml of the SolrServer. The default value      * for this config in Solr 1.4 is 1024.      *<p>      * This value is important for generating queries that search for multiple documents, because it      * determines the maximum number of OR combination for the searched document ids.      */
specifier|public
specifier|static
specifier|final
name|String
name|MAX_BOOLEAN_CLAUSES
init|=
literal|"org.apache.stanbol.entityhub.yard.solr.maxBooleanClauses"
decl_stmt|;
comment|/**      * This property allows to define a field that is used to parse the boost for the parsed representation.      * Typically this will be the pageRank of that entity within the referenced site (e.g.      * {@link Math#log1p(double)} of the number of incoming links      */
specifier|public
specifier|static
specifier|final
name|String
name|DOCUMENT_BOOST_FIELD
init|=
literal|"org.apache.stanbol.entityhub.yard.solr.documentBoost"
decl_stmt|;
comment|/**      * Key used to configure {@link Entry Entry&lt;String,Float&gt;} for fields with the boost. If no Map is      * configured or a field is not present in the Map, than 1.0f is used as Boost. If a Document boost is      * present than the boost of a Field is documentBoost*fieldBoost.      */
specifier|public
specifier|static
specifier|final
name|String
name|FIELD_BOOST_MAPPINGS
init|=
literal|"org.apache.stanbol.entityhub.yard.solr.fieldBoosts"
decl_stmt|;
comment|//    /**
comment|//     * Key used to configure the implementation of the {@link SolrServer} to be used by this SolrYard
comment|//     * implementation. The default value is determined by the type of the value configured by the
comment|//     * {@link #SOLR_SERVER_LOCATION}. In case a path of a File URI is used, the type is set to
comment|//     * {@link SolrServerTypeEnum#EMBEDDED} otherwise {@link SolrServerTypeEnum#HTTP} is used as default.
comment|//     */
comment|//    public static final String SOLR_SERVER_TYPE = "org.apache.stanbol.entityhub.yard.solr.solrServerType";
comment|/**      * Key used to to enable/disable the default configuration. If this is enabled,      * that the index will get initialised with the Default configuration.<p>      * Notes:<ul>      *<li> Configuration is only supported for EmbeddedSolrServers that use a      * relative path      *<li> If this property is enabled the value of the       * {@link #SOLR_INDEX_CONFIGURATION_NAME} will be ignored.      *</ul>      * Only applies in case a EmbeddedSolrServer is used.      * @see SolrYardConfig#isDefaultInitialisation()      * @see SolrYardConfig#setDefaultInitialisation(Boolean)      */
specifier|public
specifier|static
specifier|final
name|String
name|SOLR_INDEX_DEFAULT_CONFIG
init|=
literal|"org.apache.stanbol.entityhub.yard.solr.useDefaultConfig"
decl_stmt|;
comment|/**      * By default the use of an default configuration is disabled!      */
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_SOLR_INDEX_DEFAULT_CONFIG_STATE
init|=
literal|false
decl_stmt|;
comment|/**      * The name of the configuration use as default.       */
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_SOLR_INDEX_CONFIGURATION_NAME
init|=
literal|"default"
decl_stmt|;
comment|/**      * Allows to configure the name of the index used for the configuration of the Solr Core.      * Only applies in case of using an EmbeddedSolrServer and      * {@link #SOLR_INDEX_DEFAULT_CONFIG} is disabled.      * As default the value of the {@link #SOLR_SERVER_LOCATION} is used.      * @see SolrYardConfig#getIndexConfigurationName()      * @see SolrYardConfig#setIndexConfigurationName(String)      */
specifier|public
specifier|static
specifier|final
name|String
name|SOLR_INDEX_CONFIGURATION_NAME
init|=
literal|"org.apache.stanbol.entityhub.yard.solr.configName"
decl_stmt|;
comment|/**      * The default value for the maxBooleanClauses of SolrQueries. Set to {@value #defaultMaxBooleanClauses}      * the default of Slor 1.4      */
specifier|protected
specifier|static
specifier|final
name|int
name|defaultMaxBooleanClauses
init|=
literal|1024
decl_stmt|;
comment|/**      * Key used to enable/disable committing of update(..) and store(..) operations. Enabling this ensures      * that indexed documents are immediately available for searches, but it will also decrease the      * performance for updates.      */
specifier|public
specifier|static
specifier|final
name|String
name|IMMEDIATE_COMMIT
init|=
literal|"org.apache.stanbol.entityhub.yard.solr.immediateCommit"
decl_stmt|;
comment|/**      * By default {@link #IMMEDIATE_COMMIT} is enabled      */
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_IMMEDIATE_COMMIT_STATE
init|=
literal|true
decl_stmt|;
comment|/**      * If {@link #IMMEDIATE_COMMIT} is deactivated, than this time is parsed to update(..) and store(..)      * operations as the maximum time (in ms) until a commit.      */
specifier|public
specifier|static
specifier|final
name|String
name|COMMIT_WITHIN_DURATION
init|=
literal|"org.apache.stanbol.entityhub.yard.solr.commitWithinDuration"
decl_stmt|;
comment|/**      * The default value for the {@link #COMMIT_WITHIN_DURATION} parameter is 10 sec.      */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_COMMIT_WITHIN_DURATION
init|=
literal|1000
operator|*
literal|10
decl_stmt|;
comment|/**      * What a surprise it's the logger!      */
specifier|private
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SolrYard
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * The SolrServer used for this Yard. Initialisation is done based on the configured parameters in      * {@link #activate(ComponentContext)}.      */
specifier|private
name|SolrServer
name|_server
decl_stmt|;
comment|/**      * In case the {@link SolrServer} changes during normal operation the      * {@link SolrFieldMapper} needs to be reinitialised for the new Core.      * This lock is used to avoid NPE when setting the {@link #_fieldMapper}      * variable back to<code>null</code> in those cases. While this will      * trigger automatic re-initialisation on the next call to       * {@link #getFieldMapper()} there would be the possibility that calls to      * {@link #getFieldMapper()} return<code>null</code>.      */
specifier|private
specifier|final
name|ReadWriteLock
name|fieldMapperLock
init|=
operator|new
name|ReentrantReadWriteLock
argument_list|()
decl_stmt|;
comment|/**      * The {@link FieldMapper} is responsible for converting fields of {@link Representation} to fields in the      * {@link SolrInputDocument} and vice versa      */
specifier|private
name|SolrFieldMapper
name|_fieldMapper
decl_stmt|;
comment|/**      * The {@link IndexValueFactory} is responsible for converting values of fields in the      * {@link Representation} to the according {@link IndexValue}. One should note, that some properties of      * the {@link IndexValue} such as the language ({@link IndexValue#getLanguage()}) and the dataType (      * {@link IndexValue#getType()}) are encoded within the field name inside the {@link SolrInputDocument}      * and {@link SolrDocument}. This is done by the configured {@link FieldMapper}.      */
specifier|private
name|IndexValueFactory
name|indexValueFactory
decl_stmt|;
comment|/**      * The {@link SolrQueryFactory} is responsible for converting the {@link Constraint}s of a query to      * constraints in the index. This requires usually that a single {@link Constraint} is described by      * several constraints in the index (see {@link IndexConstraintTypeEnum}).      *<p>      * TODO: The encoding of such constraints is already designed correctly, the {@link SolrQueryFactory} that      * implements logic of converting the Incoming {@link Constraint}s and generating the {@link SolrQuery}      * needs to undergo some refactoring!      *       */
specifier|private
name|SolrQueryFactory
name|_solrQueryFactoy
decl_stmt|;
comment|/**      * Used to store the name of the field used to get the {@link SolrInputDocument#setDocumentBoost(float)}      * for a Representation. This name is available via {@link SolrYardConfig#getDocumentBoostFieldName()}      * however it is stored here to prevent lookups for field of every stored {@link Representation}.      */
specifier|private
name|String
name|documentBoostFieldName
decl_stmt|;
comment|/**      * Map used to store boost values for fields. The default Boost for fields is 1.0f. This is used if this      * map is<code>null</code>, a field is not a key in this map, the value of a field in that map is      *<code>null</code> or lower equals zero. Also NOTE that the boost for fields is multiplied with the      * boost for the Document if present.      */
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|fieldBoostMap
decl_stmt|;
comment|/**      * Optionally a {@link ManagedSolrServer} that is used to create new       * Solr indexes based on parsed configurations.      */
annotation|@
name|Reference
argument_list|(
name|cardinality
operator|=
name|ReferenceCardinality
operator|.
name|OPTIONAL_UNARY
argument_list|,
name|bind
operator|=
literal|"bindManagedSolrServer"
argument_list|,
name|unbind
operator|=
literal|"unbindManagedSolrServer"
argument_list|,
name|strategy
operator|=
name|ReferenceStrategy
operator|.
name|EVENT
argument_list|,
name|policy
operator|=
name|ReferencePolicy
operator|.
name|DYNAMIC
argument_list|)
specifier|private
name|ManagedSolrServer
name|managedSolrServer
decl_stmt|;
comment|/**      * If update(..) and store(..) calls should be immediately committed.      */
specifier|private
name|boolean
name|immediateCommit
init|=
name|DEFAULT_IMMEDIATE_COMMIT_STATE
decl_stmt|;
comment|/**      * If<code>{@link #immediateCommit} == false</code> this is the time in ms parsed to Solr until the      * documents parsed to update(..) and store(..) need to be committed.      */
specifier|private
name|int
name|commitWithin
init|=
name|DEFAULT_COMMIT_WITHIN_DURATION
decl_stmt|;
comment|/**      * the {@link ComponentContext}. Will be<code>null</code> if not running      * within OSGI      */
specifier|private
name|ComponentContext
name|context
decl_stmt|;
specifier|private
name|RegisteredSolrServerTracker
name|_registeredServerTracker
decl_stmt|;
comment|/**      * Default constructor as used by the OSGI environment.      *<p>      * DO NOT USE to manually create instances! The SolrYard instances do need to be configured. YOU NEED TO      * USE {@link #SolrYard(SolrYardConfig)} to parse the configuration and the initialise the Yard if running      * outside a OSGI environment.      */
specifier|public
name|SolrYard
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
comment|/**      * Constructor to be used outside of an OSGI environment      *       * @param config      *            the configuration for the SolrYard      * @throws IllegalArgumentException      *             if the configuration is not valid      * @throws YardException      *             on any Error while initialising the Solr Server for this Yard      */
specifier|public
name|SolrYard
parameter_list|(
name|SolrYardConfig
name|config
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|YardException
block|{
comment|//        solrServerProviderManager = SolrServerProviderManager.getInstance();
comment|// init via java.util.ServiceLoader
name|Iterator
argument_list|<
name|ManagedSolrServer
argument_list|>
name|providerIt
init|=
name|ServiceLoader
operator|.
name|load
argument_list|(
name|ManagedSolrServer
operator|.
name|class
argument_list|,
name|ManagedSolrServer
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|providerIt
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|managedSolrServer
operator|=
name|providerIt
operator|.
name|next
argument_list|()
expr_stmt|;
comment|//            if(config.getSolrServerType() == SolrServerTypeEnum.EMBEDDED){
comment|//                File location = ConfigUtils.toFile(config.getSolrServerLocation());
comment|//                if(!location.isAbsolute()){
comment|//                    location = solrDirectoryManager.getSolrIndexDirectory(location.toString());
comment|//                    config.setSolrServerLocation(location.getAbsolutePath());
comment|//                }
comment|//            }
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to instantiate "
operator|+
name|ManagedSolrServer
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" service by using "
operator|+
name|ServiceLoader
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|"!"
argument_list|)
throw|;
block|}
comment|// we need to change the exceptions, because this will be called outside
comment|// of an OSGI environment!
try|try
block|{
name|activate
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
operator|new
name|YardException
argument_list|(
literal|"Unable to access SolrServer"
operator|+
name|config
operator|.
name|getSolrServerLocation
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
operator|new
name|YardException
argument_list|(
literal|"Unable to initialize SolrServer"
operator|+
name|config
operator|.
name|getSolrServerLocation
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ConfigurationException
name|e
parameter_list|)
block|{
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unable to initialise SolrYard with the provided configuration"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|//    protected void bindSolrServerProviderManager(SolrServerProviderManager manager){
comment|//        this.solrServerProviderManager = manager;
comment|//    }
comment|//    protected void unbindSolrServerProviderManager(SolrServerProviderManager manager){
comment|//        this.solrServerProviderManager = null;
comment|//    }
specifier|protected
name|void
name|bindManagedSolrServer
parameter_list|(
name|ManagedSolrServer
name|manager
parameter_list|)
block|{
name|SolrYardConfig
name|config
init|=
operator|(
name|SolrYardConfig
operator|)
name|this
operator|.
name|getConfig
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|" ... bind ManagedSolrServer '{}' to SolrYard '{}'"
argument_list|,
name|manager
operator|.
name|getServerName
argument_list|()
argument_list|,
name|config
operator|!=
literal|null
condition|?
name|config
operator|.
name|getId
argument_list|()
else|:
literal|"<not yet activated>"
argument_list|)
expr_stmt|;
name|this
operator|.
name|managedSolrServer
operator|=
name|manager
expr_stmt|;
if|if
condition|(
name|config
operator|!=
literal|null
condition|)
block|{
comment|//if activated
try|try
block|{
name|checkManagedSolrIndex
argument_list|(
name|manager
argument_list|,
name|config
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Exception while checking SolrIndex '"
operator|+
name|config
operator|.
name|getSolrServerLocation
argument_list|()
operator|+
literal|"' on ManagedSolrServer '"
operator|+
name|manager
operator|.
name|getServerName
argument_list|()
operator|+
literal|"'!"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|protected
name|void
name|unbindManagedSolrServer
parameter_list|(
name|ManagedSolrServer
name|manager
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|" ... unbind ManagedSolrServer '{}' from SolrYard '{}'"
argument_list|,
name|manager
operator|.
name|getServerName
argument_list|()
argument_list|,
name|getConfig
argument_list|()
operator|!=
literal|null
condition|?
name|getConfig
argument_list|()
operator|.
name|getId
argument_list|()
else|:
literal|"<not yet activated>"
argument_list|)
expr_stmt|;
name|this
operator|.
name|managedSolrServer
operator|=
literal|null
expr_stmt|;
block|}
comment|/**      * Builds an {@link SolrYardConfig} instance based on the parsed {@link ComponentContext} and forwards to      * {@link #activate(SolrYardConfig)}.      *       * @param context      *            The component context only used to create the {@link SolrYardConfig} based on      *            {@link ComponentContext#getProperties()}.      * @throws ConfigurationException      *             If the configuration is not valid      * @throws IOException      *             In case the initialisation of the Solr index was not possible      * @throws SolrServerException      *             Indicates that the referenced SolrServer has some problems (usually an invalid      *             configuration).      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Activate
specifier|protected
specifier|final
name|void
name|activate
parameter_list|(
name|ComponentContext
name|context
parameter_list|)
throws|throws
name|ConfigurationException
throws|,
name|IOException
throws|,
name|SolrServerException
block|{
name|log
operator|.
name|info
argument_list|(
literal|"in {}.activate(..) with config {}"
argument_list|,
name|SolrYard
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
argument_list|,
name|context
operator|.
name|getProperties
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|context
operator|=
name|context
expr_stmt|;
name|activate
argument_list|(
operator|new
name|SolrYardConfig
argument_list|(
operator|(
name|Dictionary
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
operator|)
name|context
operator|.
name|getProperties
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Internally used to configure an instance (within and without an OSGI container      *       * @param config      *            The configuration      * @throws ConfigurationException      *             If the configuration is not valid      * @throws IOException      *             In case the initialisation of the Solr index was not possible      * @throws SolrServerException      *             Indicates that the referenced SolrServer has some problems (usually an invalid      *             configuration).      */
specifier|private
name|void
name|activate
parameter_list|(
name|SolrYardConfig
name|config
parameter_list|)
throws|throws
name|ConfigurationException
throws|,
name|IOException
throws|,
name|SolrServerException
block|{
comment|// init with the default implementations of the ValueFactory and the QueryFactory
name|super
operator|.
name|activate
argument_list|(
name|InMemoryValueFactory
operator|.
name|getInstance
argument_list|()
argument_list|,
name|DefaultQueryFactory
operator|.
name|getInstance
argument_list|()
argument_list|,
name|config
argument_list|)
expr_stmt|;
comment|// mayby the super activate has updated the configuration
name|config
operator|=
operator|(
name|SolrYardConfig
operator|)
name|this
operator|.
name|getConfig
argument_list|()
expr_stmt|;
comment|// check if immediateCommit is enable or disabled
if|if
condition|(
name|config
operator|.
name|isImmediateCommit
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|immediateCommit
operator|=
name|config
operator|.
name|isImmediateCommit
argument_list|()
operator|.
name|booleanValue
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|immediateCommit
operator|=
name|DEFAULT_IMMEDIATE_COMMIT_STATE
expr_stmt|;
block|}
comment|// check the maximum duration until changes are commited
if|if
condition|(
name|config
operator|.
name|getCommitWithinDuration
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|commitWithin
operator|=
name|config
operator|.
name|getCommitWithinDuration
argument_list|()
operator|.
name|intValue
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|commitWithin
operator|=
name|DEFAULT_COMMIT_WITHIN_DURATION
expr_stmt|;
block|}
name|this
operator|.
name|indexValueFactory
operator|=
name|IndexValueFactory
operator|.
name|getInstance
argument_list|()
expr_stmt|;
name|this
operator|.
name|documentBoostFieldName
operator|=
name|config
operator|.
name|getDocumentBoostFieldName
argument_list|()
expr_stmt|;
name|this
operator|.
name|fieldBoostMap
operator|=
name|config
operator|.
name|getFieldBoosts
argument_list|()
expr_stmt|;
comment|//try to initialise the SolrServer
name|ManagedSolrServer
name|managedSolrServer
init|=
name|this
operator|.
name|managedSolrServer
decl_stmt|;
if|if
condition|(
name|managedSolrServer
operator|!=
literal|null
condition|)
block|{
comment|//check also if we need to create/init an SolrServer on startup
try|try
block|{
name|checkManagedSolrIndex
argument_list|(
name|managedSolrServer
argument_list|,
name|config
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Exception while checking SolrIndex '"
operator|+
name|config
operator|.
name|getSolrServerLocation
argument_list|()
operator|+
literal|"' on ManagedSolrServer '"
operator|+
name|managedSolrServer
operator|.
name|getServerName
argument_list|()
operator|+
literal|"'!"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Activated SolrYard {}"
argument_list|,
name|config
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * @param config      */
specifier|private
name|SolrQueryFactory
name|getSolrQueryFactory
parameter_list|()
throws|throws
name|YardException
block|{
name|SolrYardConfig
name|config
init|=
operator|(
name|SolrYardConfig
operator|)
name|getConfig
argument_list|()
decl_stmt|;
if|if
condition|(
name|_solrQueryFactoy
operator|==
literal|null
condition|)
block|{
name|_solrQueryFactoy
operator|=
operator|new
name|SolrQueryFactory
argument_list|(
name|getValueFactory
argument_list|()
argument_list|,
name|indexValueFactory
argument_list|,
name|getFieldMapper
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|.
name|isMultiYardIndexLayout
argument_list|()
condition|)
block|{
comment|// set the yardID as domain if multiYardLayout is activated
name|_solrQueryFactoy
operator|.
name|setDomain
argument_list|(
name|config
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|_solrQueryFactoy
operator|.
name|setDefaultQueryResults
argument_list|(
name|config
operator|.
name|getDefaultQueryResultNumber
argument_list|()
argument_list|)
expr_stmt|;
name|_solrQueryFactoy
operator|.
name|setMaxQueryResults
argument_list|(
name|config
operator|.
name|getMaxQueryResultNumber
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|_solrQueryFactoy
return|;
block|}
comment|/**      * Getter for the {@link SolrServer} used by this {@link SolrYard}.<p>      * This method tries to {@link #initSolrServer()} if both {@link #_server}      * and {@link #_registeredServerTracker} are<code>null</code>. The      * {@link #_server} is used for remote SolrServers or if the component is      * not running within an OSGI Environment. THe {@link #_registeredServerTracker}      * is used for tracking SolrServers that do run in the same JVM.      * @throws YardException if the {@link SolrServer} is currently not       * active.      */
specifier|private
name|SolrServer
name|getServer
parameter_list|()
throws|throws
name|YardException
block|{
name|SolrServer
name|server
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|_server
operator|==
literal|null
operator|&&
name|_registeredServerTracker
operator|==
literal|null
condition|)
block|{
name|initSolrServer
argument_list|()
expr_stmt|;
block|}
comment|//when an internally managed Solr server is used by this SolrYard
comment|//we dynamically return the tracked version
if|if
condition|(
name|_registeredServerTracker
operator|!=
literal|null
condition|)
block|{
name|server
operator|=
name|_registeredServerTracker
operator|.
name|getService
argument_list|()
expr_stmt|;
comment|//TODO: remove and replace with a setting where the SolrYard does not
comment|//      not activate until the SolrServer is available.
if|if
condition|(
name|server
operator|==
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
comment|//waiting for a maximum of 5sec
try|try
block|{
name|log
operator|.
name|info
argument_list|(
literal|" ... waiting 1sec for SolrServer"
argument_list|)
expr_stmt|;
name|server
operator|=
operator|(
name|SolrServer
operator|)
name|_registeredServerTracker
operator|.
name|waitForService
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{}
block|}
block|}
if|if
condition|(
name|server
operator|!=
literal|null
operator|&&
operator|!
name|server
operator|.
name|equals
argument_list|(
name|this
operator|.
name|_server
argument_list|)
condition|)
block|{
comment|//reset the fieldMapper so that it is reinitialised for the new one
comment|//STANBOL-519
name|Lock
name|writeLock
init|=
name|fieldMapperLock
operator|.
name|writeLock
argument_list|()
decl_stmt|;
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|_fieldMapper
operator|=
literal|null
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|//for remove servers and when running outside OSGI
name|server
operator|=
name|_server
expr_stmt|;
block|}
comment|//the server is not available -> throw an exception!
if|if
condition|(
name|server
operator|!=
literal|null
condition|)
block|{
return|return
name|server
return|;
block|}
else|else
block|{
name|Lock
name|writeLock
init|=
name|fieldMapperLock
operator|.
name|writeLock
argument_list|()
decl_stmt|;
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|_fieldMapper
operator|=
literal|null
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
throw|throw
operator|new
name|YardException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"The SolrIndex '%s' for SolrYard '%s' is currently not active!"
argument_list|,
operator|(
operator|(
name|SolrYardConfig
operator|)
name|getConfig
argument_list|()
operator|)
operator|.
name|getSolrServerLocation
argument_list|()
argument_list|,
name|getName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|/**      * If the {@link SolrServer} of this SolrYard is managed on the      * {@link #managedSolrServer}, than this method deactivates it. If a      * remote server is used than calling this method does not have any effect.       */
specifier|private
name|void
name|deactivateSolrServer
parameter_list|()
block|{
name|SolrYardConfig
name|config
init|=
operator|(
name|SolrYardConfig
operator|)
name|this
operator|.
name|getConfig
argument_list|()
decl_stmt|;
name|String
name|indexLocation
init|=
name|config
operator|.
name|getSolrServerLocation
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|indexLocation
operator|.
name|startsWith
argument_list|(
literal|"http"
argument_list|)
operator|&&
name|indexLocation
operator|.
name|indexOf
argument_list|(
literal|"://"
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
name|IndexReference
name|indexReference
init|=
name|IndexReference
operator|.
name|parse
argument_list|(
name|indexLocation
argument_list|)
decl_stmt|;
name|ManagedSolrServer
name|managedSolrServer
init|=
name|this
operator|.
name|managedSolrServer
decl_stmt|;
if|if
condition|(
name|indexReference
operator|.
name|isName
argument_list|()
operator|&&
name|managedSolrServer
operator|!=
literal|null
operator|&&
operator|(
name|indexReference
operator|.
name|getServer
argument_list|()
operator|==
literal|null
operator|||
name|indexReference
operator|.
name|getServer
argument_list|()
operator|.
name|equals
argument_list|(
name|managedSolrServer
operator|.
name|getServerName
argument_list|()
argument_list|)
operator|)
condition|)
block|{
name|managedSolrServer
operator|.
name|deactivateIndex
argument_list|(
name|indexReference
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//else no managed index or index not managed on #managedSolrServer
block|}
comment|//an remote server
block|}
comment|/**      * Assumes that this method is only called if {@link #_server} and       * {@link #_registeredServerTracker} is<code>null</code>      * @throws YardException      */
specifier|private
name|void
name|initSolrServer
parameter_list|()
throws|throws
name|YardException
block|{
name|SolrYardConfig
name|config
init|=
operator|(
name|SolrYardConfig
operator|)
name|this
operator|.
name|getConfig
argument_list|()
decl_stmt|;
name|String
name|indexLocation
init|=
name|config
operator|.
name|getSolrServerLocation
argument_list|()
decl_stmt|;
if|if
condition|(
name|indexLocation
operator|.
name|startsWith
argument_list|(
literal|"http"
argument_list|)
operator|&&
name|indexLocation
operator|.
name|indexOf
argument_list|(
literal|"://"
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|//init remote server
try|try
block|{
name|_server
operator|=
operator|new
name|CommonsHttpSolrServer
argument_list|(
name|indexLocation
argument_list|)
expr_stmt|;
name|_server
operator|.
name|ping
argument_list|()
expr_stmt|;
comment|//test if remove service is available
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to connect to remote SolrServer '"
operator|+
name|config
operator|.
name|getSolrServerLocation
argument_list|()
operator|+
literal|"' because of "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to initialise to remote SolrServer '"
operator|+
name|config
operator|.
name|getSolrServerLocation
argument_list|()
operator|+
literal|"' because of "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to connect to remote SolrServer '"
operator|+
name|config
operator|.
name|getSolrServerLocation
argument_list|()
operator|+
literal|"' because of "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|//locally managed Server
comment|//(1) check if available (also tries to create if not available and
comment|//    create is allowed based on the configuration)
name|IndexReference
name|indexReference
init|=
name|checkManagedSolrIndex
argument_list|(
name|managedSolrServer
argument_list|,
name|config
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexReference
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|context
operator|==
literal|null
condition|)
block|{
comment|// outside OSGI
try|try
block|{
name|_server
operator|=
name|StandaloneEmbeddedSolrServerProvider
operator|.
name|getInstance
argument_list|()
operator|.
name|getSolrServer
argument_list|(
name|indexReference
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to initialise configured SolrServer'"
operator|+
name|config
operator|.
name|getSolrServerLocation
argument_list|()
operator|+
literal|"'!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|//within OSGI dynamically track the service
try|try
block|{
name|_registeredServerTracker
operator|=
operator|new
name|RegisteredSolrServerTracker
argument_list|(
name|context
operator|.
name|getBundleContext
argument_list|()
argument_list|,
name|indexReference
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|_registeredServerTracker
operator|.
name|open
argument_list|()
expr_stmt|;
comment|//start tracking
block|}
catch|catch
parameter_list|(
name|InvalidSyntaxException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to track configured SolrServer'"
operator|+
name|config
operator|.
name|getSolrServerLocation
argument_list|()
operator|+
literal|"'!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to initialise configured SolrServer'"
operator|+
name|config
operator|.
name|getSolrServerLocation
argument_list|()
operator|+
literal|"'!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
block|}
block|}
comment|/**      * Checks if the SolrYard is active on the {@link #managedSolrServer}      * @param config      * @param indexReference      * @throws YardException      */
specifier|private
name|IndexReference
name|checkManagedSolrIndex
parameter_list|(
name|ManagedSolrServer
name|managedSolrServer
parameter_list|,
name|SolrYardConfig
name|config
parameter_list|)
throws|throws
name|YardException
block|{
name|IndexReference
name|indexReference
init|=
name|IndexReference
operator|.
name|parse
argument_list|(
name|config
operator|.
name|getSolrServerLocation
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexReference
operator|.
name|isName
argument_list|()
condition|)
block|{
if|if
condition|(
name|managedSolrServer
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to init SolrIndex '{}' because ManagedSolrServer service is not available"
argument_list|,
name|config
operator|.
name|getSolrServerLocation
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
comment|//indicate that the server is not yet active
block|}
elseif|else
if|if
condition|(
name|indexReference
operator|.
name|getServer
argument_list|()
operator|==
literal|null
operator|||
name|indexReference
operator|.
name|getServer
argument_list|()
operator|.
name|equals
argument_list|(
name|managedSolrServer
operator|.
name|getServerName
argument_list|()
argument_list|)
condition|)
block|{
comment|//check if the referenced Index is Managed
name|IndexMetadata
name|indexMetadata
init|=
name|managedSolrServer
operator|.
name|getIndexMetadata
argument_list|(
name|indexReference
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexMetadata
operator|==
literal|null
condition|)
block|{
comment|// not managed -> try to create
name|IndexReference
name|createdIndexRef
init|=
name|createSolrIndex
argument_list|(
name|managedSolrServer
argument_list|,
name|config
argument_list|,
name|indexReference
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|context
operator|==
literal|null
condition|)
block|{
comment|//in that case we need to replace the parse SolrServerLocation
comment|//with the name of the created solr index
name|config
operator|.
name|setSolrServerLocation
argument_list|(
name|createdIndexRef
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//return the created IndexReference
return|return
name|createdIndexRef
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|indexMetadata
operator|.
name|isActive
argument_list|()
condition|)
block|{
comment|//already managed, but not active
comment|//try to activate
try|try
block|{
name|IndexMetadata
name|activatedMetadata
init|=
name|managedSolrServer
operator|.
name|activateIndex
argument_list|(
name|indexReference
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|activatedMetadata
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unable to actiate SolrIndex '%s' for SolrYard '%s"
operator|+
literal|"on MnagedSolrServer '%s'!"
argument_list|,
name|indexReference
argument_list|,
name|getConfig
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|managedSolrServer
operator|.
name|getServerName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
else|else
block|{
return|return
name|activatedMetadata
operator|.
name|getIndexReference
argument_list|()
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to actiate SolrIndex for SolrYard "
operator|+
name|getConfig
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|SAXException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to actiate SolrIndex for SolrYard "
operator|+
name|getConfig
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to actiate SolrIndex for SolrYard "
operator|+
name|getConfig
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|//already active ... noting todo
return|return
name|indexReference
return|;
block|}
block|}
else|else
block|{
comment|//indexReference.getServer() != managedSolrServer.getServerName
comment|//TODO we would need to track all active ManagedSolrServer and
comment|//     check/create the core on the requested one!
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Support for multiple ManagedSolrServer"
operator|+
literal|"is not yet implemented (defaultServerName: '"
operator|+
name|managedSolrServer
operator|.
name|getServerName
argument_list|()
operator|+
literal|"' requested: '"
operator|+
name|indexReference
operator|.
name|getServer
argument_list|()
operator|+
literal|"')!"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|//a path was parsed
comment|// -> create not supported. Users are responsible to provide the server
return|return
name|indexReference
return|;
block|}
block|}
comment|/**      * Creates a new SolrIndex based on this Yards configuration by using the      * {@link ManagedSolrServer} service      * @param config the configuration of this SolrYard      * @param solrIndexLocation the name of the index to create      * @throws YardException On any Exception while creating the index      */
specifier|private
name|IndexReference
name|createSolrIndex
parameter_list|(
name|ManagedSolrServer
name|managedServer
parameter_list|,
name|SolrYardConfig
name|config
parameter_list|,
specifier|final
name|String
name|solrIndexLocation
parameter_list|)
throws|throws
name|YardException
block|{
name|String
name|configName
decl_stmt|;
if|if
condition|(
name|config
operator|.
name|isDefaultInitialisation
argument_list|()
condition|)
block|{
name|configName
operator|=
name|SolrYard
operator|.
name|DEFAULT_SOLR_INDEX_CONFIGURATION_NAME
expr_stmt|;
block|}
else|else
block|{
name|configName
operator|=
name|config
operator|.
name|getIndexConfigurationName
argument_list|()
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|" ... initialise new SolrDirectory Index with name {} by using Index Configuration {}"
argument_list|,
name|solrIndexLocation
argument_list|,
name|configName
argument_list|)
expr_stmt|;
try|try
block|{
name|IndexMetadata
name|metadata
init|=
name|managedServer
operator|.
name|createSolrIndex
argument_list|(
name|solrIndexLocation
argument_list|,
name|configName
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|metadata
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"SolrIndex "
operator|+
name|config
operator|.
name|getSolrServerLocation
argument_list|()
operator|+
literal|" is not available"
operator|+
operator|(
name|config
operator|.
name|isDefaultInitialisation
argument_list|()
condition|?
literal|" and could not be initialised!"
else|:
literal|". The necessary Index is not yet installed."
operator|)
argument_list|)
throw|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|" ... created IndexDirectory {} for SolrIndex {} by using config {}"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|metadata
operator|.
name|getDirectory
argument_list|()
block|,
name|solrIndexLocation
block|,
name|configName
block|}
argument_list|)
expr_stmt|;
block|}
return|return
name|metadata
operator|.
name|getIndexReference
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"SolrIndex "
operator|+
name|config
operator|.
name|getSolrServerLocation
argument_list|()
operator|+
literal|" could not be initialised!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|SolrFieldMapper
name|getFieldMapper
parameter_list|()
throws|throws
name|YardException
block|{
name|Lock
name|readLock
init|=
name|fieldMapperLock
operator|.
name|readLock
argument_list|()
decl_stmt|;
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|_fieldMapper
operator|!=
literal|null
condition|)
block|{
return|return
name|_fieldMapper
return|;
block|}
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|Lock
name|writeLock
init|=
name|fieldMapperLock
operator|.
name|writeLock
argument_list|()
decl_stmt|;
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// the fieldMapper need the Server to store it's namespace prefix configuration
name|_fieldMapper
operator|=
operator|new
name|SolrFieldMapper
argument_list|(
name|getServer
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|_fieldMapper
return|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Deactivates this SolrYard instance after committing remaining changes      *       * @param context      */
annotation|@
name|Deactivate
specifier|protected
specifier|final
name|void
name|deactivate
parameter_list|(
name|ComponentContext
name|context
parameter_list|)
block|{
name|SolrYardConfig
name|config
init|=
operator|(
name|SolrYardConfig
operator|)
name|getConfig
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"... deactivating SolrYard "
operator|+
name|config
operator|.
name|getName
argument_list|()
operator|+
literal|" (id="
operator|+
name|config
operator|.
name|getId
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
comment|//close the RegisteredSolrServer tracker if used
if|if
condition|(
name|_registeredServerTracker
operator|!=
literal|null
condition|)
block|{
name|_registeredServerTracker
operator|.
name|close
argument_list|()
expr_stmt|;
name|_registeredServerTracker
operator|=
literal|null
expr_stmt|;
block|}
name|this
operator|.
name|_server
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|_fieldMapper
operator|=
literal|null
expr_stmt|;
comment|//in this case we can directly access the lazy field
name|this
operator|.
name|indexValueFactory
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|_solrQueryFactoy
operator|=
literal|null
expr_stmt|;
comment|//in this case we can directly access the lazy field
name|this
operator|.
name|documentBoostFieldName
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|fieldBoostMap
operator|=
literal|null
expr_stmt|;
comment|// reset the commitWithin and immediateCommit to the defaults
name|this
operator|.
name|commitWithin
operator|=
name|DEFAULT_COMMIT_WITHIN_DURATION
expr_stmt|;
name|this
operator|.
name|immediateCommit
operator|=
name|DEFAULT_IMMEDIATE_COMMIT_STATE
expr_stmt|;
comment|//deactivates the SolrCore used by this Yard if running in the local JVM
name|deactivateSolrServer
argument_list|()
expr_stmt|;
name|super
operator|.
name|deactivate
argument_list|()
expr_stmt|;
comment|// deactivate the super implementation
name|this
operator|.
name|context
operator|=
literal|null
expr_stmt|;
block|}
comment|/**      * This will case the SolrIndex to be optimised      * @throws YardException on any error while optimising      */
specifier|public
specifier|final
name|void
name|optimize
parameter_list|()
throws|throws
name|YardException
block|{
name|SolrServer
name|server
init|=
name|getServer
argument_list|()
decl_stmt|;
try|try
block|{
name|server
operator|.
name|optimize
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to optimise SolrIndex!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to optimise SolrIndex!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * can be used outside of the OSGI environment to deactivate this instance. Thiw will cause the SolrIndex      * to be committed and optimised.      */
specifier|public
name|void
name|close
parameter_list|()
block|{
name|deactivate
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Calls the {@link #deactivate(ComponentContext)} with<code>null</code> as component context      */
annotation|@
name|Override
specifier|protected
name|void
name|finalize
parameter_list|()
throws|throws
name|Throwable
block|{
name|deactivate
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|super
operator|.
name|finalize
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|QueryResultList
argument_list|<
name|Representation
argument_list|>
name|find
parameter_list|(
specifier|final
name|FieldQuery
name|parsedQuery
parameter_list|)
throws|throws
name|YardException
block|{
return|return
name|find
argument_list|(
name|getFieldMapper
argument_list|()
argument_list|,
name|parsedQuery
argument_list|,
name|SELECT
operator|.
name|QUERY
argument_list|)
return|;
block|}
specifier|private
name|QueryResultList
argument_list|<
name|Representation
argument_list|>
name|find
parameter_list|(
specifier|final
name|FieldMapper
name|fieldMapper
parameter_list|,
specifier|final
name|FieldQuery
name|parsedQuery
parameter_list|,
name|SELECT
name|select
parameter_list|)
throws|throws
name|YardException
block|{
comment|//create a clone of the query, because we need to refine it because the
comment|//query (as executed) needs to be included in the result set
name|FieldQuery
name|fieldQuery
init|=
name|parsedQuery
operator|.
name|clone
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"find "
operator|+
name|fieldQuery
argument_list|)
expr_stmt|;
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|selected
decl_stmt|;
if|if
condition|(
name|select
operator|==
name|SELECT
operator|.
name|QUERY
condition|)
block|{
comment|// if query set the fields to add to the result Representations
name|selected
operator|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|fieldQuery
operator|.
name|getSelectedFields
argument_list|()
argument_list|)
expr_stmt|;
comment|// add the score to query results!
name|selected
operator|.
name|add
argument_list|(
name|RdfResourceEnum
operator|.
name|resultScore
operator|.
name|getUri
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// otherwise add all fields
name|selected
operator|=
literal|null
expr_stmt|;
block|}
name|SolrQuery
name|query
init|=
name|getSolrQueryFactory
argument_list|()
operator|.
name|parseFieldQuery
argument_list|(
name|fieldQuery
argument_list|,
name|select
argument_list|)
decl_stmt|;
name|long
name|queryGeneration
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|QueryResponse
name|response
decl_stmt|;
try|try
block|{
name|StreamQueryRequest
name|request
init|=
operator|new
name|StreamQueryRequest
argument_list|(
name|query
argument_list|)
decl_stmt|;
name|response
operator|=
name|request
operator|.
name|process
argument_list|(
name|getServer
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
if|if
condition|(
literal|"unknown handler: /mlt"
operator|.
name|equals
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
operator|.
name|getMessage
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Solr is missing '<requestHandler name=\"/mlt\""
operator|+
literal|" class=\"solr.MoreLikeThisHandler\" startup=\"lazy\" />'"
operator|+
literal|" in 'solrconfig.xml'"
argument_list|,
name|e
argument_list|)
throw|;
block|}
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Error while performing Query on SolrServer: "
operator|+
name|query
operator|.
name|getQuery
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|long
name|queryTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
comment|// return a queryResultList
name|QueryResultListImpl
argument_list|<
name|Representation
argument_list|>
name|resultList
init|=
operator|new
name|QueryResultListImpl
argument_list|<
name|Representation
argument_list|>
argument_list|(
name|fieldQuery
argument_list|,
comment|// by adapting SolrDocuments to Representations
operator|new
name|AdaptingIterator
argument_list|<
name|SolrDocument
argument_list|,
name|Representation
argument_list|>
argument_list|(
name|response
operator|.
name|getResults
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|,
comment|// inline Adapter Implementation
operator|new
name|AdaptingIterator
operator|.
name|Adapter
argument_list|<
name|SolrDocument
argument_list|,
name|Representation
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Representation
name|adapt
parameter_list|(
name|SolrDocument
name|doc
parameter_list|,
name|Class
argument_list|<
name|Representation
argument_list|>
name|type
parameter_list|)
block|{
comment|// use this method for the conversion!
return|return
name|createRepresentation
argument_list|(
name|fieldMapper
argument_list|,
name|doc
argument_list|,
name|selected
argument_list|)
return|;
block|}
block|}
argument_list|,
name|Representation
operator|.
name|class
argument_list|)
argument_list|,
name|Representation
operator|.
name|class
argument_list|)
decl_stmt|;
name|long
name|resultProcessing
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"  ... done [queryGeneration=%dms|queryTime=%dms|resultProcessing=%dms|sum=%dms]"
argument_list|,
operator|(
name|queryGeneration
operator|-
name|start
operator|)
argument_list|,
operator|(
name|queryTime
operator|-
name|queryGeneration
operator|)
argument_list|,
operator|(
name|resultProcessing
operator|-
name|queryTime
operator|)
argument_list|,
operator|(
name|resultProcessing
operator|-
name|start
operator|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|resultList
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|QueryResultList
argument_list|<
name|String
argument_list|>
name|findReferences
parameter_list|(
name|FieldQuery
name|parsedQuery
parameter_list|)
throws|throws
name|YardException
block|{
comment|//create a clone of the query, because we need to refine it because the
comment|//query (as executed) needs to be included in the result set
name|FieldQuery
name|fieldQuery
init|=
name|parsedQuery
operator|.
name|clone
argument_list|()
decl_stmt|;
name|SolrQuery
name|query
init|=
name|getSolrQueryFactory
argument_list|()
operator|.
name|parseFieldQuery
argument_list|(
name|fieldQuery
argument_list|,
name|SELECT
operator|.
name|ID
argument_list|)
decl_stmt|;
name|QueryResponse
name|respone
decl_stmt|;
try|try
block|{
name|respone
operator|=
name|getServer
argument_list|()
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|METHOD
operator|.
name|POST
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Error while performing query on the SolrServer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
specifier|final
name|FieldMapper
name|fieldMapper
init|=
name|getFieldMapper
argument_list|()
decl_stmt|;
comment|// return a queryResultList
return|return
operator|new
name|QueryResultListImpl
argument_list|<
name|String
argument_list|>
argument_list|(
name|fieldQuery
argument_list|,
comment|// by adapting SolrDocuments to Representations
operator|new
name|AdaptingIterator
argument_list|<
name|SolrDocument
argument_list|,
name|String
argument_list|>
argument_list|(
name|respone
operator|.
name|getResults
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|,
comment|// inline Adapter Implementation
operator|new
name|AdaptingIterator
operator|.
name|Adapter
argument_list|<
name|SolrDocument
argument_list|,
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|adapt
parameter_list|(
name|SolrDocument
name|doc
parameter_list|,
name|Class
argument_list|<
name|String
argument_list|>
name|type
parameter_list|)
block|{
comment|// use this method for the conversion!
return|return
name|doc
operator|.
name|getFirstValue
argument_list|(
name|fieldMapper
operator|.
name|getDocumentIdField
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
argument_list|,
name|String
operator|.
name|class
argument_list|)
argument_list|,
name|String
operator|.
name|class
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|QueryResultList
argument_list|<
name|Representation
argument_list|>
name|findRepresentation
parameter_list|(
name|FieldQuery
name|parsedQuery
parameter_list|)
throws|throws
name|YardException
block|{
return|return
name|find
argument_list|(
name|getFieldMapper
argument_list|()
argument_list|,
name|parsedQuery
argument_list|,
name|SELECT
operator|.
name|ALL
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|Representation
name|getRepresentation
parameter_list|(
name|String
name|id
parameter_list|)
throws|throws
name|YardException
block|{
if|if
condition|(
name|id
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Representation id MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|id
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Representation id MUST NOT be empty!"
argument_list|)
throw|;
block|}
name|SolrServer
name|server
init|=
name|getServer
argument_list|()
decl_stmt|;
name|FieldMapper
name|fieldMapper
init|=
name|getFieldMapper
argument_list|()
decl_stmt|;
name|SolrDocument
name|doc
decl_stmt|;
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
try|try
block|{
name|doc
operator|=
name|getSolrDocument
argument_list|(
name|server
argument_list|,
name|fieldMapper
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Error while getting SolrDocument for id"
operator|+
name|id
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to access SolrServer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|long
name|retrieve
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|Representation
name|rep
decl_stmt|;
if|if
condition|(
name|doc
operator|!=
literal|null
condition|)
block|{
comment|// create an Representation for the Doc! retrieve
name|log
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Create Representation %s from SolrDocument"
argument_list|,
name|doc
operator|.
name|getFirstValue
argument_list|(
name|fieldMapper
operator|.
name|getDocumentIdField
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|rep
operator|=
name|createRepresentation
argument_list|(
name|fieldMapper
argument_list|,
name|doc
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rep
operator|=
literal|null
expr_stmt|;
block|}
name|long
name|create
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"  ... %s [retrieve=%dms|create=%dms|sum=%dms]"
argument_list|,
name|rep
operator|==
literal|null
condition|?
literal|"not found"
else|:
literal|"done"
argument_list|,
operator|(
name|retrieve
operator|-
name|start
operator|)
argument_list|,
operator|(
name|create
operator|-
name|retrieve
operator|)
argument_list|,
operator|(
name|create
operator|-
name|start
operator|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rep
return|;
block|}
comment|/**      * Creates the Representation for the parsed SolrDocument!      *       * @param doc      *            The Solr Document to convert      * @param fields      *            if NOT NULL only this fields are added to the Representation      * @return the Representation      */
specifier|protected
specifier|final
name|Representation
name|createRepresentation
parameter_list|(
name|FieldMapper
name|fieldMapper
parameter_list|,
name|SolrDocument
name|doc
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|fields
parameter_list|)
block|{
if|if
condition|(
name|fieldMapper
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed FieldMapper MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed SolrDocument MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|Object
name|id
init|=
name|doc
operator|.
name|getFirstValue
argument_list|(
name|fieldMapper
operator|.
name|getDocumentIdField
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|id
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"The parsed Solr Document does not contain a value for the %s Field!"
argument_list|,
name|fieldMapper
operator|.
name|getDocumentIdField
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|Representation
name|rep
init|=
name|getValueFactory
argument_list|()
operator|.
name|createRepresentation
argument_list|(
name|id
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|fieldName
range|:
name|doc
operator|.
name|getFieldNames
argument_list|()
control|)
block|{
name|IndexField
name|indexField
init|=
name|fieldMapper
operator|.
name|getField
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexField
operator|!=
literal|null
operator|&&
name|indexField
operator|.
name|getPath
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|String
name|lang
init|=
name|indexField
operator|.
name|getLanguages
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|indexField
operator|.
name|getLanguages
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|fields
operator|==
literal|null
operator|||
name|fields
operator|.
name|contains
argument_list|(
name|indexField
operator|.
name|getPath
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
for|for
control|(
name|Object
name|value
range|:
name|doc
operator|.
name|getFieldValues
argument_list|(
name|fieldName
argument_list|)
control|)
block|{
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|IndexDataTypeEnum
name|dataTypeEnumEntry
init|=
name|IndexDataTypeEnum
operator|.
name|forIndexType
argument_list|(
name|indexField
operator|.
name|getDataType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|dataTypeEnumEntry
operator|!=
literal|null
condition|)
block|{
name|Object
name|javaValue
init|=
name|indexValueFactory
operator|.
name|createValue
argument_list|(
name|dataTypeEnumEntry
operator|.
name|getJavaType
argument_list|()
argument_list|,
name|indexField
operator|.
name|getDataType
argument_list|()
argument_list|,
name|value
argument_list|,
name|lang
argument_list|)
decl_stmt|;
if|if
condition|(
name|javaValue
operator|!=
literal|null
condition|)
block|{
name|rep
operator|.
name|add
argument_list|(
name|indexField
operator|.
name|getPath
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|,
name|javaValue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"java value=null for index value %s"
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"No DataType Configuration found for Index Data Type %s!"
argument_list|,
name|indexField
operator|.
name|getDataType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// else index value == null -> ignore
block|}
comment|// end for all values
block|}
block|}
else|else
block|{
if|if
condition|(
name|indexField
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unable to prozess Index Field %s (for IndexDocument Field: %s)"
argument_list|,
name|indexField
argument_list|,
name|fieldName
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// end for all fields
return|return
name|rep
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|boolean
name|isRepresentation
parameter_list|(
name|String
name|id
parameter_list|)
throws|throws
name|YardException
block|{
if|if
condition|(
name|id
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Representation id MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|id
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Representation id MUST NOT be empty!"
argument_list|)
throw|;
block|}
specifier|final
name|SolrServer
name|server
init|=
name|getServer
argument_list|()
decl_stmt|;
specifier|final
name|FieldMapper
name|fieldMapper
init|=
name|getFieldMapper
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|getSolrDocument
argument_list|(
name|server
argument_list|,
name|fieldMapper
argument_list|,
name|id
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|fieldMapper
operator|.
name|getDocumentIdField
argument_list|()
argument_list|)
argument_list|)
operator|!=
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Error while performing getDocumentByID request for id "
operator|+
name|id
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to access SolrServer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Checks what of the documents referenced by the parsed IDs are present in the Solr Server      *       * @param ids      *            the ids of the documents to check      * @return the ids of the found documents      * @throws SolrServerException      *             on any exception of the SolrServer      * @throws IOException      *             an any IO exception while accessing the SolrServer      */
specifier|protected
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|checkRepresentations
parameter_list|(
name|SolrServer
name|server
parameter_list|,
name|FieldMapper
name|fieldMapper
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|ids
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|found
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|field
init|=
name|fieldMapper
operator|.
name|getDocumentIdField
argument_list|()
decl_stmt|;
for|for
control|(
name|SolrDocument
name|foundDoc
range|:
name|getSolrDocuments
argument_list|(
name|server
argument_list|,
name|fieldMapper
argument_list|,
name|ids
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|field
argument_list|)
argument_list|)
control|)
block|{
name|Object
name|value
init|=
name|foundDoc
operator|.
name|getFirstValue
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|found
operator|.
name|add
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|found
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|remove
parameter_list|(
name|String
name|id
parameter_list|)
throws|throws
name|YardException
throws|,
name|IllegalArgumentException
block|{
if|if
condition|(
name|id
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Representation id MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|id
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Representation id MUST NOT be empty!"
argument_list|)
throw|;
block|}
name|SolrServer
name|server
init|=
name|getServer
argument_list|()
decl_stmt|;
name|SolrYardConfig
name|config
init|=
operator|(
name|SolrYardConfig
operator|)
name|getConfig
argument_list|()
decl_stmt|;
name|SolrFieldMapper
name|fieldMapper
init|=
name|getFieldMapper
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|config
operator|.
name|isMultiYardIndexLayout
argument_list|()
condition|)
block|{
comment|//make sure we only delete the Entity only if it is  managed by
comment|//this Yard. Entities of other Yards MUST NOT be deleted!
name|server
operator|.
name|deleteByQuery
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"%s:%s AND %s:%s"
argument_list|,
name|fieldMapper
operator|.
name|getDocumentDomainField
argument_list|()
argument_list|,
name|SolrUtil
operator|.
name|escapeSolrSpecialChars
argument_list|(
name|getId
argument_list|()
argument_list|)
argument_list|,
name|fieldMapper
operator|.
name|getDocumentIdField
argument_list|()
argument_list|,
name|SolrUtil
operator|.
name|escapeSolrSpecialChars
argument_list|(
name|id
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|server
operator|.
name|deleteById
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
name|server
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Error while deleting document "
operator|+
name|id
operator|+
literal|" from the Solr server"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to access SolrServer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// NOTE: We do not need to update all Documents that refer this ID, because
comment|// only the representation of the Entity is deleted and not the
comment|// Entity itself. So even that we do no longer have an representation
comment|// the entity still exists and might be referenced by others!
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|remove
parameter_list|(
name|Iterable
argument_list|<
name|String
argument_list|>
name|ids
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|YardException
block|{
if|if
condition|(
name|ids
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed IDs MUST NOT be NULL"
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|toRemove
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|id
range|:
name|ids
control|)
block|{
if|if
condition|(
name|id
operator|!=
literal|null
operator|&&
operator|!
name|id
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|toRemove
operator|.
name|add
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
block|}
name|SolrServer
name|server
init|=
name|getServer
argument_list|()
decl_stmt|;
name|SolrYardConfig
name|config
init|=
operator|(
name|SolrYardConfig
operator|)
name|getConfig
argument_list|()
decl_stmt|;
name|SolrFieldMapper
name|fieldMapper
init|=
name|getFieldMapper
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|config
operator|.
name|isMultiYardIndexLayout
argument_list|()
condition|)
block|{
comment|//make sure we only delete Entities managed by this Yard
comment|//if someone parses an ID managed by an other yard we MUST NOT
comment|//delete it!
for|for
control|(
name|String
name|id
range|:
name|toRemove
control|)
block|{
name|server
operator|.
name|deleteByQuery
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"%s:%s AND %s:%s"
argument_list|,
name|fieldMapper
operator|.
name|getDocumentDomainField
argument_list|()
argument_list|,
name|SolrUtil
operator|.
name|escapeSolrSpecialChars
argument_list|(
name|getId
argument_list|()
argument_list|)
argument_list|,
name|fieldMapper
operator|.
name|getDocumentIdField
argument_list|()
argument_list|,
name|SolrUtil
operator|.
name|escapeSolrSpecialChars
argument_list|(
name|id
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|server
operator|.
name|deleteById
argument_list|(
name|toRemove
argument_list|)
expr_stmt|;
block|}
name|server
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Error while deleting documents from the Solr server"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to access SolrServer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// NOTE: We do not need to update all Documents that refer this ID, because
comment|// only the representation of the Entity is deleted and not the
comment|// Entity itself. So even that we do no longer have an representation
comment|// the entity still exists and might be referenced by others!
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeAll
parameter_list|()
throws|throws
name|YardException
block|{
name|SolrServer
name|server
init|=
name|getServer
argument_list|()
decl_stmt|;
name|SolrYardConfig
name|config
init|=
operator|(
name|SolrYardConfig
operator|)
name|getConfig
argument_list|()
decl_stmt|;
try|try
block|{
comment|//ensures that the fildMapper is initialised and reads the
comment|//namespace config before deleting all documents
name|getFieldMapper
argument_list|()
expr_stmt|;
comment|//delete all documents
if|if
condition|(
name|config
operator|.
name|isMultiYardIndexLayout
argument_list|()
condition|)
block|{
comment|//only delete entities of this referenced site
name|server
operator|.
name|deleteByQuery
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"%s:%s"
argument_list|,
name|getFieldMapper
argument_list|()
operator|.
name|getDocumentDomainField
argument_list|()
argument_list|,
name|SolrUtil
operator|.
name|escapeSolrSpecialChars
argument_list|(
name|getId
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//we can delete all
name|server
operator|.
name|deleteByQuery
argument_list|(
literal|"*:*"
argument_list|)
expr_stmt|;
block|}
comment|//ensure that the namespace config is stored again after deleting
comment|//all documents
name|getFieldMapper
argument_list|()
operator|.
name|saveNamespaceConfig
argument_list|()
expr_stmt|;
name|server
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Error while deleting documents from the Solr server"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to access SolrServer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|Representation
name|store
parameter_list|(
name|Representation
name|representation
parameter_list|)
throws|throws
name|YardException
throws|,
name|IllegalArgumentException
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Store {}"
argument_list|,
name|representation
operator|!=
literal|null
condition|?
name|representation
operator|.
name|getId
argument_list|()
else|:
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|representation
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Representation MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|SolrServer
name|server
init|=
name|getServer
argument_list|()
decl_stmt|;
name|FieldMapper
name|fieldMapper
init|=
name|getFieldMapper
argument_list|()
decl_stmt|;
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|SolrInputDocument
name|inputDocument
init|=
name|createSolrInputDocument
argument_list|(
name|fieldMapper
argument_list|,
name|representation
argument_list|)
decl_stmt|;
name|long
name|create
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
try|try
block|{
name|UpdateRequest
name|update
init|=
operator|new
name|UpdateRequest
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|immediateCommit
condition|)
block|{
name|update
operator|.
name|setCommitWithin
argument_list|(
name|commitWithin
argument_list|)
expr_stmt|;
block|}
name|update
operator|.
name|add
argument_list|(
name|inputDocument
argument_list|)
expr_stmt|;
name|update
operator|.
name|process
argument_list|(
name|server
argument_list|)
expr_stmt|;
if|if
condition|(
name|immediateCommit
condition|)
block|{
name|server
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
name|long
name|stored
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"  ... done [create={}ms|store={}ms|sum={}ms]"
argument_list|,
operator|new
name|Object
index|[]
block|{
operator|(
name|create
operator|-
name|start
operator|)
block|,
operator|(
name|stored
operator|-
name|create
operator|)
block|,
operator|(
name|stored
operator|-
name|start
operator|)
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Exception while adding Document to Solr"
argument_list|,
name|representation
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to access SolrServer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|representation
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|Iterable
argument_list|<
name|Representation
argument_list|>
name|store
parameter_list|(
name|Iterable
argument_list|<
name|Representation
argument_list|>
name|representations
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|YardException
block|{
if|if
condition|(
name|representations
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Representations MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|Collection
argument_list|<
name|Representation
argument_list|>
name|added
init|=
operator|new
name|HashSet
argument_list|<
name|Representation
argument_list|>
argument_list|()
decl_stmt|;
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|SolrInputDocument
argument_list|>
name|inputDocs
init|=
operator|new
name|HashSet
argument_list|<
name|SolrInputDocument
argument_list|>
argument_list|()
decl_stmt|;
name|SolrServer
name|server
init|=
name|getServer
argument_list|()
decl_stmt|;
name|FieldMapper
name|fieldMapper
init|=
name|getFieldMapper
argument_list|()
decl_stmt|;
for|for
control|(
name|Representation
name|representation
range|:
name|representations
control|)
block|{
if|if
condition|(
name|representation
operator|!=
literal|null
condition|)
block|{
name|inputDocs
operator|.
name|add
argument_list|(
name|createSolrInputDocument
argument_list|(
name|fieldMapper
argument_list|,
name|representation
argument_list|)
argument_list|)
expr_stmt|;
name|added
operator|.
name|add
argument_list|(
name|representation
argument_list|)
expr_stmt|;
block|}
block|}
name|long
name|created
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
try|try
block|{
name|UpdateRequest
name|update
init|=
operator|new
name|UpdateRequest
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|immediateCommit
condition|)
block|{
name|update
operator|.
name|setCommitWithin
argument_list|(
name|commitWithin
argument_list|)
expr_stmt|;
block|}
name|update
operator|.
name|add
argument_list|(
name|inputDocs
argument_list|)
expr_stmt|;
name|update
operator|.
name|process
argument_list|(
name|server
argument_list|)
expr_stmt|;
if|if
condition|(
name|immediateCommit
condition|)
block|{
name|server
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Exception while adding Documents to the Solr Server!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to access Solr server"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|long
name|ready
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Processed store request for %d documents in %dms (created %dms| stored%dms)"
argument_list|,
name|inputDocs
operator|.
name|size
argument_list|()
argument_list|,
name|ready
operator|-
name|start
argument_list|,
name|created
operator|-
name|start
argument_list|,
name|ready
operator|-
name|created
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|added
return|;
block|}
comment|/**      * Internally used to create Solr input documents for parsed representations.      *<p>      * This method supports boosting of fields. The boost is calculated by combining      *<ol>      *<li>the boot for the whole representation - by calling {@link #getDocumentBoost(Representation)}      *<li>the boost of each field - by using the configured {@link #fieldBoostMap}      *</ol>      *       * @param representation      *            the representation      * @return the Solr document for indexing      */
specifier|protected
specifier|final
name|SolrInputDocument
name|createSolrInputDocument
parameter_list|(
name|FieldMapper
name|fieldMapper
parameter_list|,
name|Representation
name|representation
parameter_list|)
block|{
name|SolrYardConfig
name|config
init|=
operator|(
name|SolrYardConfig
operator|)
name|getConfig
argument_list|()
decl_stmt|;
name|SolrInputDocument
name|inputDocument
init|=
operator|new
name|SolrInputDocument
argument_list|()
decl_stmt|;
comment|// If multiYardLayout is active, than we need to add the YardId as
comment|// domain for all added documents!
if|if
condition|(
name|config
operator|.
name|isMultiYardIndexLayout
argument_list|()
condition|)
block|{
name|inputDocument
operator|.
name|addField
argument_list|(
name|fieldMapper
operator|.
name|getDocumentDomainField
argument_list|()
argument_list|,
name|config
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// else we need to do nothing
name|inputDocument
operator|.
name|addField
argument_list|(
name|fieldMapper
operator|.
name|getDocumentIdField
argument_list|()
argument_list|,
name|representation
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
comment|// first process the document boost
name|Float
name|documentBoost
init|=
name|getDocumentBoost
argument_list|(
name|representation
argument_list|)
decl_stmt|;
comment|//NOTE: Do not use DocumentBoost, because FieldBoost will override
comment|//      document boosts and are not multiplied with with document boosts
comment|//        if(documentBoost != null){
comment|//            inputDocument.setDocumentBoost(documentBoost);
comment|//        }
for|for
control|(
name|Iterator
argument_list|<
name|String
argument_list|>
name|fields
init|=
name|representation
operator|.
name|getFieldNames
argument_list|()
init|;
name|fields
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
comment|// TODO: maybe add some functionality to prevent indexing of the
comment|// field configured as documentBoostFieldName!
comment|// But this would also prevent the possibility to intentionally
comment|// override the boost.
name|String
name|field
init|=
name|fields
operator|.
name|next
argument_list|()
decl_stmt|;
name|float
name|boost
decl_stmt|;
name|Float
name|fieldBoost
init|=
name|fieldBoostMap
operator|==
literal|null
condition|?
literal|null
else|:
name|fieldBoostMap
operator|.
name|get
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|documentBoost
operator|!=
literal|null
condition|)
block|{
name|boost
operator|=
name|documentBoost
expr_stmt|;
if|if
condition|(
name|fieldBoost
operator|!=
literal|null
condition|)
block|{
name|boost
operator|=
name|boost
operator|*
name|fieldBoost
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fieldBoost
operator|!=
literal|null
condition|)
block|{
name|boost
operator|=
name|fieldBoost
expr_stmt|;
block|}
else|else
block|{
name|boost
operator|=
operator|-
literal|1
expr_stmt|;
block|}
for|for
control|(
name|Iterator
argument_list|<
name|Object
argument_list|>
name|values
init|=
name|representation
operator|.
name|get
argument_list|(
name|field
argument_list|)
init|;
name|values
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
comment|// now we need to get the indexField for the value
name|Object
name|next
init|=
name|values
operator|.
name|next
argument_list|()
decl_stmt|;
name|IndexValue
name|value
decl_stmt|;
try|try
block|{
name|value
operator|=
name|indexValueFactory
operator|.
name|createIndexValue
argument_list|(
name|next
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|fieldName
range|:
name|fieldMapper
operator|.
name|getFieldNames
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|field
argument_list|)
argument_list|,
name|value
argument_list|)
control|)
block|{
if|if
condition|(
name|boost
operator|>
literal|0
condition|)
block|{
name|inputDocument
operator|.
name|addField
argument_list|(
name|fieldName
argument_list|,
name|value
operator|.
name|getValue
argument_list|()
argument_list|,
name|boost
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inputDocument
operator|.
name|addField
argument_list|(
name|fieldName
argument_list|,
name|value
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unable to process value %s (type:%s) for field %s!"
argument_list|,
name|next
argument_list|,
name|next
operator|.
name|getClass
argument_list|()
argument_list|,
name|field
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|inputDocument
return|;
block|}
comment|/**      * Extracts the document boost from a {@link Representation}.      *       * @param representation      *            the representation      * @return the Boost or<code>null</code> if not found or lower equals zero      */
specifier|private
name|Float
name|getDocumentBoost
parameter_list|(
name|Representation
name|representation
parameter_list|)
block|{
if|if
condition|(
name|documentBoostFieldName
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Float
name|documentBoost
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|Object
argument_list|>
name|values
init|=
name|representation
operator|.
name|get
argument_list|(
name|documentBoostFieldName
argument_list|)
init|;
name|values
operator|.
name|hasNext
argument_list|()
operator|&&
name|documentBoost
operator|==
literal|null
condition|;
control|)
block|{
name|Object
name|value
init|=
name|values
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Float
condition|)
block|{
name|documentBoost
operator|=
operator|(
name|Float
operator|)
name|value
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|documentBoost
operator|=
name|Float
operator|.
name|parseFloat
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unable to parse the Document Boost from field %s=%s[type=%s] -> The Document Boost MUST BE a Float value!"
argument_list|,
name|documentBoostFieldName
argument_list|,
name|value
argument_list|,
name|value
operator|.
name|getClass
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|documentBoost
operator|==
literal|null
condition|?
literal|null
else|:
name|documentBoost
operator|>=
literal|0
condition|?
name|documentBoost
else|:
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|Representation
name|update
parameter_list|(
name|Representation
name|representation
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|NullPointerException
throws|,
name|YardException
block|{
if|if
condition|(
name|representation
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Representation MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|boolean
name|found
init|=
name|isRepresentation
argument_list|(
name|representation
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|found
condition|)
block|{
return|return
name|store
argument_list|(
name|representation
argument_list|)
return|;
comment|// there is no "update" for solr
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Parsed Representation "
operator|+
name|representation
operator|.
name|getId
argument_list|()
operator|+
literal|" in not managed by this Yard "
operator|+
name|getName
argument_list|()
operator|+
literal|"(id="
operator|+
name|getId
argument_list|()
operator|+
literal|")"
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|Iterable
argument_list|<
name|Representation
argument_list|>
name|update
parameter_list|(
name|Iterable
argument_list|<
name|Representation
argument_list|>
name|representations
parameter_list|)
throws|throws
name|YardException
throws|,
name|IllegalArgumentException
throws|,
name|NullPointerException
block|{
if|if
condition|(
name|representations
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Iterable over Representations MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|ids
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Representation
name|representation
range|:
name|representations
control|)
block|{
if|if
condition|(
name|representation
operator|!=
literal|null
condition|)
block|{
name|ids
operator|.
name|add
argument_list|(
name|representation
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|SolrServer
name|server
init|=
name|getServer
argument_list|()
decl_stmt|;
name|FieldMapper
name|fieldMapper
init|=
name|getFieldMapper
argument_list|()
decl_stmt|;
name|int
name|numDocs
init|=
name|ids
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// for debuging
try|try
block|{
name|ids
operator|=
name|checkRepresentations
argument_list|(
name|server
argument_list|,
name|fieldMapper
argument_list|,
name|ids
argument_list|)
expr_stmt|;
comment|// returns the ids found in the solrIndex
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Error while searching for alredy present documents before executing the actual update for the parsed Representations"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to access SolrServer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|long
name|checked
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|SolrInputDocument
argument_list|>
name|inputDocs
init|=
operator|new
name|ArrayList
argument_list|<
name|SolrInputDocument
argument_list|>
argument_list|(
name|ids
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Representation
argument_list|>
name|updated
init|=
operator|new
name|ArrayList
argument_list|<
name|Representation
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Representation
name|representation
range|:
name|representations
control|)
block|{
if|if
condition|(
name|representation
operator|!=
literal|null
operator|&&
name|ids
operator|.
name|contains
argument_list|(
name|representation
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
block|{
comment|// null parsed or not
comment|// already present
name|inputDocs
operator|.
name|add
argument_list|(
name|createSolrInputDocument
argument_list|(
name|fieldMapper
argument_list|,
name|representation
argument_list|)
argument_list|)
expr_stmt|;
name|updated
operator|.
name|add
argument_list|(
name|representation
argument_list|)
expr_stmt|;
block|}
block|}
name|long
name|created
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|inputDocs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
try|try
block|{
name|UpdateRequest
name|update
init|=
operator|new
name|UpdateRequest
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|immediateCommit
condition|)
block|{
name|update
operator|.
name|setCommitWithin
argument_list|(
name|commitWithin
argument_list|)
expr_stmt|;
block|}
name|update
operator|.
name|add
argument_list|(
name|inputDocs
argument_list|)
expr_stmt|;
name|update
operator|.
name|process
argument_list|(
name|server
argument_list|)
expr_stmt|;
if|if
condition|(
name|immediateCommit
condition|)
block|{
name|server
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Error while adding updated Documents to the SolrServer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to access Solr server"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
name|long
name|ready
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Processed updateRequest for %d documents (%d in index | %d updated) in %dms (checked %dms|created %dms| stored%dms)"
argument_list|,
name|numDocs
argument_list|,
name|ids
operator|.
name|size
argument_list|()
argument_list|,
name|updated
operator|.
name|size
argument_list|()
argument_list|,
name|ready
operator|-
name|start
argument_list|,
name|checked
operator|-
name|start
argument_list|,
name|created
operator|-
name|checked
argument_list|,
name|ready
operator|-
name|created
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|updated
return|;
block|}
comment|/**      * Stores the parsed document within the Index. This Method is also used by other classes within this      * package to store configurations directly within the index      *       * @param inputDoc      *            the document to store      */
specifier|protected
specifier|final
name|void
name|storeSolrDocument
parameter_list|(
name|SolrServer
name|server
parameter_list|,
name|SolrInputDocument
name|inputDoc
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
name|server
operator|.
name|add
argument_list|(
name|inputDoc
argument_list|)
expr_stmt|;
block|}
comment|/**      * Getter for a SolrDocument based on the ID. This Method is also used by other classes within this      * package to load configurations directly from the index      *       * @param inputDoc      *            the document to store      */
specifier|protected
specifier|final
name|SolrDocument
name|getSolrDocument
parameter_list|(
name|SolrServer
name|server
parameter_list|,
name|FieldMapper
name|fieldMapper
parameter_list|,
name|String
name|uri
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
return|return
name|getSolrDocument
argument_list|(
name|server
argument_list|,
name|fieldMapper
argument_list|,
name|uri
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|protected
specifier|final
name|Collection
argument_list|<
name|SolrDocument
argument_list|>
name|getSolrDocuments
parameter_list|(
name|SolrServer
name|server
parameter_list|,
name|FieldMapper
name|fieldMapper
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|uris
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|fields
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
name|SolrYardConfig
name|config
init|=
operator|(
name|SolrYardConfig
operator|)
name|getConfig
argument_list|()
decl_stmt|;
name|SolrQuery
name|solrQuery
init|=
operator|new
name|SolrQuery
argument_list|()
decl_stmt|;
if|if
condition|(
name|fields
operator|==
literal|null
operator|||
name|fields
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|solrQuery
operator|.
name|addField
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
comment|// select all fields
block|}
else|else
block|{
for|for
control|(
name|String
name|field
range|:
name|fields
control|)
block|{
if|if
condition|(
name|field
operator|!=
literal|null
operator|&&
operator|!
name|field
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|solrQuery
operator|.
name|addField
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// NOTE: If there are more requested documents than allowed boolean
comment|// clauses in one query, than we need to send several requests!
name|Iterator
argument_list|<
name|String
argument_list|>
name|uriIterator
init|=
name|uris
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|int
name|maxClauses
decl_stmt|;
name|Integer
name|configuredMaxClauses
init|=
name|config
operator|.
name|getMaxBooleanClauses
argument_list|()
decl_stmt|;
if|if
condition|(
name|configuredMaxClauses
operator|!=
literal|null
operator|&&
name|configuredMaxClauses
operator|>
literal|0
condition|)
block|{
name|maxClauses
operator|=
name|configuredMaxClauses
expr_stmt|;
block|}
else|else
block|{
name|maxClauses
operator|=
name|defaultMaxBooleanClauses
expr_stmt|;
block|}
name|int
name|num
init|=
literal|0
decl_stmt|;
name|StringBuilder
name|queryBuilder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|boolean
name|myList
init|=
literal|false
decl_stmt|;
name|Collection
argument_list|<
name|SolrDocument
argument_list|>
name|resultDocs
init|=
literal|null
decl_stmt|;
comment|// do while more uris
while|while
condition|(
name|uriIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// do while more uris and free boolean clauses
comment|// num<= maxClauses because 1-items boolean clauses in the query!
while|while
condition|(
name|uriIterator
operator|.
name|hasNext
argument_list|()
operator|&&
name|num
operator|<=
name|maxClauses
condition|)
block|{
name|String
name|uri
init|=
name|uriIterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|uri
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|num
operator|>
literal|0
condition|)
block|{
name|queryBuilder
operator|.
name|append
argument_list|(
literal|" OR "
argument_list|)
expr_stmt|;
block|}
name|queryBuilder
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"%s:%s"
argument_list|,
name|fieldMapper
operator|.
name|getDocumentIdField
argument_list|()
argument_list|,
name|SolrUtil
operator|.
name|escapeSolrSpecialChars
argument_list|(
name|uri
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|num
operator|++
expr_stmt|;
block|}
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Get SolrDocuments for Query: "
operator|+
name|queryBuilder
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// no more items or all boolean clauses used -> send a request
name|solrQuery
operator|.
name|setQuery
argument_list|(
name|queryBuilder
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|queryBuilder
operator|=
operator|new
name|StringBuilder
argument_list|()
expr_stmt|;
comment|// and a new StringBuilder
comment|// set the number of results to the number of parsed IDs.
name|solrQuery
operator|.
name|setRows
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|num
operator|=
literal|0
expr_stmt|;
comment|// reset to 0
name|QueryResponse
name|queryResponse
init|=
name|server
operator|.
name|query
argument_list|(
name|solrQuery
argument_list|,
name|METHOD
operator|.
name|POST
argument_list|)
decl_stmt|;
if|if
condition|(
name|resultDocs
operator|==
literal|null
condition|)
block|{
name|resultDocs
operator|=
name|queryResponse
operator|.
name|getResults
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|myList
condition|)
block|{
comment|// most of the time there will be only one request, so only
comment|// create my own list when the second response is processed
name|resultDocs
operator|=
operator|new
name|ArrayList
argument_list|<
name|SolrDocument
argument_list|>
argument_list|(
name|resultDocs
argument_list|)
expr_stmt|;
name|myList
operator|=
literal|true
expr_stmt|;
block|}
name|resultDocs
operator|.
name|addAll
argument_list|(
name|queryResponse
operator|.
name|getResults
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// end while more uris
return|return
name|resultDocs
return|;
block|}
specifier|protected
specifier|final
name|SolrDocument
name|getSolrDocument
parameter_list|(
name|SolrServer
name|server
parameter_list|,
name|FieldMapper
name|fieldMapper
parameter_list|,
name|String
name|uri
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|fields
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
name|SolrQuery
name|solrQuery
init|=
operator|new
name|SolrQuery
argument_list|()
decl_stmt|;
if|if
condition|(
name|fields
operator|==
literal|null
operator|||
name|fields
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|solrQuery
operator|.
name|addField
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
comment|// select all fields
block|}
else|else
block|{
for|for
control|(
name|String
name|field
range|:
name|fields
control|)
block|{
if|if
condition|(
name|field
operator|!=
literal|null
operator|&&
operator|!
name|field
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|solrQuery
operator|.
name|addField
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|solrQuery
operator|.
name|setRows
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// we query for the id, there is only one result
name|String
name|queryString
init|=
name|String
operator|.
name|format
argument_list|(
literal|"%s:%s"
argument_list|,
name|fieldMapper
operator|.
name|getDocumentIdField
argument_list|()
argument_list|,
name|SolrUtil
operator|.
name|escapeSolrSpecialChars
argument_list|(
name|uri
argument_list|)
argument_list|)
decl_stmt|;
name|solrQuery
operator|.
name|setQuery
argument_list|(
name|queryString
argument_list|)
expr_stmt|;
name|QueryResponse
name|queryResponse
init|=
name|server
operator|.
name|query
argument_list|(
name|solrQuery
argument_list|,
name|METHOD
operator|.
name|POST
argument_list|)
decl_stmt|;
if|if
condition|(
name|queryResponse
operator|.
name|getResults
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|queryResponse
operator|.
name|getResults
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

