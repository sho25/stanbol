begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|impl
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Dictionary
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ServiceLoader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Activate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Component
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|ConfigurationPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Deactivate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Property
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|PropertyOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Reference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Service
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrServerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrRequest
operator|.
name|METHOD
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|embedded
operator|.
name|EmbeddedSolrServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|impl
operator|.
name|CommonsHttpSolrServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|impl
operator|.
name|StreamingUpdateSolrServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|request
operator|.
name|UpdateRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|response
operator|.
name|QueryResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|response
operator|.
name|SolrPingResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrInputDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|core
operator|.
name|model
operator|.
name|InMemoryValueFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|core
operator|.
name|query
operator|.
name|DefaultQueryFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|core
operator|.
name|query
operator|.
name|QueryResultListImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|core
operator|.
name|utils
operator|.
name|AdaptingIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|core
operator|.
name|yard
operator|.
name|AbstractYard
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Representation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|rdf
operator|.
name|RdfResourceEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|Constraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|FieldQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|QueryResultList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|yard
operator|.
name|Yard
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|yard
operator|.
name|YardException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|SolrDirectoryManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|SolrServerProviderManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|SolrServerProvider
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|defaults
operator|.
name|IndexDataTypeEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|impl
operator|.
name|SolrQueryFactory
operator|.
name|SELECT
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|model
operator|.
name|FieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|model
operator|.
name|IndexField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|model
operator|.
name|IndexValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|model
operator|.
name|IndexValueFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|query
operator|.
name|IndexConstraintTypeEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|utils
operator|.
name|SolrUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|service
operator|.
name|cm
operator|.
name|ConfigurationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|service
operator|.
name|component
operator|.
name|ComponentContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Implementation of the {@link Yard} interface based on a Solr Server.<p>  * This Yard implementation supports to store data of multiple yard instances  * within the same Solr index. The {@link FieldMapper#getDocumentDomainField()}  * with the value of the Yard ID ({@link #getId()}) is used to mark documents  * stored by the different Yards using the same Index. Queries are also restricted  * to documents stored by the actual Yard by adding a  *<a href="http://wiki.apache.org/solr/CommonQueryParameters#fq">FilterQuery</a>  *<code>fq=fieldMapper.getDocumentDomainField()+":"+getId()</code> to all  * queries. This feature can be activated by setting the  * {@link #MULTI_YARD_INDEX_LAYOUT} in the configuration. However this requires,  * that the documents in the index are already marked with the ID of the Yard.  * So setting this property makes usually only sense when the Solr index do not  * contain any data.<p>  * Also note, that the different Yards using the same index MUST NOT store  * Representations with the same ID. If that happens, that the Yard writing the  * Representation last will win and the Representation will be deleted for the  * other Yard!<p>  * The SolrJ library is used for the communication with the SolrServer.<p>  * TODO: There is still some refactoring needed, because a lot of the code  *       within this bundle is more generic and usable regardless what kind of  *       "document based" store is used. Currently the Solr specific stuff is in  *       the impl and the default packages. All the other classes are intended  *       to be generally useful. However there might be still some unwanted  *       dependencies.<p>  * TODO: It would be possible to support for multi cores (see  *       http://wiki.apache.org/solr/CoreAdmin for more Information)<br>  *       However it is not possible to create cores on the fly (at least not directly;  *       one would need to create first the needed directories and than call  *       CREATE via the CoreAdmin). As soon as Solr is directly started via  *       OSGI and we do know the Solr home, than it would be possible to  *       implement "on the fly" generation of new cores. this would also allow  *       a configuration where - as default - a new core is created automatically  *       on the integrated Solr Server for any configured SolrYard.  *  * @author Rupert Westenthaler  *  */
end_comment

begin_class
annotation|@
name|Component
argument_list|(
name|metatype
operator|=
literal|true
argument_list|,
name|configurationFactory
operator|=
literal|true
argument_list|,
name|policy
operator|=
name|ConfigurationPolicy
operator|.
name|REQUIRE
argument_list|,
comment|//the ID and SOLR_SERVER_LOCATION are required!
name|specVersion
operator|=
literal|"1.1"
argument_list|)
annotation|@
name|Service
annotation|@
name|Properties
argument_list|(
name|value
operator|=
block|{
comment|//TODO: Added propertied from AbstractYard to fix ordering!
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|Yard
operator|.
name|ID
argument_list|,
name|value
operator|=
literal|"entityhubYard"
argument_list|)
block|,
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|Yard
operator|.
name|NAME
argument_list|,
name|value
operator|=
literal|"Entityhub Yard"
argument_list|)
block|,
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|Yard
operator|.
name|DESCRIPTION
argument_list|,
name|value
operator|=
literal|"The Yard used by the Entityhub to store the data"
argument_list|)
block|,
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|AbstractYard
operator|.
name|DEFAULT_QUERY_RESULT_NUMBER
argument_list|,
name|intValue
operator|=
operator|-
literal|1
argument_list|)
block|,
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|AbstractYard
operator|.
name|MAX_QUERY_RESULT_NUMBER
argument_list|,
name|intValue
operator|=
operator|-
literal|1
argument_list|)
block|,
comment|//BEGIN SolrYard specific Properties
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|SolrYard
operator|.
name|SOLR_SERVER_LOCATION
argument_list|,
name|value
operator|=
literal|"entityhub"
argument_list|)
block|,
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|SolrYard
operator|.
name|MULTI_YARD_INDEX_LAYOUT
argument_list|,
name|options
operator|=
block|{
annotation|@
name|PropertyOption
argument_list|(
name|name
operator|=
literal|"true"
argument_list|,
name|value
operator|=
literal|"true"
argument_list|)
block|,
annotation|@
name|PropertyOption
argument_list|(
name|name
operator|=
literal|"false"
argument_list|,
name|value
operator|=
literal|"false"
argument_list|)
block|}
argument_list|,
name|value
operator|=
literal|"false"
argument_list|)
block|,
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|SolrYard
operator|.
name|MAX_BOOLEAN_CLAUSES
argument_list|,
name|intValue
operator|=
name|SolrYard
operator|.
name|defaultMaxBooleanClauses
argument_list|)
block|}
argument_list|)
specifier|public
class|class
name|SolrYard
extends|extends
name|AbstractYard
implements|implements
name|Yard
block|{
comment|/**      * The key used to configure the URL for the SolrServer      */
specifier|public
specifier|static
specifier|final
name|String
name|SOLR_SERVER_LOCATION
init|=
literal|"org.apache.stanbol.entityhub.yard.solr.solrUri"
decl_stmt|;
comment|/**      * The key used to configure if data of multiple Yards are stored within the      * same index (<code>default=false</code>)      */
specifier|public
specifier|static
specifier|final
name|String
name|MULTI_YARD_INDEX_LAYOUT
init|=
literal|"org.apache.stanbol.entityhub.yard.solr.multiYardIndexLayout"
decl_stmt|;
comment|/**      * The maximum boolean clauses as configured in the solrconfig.xml of the      * SolrServer. The default value for this config in Solr 1.4 is 1024.<p>      * This value is important for generating queries that search for multiple      * documents, because it determines the maximum number of OR combination for      * the searched document ids.      */
specifier|public
specifier|static
specifier|final
name|String
name|MAX_BOOLEAN_CLAUSES
init|=
literal|"org.apache.stanbol.entityhub.yard.solr.maxBooleanClauses"
decl_stmt|;
comment|/**      * This property allows to define a field that is used to parse the boost      * for the parsed representation. Typically this will be the pageRank of      * that entity within the referenced site (e.g. {@link Math#log1p(double)}      * of the number of incoming links      */
specifier|public
specifier|static
specifier|final
name|String
name|DOCUMENT_BOOST_FIELD
init|=
literal|"org.apache.stanbol.entityhub.yard.solr.documentBoost"
decl_stmt|;
comment|/**      * Key used to configure {@link Entry Entry&lt;String,Float&gt;} for fields      * with the boost. If no Map is configured or a field is not present in the      * Map, than 1.0f is used as Boost. If a Document boost is present than the      * boost of a Field is documentBoost*fieldBoost.      */
specifier|public
specifier|static
specifier|final
name|String
name|FIELD_BOOST_MAPPINGS
init|=
literal|"org.apache.stanbol.entityhub.yard.solr.fieldBoosts"
decl_stmt|;
comment|/**      * Key used to configure the implementation of the {@link SolrServer} to      * be used by this SolrYard implementation. The default value is determined      * by the type of the value configured by the {@link #SOLR_SERVER_LOCATION}.      * In case a path of a File URI is used, the type is set to      * {@link Type#EMBEDDED} otherwise {@link Type#HTTP} is used as default.      */
specifier|public
specifier|static
specifier|final
name|String
name|SOLR_SERVER_TYPE
init|=
literal|"org.apache.stanbol.entityhub.yard.solr.solrServerType"
decl_stmt|;
comment|/**      * Key used to to enable/disable the use of the default configuration when       * initialising the SolrYard. The default value MUST BE<code>true</code>      */
specifier|public
specifier|static
specifier|final
name|String
name|SOLR_INDEX_DEFAULT_CONFIG
init|=
literal|"org.apache.stanbol.entityhub.yard.solr.allowDefaultConfig"
decl_stmt|;
comment|/**      * The default value for the maxBooleanClauses of SolrQueries. Set to      * {@value #defaultMaxBooleanClauses} the default of Slor 1.4      */
specifier|protected
specifier|static
specifier|final
name|int
name|defaultMaxBooleanClauses
init|=
literal|1024
decl_stmt|;
comment|/**      * Key used to enable/disable committing of update(..) and      * store(..) operations. Enabling this ensures that indexed documents are      * immediately available for searches, but it will also decrease the      * performance for updates.      */
specifier|public
specifier|static
specifier|final
name|String
name|IMMEDIATE_COMMIT
init|=
literal|"org.apache.stanbol.entityhub.yard.solr.immediateCommit"
decl_stmt|;
comment|/**      * By default {@link #IMMEDIATE_COMMIT} is enabled      */
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_IMMEDIATE_COMMIT_STATE
init|=
literal|true
decl_stmt|;
comment|/**      * If {@link #IMMEDIATE_COMMIT} is deactivated, than this time is parsed to      * update(..) and store(..) operations as the maximum time (in ms) until      * a commit.       */
specifier|public
specifier|static
specifier|final
name|String
name|COMMIT_WITHIN_DURATION
init|=
literal|"org.apache.stanbol.entityhub.yard.solr.commitWithinDuration"
decl_stmt|;
comment|/**      * The default value for the {@link #COMMIT_WITHIN_DURATION} parameter is      * 10 sec.      */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_COMMIT_WITHIN_DURATION
init|=
literal|1000
operator|*
literal|10
decl_stmt|;
comment|/**      * What a surprise it's the logger!      */
specifier|private
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SolrYard
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * The SolrServer used for this Yard. Initialisation is done based on the      * configured parameters in {@link #activate(ComponentContext)}.      */
specifier|private
name|SolrServer
name|server
decl_stmt|;
comment|/**      * The {@link FieldMapper} is responsible for converting fields of      * {@link Representation} to fields in the {@link SolrInputDocument} and      * vice versa      */
specifier|private
name|FieldMapper
name|fieldMapper
decl_stmt|;
comment|/**      * The {@link IndexValueFactory} is responsible for converting values of      * fields in the {@link Representation} to the according {@link IndexValue}.      * One should note, that some properties of the {@link IndexValue} such as      * the language ({@link IndexValue#getLanguage()}) and the dataType      * ({@link IndexValue#getType()}) are encoded within the field name inside      * the {@link SolrInputDocument} and {@link SolrDocument}. This is done by      * the configured {@link FieldMapper}.      */
specifier|private
name|IndexValueFactory
name|indexValueFactory
decl_stmt|;
comment|/**      * The {@link SolrQueryFactory} is responsible for converting the      * {@link Constraint}s of a query to constraints in the index. This requires      * usually that a single {@link Constraint} is described by several      * constraints in the index (see {@link IndexConstraintTypeEnum}).<p>      * TODO: The encoding of such constraints is already designed correctly, the      * {@link SolrQueryFactory} that implements logic of converting the      * Incoming {@link Constraint}s and generating the {@link SolrQuery} needs      * to undergo some refactoring!      *      */
specifier|private
name|SolrQueryFactory
name|solrQueryFactoy
decl_stmt|;
comment|/**      * Used to store the name of the field used to get the      * {@link SolrInputDocument#setDocumentBoost(float)} for a Representation.      * This name is available via {@link SolrYardConfig#getDocumentBoostFieldName()}      * however it is stored here to prevent lookups for field of every      * stored {@link Representation}.      */
specifier|private
name|String
name|documentBoostFieldName
decl_stmt|;
comment|/**      * Map used to store boost values for fields. The default Boost for fields      * is 1.0f. This is used if this map is<code>null</code>, a field is not      * a key in this map, the value of a field in that map is<code>null</code> or      * lower equals zero. Also NOTE that the boost for fields is multiplied with      * the boost for the Document if present.      */
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|fieldBoostMap
decl_stmt|;
comment|/**      * Manager used to create the {@link SolrServer} instance used by this yard.      * Supports also {@link Type#STREAMING} and {@link Type#LOAD_BALANCE} type      * of servers.      * TODO: In case a remove SolrServer is configured by the      * {@link SolrYardConfig#getSolrServerLocation()}, than it would be possible      * to create both an {@link StreamingUpdateSolrServer} (by parsing       * {@link Type#STREAMING}) and an normal {@link CommonsHttpSolrServer}. The      * streaming update one should be used for indexing requests and the      * commons http one for all other requests. This would provide performance      * advantages when updating {@link Representation}s stored in a SolrYard      * using an remote SolrServer.      */
annotation|@
name|Reference
specifier|private
name|SolrServerProviderManager
name|solrServerProviderManager
decl_stmt|;
comment|/**      * Used to retrieve (and init if not already present) the Solr Index directory      * for relative paths parsed for {@link SolrYardConfig#getSolrServerLocation()}.      * Note that the {@link SolrDirectoryManager} only provides the path to the      * files. The {@link SolrServer} instance is created by the      * {@link SolrServerProviderManager}!      */
annotation|@
name|Reference
specifier|private
name|SolrDirectoryManager
name|solrDirectoryManager
decl_stmt|;
comment|/**      * If update(..) and store(..) calls should be immediately committed.      */
specifier|private
name|boolean
name|immediateCommit
init|=
name|DEFAULT_IMMEDIATE_COMMIT_STATE
decl_stmt|;
comment|/**      * If<code>{@link #immediateCommit} == false</code> this is the time in      * ms parsed to Solr until the documents parsed to update(..) and store(..)      * need to be committed.      */
specifier|private
name|int
name|commitWithin
init|=
name|DEFAULT_COMMIT_WITHIN_DURATION
decl_stmt|;
comment|/**      * Default constructor as used by the OSGI environment.<p> DO NOT USE to      * manually create instances! The SolrYard instances do need to be configured.      * YOU NEED TO USE {@link #SolrYard(SolrYardConfig)} to parse the configuration      * and the initialise the Yard if running outside a OSGI environment.      */
specifier|public
name|SolrYard
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
comment|/**      * Constructor to be used outside of an OSGI environment      * @param config the configuration for the SolrYard      * @throws IllegalArgumentException if the configuration is not valid      * @throws YardException on any Error while initialising the Solr Server for      * this Yard      */
specifier|public
name|SolrYard
parameter_list|(
name|SolrYardConfig
name|config
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|YardException
block|{
comment|//we need to change the exceptions, because this will be called outside
comment|//of an OSGI environment!
try|try
block|{
name|activate
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
operator|new
name|YardException
argument_list|(
literal|"Unable to access SolrServer"
operator|+
name|config
operator|.
name|getSolrServerLocation
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
operator|new
name|YardException
argument_list|(
literal|"Unable to initialize SolrServer"
operator|+
name|config
operator|.
name|getSolrServerLocation
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ConfigurationException
name|e
parameter_list|)
block|{
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unable to initialise SolrYard with the provided configuration"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Builds an {@link SolrYardConfig} instance based on the parsed {@link ComponentContext}      * and forwards to {@link #activate(SolrYardConfig)}.      * @param context The component context only used to create the {@link SolrYardConfig}      * based on {@link ComponentContext#getProperties()}.      * @throws ConfigurationException If the configuration is not valid      * @throws IOException In case the initialisation of the Solr index was not      * possible      * @throws SolrServerException Indicates that the referenced SolrServer has      * some problems (usually an invalid configuration).      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Activate
specifier|protected
specifier|final
name|void
name|activate
parameter_list|(
name|ComponentContext
name|context
parameter_list|)
throws|throws
name|ConfigurationException
throws|,
name|IOException
throws|,
name|SolrServerException
block|{
if|if
condition|(
name|context
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"No valid"
operator|+
name|ComponentContext
operator|.
name|class
operator|+
literal|" parsed in activate!"
argument_list|)
throw|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"in "
operator|+
name|SolrYard
operator|.
name|class
operator|+
literal|" activate with config "
operator|+
name|context
operator|.
name|getProperties
argument_list|()
argument_list|)
expr_stmt|;
name|activate
argument_list|(
operator|new
name|SolrYardConfig
argument_list|(
operator|(
name|Dictionary
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
operator|)
name|context
operator|.
name|getProperties
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Internally used to configure an instance (within and without an OSGI      * container      * @param config The configuration      * @throws ConfigurationException If the configuration is not valid      * @throws IOException In case the initialisation of the Solr index was not      * possible      * @throws SolrServerException Indicates that the referenced SolrServer has      * some problems (usually an invalid configuration).      */
specifier|private
name|void
name|activate
parameter_list|(
name|SolrYardConfig
name|config
parameter_list|)
throws|throws
name|ConfigurationException
throws|,
name|IOException
throws|,
name|SolrServerException
block|{
comment|//init with the default implementations of the ValueFactory and the QueryFactory
name|super
operator|.
name|activate
argument_list|(
name|InMemoryValueFactory
operator|.
name|getInstance
argument_list|()
argument_list|,
name|DefaultQueryFactory
operator|.
name|getInstance
argument_list|()
argument_list|,
name|config
argument_list|)
expr_stmt|;
comment|//mayby the super activate has updated the configuration
name|config
operator|=
operator|(
name|SolrYardConfig
operator|)
name|this
operator|.
name|getConfig
argument_list|()
expr_stmt|;
if|if
condition|(
name|solrServerProviderManager
operator|==
literal|null
condition|)
block|{
comment|//not within an OSGI environment
name|solrServerProviderManager
operator|=
name|SolrServerProviderManager
operator|.
name|getInstance
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|solrDirectoryManager
operator|==
literal|null
condition|)
block|{
comment|//not within an OSGI environment
comment|//init via java.util.ServiceLoader
name|Iterator
argument_list|<
name|SolrDirectoryManager
argument_list|>
name|providerIt
init|=
name|ServiceLoader
operator|.
name|load
argument_list|(
name|SolrDirectoryManager
operator|.
name|class
argument_list|,
name|SolrDirectoryManager
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|providerIt
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|solrDirectoryManager
operator|=
name|providerIt
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to instantiate "
operator|+
name|SolrDirectoryManager
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" service by using "
operator|+
name|ServiceLoader
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|"!"
argument_list|)
throw|;
block|}
block|}
name|String
name|solrIndexLocation
decl_stmt|;
if|if
condition|(
name|config
operator|.
name|getSolrServerType
argument_list|()
operator|==
name|Type
operator|.
name|EMBEDDED
condition|)
block|{
name|File
name|indexDirectory
init|=
name|ConfigUtils
operator|.
name|toFile
argument_list|(
name|config
operator|.
name|getSolrServerLocation
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|indexDirectory
operator|.
name|isAbsolute
argument_list|()
condition|)
block|{
comment|//relative paths
comment|// need to be resolved based on the internally managed Solr directory
name|indexDirectory
operator|=
name|solrDirectoryManager
operator|.
name|getSolrIndexDirectory
argument_list|(
name|indexDirectory
operator|.
name|toString
argument_list|()
argument_list|,
name|config
operator|.
name|isDefaultInitialisation
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|indexDirectory
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|SolrYard
operator|.
name|SOLR_SERVER_LOCATION
argument_list|,
literal|"SolrIndex "
operator|+
name|config
operator|.
name|getSolrServerLocation
argument_list|()
operator|+
literal|" is not available"
operator|+
operator|(
name|config
operator|.
name|isDefaultInitialisation
argument_list|()
condition|?
literal|" and could not be initialised!"
else|:
literal|". The necessary Index is not yet installed."
operator|)
argument_list|)
throw|;
block|}
block|}
name|solrIndexLocation
operator|=
name|indexDirectory
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|solrIndexLocation
operator|=
name|config
operator|.
name|getSolrServerLocation
argument_list|()
expr_stmt|;
block|}
name|server
operator|=
name|solrServerProviderManager
operator|.
name|getSolrServer
argument_list|(
name|config
operator|.
name|getSolrServerType
argument_list|()
argument_list|,
name|solrIndexLocation
argument_list|)
expr_stmt|;
comment|//test the server
name|SolrPingResponse
name|pingResponse
init|=
name|server
operator|.
name|ping
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Successful ping for SolrServer %s ( %d ms) Details: %s"
argument_list|,
name|config
operator|.
name|getSolrServerLocation
argument_list|()
argument_list|,
name|pingResponse
operator|.
name|getElapsedTime
argument_list|()
argument_list|,
name|pingResponse
argument_list|)
argument_list|)
expr_stmt|;
comment|//check if immediateCommit is enable or disabled
if|if
condition|(
name|config
operator|.
name|isImmediateCommit
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|immediateCommit
operator|=
name|config
operator|.
name|isImmediateCommit
argument_list|()
operator|.
name|booleanValue
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|immediateCommit
operator|=
name|DEFAULT_IMMEDIATE_COMMIT_STATE
expr_stmt|;
block|}
comment|//check the maximum duration until changes are commited
if|if
condition|(
name|config
operator|.
name|getCommitWithinDuration
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|commitWithin
operator|=
name|config
operator|.
name|getCommitWithinDuration
argument_list|()
operator|.
name|intValue
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|commitWithin
operator|=
name|DEFAULT_COMMIT_WITHIN_DURATION
expr_stmt|;
block|}
comment|//the fieldMapper need the Server to store it's namespace prefix configuration
name|this
operator|.
name|fieldMapper
operator|=
operator|new
name|SolrFieldMapper
argument_list|(
name|server
argument_list|)
expr_stmt|;
name|this
operator|.
name|indexValueFactory
operator|=
name|IndexValueFactory
operator|.
name|getInstance
argument_list|()
expr_stmt|;
name|this
operator|.
name|solrQueryFactoy
operator|=
operator|new
name|SolrQueryFactory
argument_list|(
name|getValueFactory
argument_list|()
argument_list|,
name|indexValueFactory
argument_list|,
name|fieldMapper
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|.
name|isMultiYardIndexLayout
argument_list|()
condition|)
block|{
comment|// set the yardID as domain if multiYardLayout is activated
name|solrQueryFactoy
operator|.
name|setDomain
argument_list|(
name|config
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|solrQueryFactoy
operator|.
name|setDefaultQueryResults
argument_list|(
name|config
operator|.
name|getDefaultQueryResultNumber
argument_list|()
argument_list|)
expr_stmt|;
name|solrQueryFactoy
operator|.
name|setMaxQueryResults
argument_list|(
name|config
operator|.
name|getMaxQueryResultNumber
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|documentBoostFieldName
operator|=
name|config
operator|.
name|getDocumentBoostFieldName
argument_list|()
expr_stmt|;
name|this
operator|.
name|fieldBoostMap
operator|=
name|config
operator|.
name|getFieldBoosts
argument_list|()
expr_stmt|;
block|}
comment|/**      * Deactivates this SolrYard instance after committing remaining changes      * @param context      */
annotation|@
name|Deactivate
specifier|protected
specifier|final
name|void
name|deactivate
parameter_list|(
name|ComponentContext
name|context
parameter_list|)
block|{
name|SolrYardConfig
name|config
init|=
operator|(
name|SolrYardConfig
operator|)
name|getConfig
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"... deactivating SolrYard "
operator|+
name|config
operator|.
name|getName
argument_list|()
operator|+
literal|" (id="
operator|+
name|config
operator|.
name|getId
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
try|try
block|{
name|this
operator|.
name|server
operator|.
name|commit
argument_list|()
expr_stmt|;
name|this
operator|.
name|server
operator|.
name|optimize
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unable to commit unsaved changes to SolrServer %s during deactivate!"
argument_list|,
name|config
operator|.
name|getSolrServerLocation
argument_list|()
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unable to commit unsaved changes to SolrServer %s during deactivate!"
argument_list|,
name|config
operator|.
name|getSolrServerLocation
argument_list|()
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|server
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|fieldMapper
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|indexValueFactory
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|solrQueryFactoy
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|documentBoostFieldName
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|fieldBoostMap
operator|=
literal|null
expr_stmt|;
comment|//reset the commitWithin and immediateCommit to the defaults
name|this
operator|.
name|commitWithin
operator|=
name|DEFAULT_COMMIT_WITHIN_DURATION
expr_stmt|;
name|this
operator|.
name|immediateCommit
operator|=
name|DEFAULT_IMMEDIATE_COMMIT_STATE
expr_stmt|;
name|super
operator|.
name|deactivate
argument_list|()
expr_stmt|;
comment|//deactivate the super implementation
block|}
comment|/**      * can be used outside of the OSGI environment to deactivate this instance.      * Thiw will cause the SolrIndex to be committed and optimised.      */
specifier|public
name|void
name|close
parameter_list|()
block|{
name|deactivate
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Calls the {@link #deactivate(ComponentContext)} with<code>null</code>      * as component context      */
annotation|@
name|Override
specifier|protected
name|void
name|finalize
parameter_list|()
throws|throws
name|Throwable
block|{
name|deactivate
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|super
operator|.
name|finalize
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|QueryResultList
argument_list|<
name|Representation
argument_list|>
name|find
parameter_list|(
specifier|final
name|FieldQuery
name|parsedQuery
parameter_list|)
throws|throws
name|YardException
block|{
return|return
name|find
argument_list|(
name|parsedQuery
argument_list|,
name|SELECT
operator|.
name|QUERY
argument_list|)
return|;
block|}
specifier|private
name|QueryResultList
argument_list|<
name|Representation
argument_list|>
name|find
parameter_list|(
specifier|final
name|FieldQuery
name|parsedQuery
parameter_list|,
name|SELECT
name|select
parameter_list|)
throws|throws
name|YardException
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"find "
operator|+
name|parsedQuery
argument_list|)
expr_stmt|;
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|SolrQuery
name|query
init|=
name|solrQueryFactoy
operator|.
name|parseFieldQuery
argument_list|(
name|parsedQuery
argument_list|,
name|select
argument_list|)
decl_stmt|;
name|long
name|queryGeneration
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|selected
decl_stmt|;
if|if
condition|(
name|select
operator|==
name|SELECT
operator|.
name|QUERY
condition|)
block|{
comment|//if query set the fields to add to the result Representations
name|selected
operator|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|parsedQuery
operator|.
name|getSelectedFields
argument_list|()
argument_list|)
expr_stmt|;
comment|//add the score to query results!
name|selected
operator|.
name|add
argument_list|(
name|RdfResourceEnum
operator|.
name|resultScore
operator|.
name|getUri
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//otherwise add all fields
name|selected
operator|=
literal|null
expr_stmt|;
block|}
name|QueryResponse
name|respone
decl_stmt|;
try|try
block|{
name|respone
operator|=
name|server
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|METHOD
operator|.
name|POST
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Error while performing Query on SolrServer!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|long
name|queryTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
comment|//return a queryResultList
name|QueryResultListImpl
argument_list|<
name|Representation
argument_list|>
name|resultList
init|=
operator|new
name|QueryResultListImpl
argument_list|<
name|Representation
argument_list|>
argument_list|(
name|parsedQuery
argument_list|,
comment|// by adapting SolrDocuments to Representations
operator|new
name|AdaptingIterator
argument_list|<
name|SolrDocument
argument_list|,
name|Representation
argument_list|>
argument_list|(
name|respone
operator|.
name|getResults
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|,
comment|//inline Adapter Implementation
operator|new
name|AdaptingIterator
operator|.
name|Adapter
argument_list|<
name|SolrDocument
argument_list|,
name|Representation
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Representation
name|adapt
parameter_list|(
name|SolrDocument
name|doc
parameter_list|,
name|Class
argument_list|<
name|Representation
argument_list|>
name|type
parameter_list|)
block|{
comment|//use this method for the conversion!
return|return
name|createRepresentation
argument_list|(
name|doc
argument_list|,
name|selected
argument_list|)
return|;
block|}
block|}
argument_list|,
name|Representation
operator|.
name|class
argument_list|)
argument_list|,
name|Representation
operator|.
name|class
argument_list|)
decl_stmt|;
name|long
name|resultProcessing
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"  ... done [queryGeneration=%dms|queryTime=%dms|resultProcessing=%dms|sum=%dms]"
argument_list|,
operator|(
name|queryGeneration
operator|-
name|start
operator|)
argument_list|,
operator|(
name|queryTime
operator|-
name|queryGeneration
operator|)
argument_list|,
operator|(
name|resultProcessing
operator|-
name|queryTime
operator|)
argument_list|,
operator|(
name|resultProcessing
operator|-
name|start
operator|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|resultList
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|QueryResultList
argument_list|<
name|String
argument_list|>
name|findReferences
parameter_list|(
name|FieldQuery
name|parsedQuery
parameter_list|)
throws|throws
name|YardException
block|{
name|SolrQuery
name|query
init|=
name|solrQueryFactoy
operator|.
name|parseFieldQuery
argument_list|(
name|parsedQuery
argument_list|,
name|SELECT
operator|.
name|ID
argument_list|)
decl_stmt|;
name|QueryResponse
name|respone
decl_stmt|;
try|try
block|{
name|respone
operator|=
name|server
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|METHOD
operator|.
name|POST
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Error while performing query on the SolrServer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|//return a queryResultList
return|return
operator|new
name|QueryResultListImpl
argument_list|<
name|String
argument_list|>
argument_list|(
name|parsedQuery
argument_list|,
comment|// by adapting SolrDocuments to Representations
operator|new
name|AdaptingIterator
argument_list|<
name|SolrDocument
argument_list|,
name|String
argument_list|>
argument_list|(
name|respone
operator|.
name|getResults
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|,
comment|//inline Adapter Implementation
operator|new
name|AdaptingIterator
operator|.
name|Adapter
argument_list|<
name|SolrDocument
argument_list|,
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|adapt
parameter_list|(
name|SolrDocument
name|doc
parameter_list|,
name|Class
argument_list|<
name|String
argument_list|>
name|type
parameter_list|)
block|{
comment|//use this method for the conversion!
return|return
name|doc
operator|.
name|getFirstValue
argument_list|(
name|fieldMapper
operator|.
name|getDocumentIdField
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
argument_list|,
name|String
operator|.
name|class
argument_list|)
argument_list|,
name|String
operator|.
name|class
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|QueryResultList
argument_list|<
name|Representation
argument_list|>
name|findRepresentation
parameter_list|(
name|FieldQuery
name|parsedQuery
parameter_list|)
throws|throws
name|YardException
block|{
return|return
name|find
argument_list|(
name|parsedQuery
argument_list|,
name|SELECT
operator|.
name|ALL
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|Representation
name|getRepresentation
parameter_list|(
name|String
name|id
parameter_list|)
throws|throws
name|YardException
block|{
if|if
condition|(
name|id
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Representation id MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|id
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Representation id MUST NOT be empty!"
argument_list|)
throw|;
block|}
name|SolrDocument
name|doc
decl_stmt|;
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
try|try
block|{
name|doc
operator|=
name|getSolrDocument
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Error while getting SolrDocument for id"
operator|+
name|id
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to access SolrServer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|long
name|retrieve
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|Representation
name|rep
decl_stmt|;
if|if
condition|(
name|doc
operator|!=
literal|null
condition|)
block|{
comment|//create an Representation for the Doc! retrieve
name|log
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Create Representation %s from SolrDocument"
argument_list|,
name|doc
operator|.
name|getFirstValue
argument_list|(
name|fieldMapper
operator|.
name|getDocumentIdField
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|rep
operator|=
name|createRepresentation
argument_list|(
name|doc
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rep
operator|=
literal|null
expr_stmt|;
block|}
name|long
name|create
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"  ... %s [retrieve=%dms|create=%dms|sum=%dms]"
argument_list|,
name|rep
operator|==
literal|null
condition|?
literal|"not found"
else|:
literal|"done"
argument_list|,
operator|(
name|retrieve
operator|-
name|start
operator|)
argument_list|,
operator|(
name|create
operator|-
name|retrieve
operator|)
argument_list|,
operator|(
name|create
operator|-
name|start
operator|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rep
return|;
block|}
comment|/**      * Creates the Representation for the parsed SolrDocument!      * @param doc The Solr Document to convert      * @param fields if NOT NULL only this fields are added to the Representation      * @return the Representation      */
specifier|protected
specifier|final
name|Representation
name|createRepresentation
parameter_list|(
name|SolrDocument
name|doc
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|fields
parameter_list|)
block|{
name|Object
name|id
init|=
name|doc
operator|.
name|getFirstValue
argument_list|(
name|fieldMapper
operator|.
name|getDocumentIdField
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|id
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"The parsed Solr Document does not contain a value for the %s Field!"
argument_list|,
name|fieldMapper
operator|.
name|getDocumentIdField
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|Representation
name|rep
init|=
name|getValueFactory
argument_list|()
operator|.
name|createRepresentation
argument_list|(
name|id
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|fieldName
range|:
name|doc
operator|.
name|getFieldNames
argument_list|()
control|)
block|{
name|IndexField
name|indexField
init|=
name|fieldMapper
operator|.
name|getField
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexField
operator|!=
literal|null
operator|&&
name|indexField
operator|.
name|getPath
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|String
name|lang
init|=
name|indexField
operator|.
name|getLanguages
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|indexField
operator|.
name|getLanguages
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|fields
operator|==
literal|null
operator|||
name|fields
operator|.
name|contains
argument_list|(
name|indexField
operator|.
name|getPath
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
for|for
control|(
name|Object
name|value
range|:
name|doc
operator|.
name|getFieldValues
argument_list|(
name|fieldName
argument_list|)
control|)
block|{
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|IndexDataTypeEnum
name|dataTypeEnumEntry
init|=
name|IndexDataTypeEnum
operator|.
name|forIndexType
argument_list|(
name|indexField
operator|.
name|getDataType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|dataTypeEnumEntry
operator|!=
literal|null
condition|)
block|{
name|Object
name|javaValue
init|=
name|indexValueFactory
operator|.
name|createValue
argument_list|(
name|dataTypeEnumEntry
operator|.
name|getJavaType
argument_list|()
argument_list|,
name|indexField
operator|.
name|getDataType
argument_list|()
argument_list|,
name|value
argument_list|,
name|lang
argument_list|)
decl_stmt|;
if|if
condition|(
name|javaValue
operator|!=
literal|null
condition|)
block|{
name|rep
operator|.
name|add
argument_list|(
name|indexField
operator|.
name|getPath
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|,
name|javaValue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"java value=null for index value %s"
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"No DataType Configuration found for Index Data Type %s!"
argument_list|,
name|indexField
operator|.
name|getDataType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|//else index value == null -> ignore
block|}
comment|//end for all values
block|}
block|}
else|else
block|{
if|if
condition|(
name|indexField
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unable to prozess Index Field %s (for IndexDocument Field: %s)"
argument_list|,
name|indexField
argument_list|,
name|fieldName
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//end for all fields
return|return
name|rep
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|boolean
name|isRepresentation
parameter_list|(
name|String
name|id
parameter_list|)
throws|throws
name|YardException
block|{
if|if
condition|(
name|id
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Representation id MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|id
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Representation id MUST NOT be empty!"
argument_list|)
throw|;
block|}
try|try
block|{
return|return
name|getSolrDocument
argument_list|(
name|id
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|fieldMapper
operator|.
name|getDocumentIdField
argument_list|()
argument_list|)
argument_list|)
operator|!=
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Error while performing getDocumentByID request for id "
operator|+
name|id
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to access SolrServer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Checks what of the documents referenced by the parsed IDs are present      * in the Solr Server      * @param ids the ids of the documents to check      * @return the ids of the found documents      * @throws SolrServerException on any exception of the SolrServer      * @throws IOException an any IO exception while accessing the SolrServer      */
specifier|protected
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|checkRepresentations
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|ids
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|found
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|field
init|=
name|fieldMapper
operator|.
name|getDocumentIdField
argument_list|()
decl_stmt|;
for|for
control|(
name|SolrDocument
name|foundDoc
range|:
name|getSolrDocuments
argument_list|(
name|ids
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|field
argument_list|)
argument_list|)
control|)
block|{
name|Object
name|value
init|=
name|foundDoc
operator|.
name|getFirstValue
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|found
operator|.
name|add
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|found
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|remove
parameter_list|(
name|String
name|id
parameter_list|)
throws|throws
name|YardException
throws|,
name|IllegalArgumentException
block|{
if|if
condition|(
name|id
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Representation id MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|id
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Representation id MUST NOT be empty!"
argument_list|)
throw|;
block|}
try|try
block|{
name|server
operator|.
name|deleteById
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|server
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Error while deleting document "
operator|+
name|id
operator|+
literal|" from the Solr server"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to access SolrServer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|//NOTE: We do not need to update all Documents that refer this ID, because
comment|//      only the representation of the Entity is deleted and not the
comment|//      Entity itself. So even that we do no longer have an representation
comment|//      the entity still exists and might be referenced by others!
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|remove
parameter_list|(
name|Iterable
argument_list|<
name|String
argument_list|>
name|ids
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|YardException
block|{
if|if
condition|(
name|ids
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed IDs MUST NOT be NULL"
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|toRemove
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|id
range|:
name|ids
control|)
block|{
if|if
condition|(
name|id
operator|!=
literal|null
operator|&&
operator|!
name|id
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|toRemove
operator|.
name|add
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
block|}
try|try
block|{
name|server
operator|.
name|deleteById
argument_list|(
name|toRemove
argument_list|)
expr_stmt|;
name|server
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Error while deleting documents from the Solr server"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to access SolrServer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|//NOTE: We do not need to update all Documents that refer this ID, because
comment|//      only the representation of the Entity is deleted and not the
comment|//      Entity itself. So even that we do no longer have an representation
comment|//      the entity still exists and might be referenced by others!
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|Representation
name|store
parameter_list|(
name|Representation
name|representation
parameter_list|)
throws|throws
name|YardException
throws|,
name|IllegalArgumentException
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Store {}"
argument_list|,
name|representation
operator|!=
literal|null
condition|?
name|representation
operator|.
name|getId
argument_list|()
else|:
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|representation
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Representation MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|SolrInputDocument
name|inputDocument
init|=
name|createSolrInputDocument
argument_list|(
name|representation
argument_list|)
decl_stmt|;
name|long
name|create
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
try|try
block|{
name|UpdateRequest
name|update
init|=
operator|new
name|UpdateRequest
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|immediateCommit
condition|)
block|{
name|update
operator|.
name|setCommitWithin
argument_list|(
name|commitWithin
argument_list|)
expr_stmt|;
block|}
name|update
operator|.
name|add
argument_list|(
name|inputDocument
argument_list|)
expr_stmt|;
name|update
operator|.
name|process
argument_list|(
name|server
argument_list|)
expr_stmt|;
if|if
condition|(
name|immediateCommit
condition|)
block|{
name|server
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
name|long
name|stored
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"  ... done [create={}ms|store={}ms|sum={}ms]"
argument_list|,
operator|new
name|Object
index|[]
block|{
operator|(
name|create
operator|-
name|start
operator|)
block|,
operator|(
name|stored
operator|-
name|create
operator|)
block|,
operator|(
name|stored
operator|-
name|start
operator|)
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Exception while adding Document to Solr"
argument_list|,
name|representation
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to access SolrServer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|representation
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|Iterable
argument_list|<
name|Representation
argument_list|>
name|store
parameter_list|(
name|Iterable
argument_list|<
name|Representation
argument_list|>
name|representations
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|YardException
block|{
if|if
condition|(
name|representations
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Representations MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|Collection
argument_list|<
name|Representation
argument_list|>
name|added
init|=
operator|new
name|HashSet
argument_list|<
name|Representation
argument_list|>
argument_list|()
decl_stmt|;
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|SolrInputDocument
argument_list|>
name|inputDocs
init|=
operator|new
name|HashSet
argument_list|<
name|SolrInputDocument
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Representation
name|representation
range|:
name|representations
control|)
block|{
if|if
condition|(
name|representation
operator|!=
literal|null
condition|)
block|{
name|inputDocs
operator|.
name|add
argument_list|(
name|createSolrInputDocument
argument_list|(
name|representation
argument_list|)
argument_list|)
expr_stmt|;
name|added
operator|.
name|add
argument_list|(
name|representation
argument_list|)
expr_stmt|;
block|}
block|}
name|long
name|created
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
try|try
block|{
name|UpdateRequest
name|update
init|=
operator|new
name|UpdateRequest
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|immediateCommit
condition|)
block|{
name|update
operator|.
name|setCommitWithin
argument_list|(
name|commitWithin
argument_list|)
expr_stmt|;
block|}
name|update
operator|.
name|add
argument_list|(
name|inputDocs
argument_list|)
expr_stmt|;
name|update
operator|.
name|process
argument_list|(
name|server
argument_list|)
expr_stmt|;
if|if
condition|(
name|immediateCommit
condition|)
block|{
name|server
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Exception while adding Documents to the Solr Server!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to access Solr server"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|long
name|ready
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Processed store request for %d documents in %dms (created %dms| stored%dms)"
argument_list|,
name|inputDocs
operator|.
name|size
argument_list|()
argument_list|,
name|ready
operator|-
name|start
argument_list|,
name|created
operator|-
name|start
argument_list|,
name|ready
operator|-
name|created
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|added
return|;
block|}
comment|/**      * Internally used to create Solr input documents for parsed representations.<p>      * This method supports boosting of fields. The boost is calculated by combining<ol>      *<li> the boot for the whole representation - by calling       * {@link #getDocumentBoost(Representation)}      *<li> the boost of each field - by using the configured {@link #fieldBoostMap}      *</ol>      * @param representation the representation      * @return the Solr document for indexing      */
specifier|protected
specifier|final
name|SolrInputDocument
name|createSolrInputDocument
parameter_list|(
name|Representation
name|representation
parameter_list|)
block|{
name|SolrYardConfig
name|config
init|=
operator|(
name|SolrYardConfig
operator|)
name|getConfig
argument_list|()
decl_stmt|;
name|SolrInputDocument
name|inputDocument
init|=
operator|new
name|SolrInputDocument
argument_list|()
decl_stmt|;
comment|// If multiYardLayout is active, than we need to add the YardId as
comment|// domain for all added documents!
if|if
condition|(
name|config
operator|.
name|isMultiYardIndexLayout
argument_list|()
condition|)
block|{
name|inputDocument
operator|.
name|addField
argument_list|(
name|fieldMapper
operator|.
name|getDocumentDomainField
argument_list|()
argument_list|,
name|config
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// else we need to do nothing
name|inputDocument
operator|.
name|addField
argument_list|(
name|fieldMapper
operator|.
name|getDocumentIdField
argument_list|()
argument_list|,
name|representation
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
comment|//first process the document boost
name|float
name|documentBoost
init|=
name|documentBoostFieldName
operator|==
literal|null
condition|?
literal|1.0f
else|:
name|getDocumentBoost
argument_list|(
name|representation
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|String
argument_list|>
name|fields
init|=
name|representation
operator|.
name|getFieldNames
argument_list|()
init|;
name|fields
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
comment|//TODO: maybe add some functionality to prevent indexing of the
comment|//      field configured as documentBoostFieldName!
comment|//      But this would also prevent the possibility to intentionally
comment|//      override the boost.
name|String
name|field
init|=
name|fields
operator|.
name|next
argument_list|()
decl_stmt|;
name|Float
name|fieldBoost
init|=
name|fieldBoostMap
operator|==
literal|null
condition|?
literal|null
else|:
name|fieldBoostMap
operator|.
name|get
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|float
name|boost
init|=
name|fieldBoost
operator|==
literal|null
condition|?
name|documentBoost
else|:
name|fieldBoost
operator|>=
literal|0
condition|?
name|fieldBoost
operator|*
name|documentBoost
else|:
name|documentBoost
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|Object
argument_list|>
name|values
init|=
name|representation
operator|.
name|get
argument_list|(
name|field
argument_list|)
init|;
name|values
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
comment|//now we need to get the indexField for the value
name|Object
name|next
init|=
name|values
operator|.
name|next
argument_list|()
decl_stmt|;
name|IndexValue
name|value
decl_stmt|;
try|try
block|{
name|value
operator|=
name|indexValueFactory
operator|.
name|createIndexValue
argument_list|(
name|next
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|fieldName
range|:
name|fieldMapper
operator|.
name|getFieldNames
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|field
argument_list|)
argument_list|,
name|value
argument_list|)
control|)
block|{
name|inputDocument
operator|.
name|addField
argument_list|(
name|fieldName
argument_list|,
name|value
operator|.
name|getValue
argument_list|()
argument_list|,
name|boost
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unable to process value %s (type:%s) for field %s!"
argument_list|,
name|next
argument_list|,
name|next
operator|.
name|getClass
argument_list|()
argument_list|,
name|field
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|inputDocument
return|;
block|}
comment|/**      * Extracts the document boost from a {@link Representation}.      * @param representation the representation      * @return the Boost or<code>null</code> if not found or lower equals zero      */
specifier|private
name|float
name|getDocumentBoost
parameter_list|(
name|Representation
name|representation
parameter_list|)
block|{
if|if
condition|(
name|documentBoostFieldName
operator|==
literal|null
condition|)
block|{
return|return
literal|1.0f
return|;
block|}
name|Float
name|documentBoost
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|Object
argument_list|>
name|values
init|=
name|representation
operator|.
name|get
argument_list|(
name|documentBoostFieldName
argument_list|)
init|;
name|values
operator|.
name|hasNext
argument_list|()
operator|&&
name|documentBoost
operator|==
literal|null
condition|;
control|)
block|{
name|Object
name|value
init|=
name|values
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Float
condition|)
block|{
name|documentBoost
operator|=
operator|(
name|Float
operator|)
name|value
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|documentBoost
operator|=
name|Float
operator|.
name|parseFloat
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unable to parse the Document Boost from field %s=%s[type=%s] -> The Document Boost MUST BE a Float value!"
argument_list|,
name|documentBoostFieldName
argument_list|,
name|value
argument_list|,
name|value
operator|.
name|getClass
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|documentBoost
operator|==
literal|null
condition|?
literal|1.0f
else|:
name|documentBoost
operator|>=
literal|0
condition|?
name|documentBoost
else|:
literal|1.0f
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|Representation
name|update
parameter_list|(
name|Representation
name|representation
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|NullPointerException
throws|,
name|YardException
block|{
if|if
condition|(
name|representation
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Representation MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|boolean
name|found
init|=
name|isRepresentation
argument_list|(
name|representation
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|found
condition|)
block|{
return|return
name|store
argument_list|(
name|representation
argument_list|)
return|;
comment|//there is no "update" for solr
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Parsed Representation "
operator|+
name|representation
operator|.
name|getId
argument_list|()
operator|+
literal|" in not managed by this Yard "
operator|+
name|getName
argument_list|()
operator|+
literal|"(id="
operator|+
name|getId
argument_list|()
operator|+
literal|")"
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|Iterable
argument_list|<
name|Representation
argument_list|>
name|update
parameter_list|(
name|Iterable
argument_list|<
name|Representation
argument_list|>
name|representations
parameter_list|)
throws|throws
name|YardException
throws|,
name|IllegalArgumentException
throws|,
name|NullPointerException
block|{
if|if
condition|(
name|representations
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Iterable over Representations MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|ids
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Representation
name|representation
range|:
name|representations
control|)
block|{
if|if
condition|(
name|representation
operator|!=
literal|null
condition|)
block|{
name|ids
operator|.
name|add
argument_list|(
name|representation
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|numDocs
init|=
name|ids
operator|.
name|size
argument_list|()
decl_stmt|;
comment|//for debuging
try|try
block|{
name|ids
operator|=
name|checkRepresentations
argument_list|(
name|ids
argument_list|)
expr_stmt|;
comment|//returns the ids found in the solrIndex
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Error while searching for alredy present documents before executing the actual update for the parsed Representations"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to access SolrServer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|long
name|checked
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|SolrInputDocument
argument_list|>
name|inputDocs
init|=
operator|new
name|ArrayList
argument_list|<
name|SolrInputDocument
argument_list|>
argument_list|(
name|ids
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Representation
argument_list|>
name|updated
init|=
operator|new
name|ArrayList
argument_list|<
name|Representation
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Representation
name|representation
range|:
name|representations
control|)
block|{
if|if
condition|(
name|representation
operator|!=
literal|null
operator|&&
name|ids
operator|.
name|contains
argument_list|(
name|representation
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
block|{
comment|//null parsed or not already present
name|inputDocs
operator|.
name|add
argument_list|(
name|createSolrInputDocument
argument_list|(
name|representation
argument_list|)
argument_list|)
expr_stmt|;
name|updated
operator|.
name|add
argument_list|(
name|representation
argument_list|)
expr_stmt|;
block|}
block|}
name|long
name|created
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|inputDocs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
try|try
block|{
name|UpdateRequest
name|update
init|=
operator|new
name|UpdateRequest
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|immediateCommit
condition|)
block|{
name|update
operator|.
name|setCommitWithin
argument_list|(
name|commitWithin
argument_list|)
expr_stmt|;
block|}
name|update
operator|.
name|add
argument_list|(
name|inputDocs
argument_list|)
expr_stmt|;
name|update
operator|.
name|process
argument_list|(
name|server
argument_list|)
expr_stmt|;
if|if
condition|(
name|immediateCommit
condition|)
block|{
name|server
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Error while adding updated Documents to the SolrServer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to access Solr server"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
name|long
name|ready
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Processed updateRequest for %d documents (%d in index | %d updated) in %dms (checked %dms|created %dms| stored%dms)"
argument_list|,
name|numDocs
argument_list|,
name|ids
operator|.
name|size
argument_list|()
argument_list|,
name|updated
operator|.
name|size
argument_list|()
argument_list|,
name|ready
operator|-
name|start
argument_list|,
name|checked
operator|-
name|start
argument_list|,
name|created
operator|-
name|checked
argument_list|,
name|ready
operator|-
name|created
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|updated
return|;
block|}
comment|/**      * Stores the parsed document within the Index. This Method is also used by      * other classes within this package to store configurations directly within      * the index      * @param inputDoc the document to store      */
specifier|protected
specifier|final
name|void
name|storeSolrDocument
parameter_list|(
name|SolrInputDocument
name|inputDoc
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
name|server
operator|.
name|add
argument_list|(
name|inputDoc
argument_list|)
expr_stmt|;
block|}
comment|/**      * Getter for a SolrDocument based on the ID. This Method is also used by      * other classes within this package to load configurations directly from      * the index      * @param inputDoc the document to store      */
specifier|public
specifier|final
name|SolrDocument
name|getSolrDocument
parameter_list|(
name|String
name|uri
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
return|return
name|getSolrDocument
argument_list|(
name|uri
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|protected
specifier|final
name|Collection
argument_list|<
name|SolrDocument
argument_list|>
name|getSolrDocuments
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|uris
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|fields
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
name|SolrYardConfig
name|config
init|=
operator|(
name|SolrYardConfig
operator|)
name|getConfig
argument_list|()
decl_stmt|;
name|SolrQuery
name|solrQuery
init|=
operator|new
name|SolrQuery
argument_list|()
decl_stmt|;
if|if
condition|(
name|fields
operator|==
literal|null
operator|||
name|fields
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|solrQuery
operator|.
name|addField
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
comment|//select all fields
block|}
else|else
block|{
for|for
control|(
name|String
name|field
range|:
name|fields
control|)
block|{
if|if
condition|(
name|field
operator|!=
literal|null
operator|&&
operator|!
name|field
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|solrQuery
operator|.
name|addField
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//NOTE: If there are more requested documents than allowed boolean
comment|//      clauses in one query, than we need to send several requests!
name|Iterator
argument_list|<
name|String
argument_list|>
name|uriIterator
init|=
name|uris
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|int
name|maxClauses
decl_stmt|;
name|Integer
name|configuredMaxClauses
init|=
name|config
operator|.
name|getMaxBooleanClauses
argument_list|()
decl_stmt|;
if|if
condition|(
name|configuredMaxClauses
operator|!=
literal|null
operator|&&
name|configuredMaxClauses
operator|>
literal|0
condition|)
block|{
name|maxClauses
operator|=
name|configuredMaxClauses
expr_stmt|;
block|}
else|else
block|{
name|maxClauses
operator|=
name|defaultMaxBooleanClauses
expr_stmt|;
block|}
name|int
name|num
init|=
literal|0
decl_stmt|;
name|StringBuilder
name|queryBuilder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|boolean
name|myList
init|=
literal|false
decl_stmt|;
name|Collection
argument_list|<
name|SolrDocument
argument_list|>
name|resultDocs
init|=
literal|null
decl_stmt|;
comment|//do while more uris
while|while
condition|(
name|uriIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|//do while more uris and free boolean clauses
comment|//num<= maxClauses because 1-items boolean clauses in the query!
while|while
condition|(
name|uriIterator
operator|.
name|hasNext
argument_list|()
operator|&&
name|num
operator|<=
name|maxClauses
condition|)
block|{
name|String
name|uri
init|=
name|uriIterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|uri
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|num
operator|>
literal|0
condition|)
block|{
name|queryBuilder
operator|.
name|append
argument_list|(
literal|" OR "
argument_list|)
expr_stmt|;
block|}
name|queryBuilder
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"%s:%s"
argument_list|,
name|fieldMapper
operator|.
name|getDocumentIdField
argument_list|()
argument_list|,
name|SolrUtil
operator|.
name|escapeSolrSpecialChars
argument_list|(
name|uri
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|num
operator|++
expr_stmt|;
block|}
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Get SolrDocuments for Query: "
operator|+
name|queryBuilder
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|//no more items or all boolean clauses used -> send a request
name|solrQuery
operator|.
name|setQuery
argument_list|(
name|queryBuilder
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|queryBuilder
operator|=
operator|new
name|StringBuilder
argument_list|()
expr_stmt|;
comment|// and a new StringBuilder
comment|//set the number of results to the number of parsed IDs.
name|solrQuery
operator|.
name|setRows
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|num
operator|=
literal|0
expr_stmt|;
comment|//reset to 0
name|QueryResponse
name|queryResponse
init|=
name|server
operator|.
name|query
argument_list|(
name|solrQuery
argument_list|,
name|METHOD
operator|.
name|POST
argument_list|)
decl_stmt|;
if|if
condition|(
name|resultDocs
operator|==
literal|null
condition|)
block|{
name|resultDocs
operator|=
name|queryResponse
operator|.
name|getResults
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|myList
condition|)
block|{
comment|//most of the time there will be only one request, so only
comment|//create my own list when the second response is processed
name|resultDocs
operator|=
operator|new
name|ArrayList
argument_list|<
name|SolrDocument
argument_list|>
argument_list|(
name|resultDocs
argument_list|)
expr_stmt|;
name|myList
operator|=
literal|true
expr_stmt|;
block|}
name|resultDocs
operator|.
name|addAll
argument_list|(
name|queryResponse
operator|.
name|getResults
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|//end while more uris
return|return
name|resultDocs
return|;
block|}
specifier|protected
specifier|final
name|SolrDocument
name|getSolrDocument
parameter_list|(
name|String
name|uri
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|fields
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
name|SolrQuery
name|solrQuery
init|=
operator|new
name|SolrQuery
argument_list|()
decl_stmt|;
if|if
condition|(
name|fields
operator|==
literal|null
operator|||
name|fields
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|solrQuery
operator|.
name|addField
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
comment|//select all fields
block|}
else|else
block|{
for|for
control|(
name|String
name|field
range|:
name|fields
control|)
block|{
if|if
condition|(
name|field
operator|!=
literal|null
operator|&&
operator|!
name|field
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|solrQuery
operator|.
name|addField
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|solrQuery
operator|.
name|setRows
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|//we query for the id, there is only one result
name|String
name|queryString
init|=
name|String
operator|.
name|format
argument_list|(
literal|"%s:%s"
argument_list|,
name|fieldMapper
operator|.
name|getDocumentIdField
argument_list|()
argument_list|,
name|SolrUtil
operator|.
name|escapeSolrSpecialChars
argument_list|(
name|uri
argument_list|)
argument_list|)
decl_stmt|;
name|solrQuery
operator|.
name|setQuery
argument_list|(
name|queryString
argument_list|)
expr_stmt|;
name|QueryResponse
name|queryResponse
init|=
name|server
operator|.
name|query
argument_list|(
name|solrQuery
argument_list|,
name|METHOD
operator|.
name|POST
argument_list|)
decl_stmt|;
if|if
condition|(
name|queryResponse
operator|.
name|getResults
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|queryResponse
operator|.
name|getResults
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

