begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|impl
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|AccessController
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedActionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrRequest
operator|.
name|METHOD
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrServerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|request
operator|.
name|UpdateRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|response
operator|.
name|QueryResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|response
operator|.
name|UpdateResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrInputDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrInputField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|namespaceprefix
operator|.
name|NamespacePrefixService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|utils
operator|.
name|SolrUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|utils
operator|.
name|StreamQueryRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|core
operator|.
name|model
operator|.
name|InMemoryValueFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|core
operator|.
name|query
operator|.
name|DefaultQueryFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|core
operator|.
name|query
operator|.
name|QueryResultListImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|core
operator|.
name|yard
operator|.
name|AbstractYard
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Representation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|rdf
operator|.
name|RdfResourceEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|Constraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|FieldQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|QueryResultList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|util
operator|.
name|AdaptingIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|yard
operator|.
name|Yard
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|yard
operator|.
name|YardException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|defaults
operator|.
name|IndexDataTypeEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|impl
operator|.
name|SolrQueryFactory
operator|.
name|SELECT
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|model
operator|.
name|FieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|model
operator|.
name|IndexField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|model
operator|.
name|IndexValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|model
operator|.
name|IndexValueFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|model
operator|.
name|NoConverterException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|solr
operator|.
name|query
operator|.
name|IndexConstraintTypeEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|service
operator|.
name|component
operator|.
name|ComponentContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Implementation of the {@link Yard} interface based on a Solr Server.  *<p>  * This Yard implementation supports to store data of multiple yard instances within the same Solr index. The  * {@link FieldMapper#getDocumentDomainField()} with the value of the Yard ID ({@link #getId()}) is used to  * mark documents stored by the different Yards using the same Index. Queries are also restricted to documents  * stored by the actual Yard by adding a<a  * href="http://wiki.apache.org/solr/CommonQueryParameters#fq">FilterQuery</a>  *<code>fq=fieldMapper.getDocumentDomainField()+":"+getId()</code> to all queries. This feature can be  * activated by setting the {@link #MULTI_YARD_INDEX_LAYOUT} in the configuration. However this requires, that  * the documents in the index are already marked with the ID of the Yard. So setting this property makes  * usually only sense when the Solr index do not contain any data.  *<p>  * Also note, that the different Yards using the same index MUST NOT store Representations with the same ID.  * If that happens, that the Yard writing the Representation last will win and the Representation will be  * deleted for the other Yard!  *<p>  * The SolrJ library is used for the communication with the SolrServer.  *<p>  * TODO: There is still some refactoring needed, because a lot of the code within this bundle is more generic  * and usable regardless what kind of "document based" store is used. Currently the Solr specific stuff is in  * the impl and the default packages. All the other classes are intended to be generally useful. However there  * might be still some unwanted dependencies.  *<p>  * TODO: It would be possible to support for multi cores (see http://wiki.apache.org/solr/CoreAdmin for more  * Information)<br>  * However it is not possible to create cores on the fly (at least not directly; one would need to create  * first the needed directories and than call CREATE via the CoreAdmin). As soon as Solr is directly started  * via OSGI and we do know the Solr home, than it would be possible to implement "on the fly" generation of  * new cores. this would also allow a configuration where - as default - a new core is created automatically  * on the integrated Solr Server for any configured SolrYard.  *   * @author Rupert Westenthaler  *   */
end_comment

begin_class
specifier|public
class|class
name|SolrYard
extends|extends
name|AbstractYard
implements|implements
name|Yard
block|{
comment|/**      * What a surprise it's the logger!      */
specifier|private
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SolrYard
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * The SolrServer used for this Yard.      */
specifier|private
specifier|final
name|SolrServer
name|server
decl_stmt|;
comment|/**      * The {@link FieldMapper} is responsible for converting fields of {@link Representation} to fields in the      * {@link SolrInputDocument} and vice versa      */
specifier|private
specifier|final
name|SolrFieldMapper
name|fieldMapper
decl_stmt|;
comment|/**      * The {@link IndexValueFactory} is responsible for converting values of fields in the      * {@link Representation} to the according {@link IndexValue}. One should note, that some properties of      * the {@link IndexValue} such as the language ({@link IndexValue#getLanguage()}) and the dataType (      * {@link IndexValue#getType()}) are encoded within the field name inside the {@link SolrInputDocument}      * and {@link SolrDocument}. This is done by the configured {@link FieldMapper}.      */
specifier|private
name|IndexValueFactory
name|indexValueFactory
decl_stmt|;
comment|/**      * The {@link SolrQueryFactory} is responsible for converting the {@link Constraint}s of a query to      * constraints in the index. This requires usually that a single {@link Constraint} is described by      * several constraints in the index (see {@link IndexConstraintTypeEnum}).      *<p>      * TODO: The encoding of such constraints is already designed correctly, the {@link SolrQueryFactory} that      * implements logic of converting the Incoming {@link Constraint}s and generating the {@link SolrQuery}      * needs to undergo some refactoring!      *       */
specifier|private
specifier|final
name|SolrQueryFactory
name|solrQueryFactoy
decl_stmt|;
comment|/**      * Used to store the name of the field used to get the {@link SolrInputDocument#setDocumentBoost(float)}      * for a Representation. This name is available via {@link SolrYardConfig#getDocumentBoostFieldName()}      * however it is stored here to prevent lookups for field of every stored {@link Representation}.      */
specifier|private
specifier|final
name|String
name|documentBoostFieldName
decl_stmt|;
comment|/**      * Map used to store boost values for fields. The default Boost for fields is 1.0f. This is used if this      * map is<code>null</code>, a field is not a key in this map, the value of a field in that map is      *<code>null</code> or lower equals zero. Also NOTE that the boost for fields is multiplied with the      * boost for the Document if present.      */
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|fieldBoostMap
decl_stmt|;
comment|/**      * If update(..) and store(..) calls should be immediately committed.      */
specifier|private
name|boolean
name|immediateCommit
init|=
name|DEFAULT_IMMEDIATE_COMMIT_STATE
decl_stmt|;
comment|/**      * If<code>{@link #immediateCommit} == false</code> this is the time in ms parsed to Solr until the      * documents parsed to update(..) and store(..) need to be committed.      */
specifier|private
name|int
name|commitWithin
init|=
name|DEFAULT_COMMIT_WITHIN_DURATION
decl_stmt|;
specifier|private
specifier|final
name|SolrYardConfig
name|config
decl_stmt|;
specifier|private
name|boolean
name|closed
decl_stmt|;
comment|/**      * Creates a new SolrYard by parsing the SolrServer, the SolrYard config and      * optionally a namespace prefix service      * @param server the {@link SolrServer} used by this Yard      * @param config the configuration      * @param nsPrefixService the {@link NamespacePrefixService} or<code>null</code>      * if not available.      */
specifier|public
name|SolrYard
parameter_list|(
name|SolrServer
name|server
parameter_list|,
name|SolrYardConfig
name|config
parameter_list|,
name|NamespacePrefixService
name|nsPrefixService
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
if|if
condition|(
name|server
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed SolrServer instance"
operator|+
literal|"MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|this
operator|.
name|server
operator|=
name|server
expr_stmt|;
if|if
condition|(
name|config
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed SolrYard configuration"
operator|+
literal|"MUST NOT be NULL"
argument_list|)
throw|;
block|}
name|this
operator|.
name|config
operator|=
name|config
expr_stmt|;
comment|//set the value/query/indexValue factory
name|activate
argument_list|(
name|InMemoryValueFactory
operator|.
name|getInstance
argument_list|()
argument_list|,
name|DefaultQueryFactory
operator|.
name|getInstance
argument_list|()
argument_list|,
name|config
argument_list|)
expr_stmt|;
name|this
operator|.
name|indexValueFactory
operator|=
name|IndexValueFactory
operator|.
name|getInstance
argument_list|()
expr_stmt|;
comment|// Set often accessed fields based on config
name|this
operator|.
name|immediateCommit
operator|=
name|config
operator|.
name|isImmediateCommit
argument_list|()
expr_stmt|;
name|this
operator|.
name|commitWithin
operator|=
name|config
operator|.
name|getCommitWithinDuration
argument_list|()
expr_stmt|;
name|this
operator|.
name|documentBoostFieldName
operator|=
name|config
operator|.
name|getDocumentBoostFieldName
argument_list|()
expr_stmt|;
name|this
operator|.
name|fieldBoostMap
operator|=
name|config
operator|.
name|getFieldBoosts
argument_list|()
expr_stmt|;
comment|//init fieldMapper and queryFactory
name|this
operator|.
name|fieldMapper
operator|=
operator|new
name|SolrFieldMapper
argument_list|(
name|this
operator|.
name|server
argument_list|,
name|nsPrefixService
argument_list|)
expr_stmt|;
name|this
operator|.
name|solrQueryFactoy
operator|=
operator|new
name|SolrQueryFactory
argument_list|(
name|getValueFactory
argument_list|()
argument_list|,
name|indexValueFactory
argument_list|,
name|fieldMapper
argument_list|)
expr_stmt|;
block|}
comment|/**      * This will case the SolrIndex to be optimised      * @throws YardException on any error while optimising      */
specifier|public
specifier|final
name|void
name|optimize
parameter_list|()
throws|throws
name|YardException
block|{
if|if
condition|(
name|closed
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"The SolrYard is already closed!"
argument_list|)
throw|;
block|}
try|try
block|{
name|server
operator|.
name|optimize
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to optimise SolrIndex!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to optimise SolrIndex!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * can be used outside of the OSGI environment to deactivate this instance. Thiw will cause the SolrIndex      * to be committed and optimised.      */
specifier|public
name|void
name|close
parameter_list|()
block|{
if|if
condition|(
name|closed
condition|)
block|{
return|return;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"... deactivating SolrYard "
operator|+
name|config
operator|.
name|getName
argument_list|()
operator|+
literal|" (id="
operator|+
name|config
operator|.
name|getId
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
try|try
block|{
name|server
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to perform final commit during deactivation"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to perform final commit during deactivation"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|closed
operator|=
literal|true
expr_stmt|;
block|}
comment|/**      * Calls the {@link #deactivate(ComponentContext)} with<code>null</code> as component context      */
annotation|@
name|Override
specifier|protected
name|void
name|finalize
parameter_list|()
throws|throws
name|Throwable
block|{
name|close
argument_list|()
expr_stmt|;
name|super
operator|.
name|finalize
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|QueryResultList
argument_list|<
name|Representation
argument_list|>
name|find
parameter_list|(
specifier|final
name|FieldQuery
name|parsedQuery
parameter_list|)
throws|throws
name|YardException
block|{
return|return
name|find
argument_list|(
name|parsedQuery
argument_list|,
name|SELECT
operator|.
name|QUERY
argument_list|)
return|;
block|}
specifier|private
name|QueryResultList
argument_list|<
name|Representation
argument_list|>
name|find
parameter_list|(
specifier|final
name|FieldQuery
name|parsedQuery
parameter_list|,
name|SELECT
name|select
parameter_list|)
throws|throws
name|YardException
block|{
comment|//create a clone of the query, because we need to refine it because the
comment|//query (as executed) needs to be included in the result set
name|FieldQuery
name|fieldQuery
init|=
name|parsedQuery
operator|.
name|clone
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"find "
operator|+
name|fieldQuery
argument_list|)
expr_stmt|;
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|selected
decl_stmt|;
if|if
condition|(
name|select
operator|==
name|SELECT
operator|.
name|QUERY
condition|)
block|{
comment|// if query set the fields to add to the result Representations
name|selected
operator|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|fieldQuery
operator|.
name|getSelectedFields
argument_list|()
argument_list|)
expr_stmt|;
comment|// add the score to query results!
name|selected
operator|.
name|add
argument_list|(
name|RdfResourceEnum
operator|.
name|resultScore
operator|.
name|getUri
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// otherwise add all fields
name|selected
operator|=
literal|null
expr_stmt|;
block|}
specifier|final
name|SolrQuery
name|query
init|=
name|solrQueryFactoy
operator|.
name|parseFieldQuery
argument_list|(
name|fieldQuery
argument_list|,
name|select
argument_list|)
decl_stmt|;
name|long
name|queryGeneration
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|closed
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"The SolrYard '{}' was already closed!"
argument_list|,
name|config
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|QueryResponse
name|response
decl_stmt|;
try|try
block|{
name|response
operator|=
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|QueryResponse
argument_list|>
argument_list|()
block|{
specifier|public
name|QueryResponse
name|run
parameter_list|()
throws|throws
name|IOException
throws|,
name|SolrServerException
block|{
name|StreamQueryRequest
name|request
init|=
operator|new
name|StreamQueryRequest
argument_list|(
name|query
argument_list|)
decl_stmt|;
return|return
name|request
operator|.
name|process
argument_list|(
name|server
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PrivilegedActionException
name|pae
parameter_list|)
block|{
name|Exception
name|e
init|=
name|pae
operator|.
name|getException
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|SolrServerException
condition|)
block|{
if|if
condition|(
literal|"unknown handler: /mlt"
operator|.
name|equals
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
operator|.
name|getMessage
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Solr is missing '<requestHandler name=\"/mlt\""
operator|+
literal|" class=\"solr.MoreLikeThisHandler\" startup=\"lazy\" />'"
operator|+
literal|" in 'solrconfig.xml'"
argument_list|,
name|e
argument_list|)
throw|;
block|}
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Error while performing Query on SolrServer: "
operator|+
name|query
operator|.
name|getQuery
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|e
operator|instanceof
name|IOException
condition|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to access SolrServer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
name|RuntimeException
operator|.
name|class
operator|.
name|cast
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|query
operator|.
name|getRequestHandler
argument_list|()
operator|==
name|SolrQueryFactory
operator|.
name|MLT_QUERY_TYPE
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"{}"
argument_list|,
name|response
argument_list|)
expr_stmt|;
block|}
name|long
name|queryTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
comment|// return a queryResultList
name|QueryResultListImpl
argument_list|<
name|Representation
argument_list|>
name|resultList
init|=
operator|new
name|QueryResultListImpl
argument_list|<
name|Representation
argument_list|>
argument_list|(
name|fieldQuery
argument_list|,
comment|// by adapting SolrDocuments to Representations
operator|new
name|AdaptingIterator
argument_list|<
name|SolrDocument
argument_list|,
name|Representation
argument_list|>
argument_list|(
name|response
operator|.
name|getResults
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|,
comment|// inline Adapter Implementation
operator|new
name|AdaptingIterator
operator|.
name|Adapter
argument_list|<
name|SolrDocument
argument_list|,
name|Representation
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Representation
name|adapt
parameter_list|(
name|SolrDocument
name|doc
parameter_list|,
name|Class
argument_list|<
name|Representation
argument_list|>
name|type
parameter_list|)
block|{
comment|// use this method for the conversion!
return|return
name|createRepresentation
argument_list|(
name|doc
argument_list|,
name|selected
argument_list|)
return|;
block|}
block|}
argument_list|,
name|Representation
operator|.
name|class
argument_list|)
argument_list|,
name|Representation
operator|.
name|class
argument_list|)
decl_stmt|;
name|long
name|resultProcessing
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"  ... done [queryGeneration=%dms|queryTime=%dms|resultProcessing=%dms|sum=%dms]"
argument_list|,
operator|(
name|queryGeneration
operator|-
name|start
operator|)
argument_list|,
operator|(
name|queryTime
operator|-
name|queryGeneration
operator|)
argument_list|,
operator|(
name|resultProcessing
operator|-
name|queryTime
operator|)
argument_list|,
operator|(
name|resultProcessing
operator|-
name|start
operator|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|resultList
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|QueryResultList
argument_list|<
name|String
argument_list|>
name|findReferences
parameter_list|(
name|FieldQuery
name|parsedQuery
parameter_list|)
throws|throws
name|YardException
block|{
comment|//create a clone of the query, because we need to refine it because the
comment|//query (as executed) needs to be included in the result set
name|FieldQuery
name|fieldQuery
init|=
name|parsedQuery
operator|.
name|clone
argument_list|()
decl_stmt|;
specifier|final
name|SolrQuery
name|query
init|=
name|solrQueryFactoy
operator|.
name|parseFieldQuery
argument_list|(
name|fieldQuery
argument_list|,
name|SELECT
operator|.
name|ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|closed
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"The SolrYard '{}' was already closed!"
argument_list|,
name|config
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|QueryResponse
name|response
decl_stmt|;
try|try
block|{
name|response
operator|=
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|QueryResponse
argument_list|>
argument_list|()
block|{
specifier|public
name|QueryResponse
name|run
parameter_list|()
throws|throws
name|IOException
throws|,
name|SolrServerException
block|{
return|return
name|server
operator|.
name|query
argument_list|(
name|query
argument_list|,
name|METHOD
operator|.
name|POST
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PrivilegedActionException
name|pae
parameter_list|)
block|{
name|Exception
name|e
init|=
name|pae
operator|.
name|getException
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|SolrServerException
condition|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Error while performing query on the SolrServer (query: "
operator|+
name|query
operator|.
name|getQuery
argument_list|()
operator|+
literal|")!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|e
operator|instanceof
name|IOException
condition|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to access SolrServer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
name|RuntimeException
operator|.
name|class
operator|.
name|cast
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|// return a queryResultList
return|return
operator|new
name|QueryResultListImpl
argument_list|<
name|String
argument_list|>
argument_list|(
name|fieldQuery
argument_list|,
comment|// by adapting SolrDocuments to Representations
operator|new
name|AdaptingIterator
argument_list|<
name|SolrDocument
argument_list|,
name|String
argument_list|>
argument_list|(
name|response
operator|.
name|getResults
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|,
comment|// inline Adapter Implementation
operator|new
name|AdaptingIterator
operator|.
name|Adapter
argument_list|<
name|SolrDocument
argument_list|,
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|adapt
parameter_list|(
name|SolrDocument
name|doc
parameter_list|,
name|Class
argument_list|<
name|String
argument_list|>
name|type
parameter_list|)
block|{
comment|// use this method for the conversion!
return|return
name|doc
operator|.
name|getFirstValue
argument_list|(
name|fieldMapper
operator|.
name|getDocumentIdField
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
argument_list|,
name|String
operator|.
name|class
argument_list|)
argument_list|,
name|String
operator|.
name|class
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|QueryResultList
argument_list|<
name|Representation
argument_list|>
name|findRepresentation
parameter_list|(
name|FieldQuery
name|parsedQuery
parameter_list|)
throws|throws
name|YardException
block|{
return|return
name|find
argument_list|(
name|parsedQuery
argument_list|,
name|SELECT
operator|.
name|ALL
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|Representation
name|getRepresentation
parameter_list|(
name|String
name|id
parameter_list|)
throws|throws
name|YardException
block|{
if|if
condition|(
name|id
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Representation id MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|id
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Representation id MUST NOT be empty!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|closed
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"The SolrYard '{}' was already closed!"
argument_list|,
name|config
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|SolrDocument
name|doc
decl_stmt|;
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
try|try
block|{
name|doc
operator|=
name|getSolrDocument
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Error while getting SolrDocument for id"
operator|+
name|id
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to access SolrServer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|long
name|retrieve
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|Representation
name|rep
decl_stmt|;
if|if
condition|(
name|doc
operator|!=
literal|null
condition|)
block|{
comment|// create an Representation for the Doc! retrieve
name|log
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Create Representation %s from SolrDocument"
argument_list|,
name|doc
operator|.
name|getFirstValue
argument_list|(
name|fieldMapper
operator|.
name|getDocumentIdField
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|rep
operator|=
name|createRepresentation
argument_list|(
name|doc
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rep
operator|=
literal|null
expr_stmt|;
block|}
name|long
name|create
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"  ... %s [retrieve=%dms|create=%dms|sum=%dms]"
argument_list|,
name|rep
operator|==
literal|null
condition|?
literal|"not found"
else|:
literal|"done"
argument_list|,
operator|(
name|retrieve
operator|-
name|start
operator|)
argument_list|,
operator|(
name|create
operator|-
name|retrieve
operator|)
argument_list|,
operator|(
name|create
operator|-
name|start
operator|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rep
return|;
block|}
comment|/**      * Creates the Representation for the parsed SolrDocument!      *       * @param doc      *            The Solr Document to convert      * @param fields      *            if NOT NULL only this fields are added to the Representation      * @return the Representation      */
specifier|protected
specifier|final
name|Representation
name|createRepresentation
parameter_list|(
name|SolrDocument
name|doc
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|fields
parameter_list|)
block|{
if|if
condition|(
name|fieldMapper
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed FieldMapper MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed SolrDocument MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|Object
name|id
init|=
name|doc
operator|.
name|getFirstValue
argument_list|(
name|fieldMapper
operator|.
name|getDocumentIdField
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|id
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"The parsed Solr Document does not contain a value for the %s Field!"
argument_list|,
name|fieldMapper
operator|.
name|getDocumentIdField
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|Representation
name|rep
init|=
name|getValueFactory
argument_list|()
operator|.
name|createRepresentation
argument_list|(
name|id
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|fieldName
range|:
name|doc
operator|.
name|getFieldNames
argument_list|()
control|)
block|{
name|IndexField
name|indexField
init|=
name|fieldMapper
operator|.
name|getField
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexField
operator|!=
literal|null
operator|&&
name|indexField
operator|.
name|getPath
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|String
name|lang
init|=
name|indexField
operator|.
name|getLanguages
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|indexField
operator|.
name|getLanguages
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|fields
operator|==
literal|null
operator|||
name|fields
operator|.
name|contains
argument_list|(
name|indexField
operator|.
name|getPath
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
for|for
control|(
name|Object
name|value
range|:
name|doc
operator|.
name|getFieldValues
argument_list|(
name|fieldName
argument_list|)
control|)
block|{
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|IndexDataTypeEnum
name|dataTypeEnumEntry
init|=
name|IndexDataTypeEnum
operator|.
name|forIndexType
argument_list|(
name|indexField
operator|.
name|getDataType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|dataTypeEnumEntry
operator|!=
literal|null
condition|)
block|{
name|Object
name|javaValue
init|=
name|indexValueFactory
operator|.
name|createValue
argument_list|(
name|dataTypeEnumEntry
operator|.
name|getJavaType
argument_list|()
argument_list|,
name|indexField
operator|.
name|getDataType
argument_list|()
argument_list|,
name|value
argument_list|,
name|lang
argument_list|)
decl_stmt|;
if|if
condition|(
name|javaValue
operator|!=
literal|null
condition|)
block|{
name|rep
operator|.
name|add
argument_list|(
name|indexField
operator|.
name|getPath
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|,
name|javaValue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"java value=null for index value %s"
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"No DataType Configuration found for Index Data Type %s!"
argument_list|,
name|indexField
operator|.
name|getDataType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// else index value == null -> ignore
block|}
comment|// end for all values
block|}
block|}
else|else
block|{
if|if
condition|(
name|indexField
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unable to prozess Index Field %s (for IndexDocument Field: %s)"
argument_list|,
name|indexField
argument_list|,
name|fieldName
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// end for all fields
return|return
name|rep
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|boolean
name|isRepresentation
parameter_list|(
name|String
name|id
parameter_list|)
throws|throws
name|YardException
block|{
if|if
condition|(
name|id
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Representation id MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|id
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Representation id MUST NOT be empty!"
argument_list|)
throw|;
block|}
try|try
block|{
return|return
name|getSolrDocument
argument_list|(
name|id
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|fieldMapper
operator|.
name|getDocumentIdField
argument_list|()
argument_list|)
argument_list|)
operator|!=
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Error while performing getDocumentByID request for id "
operator|+
name|id
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to access SolrServer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Checks what of the documents referenced by the parsed IDs are present in the Solr Server      *       * @param ids      *            the ids of the documents to check      * @return the ids of the found documents      * @throws SolrServerException      *             on any exception of the SolrServer      * @throws IOException      *             an any IO exception while accessing the SolrServer      */
specifier|protected
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|checkRepresentations
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|ids
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|found
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|field
init|=
name|fieldMapper
operator|.
name|getDocumentIdField
argument_list|()
decl_stmt|;
for|for
control|(
name|SolrDocument
name|foundDoc
range|:
name|getSolrDocuments
argument_list|(
name|ids
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|field
argument_list|)
argument_list|)
control|)
block|{
name|Object
name|value
init|=
name|foundDoc
operator|.
name|getFirstValue
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|found
operator|.
name|add
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|found
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|remove
parameter_list|(
specifier|final
name|String
name|id
parameter_list|)
throws|throws
name|YardException
throws|,
name|IllegalArgumentException
block|{
if|if
condition|(
name|id
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Representation id MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|id
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Representation id MUST NOT be empty!"
argument_list|)
throw|;
block|}
specifier|final
name|SolrYardConfig
name|config
init|=
operator|(
name|SolrYardConfig
operator|)
name|getConfig
argument_list|()
decl_stmt|;
try|try
block|{
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
specifier|public
name|Object
name|run
parameter_list|()
throws|throws
name|IOException
throws|,
name|SolrServerException
block|{
if|if
condition|(
name|config
operator|.
name|isMultiYardIndexLayout
argument_list|()
condition|)
block|{
comment|//make sure we only delete the Entity only if it is  managed by
comment|//this Yard. Entities of other Yards MUST NOT be deleted!
name|server
operator|.
name|deleteByQuery
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"%s:%s AND %s:%s"
argument_list|,
name|fieldMapper
operator|.
name|getDocumentDomainField
argument_list|()
argument_list|,
name|SolrUtil
operator|.
name|escapeSolrSpecialChars
argument_list|(
name|getId
argument_list|()
argument_list|)
argument_list|,
name|fieldMapper
operator|.
name|getDocumentIdField
argument_list|()
argument_list|,
name|SolrUtil
operator|.
name|escapeSolrSpecialChars
argument_list|(
name|id
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|server
operator|.
name|deleteById
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
name|server
operator|.
name|commit
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PrivilegedActionException
name|pae
parameter_list|)
block|{
name|Exception
name|e
init|=
name|pae
operator|.
name|getException
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|SolrServerException
condition|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Error while deleting document "
operator|+
name|id
operator|+
literal|" from the Solr server"
argument_list|,
name|e
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|e
operator|instanceof
name|IOException
condition|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to access SolrServer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
name|RuntimeException
operator|.
name|class
operator|.
name|cast
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|// NOTE: We do not need to update all Documents that refer this ID, because
comment|// only the representation of the Entity is deleted and not the
comment|// Entity itself. So even that we do no longer have an representation
comment|// the entity still exists and might be referenced by others!
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|remove
parameter_list|(
name|Iterable
argument_list|<
name|String
argument_list|>
name|ids
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|YardException
block|{
if|if
condition|(
name|ids
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed IDs MUST NOT be NULL"
argument_list|)
throw|;
block|}
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|toRemove
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|id
range|:
name|ids
control|)
block|{
if|if
condition|(
name|id
operator|!=
literal|null
operator|&&
operator|!
name|id
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|toRemove
operator|.
name|add
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
block|}
try|try
block|{
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
specifier|public
name|Object
name|run
parameter_list|()
throws|throws
name|IOException
throws|,
name|SolrServerException
block|{
if|if
condition|(
name|config
operator|.
name|isMultiYardIndexLayout
argument_list|()
condition|)
block|{
comment|//make sure we only delete Entities managed by this Yard
comment|//if someone parses an ID managed by an other yard we MUST NOT
comment|//delete it!
for|for
control|(
name|String
name|id
range|:
name|toRemove
control|)
block|{
name|server
operator|.
name|deleteByQuery
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"%s:%s AND %s:%s"
argument_list|,
name|fieldMapper
operator|.
name|getDocumentDomainField
argument_list|()
argument_list|,
name|SolrUtil
operator|.
name|escapeSolrSpecialChars
argument_list|(
name|getId
argument_list|()
argument_list|)
argument_list|,
name|fieldMapper
operator|.
name|getDocumentIdField
argument_list|()
argument_list|,
name|SolrUtil
operator|.
name|escapeSolrSpecialChars
argument_list|(
name|id
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|server
operator|.
name|deleteById
argument_list|(
name|toRemove
argument_list|)
expr_stmt|;
block|}
name|server
operator|.
name|commit
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PrivilegedActionException
name|pae
parameter_list|)
block|{
name|Exception
name|e
init|=
name|pae
operator|.
name|getException
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|SolrServerException
condition|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Error while deleting documents from the Solr server"
argument_list|,
name|e
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|e
operator|instanceof
name|IOException
condition|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to access SolrServer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
name|RuntimeException
operator|.
name|class
operator|.
name|cast
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|// NOTE: We do not need to update all Documents that refer this ID, because
comment|// only the representation of the Entity is deleted and not the
comment|// Entity itself. So even that we do no longer have an representation
comment|// the entity still exists and might be referenced by others!
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeAll
parameter_list|()
throws|throws
name|YardException
block|{
if|if
condition|(
name|closed
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"The SolrYard '{}' was already closed!"
argument_list|,
name|config
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
comment|//delete all documents
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
specifier|public
name|Object
name|run
parameter_list|()
throws|throws
name|IOException
throws|,
name|SolrServerException
throws|,
name|YardException
block|{
comment|//ensures that the fildMapper is initialised and reads the
comment|//namespace config before deleting all documents
if|if
condition|(
name|config
operator|.
name|isMultiYardIndexLayout
argument_list|()
condition|)
block|{
comment|//only delete entities of this referenced site
name|server
operator|.
name|deleteByQuery
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"%s:%s"
argument_list|,
name|fieldMapper
operator|.
name|getDocumentDomainField
argument_list|()
argument_list|,
name|SolrUtil
operator|.
name|escapeSolrSpecialChars
argument_list|(
name|getId
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//we can delete all
name|server
operator|.
name|deleteByQuery
argument_list|(
literal|"*:*"
argument_list|)
expr_stmt|;
block|}
comment|//ensure that the namespace config is stored again after deleting
comment|//all documents
name|fieldMapper
operator|.
name|saveNamespaceConfig
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|server
operator|.
name|commit
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PrivilegedActionException
name|pae
parameter_list|)
block|{
name|Exception
name|e
init|=
name|pae
operator|.
name|getException
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|SolrServerException
condition|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Error while deleting documents from the Solr server"
argument_list|,
name|e
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|e
operator|instanceof
name|IOException
condition|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to access SolrServer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|e
operator|instanceof
name|YardException
condition|)
block|{
throw|throw
operator|(
name|YardException
operator|)
name|e
throw|;
block|}
else|else
block|{
throw|throw
name|RuntimeException
operator|.
name|class
operator|.
name|cast
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|Representation
name|store
parameter_list|(
name|Representation
name|representation
parameter_list|)
throws|throws
name|YardException
throws|,
name|IllegalArgumentException
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Store {}"
argument_list|,
name|representation
operator|!=
literal|null
condition|?
name|representation
operator|.
name|getId
argument_list|()
else|:
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|representation
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Representation MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
specifier|final
name|SolrInputDocument
name|inputDocument
init|=
name|createSolrInputDocument
argument_list|(
name|representation
argument_list|)
decl_stmt|;
name|long
name|create
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|closed
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"The SolrYard '{}' was already closed!"
argument_list|,
name|config
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
specifier|final
name|UpdateRequest
name|update
init|=
operator|new
name|UpdateRequest
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|immediateCommit
condition|)
block|{
name|update
operator|.
name|setCommitWithin
argument_list|(
name|commitWithin
argument_list|)
expr_stmt|;
block|}
name|update
operator|.
name|add
argument_list|(
name|inputDocument
argument_list|)
expr_stmt|;
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
specifier|public
name|Object
name|run
parameter_list|()
throws|throws
name|IOException
throws|,
name|SolrServerException
block|{
name|update
operator|.
name|process
argument_list|(
name|server
argument_list|)
expr_stmt|;
if|if
condition|(
name|immediateCommit
condition|)
block|{
name|server
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
return|return
literal|null
return|;
comment|// nothing to return
block|}
block|}
argument_list|)
expr_stmt|;
name|long
name|stored
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"  ... done [create={}ms|store={}ms|sum={}ms]"
argument_list|,
operator|new
name|Object
index|[]
block|{
operator|(
name|create
operator|-
name|start
operator|)
block|,
operator|(
name|stored
operator|-
name|create
operator|)
block|,
operator|(
name|stored
operator|-
name|start
operator|)
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PrivilegedActionException
name|pae
parameter_list|)
block|{
if|if
condition|(
name|pae
operator|.
name|getException
argument_list|()
operator|instanceof
name|SolrServerException
condition|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Exception while adding Document to Solr"
argument_list|,
name|representation
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|,
name|pae
operator|.
name|getException
argument_list|()
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|pae
operator|.
name|getException
argument_list|()
operator|instanceof
name|IOException
condition|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to access SolrServer"
argument_list|,
name|pae
operator|.
name|getException
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
name|RuntimeException
operator|.
name|class
operator|.
name|cast
argument_list|(
name|pae
operator|.
name|getException
argument_list|()
argument_list|)
throw|;
block|}
block|}
return|return
name|representation
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|Iterable
argument_list|<
name|Representation
argument_list|>
name|store
parameter_list|(
name|Iterable
argument_list|<
name|Representation
argument_list|>
name|representations
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|YardException
block|{
if|if
condition|(
name|representations
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Representations MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|Collection
argument_list|<
name|Representation
argument_list|>
name|added
init|=
operator|new
name|HashSet
argument_list|<
name|Representation
argument_list|>
argument_list|()
decl_stmt|;
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|SolrInputDocument
argument_list|>
name|inputDocs
init|=
operator|new
name|HashSet
argument_list|<
name|SolrInputDocument
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Representation
name|representation
range|:
name|representations
control|)
block|{
if|if
condition|(
name|representation
operator|!=
literal|null
condition|)
block|{
name|inputDocs
operator|.
name|add
argument_list|(
name|createSolrInputDocument
argument_list|(
name|representation
argument_list|)
argument_list|)
expr_stmt|;
name|added
operator|.
name|add
argument_list|(
name|representation
argument_list|)
expr_stmt|;
block|}
block|}
name|long
name|created
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|closed
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"The SolrYard '{}' was already closed!"
argument_list|,
name|config
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|UpdateRequest
name|update
init|=
operator|new
name|UpdateRequest
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|immediateCommit
condition|)
block|{
name|update
operator|.
name|setCommitWithin
argument_list|(
name|commitWithin
argument_list|)
expr_stmt|;
block|}
name|update
operator|.
name|add
argument_list|(
name|inputDocs
argument_list|)
expr_stmt|;
name|update
operator|.
name|process
argument_list|(
name|server
argument_list|)
expr_stmt|;
if|if
condition|(
name|immediateCommit
condition|)
block|{
name|server
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Exception while adding Documents to the Solr Server!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to access Solr server"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|long
name|ready
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Processed store request for %d documents in %dms (created %dms| stored%dms)"
argument_list|,
name|inputDocs
operator|.
name|size
argument_list|()
argument_list|,
name|ready
operator|-
name|start
argument_list|,
name|created
operator|-
name|start
argument_list|,
name|ready
operator|-
name|created
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|added
return|;
block|}
comment|/**      * Internally used to create Solr input documents for parsed representations.      *<p>      * This method supports boosting of fields. The boost is calculated by combining      *<ol>      *<li>the boot for the whole representation - by calling {@link #getDocumentBoost(Representation)}      *<li>the boost of each field - by using the configured {@link #fieldBoostMap}      *</ol>      *       * @param representation      *            the representation      * @return the Solr document for indexing      */
specifier|protected
specifier|final
name|SolrInputDocument
name|createSolrInputDocument
parameter_list|(
name|Representation
name|representation
parameter_list|)
block|{
name|SolrYardConfig
name|config
init|=
operator|(
name|SolrYardConfig
operator|)
name|getConfig
argument_list|()
decl_stmt|;
name|SolrInputDocument
name|inputDocument
init|=
operator|new
name|SolrInputDocument
argument_list|()
decl_stmt|;
comment|// If multiYardLayout is active, than we need to add the YardId as
comment|// domain for all added documents!
if|if
condition|(
name|config
operator|.
name|isMultiYardIndexLayout
argument_list|()
condition|)
block|{
name|inputDocument
operator|.
name|addField
argument_list|(
name|fieldMapper
operator|.
name|getDocumentDomainField
argument_list|()
argument_list|,
name|config
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// else we need to do nothing
name|inputDocument
operator|.
name|addField
argument_list|(
name|fieldMapper
operator|.
name|getDocumentIdField
argument_list|()
argument_list|,
name|representation
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
comment|// first process the document boost
name|Float
name|documentBoost
init|=
name|getDocumentBoost
argument_list|(
name|representation
argument_list|)
decl_stmt|;
comment|//NOTE: Do not use DocumentBoost, because FieldBoost will override
comment|//      document boosts and are not multiplied with with document boosts
comment|//        if(documentBoost != null){
comment|//            inputDocument.setDocumentBoost(documentBoost);
comment|//        }
for|for
control|(
name|Iterator
argument_list|<
name|String
argument_list|>
name|fields
init|=
name|representation
operator|.
name|getFieldNames
argument_list|()
init|;
name|fields
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
comment|// TODO: maybe add some functionality to prevent indexing of the
comment|// field configured as documentBoostFieldName!
comment|// But this would also prevent the possibility to intentionally
comment|// override the boost.
name|String
name|field
init|=
name|fields
operator|.
name|next
argument_list|()
decl_stmt|;
comment|/*              * With STANBOL-1027 the calculation of the boost has changed to              * consider multiple values for Representation#get(field).              */
name|float
name|baseBoost
decl_stmt|;
comment|//the boost without considering the number of values per solr field
name|Float
name|fieldBoost
init|=
name|fieldBoostMap
operator|==
literal|null
condition|?
literal|null
else|:
name|fieldBoostMap
operator|.
name|get
argument_list|(
name|field
argument_list|)
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|int
index|[]
argument_list|>
name|fieldsToBoost
decl_stmt|;
comment|//used to keep track of field we need boost
if|if
condition|(
name|fieldBoost
operator|!=
literal|null
condition|)
block|{
name|baseBoost
operator|=
name|documentBoost
operator|!=
literal|null
condition|?
name|fieldBoost
operator|*
name|documentBoost
else|:
name|fieldBoost
expr_stmt|;
name|fieldsToBoost
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|int
index|[]
argument_list|>
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|baseBoost
operator|=
operator|-
literal|1
expr_stmt|;
name|fieldsToBoost
operator|=
literal|null
expr_stmt|;
block|}
comment|//NOTE: Setting a boost requires two iteration
comment|//  (1) we add the values to the SolrInputDocument without an boost
comment|//  (2) set the boost by using doc.setField(field,doc.getFieldValues(),boost)
comment|//  Holding field values in an own map does not make sense as the SolrInputDocument
comment|//  does already exactly that (in an more efficient way)
for|for
control|(
name|Iterator
argument_list|<
name|Object
argument_list|>
name|values
init|=
name|representation
operator|.
name|get
argument_list|(
name|field
argument_list|)
init|;
name|values
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
comment|// now we need to get the indexField for the value
name|Object
name|next
init|=
name|values
operator|.
name|next
argument_list|()
decl_stmt|;
name|IndexValue
name|value
decl_stmt|;
try|try
block|{
name|value
operator|=
name|indexValueFactory
operator|.
name|createIndexValue
argument_list|(
name|next
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|fieldName
range|:
name|fieldMapper
operator|.
name|getFieldNames
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|field
argument_list|)
argument_list|,
name|value
argument_list|)
control|)
block|{
comment|//In step (1) of boosting just keep track of the field
if|if
condition|(
name|fieldBoost
operator|!=
literal|null
condition|)
block|{
comment|//wee need to boost in (2)
name|int
index|[]
name|numValues
init|=
name|fieldsToBoost
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|numValues
operator|==
literal|null
condition|)
block|{
name|numValues
operator|=
operator|new
name|int
index|[]
block|{
literal|1
block|}
expr_stmt|;
name|fieldsToBoost
operator|.
name|put
argument_list|(
name|fieldName
argument_list|,
name|numValues
argument_list|)
expr_stmt|;
comment|//the first time add the document with the baseBoost
comment|//as this will be the correct boost for single value fields
name|inputDocument
operator|.
name|addField
argument_list|(
name|fieldName
argument_list|,
name|value
operator|.
name|getValue
argument_list|()
argument_list|,
name|baseBoost
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|numValues
index|[
literal|0
index|]
operator|++
expr_stmt|;
comment|//for multi valued fields the correct boost is set in (2)
comment|//so we can add here without an boost
name|inputDocument
operator|.
name|addField
argument_list|(
name|fieldName
argument_list|,
name|value
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//add add the values without boost
name|inputDocument
operator|.
name|addField
argument_list|(
name|fieldName
argument_list|,
name|value
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|NoConverterException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unable to convert value %s (type:%s) for field %s!"
argument_list|,
name|next
argument_list|,
name|next
operator|.
name|getClass
argument_list|()
argument_list|,
name|field
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
comment|//usually because the Object is NULL or empty
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Illegal Value %s (type:%s) for field %s!"
argument_list|,
name|next
argument_list|,
name|next
operator|.
name|getClass
argument_list|()
argument_list|,
name|field
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unable to process value %s (type:%s) for field %s!"
argument_list|,
name|next
argument_list|,
name|next
operator|.
name|getClass
argument_list|()
argument_list|,
name|field
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fieldBoost
operator|!=
literal|null
condition|)
block|{
comment|//we need still to do part (2) of setting the correct boost
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|int
index|[]
argument_list|>
name|entry
range|:
name|fieldsToBoost
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|getValue
argument_list|()
index|[
literal|0
index|]
operator|>
literal|1
condition|)
block|{
comment|//adapt the boost only for multi valued fields
name|SolrInputField
name|solrField
init|=
name|inputDocument
operator|.
name|getField
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
comment|//the correct bosst is baseBoost (representing entity boost with field
comment|//boost) multiplied with the sqrt(fieldValues). The 2nd part aims to
comment|//compensate the Solr lengthNorm (1/sqrt(fieldTokens))
comment|//see STANBOL-1027 for details
name|solrField
operator|.
name|setBoost
argument_list|(
name|baseBoost
operator|*
operator|(
name|float
operator|)
name|Math
operator|.
name|sqrt
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|inputDocument
return|;
block|}
comment|/**      * Extracts the document boost from a {@link Representation}.      *       * @param representation      *            the representation      * @return the Boost or<code>null</code> if not found or lower equals zero      */
specifier|private
name|Float
name|getDocumentBoost
parameter_list|(
name|Representation
name|representation
parameter_list|)
block|{
if|if
condition|(
name|documentBoostFieldName
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Float
name|documentBoost
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|Object
argument_list|>
name|values
init|=
name|representation
operator|.
name|get
argument_list|(
name|documentBoostFieldName
argument_list|)
init|;
name|values
operator|.
name|hasNext
argument_list|()
operator|&&
name|documentBoost
operator|==
literal|null
condition|;
control|)
block|{
name|Object
name|value
init|=
name|values
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Float
condition|)
block|{
name|documentBoost
operator|=
operator|(
name|Float
operator|)
name|value
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|documentBoost
operator|=
name|Float
operator|.
name|parseFloat
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unable to parse the Document Boost from field %s=%s[type=%s] -> The Document Boost MUST BE a Float value!"
argument_list|,
name|documentBoostFieldName
argument_list|,
name|value
argument_list|,
name|value
operator|.
name|getClass
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|documentBoost
operator|==
literal|null
condition|?
literal|null
else|:
name|documentBoost
operator|>=
literal|0
condition|?
name|documentBoost
else|:
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|Representation
name|update
parameter_list|(
name|Representation
name|representation
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|NullPointerException
throws|,
name|YardException
block|{
if|if
condition|(
name|representation
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Representation MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|boolean
name|found
init|=
name|isRepresentation
argument_list|(
name|representation
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|found
condition|)
block|{
return|return
name|store
argument_list|(
name|representation
argument_list|)
return|;
comment|// there is no "update" for solr
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Parsed Representation "
operator|+
name|representation
operator|.
name|getId
argument_list|()
operator|+
literal|" in not managed by this Yard "
operator|+
name|getName
argument_list|()
operator|+
literal|"(id="
operator|+
name|getId
argument_list|()
operator|+
literal|")"
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|Iterable
argument_list|<
name|Representation
argument_list|>
name|update
parameter_list|(
name|Iterable
argument_list|<
name|Representation
argument_list|>
name|representations
parameter_list|)
throws|throws
name|YardException
throws|,
name|IllegalArgumentException
throws|,
name|NullPointerException
block|{
if|if
condition|(
name|representations
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Iterable over Representations MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|ids
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Representation
name|representation
range|:
name|representations
control|)
block|{
if|if
condition|(
name|representation
operator|!=
literal|null
condition|)
block|{
name|ids
operator|.
name|add
argument_list|(
name|representation
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|closed
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"The SolrYard '{}' was already closed!"
argument_list|,
name|config
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|int
name|numDocs
init|=
name|ids
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// for debuging
try|try
block|{
name|ids
operator|=
name|checkRepresentations
argument_list|(
name|ids
argument_list|)
expr_stmt|;
comment|// returns the ids found in the solrIndex
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Error while searching for alredy present documents before executing the actual update for the parsed Representations"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to access SolrServer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|long
name|checked
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|SolrInputDocument
argument_list|>
name|inputDocs
init|=
operator|new
name|ArrayList
argument_list|<
name|SolrInputDocument
argument_list|>
argument_list|(
name|ids
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Representation
argument_list|>
name|updated
init|=
operator|new
name|ArrayList
argument_list|<
name|Representation
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Representation
name|representation
range|:
name|representations
control|)
block|{
if|if
condition|(
name|representation
operator|!=
literal|null
operator|&&
name|ids
operator|.
name|contains
argument_list|(
name|representation
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
block|{
comment|// null parsed or not
comment|// already present
name|inputDocs
operator|.
name|add
argument_list|(
name|createSolrInputDocument
argument_list|(
name|representation
argument_list|)
argument_list|)
expr_stmt|;
name|updated
operator|.
name|add
argument_list|(
name|representation
argument_list|)
expr_stmt|;
block|}
block|}
name|long
name|created
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|inputDocs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
try|try
block|{
specifier|final
name|UpdateRequest
name|update
init|=
operator|new
name|UpdateRequest
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|immediateCommit
condition|)
block|{
name|update
operator|.
name|setCommitWithin
argument_list|(
name|commitWithin
argument_list|)
expr_stmt|;
block|}
name|update
operator|.
name|add
argument_list|(
name|inputDocs
argument_list|)
expr_stmt|;
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
specifier|public
name|UpdateResponse
name|run
parameter_list|()
throws|throws
name|IOException
throws|,
name|SolrServerException
block|{
name|update
operator|.
name|process
argument_list|(
name|server
argument_list|)
expr_stmt|;
if|if
condition|(
name|immediateCommit
condition|)
block|{
name|server
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PrivilegedActionException
name|pae
parameter_list|)
block|{
if|if
condition|(
name|pae
operator|.
name|getException
argument_list|()
operator|instanceof
name|SolrServerException
condition|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Error while adding updated Documents to the SolrServer"
argument_list|,
name|pae
operator|.
name|getException
argument_list|()
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|pae
operator|.
name|getException
argument_list|()
operator|instanceof
name|IOException
condition|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to access SolrServer"
argument_list|,
name|pae
operator|.
name|getException
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
name|RuntimeException
operator|.
name|class
operator|.
name|cast
argument_list|(
name|pae
operator|.
name|getException
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
name|long
name|ready
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Processed updateRequest for %d documents (%d in index | %d updated) in %dms (checked %dms|created %dms| stored%dms)"
argument_list|,
name|numDocs
argument_list|,
name|ids
operator|.
name|size
argument_list|()
argument_list|,
name|updated
operator|.
name|size
argument_list|()
argument_list|,
name|ready
operator|-
name|start
argument_list|,
name|checked
operator|-
name|start
argument_list|,
name|created
operator|-
name|checked
argument_list|,
name|ready
operator|-
name|created
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|updated
return|;
block|}
comment|/**      * Stores the parsed document within the Index. This Method is also used by other classes within this      * package to store configurations directly within the index      *       * @param inputDoc      *            the document to store      */
specifier|protected
specifier|final
name|void
name|storeSolrDocument
parameter_list|(
specifier|final
name|SolrInputDocument
name|inputDoc
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
try|try
block|{
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|UpdateResponse
argument_list|>
argument_list|()
block|{
specifier|public
name|UpdateResponse
name|run
parameter_list|()
throws|throws
name|IOException
throws|,
name|SolrServerException
block|{
return|return
name|server
operator|.
name|add
argument_list|(
name|inputDoc
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PrivilegedActionException
name|pae
parameter_list|)
block|{
if|if
condition|(
name|pae
operator|.
name|getException
argument_list|()
operator|instanceof
name|SolrServerException
condition|)
block|{
throw|throw
operator|(
name|SolrServerException
operator|)
name|pae
operator|.
name|getException
argument_list|()
throw|;
block|}
elseif|else
if|if
condition|(
name|pae
operator|.
name|getException
argument_list|()
operator|instanceof
name|IOException
condition|)
block|{
throw|throw
operator|(
name|IOException
operator|)
name|pae
operator|.
name|getException
argument_list|()
throw|;
block|}
else|else
block|{
throw|throw
name|RuntimeException
operator|.
name|class
operator|.
name|cast
argument_list|(
name|pae
operator|.
name|getException
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**      * Getter for a SolrDocument based on the ID. This Method is also used by other classes within this      * package to load configurations directly from the index      *       * @param inputDoc      *            the document to store      */
specifier|protected
specifier|final
name|SolrDocument
name|getSolrDocument
parameter_list|(
name|String
name|uri
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
return|return
name|getSolrDocument
argument_list|(
name|uri
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|protected
specifier|final
name|Collection
argument_list|<
name|SolrDocument
argument_list|>
name|getSolrDocuments
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|uris
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|fields
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
name|SolrYardConfig
name|config
init|=
operator|(
name|SolrYardConfig
operator|)
name|getConfig
argument_list|()
decl_stmt|;
specifier|final
name|SolrQuery
name|solrQuery
init|=
operator|new
name|SolrQuery
argument_list|()
decl_stmt|;
if|if
condition|(
name|fields
operator|==
literal|null
operator|||
name|fields
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|solrQuery
operator|.
name|addField
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
comment|// select all fields
block|}
else|else
block|{
for|for
control|(
name|String
name|field
range|:
name|fields
control|)
block|{
if|if
condition|(
name|field
operator|!=
literal|null
operator|&&
operator|!
name|field
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|solrQuery
operator|.
name|addField
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// NOTE: If there are more requested documents than allowed boolean
comment|// clauses in one query, than we need to send several requests!
name|Iterator
argument_list|<
name|String
argument_list|>
name|uriIterator
init|=
name|uris
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|int
name|maxClauses
init|=
name|config
operator|.
name|getMaxBooleanClauses
argument_list|()
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|;
name|StringBuilder
name|queryBuilder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|boolean
name|myList
init|=
literal|false
decl_stmt|;
name|Collection
argument_list|<
name|SolrDocument
argument_list|>
name|resultDocs
init|=
literal|null
decl_stmt|;
comment|// do while more uris
while|while
condition|(
name|uriIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// do while more uris and free boolean clauses
comment|// num<= maxClauses because 1-items boolean clauses in the query!
while|while
condition|(
name|uriIterator
operator|.
name|hasNext
argument_list|()
operator|&&
name|num
operator|<=
name|maxClauses
condition|)
block|{
name|String
name|uri
init|=
name|uriIterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|uri
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|num
operator|>
literal|0
condition|)
block|{
name|queryBuilder
operator|.
name|append
argument_list|(
literal|" OR "
argument_list|)
expr_stmt|;
block|}
name|queryBuilder
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"%s:%s"
argument_list|,
name|fieldMapper
operator|.
name|getDocumentIdField
argument_list|()
argument_list|,
name|SolrUtil
operator|.
name|escapeSolrSpecialChars
argument_list|(
name|uri
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|num
operator|++
expr_stmt|;
block|}
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Get SolrDocuments for Query: "
operator|+
name|queryBuilder
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// no more items or all boolean clauses used -> send a request
name|solrQuery
operator|.
name|setQuery
argument_list|(
name|queryBuilder
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|queryBuilder
operator|=
operator|new
name|StringBuilder
argument_list|()
expr_stmt|;
comment|// and a new StringBuilder
comment|// set the number of results to the number of parsed IDs.
name|solrQuery
operator|.
name|setRows
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|num
operator|=
literal|0
expr_stmt|;
comment|// reset to 0
name|QueryResponse
name|queryResponse
decl_stmt|;
try|try
block|{
name|queryResponse
operator|=
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|QueryResponse
argument_list|>
argument_list|()
block|{
specifier|public
name|QueryResponse
name|run
parameter_list|()
throws|throws
name|IOException
throws|,
name|SolrServerException
block|{
return|return
name|server
operator|.
name|query
argument_list|(
name|solrQuery
argument_list|,
name|METHOD
operator|.
name|POST
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PrivilegedActionException
name|pae
parameter_list|)
block|{
name|Exception
name|e
init|=
name|pae
operator|.
name|getException
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|SolrServerException
condition|)
block|{
throw|throw
operator|(
name|SolrServerException
operator|)
name|e
throw|;
block|}
elseif|else
if|if
condition|(
name|e
operator|instanceof
name|IOException
condition|)
block|{
throw|throw
operator|(
name|IOException
operator|)
name|e
throw|;
block|}
else|else
block|{
throw|throw
name|RuntimeException
operator|.
name|class
operator|.
name|cast
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|resultDocs
operator|==
literal|null
condition|)
block|{
name|resultDocs
operator|=
name|queryResponse
operator|.
name|getResults
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|myList
condition|)
block|{
comment|// most of the time there will be only one request, so only
comment|// create my own list when the second response is processed
name|resultDocs
operator|=
operator|new
name|ArrayList
argument_list|<
name|SolrDocument
argument_list|>
argument_list|(
name|resultDocs
argument_list|)
expr_stmt|;
name|myList
operator|=
literal|true
expr_stmt|;
block|}
name|resultDocs
operator|.
name|addAll
argument_list|(
name|queryResponse
operator|.
name|getResults
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// end while more uris
return|return
name|resultDocs
return|;
block|}
specifier|protected
specifier|final
name|SolrDocument
name|getSolrDocument
parameter_list|(
name|String
name|uri
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|fields
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
specifier|final
name|SolrQuery
name|solrQuery
init|=
operator|new
name|SolrQuery
argument_list|()
decl_stmt|;
if|if
condition|(
name|fields
operator|==
literal|null
operator|||
name|fields
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|solrQuery
operator|.
name|addField
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
comment|// select all fields
block|}
else|else
block|{
for|for
control|(
name|String
name|field
range|:
name|fields
control|)
block|{
if|if
condition|(
name|field
operator|!=
literal|null
operator|&&
operator|!
name|field
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|solrQuery
operator|.
name|addField
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|solrQuery
operator|.
name|setRows
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// we query for the id, there is only one result
name|String
name|queryString
init|=
name|String
operator|.
name|format
argument_list|(
literal|"%s:%s"
argument_list|,
name|fieldMapper
operator|.
name|getDocumentIdField
argument_list|()
argument_list|,
name|SolrUtil
operator|.
name|escapeSolrSpecialChars
argument_list|(
name|uri
argument_list|)
argument_list|)
decl_stmt|;
name|solrQuery
operator|.
name|setQuery
argument_list|(
name|queryString
argument_list|)
expr_stmt|;
name|QueryResponse
name|queryResponse
decl_stmt|;
try|try
block|{
name|queryResponse
operator|=
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|QueryResponse
argument_list|>
argument_list|()
block|{
specifier|public
name|QueryResponse
name|run
parameter_list|()
throws|throws
name|IOException
throws|,
name|SolrServerException
block|{
return|return
name|server
operator|.
name|query
argument_list|(
name|solrQuery
argument_list|,
name|METHOD
operator|.
name|POST
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PrivilegedActionException
name|pae
parameter_list|)
block|{
name|Exception
name|e
init|=
name|pae
operator|.
name|getException
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|SolrServerException
condition|)
block|{
throw|throw
operator|(
name|SolrServerException
operator|)
name|e
throw|;
block|}
elseif|else
if|if
condition|(
name|e
operator|instanceof
name|IOException
condition|)
block|{
throw|throw
operator|(
name|IOException
operator|)
name|e
throw|;
block|}
else|else
block|{
throw|throw
name|RuntimeException
operator|.
name|class
operator|.
name|cast
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|queryResponse
operator|.
name|getResults
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|queryResponse
operator|.
name|getResults
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
block|}
comment|/*      * Deprecated Constants -- moved to SolrYardConfig      */
comment|/**      * The key used to configure the URL for the SolrServer      * @deprecated use {@link SolrYardConfig#SOLR_SERVER_LOCATION} instead      */
annotation|@
name|Deprecated
specifier|public
specifier|static
specifier|final
name|String
name|SOLR_SERVER_LOCATION
init|=
name|SolrYardConfig
operator|.
name|SOLR_SERVER_LOCATION
decl_stmt|;
comment|/**      * The key used to configure if data of multiple Yards are stored within the same index (      *<code>default=false</code>)      * @deprecated use {@link SolrYardConfig#MULTI_YARD_INDEX_LAYOUT} instead      */
specifier|public
specifier|static
specifier|final
name|String
name|MULTI_YARD_INDEX_LAYOUT
init|=
name|SolrYardConfig
operator|.
name|MULTI_YARD_INDEX_LAYOUT
decl_stmt|;
comment|/**      * The maximum boolean clauses as configured in the solrconfig.xml of the SolrServer. The default value      * for this config in Solr 1.4 is 1024.      *<p>      * This value is important for generating queries that search for multiple documents, because it      * determines the maximum number of OR combination for the searched document ids.      * @deprecated use {@link SolrYardConfig#MAX_BOOLEAN_CLAUSES} instead      */
specifier|public
specifier|static
specifier|final
name|String
name|MAX_BOOLEAN_CLAUSES
init|=
name|SolrYardConfig
operator|.
name|MAX_BOOLEAN_CLAUSES
decl_stmt|;
comment|/**      * This property allows to define a field that is used to parse the boost for the parsed representation.      * Typically this will be the pageRank of that entity within the referenced site (e.g.      * {@link Math#log1p(double)} of the number of incoming links      * @deprecated use {@link SolrYardConfig#DOCUMENT_BOOST_FIELD} instead      */
specifier|public
specifier|static
specifier|final
name|String
name|DOCUMENT_BOOST_FIELD
init|=
name|SolrYardConfig
operator|.
name|DOCUMENT_BOOST_FIELD
decl_stmt|;
comment|/**      * Key used to configure {@link Entry Entry&lt;String,Float&gt;} for fields with the boost. If no Map is      * configured or a field is not present in the Map, than 1.0f is used as Boost. If a Document boost is      * present than the boost of a Field is documentBoost*fieldBoost.      * @deprecated use {@link SolrYardConfig#FIELD_BOOST_MAPPINGS} instead      */
specifier|public
specifier|static
specifier|final
name|String
name|FIELD_BOOST_MAPPINGS
init|=
name|SolrYardConfig
operator|.
name|FIELD_BOOST_MAPPINGS
decl_stmt|;
comment|/**      * Key used to to enable/disable the default configuration. If this is enabled,      * that the index will get initialised with the configuration as specified by      * the configuration name.      * @deprecated use {@link SolrYardConfig#ALLOW_INITIALISATION_STATE} instead      */
specifier|public
specifier|static
specifier|final
name|String
name|SOLR_INDEX_DEFAULT_CONFIG
init|=
name|SolrYardConfig
operator|.
name|ALLOW_INITIALISATION_STATE
decl_stmt|;
comment|/**      * By default the use of an default configuration is disabled!      * @deprecated use {@link SolrYardConfig#DEFAULT_ALLOW_INITIALISATION_STATE} instead      */
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_SOLR_INDEX_DEFAULT_CONFIG_STATE
init|=
name|SolrYardConfig
operator|.
name|DEFAULT_ALLOW_INITIALISATION_STATE
decl_stmt|;
comment|/**      * The name of the configuration use as default.       * @deprecated use {@link SolrYardConfig#DEFAULT_SOLR_INDEX_CONFIGURATION_NAME} instead      */
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_SOLR_INDEX_CONFIGURATION_NAME
init|=
name|SolrYardConfig
operator|.
name|DEFAULT_SOLR_INDEX_CONFIGURATION_NAME
decl_stmt|;
comment|/**      * Allows to configure the name of the index used for the configuration of the Solr Core.      * @deprecated use {@link SolrYardConfig#SOLR_INDEX_CONFIGURATION_NAME} instead      */
specifier|public
specifier|static
specifier|final
name|String
name|SOLR_INDEX_CONFIGURATION_NAME
init|=
name|SolrYardConfig
operator|.
name|SOLR_INDEX_CONFIGURATION_NAME
decl_stmt|;
comment|/**      * The default value for the maxBooleanClauses of SolrQueries. Set to {@value #defaultMaxBooleanClauses}      * the default of Slor 1.4      * @deprecated use {@link SolrYardConfig#DEFAULT_MAX_BOOLEAN_CLAUSES} instead      */
specifier|protected
specifier|static
specifier|final
name|int
name|defaultMaxBooleanClauses
init|=
name|SolrYardConfig
operator|.
name|DEFAULT_MAX_BOOLEAN_CLAUSES
decl_stmt|;
comment|/**      * Key used to enable/disable committing of update(..) and store(..) operations. Enabling this ensures      * that indexed documents are immediately available for searches, but it will also decrease the      * performance for updates.      * @deprecated use {@link SolrYardConfig#IMMEDIATE_COMMIT} instead      */
specifier|public
specifier|static
specifier|final
name|String
name|IMMEDIATE_COMMIT
init|=
name|SolrYardConfig
operator|.
name|IMMEDIATE_COMMIT
decl_stmt|;
comment|/**      * By default {@link #IMMEDIATE_COMMIT} is enabled      * @deprecated use {@link SolrYardConfig#DEFAULT_IMMEDIATE_COMMIT_STATE} instead      */
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_IMMEDIATE_COMMIT_STATE
init|=
name|SolrYardConfig
operator|.
name|DEFAULT_IMMEDIATE_COMMIT_STATE
decl_stmt|;
comment|/**      * If {@link #IMMEDIATE_COMMIT} is deactivated, than this time is parsed to update(..) and store(..)      * operations as the maximum time (in ms) until a commit.      * @deprecated use {@link SolrYardConfig#COMMIT_WITHIN_DURATION} instead      */
specifier|public
specifier|static
specifier|final
name|String
name|COMMIT_WITHIN_DURATION
init|=
name|SolrYardConfig
operator|.
name|COMMIT_WITHIN_DURATION
decl_stmt|;
comment|/**      * The default value for the {@link #COMMIT_WITHIN_DURATION} parameter is 10 sec.      * @deprecated use {@link SolrYardConfig#DEFAULT_COMMIT_WITHIN_DURATION} instead      */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_COMMIT_WITHIN_DURATION
init|=
name|SolrYardConfig
operator|.
name|DEFAULT_COMMIT_WITHIN_DURATION
decl_stmt|;
block|}
end_class

end_unit

