begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|yard
operator|.
name|clerezza
operator|.
name|impl
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|BNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Graph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Literal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|LiteralFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|MGraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|NonLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Triple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|TripleCollection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|UriRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|access
operator|.
name|LockableMGraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|access
operator|.
name|NoSuchEntityException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|access
operator|.
name|TcManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|impl
operator|.
name|SimpleMGraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|impl
operator|.
name|TripleImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|sparql
operator|.
name|ParseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|sparql
operator|.
name|QueryParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|sparql
operator|.
name|ResultSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|sparql
operator|.
name|SolutionMapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|sparql
operator|.
name|query
operator|.
name|Query
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|sparql
operator|.
name|query
operator|.
name|SelectQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Activate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Component
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|ConfigurationPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Deactivate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Reference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Service
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|core
operator|.
name|query
operator|.
name|QueryResultListImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|core
operator|.
name|query
operator|.
name|QueryUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|core
operator|.
name|utils
operator|.
name|AdaptingIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|core
operator|.
name|yard
operator|.
name|AbstractYard
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|core
operator|.
name|yard
operator|.
name|SimpleYardConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|model
operator|.
name|clerezza
operator|.
name|RdfRepresentation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|model
operator|.
name|clerezza
operator|.
name|RdfValueFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|model
operator|.
name|clerezza
operator|.
name|utils
operator|.
name|Resource2StringAdapter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|query
operator|.
name|clerezza
operator|.
name|RdfQueryResultList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|query
operator|.
name|clerezza
operator|.
name|SparqlFieldQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|query
operator|.
name|clerezza
operator|.
name|SparqlFieldQueryFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|query
operator|.
name|clerezza
operator|.
name|SparqlQueryUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|query
operator|.
name|clerezza
operator|.
name|SparqlQueryUtils
operator|.
name|EndpointTypeEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Representation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|rdf
operator|.
name|RdfResourceEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|FieldQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|QueryResultList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|yard
operator|.
name|Yard
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|yard
operator|.
name|YardException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|service
operator|.
name|cm
operator|.
name|ConfigurationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|service
operator|.
name|component
operator|.
name|ComponentContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Implementation of the Yard Interface based on a RDF Triple Store. This  * Implementation uses Clerezza as RDF Framework. The actual Triple Store used  * to store the data depends on the configuration of Clerezza.<p>  * This implementation uses {@link LockableMGraph} interface for write locks  * when updating the graph. SPARQL queries are not within a write lock.<p>  *  * @author Rupert Westenthaler  *  */
end_comment

begin_class
annotation|@
name|Component
argument_list|(
comment|//name="org.apache.stanbol.entityhub.yard.clerezzaYard",
comment|//factory="org.apache.stanbol.entityhub.yard.clerezzaYardFactory",
name|configurationFactory
operator|=
literal|true
argument_list|,
name|policy
operator|=
name|ConfigurationPolicy
operator|.
name|REQUIRE
argument_list|,
comment|//the ID is required!
name|specVersion
operator|=
literal|"1.1"
argument_list|,
name|metatype
operator|=
literal|true
argument_list|)
annotation|@
name|Service
comment|//@Properties(value={
comment|//        @Property(name=Yard.ID,value="entityhubYard"),
comment|//        @Property(name=Yard.NAME,value="Entityhub Yard"),
comment|//        @Property(name=Yard.DESCRIPTION,value="Default values for configuring the Entityhub Yard without editing")
comment|//})
specifier|public
class|class
name|ClerezzaYard
extends|extends
name|AbstractYard
implements|implements
name|Yard
block|{
specifier|private
specifier|static
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ClerezzaYard
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * Property used to mark empty Representations managed by this Graph. This is      * needed to workaround the fact, that the Entityhub supports the storage of      * empty Representations but this Yard uses the search for any outgoing      * relation (triple with the id of the representation as Subject) for the       * implementation of {@link #isRepresentation(String)}. Therefore for an      * empty Representation {@link #isRepresentation(String)} would return false      * even if the representation was {@link #store(Representation)} previously.      *<p>      * Adding the Triple<br>      *<code> ?representationId<{@value #MANAGED_REPRESENTATION}> true^^xsd:boolean</code>      *<br> for any empty Representation avoids this unwanted behaviour.      */
specifier|public
specifier|static
specifier|final
name|UriRef
name|MANAGED_REPRESENTATION
init|=
operator|new
name|UriRef
argument_list|(
literal|"urn:org.apache.stanbol:entityhub.yard:rdf.clerezza:managesRepresentation"
argument_list|)
decl_stmt|;
comment|/**      * The TRUE value used as object for the property {@link #MANAGED_REPRESENTATION}.      */
specifier|private
specifier|static
specifier|final
name|Literal
name|TRUE_LITERAL
init|=
name|LiteralFactory
operator|.
name|getInstance
argument_list|()
operator|.
name|createTypedLiteral
argument_list|(
name|Boolean
operator|.
name|FALSE
argument_list|)
decl_stmt|;
comment|//public static final String YARD_URI_PREFIX = "urn:org.apache.stanbol:entityhub.yard:rdf.clerezza:";
comment|//    public static final UriRef REPRESENTATION = new UriRef(RdfResourceEnum.Representation.getUri());
comment|//    protected ComponentContext context;
comment|//    protected Dictionary<String,?> properties;
annotation|@
name|Reference
specifier|private
name|TcManager
name|tcManager
decl_stmt|;
specifier|private
name|UriRef
name|yardGraphUri
decl_stmt|;
specifier|private
name|LockableMGraph
name|graph
decl_stmt|;
specifier|public
name|ClerezzaYard
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
specifier|public
name|ClerezzaYard
parameter_list|(
name|YardConfig
name|config
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|activate
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Activate
specifier|protected
specifier|final
name|void
name|activate
parameter_list|(
name|ComponentContext
name|context
parameter_list|)
throws|throws
name|ConfigurationException
block|{
name|log
operator|.
name|info
argument_list|(
literal|"in "
operator|+
name|ClerezzaYard
operator|.
name|class
operator|+
literal|" activate with context "
operator|+
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|==
literal|null
operator|||
name|context
operator|.
name|getProperties
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"No valid"
operator|+
name|ComponentContext
operator|.
name|class
operator|+
literal|" parsed in activate!"
argument_list|)
throw|;
block|}
name|activate
argument_list|(
operator|new
name|SimpleYardConfig
argument_list|(
name|context
operator|.
name|getProperties
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Internally used to activate the Yard. In case the Yard runs within a      * OSGI container it is called by the {@link #activate(ComponentContext)}      * Method. In case the Yard runs outside of an OSGI Container it is called      * by the Constructor taking the {@link YardConfig} as parameter      * @param config The configuration for the new Yard instance      * @throws IllegalArgumentException In case<code>null</code> is parsed as       * configuration or the configuration is invalid      */
specifier|private
specifier|final
name|void
name|activate
parameter_list|(
name|YardConfig
name|config
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|super
operator|.
name|activate
argument_list|(
name|RdfValueFactory
operator|.
name|getInstance
argument_list|()
argument_list|,
name|SparqlFieldQueryFactory
operator|.
name|getInstance
argument_list|()
argument_list|,
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcManager
operator|==
literal|null
condition|)
block|{
comment|//this will be the case if we are not in an OSGI environment
comment|//use the getInstance() method!
name|tcManager
operator|=
name|TcManager
operator|.
name|getInstance
argument_list|()
expr_stmt|;
block|}
name|String
name|yardUri
init|=
name|getUriPrefix
argument_list|()
decl_stmt|;
comment|//remove the "." at the last position of the prefix
name|this
operator|.
name|yardGraphUri
operator|=
operator|new
name|UriRef
argument_list|(
name|yardUri
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|yardUri
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|this
operator|.
name|graph
operator|=
name|tcManager
operator|.
name|getMGraph
argument_list|(
name|yardGraphUri
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"  ... (re)use existing Graph "
operator|+
name|yardGraphUri
operator|+
literal|" for Yard "
operator|+
name|config
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchEntityException
name|e
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"   ... create new Graph "
operator|+
name|yardGraphUri
operator|+
literal|" for Yard "
operator|+
name|config
operator|.
name|getName
argument_list|()
operator|+
literal|"!"
argument_list|)
expr_stmt|;
name|this
operator|.
name|graph
operator|=
name|tcManager
operator|.
name|createMGraph
argument_list|(
name|yardGraphUri
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Deactivate
specifier|protected
specifier|final
name|void
name|deactivate
parameter_list|(
name|ComponentContext
name|context
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"in "
operator|+
name|ClerezzaYard
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" deactivate with context "
operator|+
name|context
argument_list|)
expr_stmt|;
name|this
operator|.
name|yardGraphUri
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|graph
operator|=
literal|null
expr_stmt|;
name|super
operator|.
name|deactivate
argument_list|()
expr_stmt|;
block|}
comment|/**      * Getter for the URI used for the named graph. The returned value is      * {@link #YARD_URI_PREFIX}+{@link #getId()}.      * @return the URI used for the RDF graph that stores all the data of this      * yard.      */
specifier|public
specifier|final
name|String
name|getYardGraphUri
parameter_list|()
block|{
return|return
name|yardGraphUri
operator|.
name|getUnicodeString
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Representation
name|getRepresentation
parameter_list|(
name|String
name|id
parameter_list|)
block|{
if|if
condition|(
name|id
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed representation id MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|id
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed representation id MUST NOT be EMTPY!"
argument_list|)
throw|;
block|}
return|return
name|getRepresentation
argument_list|(
operator|new
name|UriRef
argument_list|(
name|id
argument_list|)
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Internally used to create Representations for URIs      * @param uri the uri      * @param check if<code>false</code> than there is no check if the URI      *     refers to a Resource in the graph that is of type {@link #REPRESENTATION}      * @return the Representation      */
specifier|protected
specifier|final
name|Representation
name|getRepresentation
parameter_list|(
name|UriRef
name|uri
parameter_list|,
name|boolean
name|check
parameter_list|)
block|{
name|Lock
name|readLock
init|=
name|graph
operator|.
name|getLock
argument_list|()
operator|.
name|readLock
argument_list|()
decl_stmt|;
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|check
operator|||
name|isRepresentation
argument_list|(
name|uri
argument_list|)
condition|)
block|{
name|MGraph
name|nodeGraph
init|=
name|createRepresentationGraph
argument_list|(
name|uri
argument_list|,
name|graph
argument_list|)
decl_stmt|;
comment|//Remove the triple internally used to represent an empty Representation
comment|// ... this will only remove the triple if the Representation is empty
comment|//     but a check would take longer than the this call
name|nodeGraph
operator|.
name|remove
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|uri
argument_list|,
name|MANAGED_REPRESENTATION
argument_list|,
name|TRUE_LITERAL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|RdfValueFactory
operator|)
name|getValueFactory
argument_list|()
operator|)
operator|.
name|createRdfRepresentation
argument_list|(
name|uri
argument_list|,
name|nodeGraph
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
comment|//not found
block|}
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Extracts the triples that belong to the {@link Representation} with the      * parsed id from the parsed graph. The graph is not modified and changes      * in the returned graph will not affect the parsed graph.      * @param id the {@link UriRef} node representing the id of the Representation.      * @param graph the Graph to extract the representation from      * @return the extracted graph.      */
specifier|protected
name|MGraph
name|createRepresentationGraph
parameter_list|(
name|UriRef
name|id
parameter_list|,
name|TripleCollection
name|graph
parameter_list|)
block|{
return|return
name|extractRepresentation
argument_list|(
name|graph
argument_list|,
operator|new
name|SimpleMGraph
argument_list|()
argument_list|,
name|id
argument_list|,
operator|new
name|HashSet
argument_list|<
name|BNode
argument_list|>
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Recursive Method internally doing all the work for       * {@link #createRepresentationGraph(UriRef, TripleCollection)}      * @param source The graph to extract the Representation (source)      * @param target The graph to store the extracted triples (target)      * @param node the current node. Changes in recursive calls as it follows      * @param visited holding all the visited BNodes to avoid cycles. Other nodes       * need not be added because this implementation would not follow it anyway      * outgoing relations if the object is a {@link BNode} instance.      * @return the target graph (for convenience)      */
specifier|private
name|MGraph
name|extractRepresentation
parameter_list|(
name|TripleCollection
name|source
parameter_list|,
name|MGraph
name|target
parameter_list|,
name|NonLiteral
name|node
parameter_list|,
name|Set
argument_list|<
name|BNode
argument_list|>
name|visited
parameter_list|)
block|{
comment|//we need all the outgoing relations and also want to follow bNodes until
comment|//the next UriRef. However we are not interested in incoming relations!
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|outgoing
init|=
name|source
operator|.
name|filter
argument_list|(
operator|(
name|NonLiteral
operator|)
name|node
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
while|while
condition|(
name|outgoing
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Triple
name|triple
init|=
name|outgoing
operator|.
name|next
argument_list|()
decl_stmt|;
name|target
operator|.
name|add
argument_list|(
name|triple
argument_list|)
expr_stmt|;
name|Resource
name|object
init|=
name|triple
operator|.
name|getObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|object
operator|instanceof
name|BNode
condition|)
block|{
comment|//add first and than follow because there might be a triple such as
comment|// bnode1<urn:someProperty> bnode1
name|visited
operator|.
name|add
argument_list|(
operator|(
name|BNode
operator|)
name|object
argument_list|)
expr_stmt|;
name|extractRepresentation
argument_list|(
name|source
argument_list|,
name|target
argument_list|,
operator|(
name|NonLiteral
operator|)
name|object
argument_list|,
name|visited
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|target
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isRepresentation
parameter_list|(
name|String
name|id
parameter_list|)
block|{
if|if
condition|(
name|id
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed id MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|id
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed id MUST NOT be EMPTY!"
argument_list|)
throw|;
block|}
comment|//search for any outgoing triple
return|return
name|isRepresentation
argument_list|(
operator|new
name|UriRef
argument_list|(
name|id
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Internally used to check if a URI resource represents an representation      * @param resource the resource to check      * @return the state      */
specifier|protected
specifier|final
name|boolean
name|isRepresentation
parameter_list|(
name|UriRef
name|resource
parameter_list|)
block|{
return|return
name|graph
operator|.
name|filter
argument_list|(
name|resource
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|(
name|String
name|id
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
name|id
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Representation id MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|UriRef
name|resource
init|=
operator|new
name|UriRef
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|Lock
name|writeLock
init|=
name|graph
operator|.
name|getLock
argument_list|()
operator|.
name|writeLock
argument_list|()
decl_stmt|;
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|isRepresentation
argument_list|(
name|resource
argument_list|)
condition|)
block|{
name|graph
operator|.
name|removeAll
argument_list|(
name|createRepresentationGraph
argument_list|(
name|resource
argument_list|,
name|graph
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//else not found  -> nothing to do
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|void
name|remove
parameter_list|(
name|Iterable
argument_list|<
name|String
argument_list|>
name|ids
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|YardException
block|{
if|if
condition|(
name|ids
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Iterable over the IDs to remove MUST NOT be NULL!"
argument_list|)
throw|;
block|}
for|for
control|(
name|String
name|id
range|:
name|ids
control|)
block|{
if|if
condition|(
name|id
operator|!=
literal|null
condition|)
block|{
name|remove
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
comment|//else ignore null values within the parsed Iterable
block|}
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|Representation
name|store
parameter_list|(
name|Representation
name|representation
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|YardException
block|{
if|if
condition|(
name|representation
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Representation MUST NOT be NULL!"
argument_list|)
throw|;
block|}
return|return
name|store
argument_list|(
name|representation
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|Iterable
argument_list|<
name|Representation
argument_list|>
name|store
parameter_list|(
name|Iterable
argument_list|<
name|Representation
argument_list|>
name|representations
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|YardException
block|{
if|if
condition|(
name|representations
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Iterable over the Representations to store MUST NOT be NULL!"
argument_list|)
throw|;
block|}
return|return
name|store
argument_list|(
name|representations
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|Representation
name|update
parameter_list|(
name|Representation
name|representation
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|YardException
block|{
if|if
condition|(
name|representation
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Representation MUST NOT be NULL!"
argument_list|)
throw|;
block|}
return|return
name|store
argument_list|(
name|representation
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|Iterable
argument_list|<
name|Representation
argument_list|>
name|update
parameter_list|(
name|Iterable
argument_list|<
name|Representation
argument_list|>
name|representations
parameter_list|)
throws|throws
name|YardException
throws|,
name|IllegalArgumentException
block|{
if|if
condition|(
name|representations
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Iterable over the Representations to update MUST NOT be NULL!"
argument_list|)
throw|;
block|}
return|return
name|store
argument_list|(
name|representations
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|protected
specifier|final
name|Iterable
argument_list|<
name|Representation
argument_list|>
name|store
parameter_list|(
name|Iterable
argument_list|<
name|Representation
argument_list|>
name|representations
parameter_list|,
name|boolean
name|allowCreate
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|YardException
block|{
name|ArrayList
argument_list|<
name|Representation
argument_list|>
name|added
init|=
operator|new
name|ArrayList
argument_list|<
name|Representation
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Representation
name|representation
range|:
name|representations
control|)
block|{
if|if
condition|(
name|representation
operator|!=
literal|null
condition|)
block|{
name|Representation
name|stored
init|=
name|store
argument_list|(
name|representation
argument_list|,
name|allowCreate
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|//reassign
comment|//to check if the store was successful
if|if
condition|(
name|stored
operator|!=
literal|null
condition|)
block|{
name|added
operator|.
name|add
argument_list|(
name|stored
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//can only be the case if allowCreate==false (update was called)
name|log
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unable to update Representation %s in Yard %s because it is not present!"
argument_list|,
name|representation
operator|.
name|getId
argument_list|()
argument_list|,
name|getId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|//ignore null values in the parsed Iterable!
block|}
return|return
name|added
return|;
block|}
specifier|protected
specifier|final
name|Representation
name|store
parameter_list|(
name|Representation
name|representation
parameter_list|,
name|boolean
name|allowCreate
parameter_list|,
name|boolean
name|canNotCreateIsError
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|YardException
block|{
name|log
operator|.
name|info
argument_list|(
literal|"store Representation "
operator|+
name|representation
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
comment|//        log.info("> entityhub size: "+graph.size());
if|if
condition|(
name|representation
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|isRepresentation
argument_list|(
name|representation
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
block|{
comment|//            log.info("> remove previous version");
name|remove
argument_list|(
name|representation
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
comment|//            log.info("> entityhub size: "+graph.size());
block|}
elseif|else
if|if
condition|(
operator|!
name|allowCreate
condition|)
block|{
if|if
condition|(
name|canNotCreateIsError
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Parsed Representation "
operator|+
name|representation
operator|.
name|getId
argument_list|()
operator|+
literal|" in not managed by this Yard "
operator|+
name|getName
argument_list|()
operator|+
literal|"(id="
operator|+
name|getId
argument_list|()
operator|+
literal|")"
argument_list|)
throw|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|//get the graph for the Representation and add it to the store
name|RdfRepresentation
name|toAdd
init|=
operator|(
operator|(
name|RdfValueFactory
operator|)
name|getValueFactory
argument_list|()
operator|)
operator|.
name|toRdfRepresentation
argument_list|(
name|representation
argument_list|)
decl_stmt|;
comment|//        log.info("> add "+toAdd.size()+" triples to Yard "+getId());
name|Lock
name|writeLock
init|=
name|graph
operator|.
name|getLock
argument_list|()
operator|.
name|writeLock
argument_list|()
decl_stmt|;
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|graph
operator|.
name|addAll
argument_list|(
name|toAdd
operator|.
name|getRdfGraph
argument_list|()
argument_list|)
expr_stmt|;
comment|//also add the representation type within the Representation
comment|//TODO: Note somewhere that this Triple is reserved and MUST NOT
comment|//      be used by externally.
if|if
condition|(
operator|!
name|toAdd
operator|.
name|getRdfGraph
argument_list|()
operator|.
name|filter
argument_list|(
name|toAdd
operator|.
name|getNode
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|toAdd
operator|.
name|getNode
argument_list|()
argument_list|,
name|MANAGED_REPRESENTATION
argument_list|,
name|TRUE_LITERAL
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|//        log.info("> currently "+graph.size()+" triples in Yard "+getId());
return|return
name|toAdd
return|;
block|}
annotation|@
name|Override
specifier|public
name|QueryResultList
argument_list|<
name|String
argument_list|>
name|findReferences
parameter_list|(
name|FieldQuery
name|parsedQuery
parameter_list|)
throws|throws
name|YardException
throws|,
name|IllegalArgumentException
block|{
if|if
condition|(
name|parsedQuery
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed query MUST NOT be NULL!"
argument_list|)
throw|;
block|}
specifier|final
name|SparqlFieldQuery
name|query
init|=
name|SparqlFieldQueryFactory
operator|.
name|getSparqlFieldQuery
argument_list|(
name|parsedQuery
argument_list|)
decl_stmt|;
specifier|final
name|ResultSet
name|result
init|=
name|executeSparqlFieldQuery
argument_list|(
name|query
argument_list|)
decl_stmt|;
comment|//A little bit complex construct ...
comment|// first we use the adaptingIterator to convert reseource to string
comment|// to get the resources we have to retrieve the root-variable of the
comment|// Iterator<SolutionMapping> provided by the ResultSet of the SPARQL query
name|Iterator
argument_list|<
name|String
argument_list|>
name|representationIdIterator
init|=
operator|new
name|AdaptingIterator
argument_list|<
name|Resource
argument_list|,
name|String
argument_list|>
argument_list|(
operator|new
name|Iterator
argument_list|<
name|Resource
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|result
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Resource
name|next
parameter_list|()
block|{
return|return
name|result
operator|.
name|next
argument_list|()
operator|.
name|get
argument_list|(
name|query
operator|.
name|getRootVariableName
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|result
operator|.
name|hasNext
argument_list|()
return|;
block|}
block|}
argument_list|,
operator|new
name|Resource2StringAdapter
argument_list|<
name|Resource
argument_list|>
argument_list|()
argument_list|,
name|String
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
operator|new
name|QueryResultListImpl
argument_list|<
name|String
argument_list|>
argument_list|(
name|query
argument_list|,
name|representationIdIterator
argument_list|,
name|String
operator|.
name|class
argument_list|)
return|;
block|}
comment|/**      * Returns the SPARQL result set for a given {@link SparqlFieldQuery} that      * was executed on this yard      * @param query the SparqlFieldQuery instance      * @return the results of the SPARQL query in the yard      * @throws YardException in case the generated SPARQL query could not be parsed      * or the generated Query is not an SPARQL SELECT query.      */
specifier|private
name|ResultSet
name|executeSparqlFieldQuery
parameter_list|(
specifier|final
name|SparqlFieldQuery
name|query
parameter_list|)
throws|throws
name|YardException
block|{
name|int
name|limit
init|=
name|QueryUtils
operator|.
name|getLimit
argument_list|(
name|query
argument_list|,
name|getConfig
argument_list|()
operator|.
name|getDefaultQueryResultNumber
argument_list|()
argument_list|,
name|getConfig
argument_list|()
operator|.
name|getMaxQueryResultNumber
argument_list|()
argument_list|)
decl_stmt|;
name|SelectQuery
name|sparqlQuery
decl_stmt|;
name|String
name|sparqlQueryString
init|=
name|SparqlQueryUtils
operator|.
name|createSparqlSelectQuery
argument_list|(
name|query
argument_list|,
literal|false
argument_list|,
name|limit
argument_list|,
name|EndpointTypeEnum
operator|.
name|Standard
argument_list|)
decl_stmt|;
try|try
block|{
name|sparqlQuery
operator|=
operator|(
name|SelectQuery
operator|)
name|QueryParser
operator|.
name|getInstance
argument_list|()
operator|.
name|parse
argument_list|(
name|sparqlQueryString
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"ParseException for SPARQL Query in findRepresentation"
argument_list|)
expr_stmt|;
name|log
operator|.
name|error
argument_list|(
literal|"FieldQuery: "
operator|+
name|query
argument_list|)
expr_stmt|;
name|log
operator|.
name|error
argument_list|(
literal|"SPARQL Query: "
operator|+
name|sparqlQueryString
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to parse SPARQL query generated for the parse FieldQuery"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"ClassCastExeption because parsed SPARQL Query is not of Type "
operator|+
name|SelectQuery
operator|.
name|class
argument_list|)
expr_stmt|;
name|log
operator|.
name|error
argument_list|(
literal|"FieldQuery: "
operator|+
name|query
argument_list|)
expr_stmt|;
name|log
operator|.
name|error
argument_list|(
literal|"SPARQL Query: "
operator|+
name|sparqlQueryString
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to parse SPARQL SELECT query generated for the parse FieldQuery"
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|tcManager
operator|.
name|executeSparqlQuery
argument_list|(
operator|(
name|SelectQuery
operator|)
name|sparqlQuery
argument_list|,
name|graph
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|QueryResultList
argument_list|<
name|Representation
argument_list|>
name|findRepresentation
parameter_list|(
name|FieldQuery
name|parsedQuery
parameter_list|)
throws|throws
name|YardException
throws|,
name|IllegalArgumentException
block|{
if|if
condition|(
name|parsedQuery
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed query MUST NOT be NULL!"
argument_list|)
throw|;
block|}
specifier|final
name|SparqlFieldQuery
name|query
init|=
name|SparqlFieldQueryFactory
operator|.
name|getSparqlFieldQuery
argument_list|(
name|parsedQuery
argument_list|)
decl_stmt|;
specifier|final
name|ResultSet
name|result
init|=
name|executeSparqlFieldQuery
argument_list|(
name|query
argument_list|)
decl_stmt|;
comment|//Note: An other possibility would be to first iterate over all results and add it to
comment|//      a list and create this Iterator than based on the List. This would
comment|//      be the preferenced way if changes in the graph could affect the
comment|//     Iteration over the SPARQL query results.
name|Iterator
argument_list|<
name|Representation
argument_list|>
name|representationIterator
init|=
operator|new
name|AdaptingIterator
argument_list|<
name|SolutionMapping
argument_list|,
name|Representation
argument_list|>
argument_list|(
name|result
argument_list|,
operator|new
name|AdaptingIterator
operator|.
name|Adapter
argument_list|<
name|SolutionMapping
argument_list|,
name|Representation
argument_list|>
argument_list|()
block|{
comment|/**                      * Adapter that gets the rootVariable of the Query (selecting the ID)                      * and creates a Representation for it.                      * @param solution a solution of the query                      * @param type the type (no generics here)                      * @return the representation or<code>null</code> if result is                      * not an UriRef or there is no Representation for the result.                      */
annotation|@
name|Override
specifier|public
name|Representation
name|adapt
parameter_list|(
name|SolutionMapping
name|solution
parameter_list|,
name|Class
argument_list|<
name|Representation
argument_list|>
name|type
parameter_list|)
block|{
name|Resource
name|resource
init|=
name|solution
operator|.
name|get
argument_list|(
name|query
operator|.
name|getRootVariableName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|resource
operator|instanceof
name|UriRef
condition|)
block|{
try|try
block|{
return|return
name|getRepresentation
argument_list|(
operator|(
name|UriRef
operator|)
name|resource
argument_list|,
literal|false
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to create Representation for ID "
operator|+
name|resource
operator|+
literal|"! -> ignore query result"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
block|}
argument_list|,
name|Representation
operator|.
name|class
argument_list|)
decl_stmt|;
comment|//NOTE: currently this list iterates in the constructor over all elements
comment|//      of the Iterator. This means, that all the representations are
comment|//      created before the method returns.
return|return
operator|new
name|QueryResultListImpl
argument_list|<
name|Representation
argument_list|>
argument_list|(
name|query
argument_list|,
name|representationIterator
argument_list|,
name|Representation
operator|.
name|class
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|final
name|QueryResultList
argument_list|<
name|Representation
argument_list|>
name|find
parameter_list|(
name|FieldQuery
name|parsedQuery
parameter_list|)
throws|throws
name|YardException
throws|,
name|IllegalArgumentException
block|{
if|if
condition|(
name|parsedQuery
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed query MUST NOT be NULL!"
argument_list|)
throw|;
block|}
specifier|final
name|SparqlFieldQuery
name|query
init|=
name|SparqlFieldQueryFactory
operator|.
name|getSparqlFieldQuery
argument_list|(
name|parsedQuery
argument_list|)
decl_stmt|;
name|int
name|limit
init|=
name|QueryUtils
operator|.
name|getLimit
argument_list|(
name|query
argument_list|,
name|getConfig
argument_list|()
operator|.
name|getDefaultQueryResultNumber
argument_list|()
argument_list|,
name|getConfig
argument_list|()
operator|.
name|getMaxQueryResultNumber
argument_list|()
argument_list|)
decl_stmt|;
name|Query
name|sparqlQuery
decl_stmt|;
comment|//NOTE(s):
comment|// - parse RdfResourceEnum.representationType as additional field, because
comment|//   this info is needed to correctly init the Representations
comment|// - use the endpoint type standard, because we do not know what type of
comment|//   SPARQL implementation is configured for Clerezza via OSGI
name|String
name|sparqlQueryString
init|=
name|SparqlQueryUtils
operator|.
name|createSparqlConstructQuery
argument_list|(
name|query
argument_list|,
name|limit
argument_list|,
name|EndpointTypeEnum
operator|.
name|Standard
argument_list|,
name|RdfResourceEnum
operator|.
name|signType
operator|.
name|getUri
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|sparqlQuery
operator|=
name|QueryParser
operator|.
name|getInstance
argument_list|()
operator|.
name|parse
argument_list|(
name|sparqlQueryString
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"ParseException for SPARQL Query in findRepresentation"
argument_list|)
expr_stmt|;
name|log
operator|.
name|error
argument_list|(
literal|"FieldQuery: "
operator|+
name|query
argument_list|)
expr_stmt|;
name|log
operator|.
name|error
argument_list|(
literal|"SPARQL Query: "
operator|+
name|sparqlQueryString
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to parse SPARQL query generated for the parse FieldQuery"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|Object
name|resultObject
init|=
name|tcManager
operator|.
name|executeSparqlQuery
argument_list|(
name|sparqlQuery
argument_list|,
name|graph
argument_list|)
decl_stmt|;
specifier|final
name|MGraph
name|resultGraph
decl_stmt|;
if|if
condition|(
name|resultObject
operator|instanceof
name|MGraph
condition|)
block|{
name|resultGraph
operator|=
operator|(
name|MGraph
operator|)
name|resultObject
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|resultObject
operator|instanceof
name|Graph
condition|)
block|{
name|resultGraph
operator|=
operator|new
name|SimpleMGraph
argument_list|()
expr_stmt|;
name|resultGraph
operator|.
name|addAll
argument_list|(
operator|(
name|Graph
operator|)
name|resultObject
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Unable to create "
operator|+
name|MGraph
operator|.
name|class
operator|+
literal|" instance for query reults of type "
operator|+
name|resultObject
operator|.
name|getClass
argument_list|()
operator|+
literal|" (this indicates that the used SPARQL Query was not of type CONSTRUCT)"
argument_list|)
expr_stmt|;
name|log
operator|.
name|error
argument_list|(
literal|"FieldQuery: "
operator|+
name|query
argument_list|)
expr_stmt|;
name|log
operator|.
name|error
argument_list|(
literal|"SPARQL Query: "
operator|+
name|sparqlQueryString
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to process results of Query"
argument_list|)
throw|;
block|}
return|return
operator|new
name|RdfQueryResultList
argument_list|(
name|query
argument_list|,
name|resultGraph
argument_list|)
return|;
block|}
block|}
end_class

end_unit

