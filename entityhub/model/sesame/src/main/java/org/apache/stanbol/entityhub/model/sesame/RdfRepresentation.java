begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|model
operator|.
name|sesame
package|;
end_package

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|datatype
operator|.
name|Duration
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|datatype
operator|.
name|XMLGregorianCalendar
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|collections
operator|.
name|IteratorUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|collections
operator|.
name|Transformer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|defaults
operator|.
name|DataTypeEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Reference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Representation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|UnsupportedTypeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|util
operator|.
name|ModelUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|openrdf
operator|.
name|model
operator|.
name|BNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|openrdf
operator|.
name|model
operator|.
name|Literal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|openrdf
operator|.
name|model
operator|.
name|Model
import|;
end_import

begin_import
import|import
name|org
operator|.
name|openrdf
operator|.
name|model
operator|.
name|Statement
import|;
end_import

begin_import
import|import
name|org
operator|.
name|openrdf
operator|.
name|model
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|org
operator|.
name|openrdf
operator|.
name|model
operator|.
name|Value
import|;
end_import

begin_import
import|import
name|org
operator|.
name|openrdf
operator|.
name|model
operator|.
name|datatypes
operator|.
name|XMLDatatypeUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|openrdf
operator|.
name|model
operator|.
name|vocabulary
operator|.
name|XMLSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|openrdf
operator|.
name|repository
operator|.
name|RepositoryException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * A {@link Representation} implementation backed by a Sesame {@link Model}  * @author Rupert Westenthaler  */
end_comment

begin_class
specifier|public
class|class
name|RdfRepresentation
implements|implements
name|Representation
implements|,
name|RdfWrapper
block|{
specifier|private
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|RdfRepresentation
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
name|URI
name|subject
decl_stmt|;
specifier|private
specifier|final
name|Model
name|model
decl_stmt|;
specifier|private
specifier|final
name|RdfValueFactory
name|factory
decl_stmt|;
specifier|private
specifier|final
name|org
operator|.
name|openrdf
operator|.
name|model
operator|.
name|ValueFactory
name|sesameFactory
decl_stmt|;
comment|/**      * Emits {@link Statement#getObject()}      */
specifier|protected
name|Transformer
name|objectTransFormer
init|=
operator|new
name|Transformer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Value
name|transform
parameter_list|(
name|Object
name|input
parameter_list|)
block|{
return|return
operator|(
operator|(
name|Statement
operator|)
name|input
operator|)
operator|.
name|getObject
argument_list|()
return|;
block|}
block|}
decl_stmt|;
comment|/**      * Emits {@link Value#stringValue()}      */
specifier|protected
name|Transformer
name|stringTransformer
init|=
operator|new
name|Transformer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|transform
parameter_list|(
name|Object
name|input
parameter_list|)
block|{
return|return
operator|(
operator|(
name|Value
operator|)
name|input
operator|)
operator|.
name|stringValue
argument_list|()
return|;
block|}
block|}
decl_stmt|;
comment|/**      * A {@link Value} to {@link Object} transformer intended to be used for      * {@link IteratorUtils#transformedIterator(Iterator, Transformer)} to      * convert       */
specifier|protected
name|Transformer
name|sesameTransformer
init|=
operator|new
name|Transformer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|transform
parameter_list|(
name|Object
name|input
parameter_list|)
block|{
if|if
condition|(
name|input
operator|instanceof
name|Value
condition|)
block|{
name|Value
name|sesameValue
init|=
operator|(
name|Value
operator|)
name|input
decl_stmt|;
if|if
condition|(
name|sesameValue
operator|instanceof
name|URI
condition|)
block|{
return|return
operator|new
name|RdfReference
argument_list|(
operator|(
name|URI
operator|)
name|sesameValue
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|sesameValue
operator|instanceof
name|Literal
condition|)
block|{
name|Literal
name|literal
init|=
operator|(
name|Literal
operator|)
name|sesameValue
decl_stmt|;
if|if
condition|(
name|literal
operator|.
name|getDatatype
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|//TODO: adapt to RDF1.1
return|return
operator|new
name|RdfText
argument_list|(
name|literal
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|transformTypedLiteral
argument_list|(
name|literal
argument_list|)
return|;
block|}
block|}
else|else
block|{
return|return
operator|new
name|RdfBNode
argument_list|(
operator|(
name|BNode
operator|)
name|sesameValue
argument_list|)
return|;
block|}
block|}
else|else
block|{
comment|//do not transform objects of other types (incl. null)
return|return
name|input
return|;
block|}
block|}
block|}
decl_stmt|;
comment|/**      * Transforms typed literals with datatype {@link XMLSchema#STRING} to      * {@link Text} instances as required by some {@link Representation}      * methods. This transformer is usually used in front of the      * {@link #sesameTransformer}.      */
specifier|protected
name|Transformer
name|stringLiteral2TextTransformer
init|=
operator|new
name|Transformer
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|transform
parameter_list|(
name|Object
name|input
parameter_list|)
block|{
if|if
condition|(
name|input
operator|instanceof
name|Literal
operator|&&
name|XMLSchema
operator|.
name|STRING
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|Literal
operator|)
name|input
operator|)
operator|.
name|getDatatype
argument_list|()
argument_list|)
condition|)
block|{
return|return
operator|new
name|RdfText
argument_list|(
operator|(
name|Literal
operator|)
name|input
argument_list|)
return|;
block|}
return|return
name|input
return|;
block|}
block|}
decl_stmt|;
comment|/**      * Creates a {@link Representation} for the parsed subject. Data will be      * added to the model.      * @param subject the subject      * @param model the model      * @param factory the factory      */
specifier|protected
name|RdfRepresentation
parameter_list|(
name|URI
name|subject
parameter_list|,
name|Model
name|model
parameter_list|,
name|RdfValueFactory
name|factory
parameter_list|)
block|{
name|this
operator|.
name|subject
operator|=
name|subject
expr_stmt|;
name|this
operator|.
name|model
operator|=
name|model
expr_stmt|;
name|this
operator|.
name|factory
operator|=
name|factory
expr_stmt|;
name|this
operator|.
name|sesameFactory
operator|=
name|factory
operator|.
name|getSesameFactory
argument_list|()
expr_stmt|;
block|}
comment|/**      * Transforms a typed literal to the according java type.      * @param literal      * @return      */
specifier|protected
name|Object
name|transformTypedLiteral
parameter_list|(
name|Literal
name|literal
parameter_list|)
block|{
name|URI
name|dataType
init|=
name|literal
operator|.
name|getDatatype
argument_list|()
decl_stmt|;
if|if
condition|(
name|XMLSchema
operator|.
name|INT
operator|.
name|equals
argument_list|(
name|dataType
argument_list|)
condition|)
block|{
return|return
name|literal
operator|.
name|intValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|XMLSchema
operator|.
name|LONG
operator|.
name|equals
argument_list|(
name|dataType
argument_list|)
condition|)
block|{
return|return
name|literal
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|XMLSchema
operator|.
name|FLOAT
operator|.
name|equals
argument_list|(
name|dataType
argument_list|)
condition|)
block|{
return|return
name|literal
operator|.
name|floatValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|XMLSchema
operator|.
name|DOUBLE
operator|.
name|equals
argument_list|(
name|dataType
argument_list|)
condition|)
block|{
return|return
name|literal
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|XMLSchema
operator|.
name|BOOLEAN
operator|.
name|equals
argument_list|(
name|dataType
argument_list|)
condition|)
block|{
return|return
name|literal
operator|.
name|booleanValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|XMLSchema
operator|.
name|INTEGER
operator|.
name|equals
argument_list|(
name|dataType
argument_list|)
condition|)
block|{
return|return
name|literal
operator|.
name|integerValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|XMLSchema
operator|.
name|DECIMAL
operator|.
name|equals
argument_list|(
name|dataType
argument_list|)
condition|)
block|{
return|return
name|literal
operator|.
name|decimalValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|XMLSchema
operator|.
name|STRING
operator|.
name|equals
argument_list|(
name|dataType
argument_list|)
condition|)
block|{
comment|//explicit handle string
comment|//to avoid going to a lot of equals checks
return|return
name|literal
operator|.
name|stringValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|XMLDatatypeUtil
operator|.
name|isCalendarDatatype
argument_list|(
name|dataType
argument_list|)
condition|)
block|{
return|return
name|literal
operator|.
name|calendarValue
argument_list|()
operator|.
name|toGregorianCalendar
argument_list|()
operator|.
name|getTime
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|XMLSchema
operator|.
name|BYTE
operator|.
name|equals
argument_list|(
name|dataType
argument_list|)
condition|)
block|{
return|return
name|literal
operator|.
name|byteValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|XMLSchema
operator|.
name|SHORT
operator|.
name|equals
argument_list|(
name|dataType
argument_list|)
condition|)
block|{
return|return
name|literal
operator|.
name|shortValue
argument_list|()
return|;
comment|//Start with the more exotic types at the end (for performance reasons)
block|}
elseif|else
if|if
condition|(
name|XMLSchema
operator|.
name|NON_NEGATIVE_INTEGER
operator|.
name|equals
argument_list|(
name|dataType
argument_list|)
operator|||
name|XMLSchema
operator|.
name|NON_POSITIVE_INTEGER
operator|.
name|equals
argument_list|(
name|dataType
argument_list|)
operator|||
name|XMLSchema
operator|.
name|NEGATIVE_INTEGER
operator|.
name|equals
argument_list|(
name|dataType
argument_list|)
operator|||
name|XMLSchema
operator|.
name|POSITIVE_INTEGER
operator|.
name|equals
argument_list|(
name|dataType
argument_list|)
condition|)
block|{
return|return
name|literal
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|XMLSchema
operator|.
name|GDAY
operator|.
name|equals
argument_list|(
name|dataType
argument_list|)
operator|||
name|XMLSchema
operator|.
name|GMONTH
operator|.
name|equals
argument_list|(
name|dataType
argument_list|)
operator|||
name|XMLSchema
operator|.
name|GMONTHDAY
operator|.
name|equals
argument_list|(
name|dataType
argument_list|)
operator|||
name|XMLSchema
operator|.
name|GYEAR
operator|.
name|equals
argument_list|(
name|dataType
argument_list|)
operator|||
name|XMLSchema
operator|.
name|GYEARMONTH
operator|.
name|equals
argument_list|(
name|dataType
argument_list|)
condition|)
block|{
return|return
name|literal
operator|.
name|calendarValue
argument_list|()
operator|.
name|toGregorianCalendar
argument_list|()
operator|.
name|getTime
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|XMLSchema
operator|.
name|UNSIGNED_BYTE
operator|.
name|equals
argument_list|(
name|dataType
argument_list|)
condition|)
block|{
return|return
name|literal
operator|.
name|shortValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|XMLSchema
operator|.
name|UNSIGNED_SHORT
operator|.
name|equals
argument_list|(
name|dataType
argument_list|)
condition|)
block|{
return|return
name|literal
operator|.
name|intValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|XMLSchema
operator|.
name|UNSIGNED_INT
operator|.
name|equals
argument_list|(
name|dataType
argument_list|)
condition|)
block|{
return|return
name|literal
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|literal
operator|.
name|stringValue
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|add
parameter_list|(
name|String
name|field
parameter_list|,
name|Object
name|value
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
name|field
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field MUST NOT be NULL"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field MUST NOT be Empty"
argument_list|)
throw|;
block|}
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"NULL values are not supported by Representations"
argument_list|)
throw|;
block|}
name|URI
name|property
init|=
name|sesameFactory
operator|.
name|createURI
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|Object
argument_list|>
name|values
init|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
comment|//process the parsed value with the Utility Method ->
comment|// this converts Objects as defined in the specification
name|ModelUtils
operator|.
name|checkValues
argument_list|(
name|factory
argument_list|,
name|value
argument_list|,
name|values
argument_list|)
expr_stmt|;
comment|//We still need to implement support for specific types supported by this implementation
for|for
control|(
name|Object
name|current
range|:
name|values
control|)
block|{
if|if
condition|(
name|current
operator|instanceof
name|Value
condition|)
block|{
comment|//native support for Sesame types!
name|addValue
argument_list|(
name|property
argument_list|,
operator|(
name|Value
operator|)
name|current
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current
operator|instanceof
name|RdfWrapper
condition|)
block|{
comment|//for Sesame RDF wrapper we can directly use the Value
name|addValue
argument_list|(
name|property
argument_list|,
operator|(
operator|(
name|RdfWrapper
operator|)
name|current
operator|)
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current
operator|instanceof
name|Reference
condition|)
block|{
name|addValue
argument_list|(
name|property
argument_list|,
name|sesameFactory
operator|.
name|createURI
argument_list|(
operator|(
operator|(
name|Reference
operator|)
name|current
operator|)
operator|.
name|getReference
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current
operator|instanceof
name|Text
condition|)
block|{
name|addValue
argument_list|(
name|property
argument_list|,
name|sesameFactory
operator|.
name|createLiteral
argument_list|(
operator|(
operator|(
name|Text
operator|)
name|current
operator|)
operator|.
name|getText
argument_list|()
argument_list|,
operator|(
operator|(
name|Text
operator|)
name|current
operator|)
operator|.
name|getLanguage
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//else add an typed Literal!
name|addValue
argument_list|(
name|property
argument_list|,
name|createTypedLiteral
argument_list|(
name|current
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Converts a Java object to a Sesame typed Literal      * @param value the java value      * @return the Sesame literal      * @throws IllegalArgumentException it the parsed object could not be      * converted to a Sesame typed literal      */
specifier|private
name|Literal
name|createTypedLiteral
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
specifier|final
name|Literal
name|literal
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Number
condition|)
block|{
name|Number
name|n
init|=
operator|(
name|Number
operator|)
name|value
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Integer
condition|)
block|{
name|literal
operator|=
name|sesameFactory
operator|.
name|createLiteral
argument_list|(
name|n
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Float
condition|)
block|{
name|literal
operator|=
name|sesameFactory
operator|.
name|createLiteral
argument_list|(
name|n
operator|.
name|floatValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Long
condition|)
block|{
name|literal
operator|=
name|sesameFactory
operator|.
name|createLiteral
argument_list|(
name|n
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Double
condition|)
block|{
name|literal
operator|=
name|sesameFactory
operator|.
name|createLiteral
argument_list|(
name|n
operator|.
name|doubleValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Short
condition|)
block|{
name|literal
operator|=
name|sesameFactory
operator|.
name|createLiteral
argument_list|(
name|n
operator|.
name|shortValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Byte
condition|)
block|{
name|literal
operator|=
name|sesameFactory
operator|.
name|createLiteral
argument_list|(
name|n
operator|.
name|byteValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|literal
operator|=
literal|null
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Boolean
condition|)
block|{
name|literal
operator|=
name|sesameFactory
operator|.
name|createLiteral
argument_list|(
operator|(
operator|(
name|Boolean
operator|)
name|value
operator|)
operator|.
name|booleanValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Date
condition|)
block|{
name|literal
operator|=
name|sesameFactory
operator|.
name|createLiteral
argument_list|(
operator|(
name|Date
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|BigInteger
condition|)
block|{
name|literal
operator|=
name|sesameFactory
operator|.
name|createLiteral
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|,
name|DataTypeEnum
operator|.
name|Integer
operator|.
name|getUri
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|BigDecimal
condition|)
block|{
name|literal
operator|=
name|sesameFactory
operator|.
name|createLiteral
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|,
name|DataTypeEnum
operator|.
name|Decimal
operator|.
name|getUri
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|XMLGregorianCalendar
condition|)
block|{
name|literal
operator|=
name|sesameFactory
operator|.
name|createLiteral
argument_list|(
operator|(
name|XMLGregorianCalendar
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Duration
condition|)
block|{
name|literal
operator|=
name|sesameFactory
operator|.
name|createLiteral
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|,
name|XMLSchema
operator|.
name|DURATION
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|String
condition|)
block|{
comment|//String type literals
name|literal
operator|=
name|sesameFactory
operator|.
name|createLiteral
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|,
name|XMLSchema
operator|.
name|STRING
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|literal
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|literal
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unable to convert value '"
operator|+
name|value
operator|+
literal|"' to a Sesame typed literal because the java type "
operator|+
name|value
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" can not be mapped to an "
operator|+
literal|"XML DataType."
argument_list|)
throw|;
block|}
return|return
name|literal
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|addNaturalText
parameter_list|(
name|String
name|field
parameter_list|,
name|String
name|text
parameter_list|,
name|String
modifier|...
name|languages
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
name|field
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field MUST NOT be NULL"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field MUST NOT be Empty"
argument_list|)
throw|;
block|}
if|if
condition|(
name|text
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"NULL values are not supported by Representations"
argument_list|)
throw|;
block|}
name|URI
name|property
init|=
name|sesameFactory
operator|.
name|createURI
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|languages
operator|==
literal|null
operator|||
name|languages
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|languages
operator|=
operator|new
name|String
index|[]
block|{
literal|null
block|}
expr_stmt|;
block|}
for|for
control|(
name|String
name|language
range|:
name|languages
control|)
block|{
name|Literal
name|value
init|=
name|sesameFactory
operator|.
name|createLiteral
argument_list|(
name|text
argument_list|,
name|language
argument_list|)
decl_stmt|;
name|addValue
argument_list|(
name|property
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|addReference
parameter_list|(
name|String
name|field
parameter_list|,
name|String
name|reference
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
name|field
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field MUST NOT be NULL"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field MUST NOT be Empty"
argument_list|)
throw|;
block|}
if|if
condition|(
name|reference
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"NULL values are not supported by Representations"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|reference
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"References MUST NOT be empty!"
argument_list|)
throw|;
block|}
name|addValue
argument_list|(
name|sesameFactory
operator|.
name|createURI
argument_list|(
name|field
argument_list|)
argument_list|,
name|sesameFactory
operator|.
name|createURI
argument_list|(
name|reference
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Adds a value to a property and handles a possible       * {@link RepositoryException} while doing so      * @param property      * @param value      * @throws IllegalStateException in case of a {@link RepositoryException}      * while adding the value.      */
specifier|private
name|void
name|addValue
parameter_list|(
name|URI
name|property
parameter_list|,
name|Value
name|value
parameter_list|)
block|{
name|model
operator|.
name|add
argument_list|(
name|subject
argument_list|,
name|property
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|Iterator
argument_list|<
name|Object
argument_list|>
name|get
parameter_list|(
name|String
name|field
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
name|field
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field MUST NOT be NULL"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field MUST NOT be Empty"
argument_list|)
throw|;
block|}
name|URI
name|property
init|=
name|sesameFactory
operator|.
name|createURI
argument_list|(
name|field
argument_list|)
decl_stmt|;
return|return
name|IteratorUtils
operator|.
name|transformedIterator
argument_list|(
name|IteratorUtils
operator|.
name|transformedIterator
argument_list|(
name|model
operator|.
name|filter
argument_list|(
name|subject
argument_list|,
name|property
argument_list|,
literal|null
argument_list|)
operator|.
name|iterator
argument_list|()
argument_list|,
name|objectTransFormer
argument_list|)
argument_list|,
comment|// get the object from the statement
name|sesameTransformer
argument_list|)
return|;
comment|// transform the values
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|Iterator
argument_list|<
name|T
argument_list|>
name|get
parameter_list|(
name|String
name|field
parameter_list|,
specifier|final
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
throws|throws
name|UnsupportedTypeException
block|{
if|if
condition|(
name|field
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field MUST NOT be NULL"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field MUST NOT be Empty"
argument_list|)
throw|;
block|}
name|URI
name|property
init|=
name|sesameFactory
operator|.
name|createURI
argument_list|(
name|field
argument_list|)
decl_stmt|;
comment|//filter for values that are compatible with the parsed type
name|Iterator
argument_list|<
name|?
argument_list|>
name|iterator
init|=
name|IteratorUtils
operator|.
name|filteredIterator
argument_list|(
name|IteratorUtils
operator|.
name|transformedIterator
argument_list|(
name|model
operator|.
name|filter
argument_list|(
name|subject
argument_list|,
name|property
argument_list|,
literal|null
argument_list|)
operator|.
name|iterator
argument_list|()
argument_list|,
name|objectTransFormer
argument_list|)
argument_list|,
comment|// get the object from the statement
operator|new
name|ValueTypeFilter
argument_list|<
name|T
argument_list|>
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Value
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|//if the requested type is not a Sesame value, we need also to
comment|//transform results
name|iterator
operator|=
name|IteratorUtils
operator|.
name|transformedIterator
argument_list|(
name|iterator
argument_list|,
comment|// the already filtered values
name|sesameTransformer
argument_list|)
expr_stmt|;
comment|// need to be transformed
block|}
return|return
operator|(
name|Iterator
argument_list|<
name|T
argument_list|>
operator|)
name|iterator
return|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|Iterator
argument_list|<
name|Text
argument_list|>
name|get
parameter_list|(
name|String
name|field
parameter_list|,
name|String
modifier|...
name|languages
parameter_list|)
block|{
if|if
condition|(
name|field
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field MUST NOT be NULL"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field MUST NOT be Empty"
argument_list|)
throw|;
block|}
name|URI
name|property
init|=
name|sesameFactory
operator|.
name|createURI
argument_list|(
name|field
argument_list|)
decl_stmt|;
return|return
name|IteratorUtils
operator|.
name|transformedIterator
argument_list|(
name|IteratorUtils
operator|.
name|transformedIterator
argument_list|(
name|IteratorUtils
operator|.
name|filteredIterator
argument_list|(
name|IteratorUtils
operator|.
name|transformedIterator
argument_list|(
name|model
operator|.
name|filter
argument_list|(
name|subject
argument_list|,
name|property
argument_list|,
literal|null
argument_list|)
operator|.
name|iterator
argument_list|()
argument_list|,
name|objectTransFormer
argument_list|)
argument_list|,
comment|// get the object from the statement
operator|new
name|ValueTypeFilter
argument_list|<
name|Text
argument_list|>
argument_list|(
name|languages
argument_list|)
argument_list|)
argument_list|,
comment|//filter languages
name|stringLiteral2TextTransformer
argument_list|)
argument_list|,
comment|//transform strings to Text
name|sesameTransformer
argument_list|)
return|;
comment|//transform to Text instances
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|Iterator
argument_list|<
name|String
argument_list|>
name|getFieldNames
parameter_list|()
block|{
return|return
operator|(
name|Iterator
argument_list|<
name|String
argument_list|>
operator|)
name|IteratorUtils
operator|.
name|transformedIterator
argument_list|(
name|model
operator|.
name|predicates
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|,
name|stringTransformer
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getFirst
parameter_list|(
name|String
name|field
parameter_list|)
block|{
if|if
condition|(
name|field
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field MUST NOT be NULL"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field MUST NOT be Empty"
argument_list|)
throw|;
block|}
name|Iterator
argument_list|<
name|Object
argument_list|>
name|it
init|=
name|get
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
return|return
name|it
operator|.
name|next
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|getFirst
parameter_list|(
name|String
name|field
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
throws|throws
name|UnsupportedTypeException
block|{
if|if
condition|(
name|field
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field MUST NOT be NULL"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field MUST NOT be Empty"
argument_list|)
throw|;
block|}
name|Iterator
argument_list|<
name|T
argument_list|>
name|it
init|=
name|get
argument_list|(
name|field
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
return|return
name|it
operator|.
name|next
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Text
name|getFirst
parameter_list|(
name|String
name|field
parameter_list|,
name|String
modifier|...
name|languages
parameter_list|)
block|{
if|if
condition|(
name|field
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field MUST NOT be NULL"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field MUST NOT be Empty"
argument_list|)
throw|;
block|}
if|if
condition|(
name|languages
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"NULL parsed as languages -> replacing with \"new String []{null}\""
operator|+
literal|" -> assuming a missing explicit cast to (String) in the var arg"
argument_list|)
expr_stmt|;
name|languages
operator|=
operator|new
name|String
index|[]
block|{
literal|null
block|}
expr_stmt|;
block|}
name|Iterator
argument_list|<
name|Text
argument_list|>
name|it
init|=
name|get
argument_list|(
name|field
argument_list|,
name|languages
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
return|return
name|it
operator|.
name|next
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Reference
name|getFirstReference
parameter_list|(
name|String
name|field
parameter_list|)
block|{
if|if
condition|(
name|field
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field MUST NOT be NULL"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field MUST NOT be Empty"
argument_list|)
throw|;
block|}
name|Iterator
argument_list|<
name|Reference
argument_list|>
name|it
init|=
name|getReferences
argument_list|(
name|field
argument_list|)
decl_stmt|;
return|return
name|it
operator|.
name|hasNext
argument_list|()
condition|?
name|it
operator|.
name|next
argument_list|()
else|:
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getId
parameter_list|()
block|{
return|return
name|subject
operator|.
name|stringValue
argument_list|()
return|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|Iterator
argument_list|<
name|Reference
argument_list|>
name|getReferences
parameter_list|(
name|String
name|field
parameter_list|)
block|{
if|if
condition|(
name|field
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field MUST NOT be NULL"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field MUST NOT be Empty"
argument_list|)
throw|;
block|}
name|URI
name|property
init|=
name|sesameFactory
operator|.
name|createURI
argument_list|(
name|field
argument_list|)
decl_stmt|;
return|return
name|IteratorUtils
operator|.
name|transformedIterator
argument_list|(
name|IteratorUtils
operator|.
name|filteredIterator
argument_list|(
name|IteratorUtils
operator|.
name|transformedIterator
argument_list|(
name|model
operator|.
name|filter
argument_list|(
name|subject
argument_list|,
name|property
argument_list|,
literal|null
argument_list|)
operator|.
name|iterator
argument_list|()
argument_list|,
name|objectTransFormer
argument_list|)
argument_list|,
comment|// get the object from the statement
operator|new
name|ValueTypeFilter
argument_list|<
name|Reference
argument_list|>
argument_list|(
name|Reference
operator|.
name|class
argument_list|)
argument_list|)
argument_list|,
comment|//filter references
name|sesameTransformer
argument_list|)
return|;
comment|//transform to Text instances
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|Iterator
argument_list|<
name|Text
argument_list|>
name|getText
parameter_list|(
name|String
name|field
parameter_list|)
block|{
if|if
condition|(
name|field
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field MUST NOT be NULL"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field MUST NOT be Empty"
argument_list|)
throw|;
block|}
name|URI
name|property
init|=
name|sesameFactory
operator|.
name|createURI
argument_list|(
name|field
argument_list|)
decl_stmt|;
return|return
name|IteratorUtils
operator|.
name|transformedIterator
argument_list|(
name|IteratorUtils
operator|.
name|transformedIterator
argument_list|(
name|IteratorUtils
operator|.
name|filteredIterator
argument_list|(
name|IteratorUtils
operator|.
name|transformedIterator
argument_list|(
name|model
operator|.
name|filter
argument_list|(
name|subject
argument_list|,
name|property
argument_list|,
literal|null
argument_list|)
operator|.
name|iterator
argument_list|()
argument_list|,
name|objectTransFormer
argument_list|)
argument_list|,
comment|// get the object from the statement
operator|new
name|ValueTypeFilter
argument_list|<
name|Text
argument_list|>
argument_list|(
name|Text
operator|.
name|class
argument_list|)
argument_list|)
argument_list|,
comment|//filter plain literals
name|stringLiteral2TextTransformer
argument_list|)
argument_list|,
name|sesameTransformer
argument_list|)
return|;
comment|//transform to Text instances
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|(
name|String
name|field
parameter_list|,
name|Object
name|parsedValue
parameter_list|)
block|{
if|if
condition|(
name|field
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field MUST NOT be NULL"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field MUST NOT be Empty"
argument_list|)
throw|;
block|}
if|if
condition|(
name|parsedValue
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"NULL parsed as value in remove method for symbol "
operator|+
name|getId
argument_list|()
operator|+
literal|" and field "
operator|+
name|field
operator|+
literal|" -> call ignored"
argument_list|)
expr_stmt|;
return|return;
block|}
name|URI
name|property
init|=
name|sesameFactory
operator|.
name|createURI
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|Object
argument_list|>
name|values
init|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|ModelUtils
operator|.
name|checkValues
argument_list|(
name|factory
argument_list|,
name|parsedValue
argument_list|,
name|values
argument_list|)
expr_stmt|;
for|for
control|(
name|Object
name|value
range|:
name|values
control|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Value
condition|)
block|{
comment|//native support for Sesame types!
name|removeValue
argument_list|(
name|property
argument_list|,
operator|(
name|Value
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|RdfWrapper
condition|)
block|{
comment|//for Sesame RDF wrapper we can directly use the Value
name|removeValue
argument_list|(
name|property
argument_list|,
operator|(
operator|(
name|RdfWrapper
operator|)
name|value
operator|)
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Reference
condition|)
block|{
name|removeValue
argument_list|(
name|property
argument_list|,
name|sesameFactory
operator|.
name|createURI
argument_list|(
operator|(
operator|(
name|Reference
operator|)
name|value
operator|)
operator|.
name|getReference
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Text
condition|)
block|{
name|removeValue
argument_list|(
name|property
argument_list|,
name|sesameFactory
operator|.
name|createLiteral
argument_list|(
operator|(
operator|(
name|Text
operator|)
name|value
operator|)
operator|.
name|getText
argument_list|()
argument_list|,
operator|(
operator|(
name|Text
operator|)
name|value
operator|)
operator|.
name|getLanguage
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//else add an typed Literal!
name|removeValue
argument_list|(
name|property
argument_list|,
name|createTypedLiteral
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Removes the value from the parsed property      * @param property      * @param value      */
specifier|private
name|boolean
name|removeValue
parameter_list|(
name|URI
name|property
parameter_list|,
name|Value
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
return|return
name|model
operator|.
name|remove
argument_list|(
name|subject
argument_list|,
name|property
argument_list|,
name|value
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeAll
parameter_list|(
name|String
name|field
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
name|field
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field MUST NOT be NULL"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field MUST NOT be Empty"
argument_list|)
throw|;
block|}
name|model
operator|.
name|remove
argument_list|(
name|subject
argument_list|,
name|sesameFactory
operator|.
name|createURI
argument_list|(
name|field
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeAllNaturalText
parameter_list|(
name|String
name|field
parameter_list|,
name|String
modifier|...
name|languages
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
name|field
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field MUST NOT be NULL"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field MUST NOT be Empty"
argument_list|)
throw|;
block|}
name|ValueTypeFilter
argument_list|<
name|Literal
argument_list|>
name|vtf
init|=
operator|new
name|ValueTypeFilter
argument_list|<
name|Literal
argument_list|>
argument_list|(
name|languages
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|Statement
argument_list|>
name|statements
init|=
name|model
operator|.
name|filter
argument_list|(
name|subject
argument_list|,
name|sesameFactory
operator|.
name|createURI
argument_list|(
name|field
argument_list|)
argument_list|,
literal|null
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|statements
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Statement
name|statement
init|=
name|statements
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|vtf
operator|.
name|evaluate
argument_list|(
name|statement
operator|.
name|getObject
argument_list|()
argument_list|)
condition|)
block|{
name|statements
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|void
name|removeNaturalText
parameter_list|(
name|String
name|field
parameter_list|,
name|String
name|value
parameter_list|,
name|String
modifier|...
name|languages
parameter_list|)
block|{
if|if
condition|(
name|field
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field MUST NOT be NULL"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field MUST NOT be Empty"
argument_list|)
throw|;
block|}
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"NULL parsed as value in remove method for symbol "
operator|+
name|getId
argument_list|()
operator|+
literal|" and field "
operator|+
name|field
operator|+
literal|" -> call ignored"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|languages
operator|==
literal|null
operator|||
name|languages
operator|.
name|length
operator|==
literal|0
condition|)
block|{
comment|//null or no language
comment|//need to be interpreted as default language
name|languages
operator|=
operator|new
name|String
index|[]
block|{
literal|null
block|}
expr_stmt|;
block|}
name|URI
name|property
init|=
name|sesameFactory
operator|.
name|createURI
argument_list|(
name|field
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|language
range|:
name|languages
control|)
block|{
name|removeValue
argument_list|(
name|property
argument_list|,
name|sesameFactory
operator|.
name|createLiteral
argument_list|(
name|value
argument_list|,
name|language
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|language
operator|==
literal|null
condition|)
block|{
comment|//we need also to remove xsd:string labels
name|removeValue
argument_list|(
name|property
argument_list|,
name|sesameFactory
operator|.
name|createLiteral
argument_list|(
name|value
argument_list|,
name|XMLSchema
operator|.
name|STRING
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeReference
parameter_list|(
name|String
name|field
parameter_list|,
name|String
name|reference
parameter_list|)
block|{
if|if
condition|(
name|field
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field MUST NOT be NULL"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field MUST NOT be Empty"
argument_list|)
throw|;
block|}
if|if
condition|(
name|reference
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"NULL parsed as value in remove method for symbol "
operator|+
name|getId
argument_list|()
operator|+
literal|" and field "
operator|+
name|field
operator|+
literal|" -> call ignored"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|removeValue
argument_list|(
name|sesameFactory
operator|.
name|createURI
argument_list|(
name|field
argument_list|)
argument_list|,
name|sesameFactory
operator|.
name|createURI
argument_list|(
name|reference
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|set
parameter_list|(
name|String
name|field
parameter_list|,
name|Object
name|value
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|removeAll
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|add
argument_list|(
name|field
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|setNaturalText
parameter_list|(
name|String
name|field
parameter_list|,
name|String
name|text
parameter_list|,
name|String
modifier|...
name|languages
parameter_list|)
block|{
name|removeAllNaturalText
argument_list|(
name|field
argument_list|,
name|languages
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
operator|!=
literal|null
condition|)
block|{
name|addNaturalText
argument_list|(
name|field
argument_list|,
name|text
argument_list|,
name|languages
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|setReference
parameter_list|(
name|String
name|field
parameter_list|,
name|String
name|reference
parameter_list|)
block|{
name|removeAll
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|reference
operator|!=
literal|null
condition|)
block|{
name|addReference
argument_list|(
name|field
argument_list|,
name|reference
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|URI
name|getURI
parameter_list|()
block|{
return|return
name|subject
return|;
block|}
annotation|@
name|Override
specifier|public
name|Value
name|getValue
parameter_list|()
block|{
return|return
name|subject
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|subject
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
return|return
name|obj
operator|instanceof
name|Representation
operator|&&
name|getId
argument_list|()
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|Representation
operator|)
name|obj
operator|)
operator|.
name|getId
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|subject
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class

end_unit

