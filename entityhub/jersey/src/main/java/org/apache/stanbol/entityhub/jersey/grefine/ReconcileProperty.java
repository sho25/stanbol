begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|jersey
operator|.
name|grefine
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|defaults
operator|.
name|NamespaceEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Special properties are used by this Google Refine Reconciliation API  * implementation to enable Users to use special features of the Entityhub  *   * The Syntax used by those properties is  *<code><pre>  *     @{propName}[:{propParameter}]  *</pre><code>  *   * where:<ul>  *<li> '@' is the special property indicator  *<li> '{propertyName} is parsed as the name of the special property  *<li> ':' separates the property name with an optional property value  *<li> {propertyParameter} an additional parameter for this special property.  * The syntax of the parameter is special property specific.  *</ul>  * Both the {propertyName} and the {propertyValue} are trimmed.<p>  * @author Rupert Westenthaler  *  */
end_comment

begin_class
specifier|public
class|class
name|ReconcileProperty
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ReconcileProperty
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|char
name|SPECIAL_PROPERTY_PREFIX
init|=
literal|'@'
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|char
name|SPECAIL_PROPERTY_VALUE_SEPARATOR
init|=
literal|':'
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|special
decl_stmt|;
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
specifier|private
specifier|final
name|String
name|parameter
decl_stmt|;
specifier|private
name|ReconcileProperty
parameter_list|(
name|boolean
name|special
parameter_list|,
name|String
name|name
parameter_list|,
name|String
name|parameter
parameter_list|)
block|{
name|this
operator|.
name|special
operator|=
name|special
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|parameter
operator|=
name|parameter
expr_stmt|;
block|}
comment|/**      * Tests if the parsed name represents a specail property      * @param name the name      * @return<code>true</code> if the parsed propertyString is not<code>null</code>,      * not empty and starts with {@link #SPECIAL_PROPERTY_PREFIX}. Otherwise      *<code>false</code>      */
specifier|public
specifier|static
name|boolean
name|isSpecialProperty
parameter_list|(
name|String
name|propertyString
parameter_list|)
block|{
name|propertyString
operator|=
name|StringUtils
operator|.
name|trimToNull
argument_list|(
name|propertyString
argument_list|)
expr_stmt|;
return|return
name|propertyString
operator|!=
literal|null
operator|&&
name|propertyString
operator|.
name|length
argument_list|()
operator|>
literal|1
operator|&&
name|propertyString
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
name|SPECIAL_PROPERTY_PREFIX
return|;
block|}
comment|/**      * Parses the Reconcile property from the parsed propertyString      * @param propertyString the property string      * @return the {@link ReconcileProperty} or<code>null</code> if the parsed      * String is illegal formatted.      */
specifier|public
specifier|static
name|ReconcileProperty
name|parseProperty
parameter_list|(
name|String
name|propertyString
parameter_list|)
block|{
name|propertyString
operator|=
name|StringUtils
operator|.
name|trimToNull
argument_list|(
name|propertyString
argument_list|)
expr_stmt|;
if|if
condition|(
name|propertyString
operator|!=
literal|null
condition|)
block|{
name|propertyString
operator|=
name|StringUtils
operator|.
name|trimToNull
argument_list|(
name|propertyString
argument_list|)
expr_stmt|;
if|if
condition|(
name|propertyString
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to parse Reconcile Property: The parsed propertyString MUST contain some none trimable chars!"
argument_list|)
expr_stmt|;
block|}
name|boolean
name|special
init|=
name|propertyString
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
name|SPECIAL_PROPERTY_PREFIX
decl_stmt|;
if|if
condition|(
operator|!
name|special
condition|)
block|{
return|return
operator|new
name|ReconcileProperty
argument_list|(
name|special
argument_list|,
name|NamespaceEnum
operator|.
name|getFullName
argument_list|(
name|propertyString
argument_list|)
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|// else parse special property name and parameter
if|if
condition|(
name|propertyString
operator|.
name|length
argument_list|()
operator|<
literal|1
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to parse Reconcile Property: The parsed propertyString MUST NOT "
operator|+
literal|"contain only the special property prefix '{}'!"
argument_list|,
name|SPECIAL_PROPERTY_PREFIX
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|int
name|valueSeparatorIndex
init|=
name|propertyString
operator|.
name|indexOf
argument_list|(
name|SPECAIL_PROPERTY_VALUE_SEPARATOR
argument_list|)
decl_stmt|;
name|String
name|name
init|=
name|StringUtils
operator|.
name|trimToNull
argument_list|(
name|propertyString
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|valueSeparatorIndex
operator|>
literal|0
condition|?
name|valueSeparatorIndex
else|:
name|propertyString
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to parse Reconcile Property: The parsed special "
operator|+
literal|"property '{}' has an empty property name!"
argument_list|,
name|propertyString
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
operator|new
name|ReconcileProperty
argument_list|(
name|special
argument_list|,
name|name
argument_list|,
comment|//parse the parameter from the parsed value
name|valueSeparatorIndex
operator|>
literal|0
operator|&&
name|valueSeparatorIndex
operator|<
name|propertyString
operator|.
name|length
argument_list|()
condition|?
name|StringUtils
operator|.
name|trimToNull
argument_list|(
name|propertyString
operator|.
name|substring
argument_list|(
name|valueSeparatorIndex
operator|+
literal|1
argument_list|)
argument_list|)
else|:
literal|null
argument_list|)
return|;
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to parse Reconcile Property from NULL or an empty String!"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Getter for the name of the property      * @return the name      */
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
comment|/**      * Getter for the parameter       * @return the value or<code>null</code> if none      */
specifier|public
name|String
name|getParameter
parameter_list|()
block|{
return|return
name|parameter
return|;
block|}
comment|/**      * Checks if this special property has a value or not.      * @return if the special property has a value or not.      */
specifier|public
name|boolean
name|hasParameter
parameter_list|()
block|{
return|return
name|parameter
operator|!=
literal|null
return|;
block|}
comment|/**      * If this reconcile property is a special property (starting with an '@')      * @return      */
specifier|public
name|boolean
name|isSpecial
parameter_list|()
block|{
return|return
name|special
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|name
operator|.
name|hashCode
argument_list|()
operator|+
operator|(
name|parameter
operator|!=
literal|null
condition|?
name|parameter
operator|.
name|hashCode
argument_list|()
else|:
literal|0
operator|)
operator|+
operator|(
name|special
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|ReconcileProperty
operator|&&
name|name
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|ReconcileProperty
operator|)
name|o
operator|)
operator|.
name|name
argument_list|)
operator|&&
name|special
operator|==
operator|(
operator|(
name|ReconcileProperty
operator|)
name|o
operator|)
operator|.
name|special
condition|)
block|{
return|return
name|parameter
operator|==
literal|null
operator|&&
operator|(
operator|(
name|ReconcileProperty
operator|)
name|o
operator|)
operator|.
name|parameter
operator|==
literal|null
operator|||
operator|(
name|parameter
operator|!=
literal|null
operator|&&
name|parameter
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|ReconcileProperty
operator|)
name|o
operator|)
operator|.
name|parameter
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**      * Serialised the {@link ReconcileProperty} as defined by the syntax      *<code><pre>      *     @{propName}[:{propValue}]      *</pre><code>      */
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|special
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|SPECIAL_PROPERTY_PREFIX
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|parameter
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|SPECAIL_PROPERTY_VALUE_SEPARATOR
argument_list|)
operator|.
name|append
argument_list|(
name|parameter
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class

end_unit

