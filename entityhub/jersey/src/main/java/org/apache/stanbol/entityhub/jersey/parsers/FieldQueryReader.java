begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|jersey
operator|.
name|parsers
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|Annotation
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|ws
operator|.
name|rs
operator|.
name|WebApplicationException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|ws
operator|.
name|rs
operator|.
name|core
operator|.
name|HttpHeaders
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|ws
operator|.
name|rs
operator|.
name|core
operator|.
name|MediaType
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|ws
operator|.
name|rs
operator|.
name|core
operator|.
name|MultivaluedMap
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|ws
operator|.
name|rs
operator|.
name|core
operator|.
name|Response
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|ws
operator|.
name|rs
operator|.
name|core
operator|.
name|Response
operator|.
name|Status
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|ws
operator|.
name|rs
operator|.
name|ext
operator|.
name|MessageBodyReader
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|ws
operator|.
name|rs
operator|.
name|ext
operator|.
name|Provider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|core
operator|.
name|mapping
operator|.
name|ValueConverterFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|core
operator|.
name|model
operator|.
name|InMemoryValueFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|core
operator|.
name|query
operator|.
name|DefaultQueryFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|core
operator|.
name|query
operator|.
name|FieldQueryImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|ldpath
operator|.
name|query
operator|.
name|LDPathFieldQueryImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|defaults
operator|.
name|DataTypeEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|defaults
operator|.
name|NamespaceEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|ValueFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|Constraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|FieldQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|FieldQueryFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|RangeConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|ReferenceConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|TextConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|ValueConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|Constraint
operator|.
name|ConstraintType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|TextConstraint
operator|.
name|PatternType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jettison
operator|.
name|json
operator|.
name|JSONArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jettison
operator|.
name|json
operator|.
name|JSONException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jettison
operator|.
name|json
operator|.
name|JSONObject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_class
annotation|@
name|Provider
specifier|public
class|class
name|FieldQueryReader
implements|implements
name|MessageBodyReader
argument_list|<
name|FieldQuery
argument_list|>
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|FieldQueryReader
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|ValueFactory
name|valueFactory
init|=
name|InMemoryValueFactory
operator|.
name|getInstance
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|ValueConverterFactory
name|converterFactory
init|=
name|ValueConverterFactory
operator|.
name|getDefaultInstance
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|isReadable
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|type
parameter_list|,
name|Type
name|genericType
parameter_list|,
name|Annotation
index|[]
name|annotations
parameter_list|,
name|MediaType
name|mediaType
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"isReadable type {}, mediaType {}"
argument_list|,
name|type
argument_list|,
name|mediaType
argument_list|)
expr_stmt|;
return|return
name|FieldQuery
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|type
argument_list|)
return|;
comment|//&& mediaType.isCompatible(MediaType.APPLICATION_JSON_TYPE);
block|}
annotation|@
name|Override
specifier|public
name|FieldQuery
name|readFrom
parameter_list|(
name|Class
argument_list|<
name|FieldQuery
argument_list|>
name|type
parameter_list|,
name|Type
name|genericType
parameter_list|,
name|Annotation
index|[]
name|annotations
parameter_list|,
name|MediaType
name|mediaType
parameter_list|,
name|MultivaluedMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|httpHeaders
parameter_list|,
name|InputStream
name|entityStream
parameter_list|)
throws|throws
name|IOException
throws|,
name|WebApplicationException
block|{
name|String
name|queryString
init|=
name|IOUtils
operator|.
name|toString
argument_list|(
name|entityStream
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Parsed QueryString: \n{}"
argument_list|,
name|queryString
argument_list|)
expr_stmt|;
name|MediaType
name|acceptedType
init|=
name|MediaType
operator|.
name|valueOf
argument_list|(
name|httpHeaders
operator|.
name|getFirst
argument_list|(
literal|"Accept"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|acceptedType
operator|.
name|isWildcardType
argument_list|()
condition|)
block|{
name|acceptedType
operator|=
name|MediaType
operator|.
name|TEXT_PLAIN_TYPE
expr_stmt|;
block|}
try|try
block|{
return|return
name|fromJSON
argument_list|(
name|queryString
argument_list|,
name|acceptedType
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|JSONException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Unable to parse Request "
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|StringBuilder
name|message
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|message
operator|.
name|append
argument_list|(
literal|"Parsed FieldQuery is not valid JSON\n"
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
literal|"Parsed String:\n"
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
name|queryString
argument_list|)
expr_stmt|;
name|log
operator|.
name|warn
argument_list|(
name|message
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|//TODO: Jersey wraps Exceptions thrown by MessageBodyReader into
comment|// other ones. Because of that the Response created by the
comment|// WebApplicationException is "lost" and the user will get an
comment|// 500 with no comment and HTML content type :(
comment|// As a workaround one could use a wrapping object as generic type
comment|// that parses the error and than throw the Exception within the
comment|// Resource using this MessageBodyReader
throw|throw
operator|new
name|WebApplicationException
argument_list|(
name|Response
operator|.
name|status
argument_list|(
name|Status
operator|.
name|BAD_REQUEST
argument_list|)
operator|.
name|entity
argument_list|(
name|message
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|header
argument_list|(
name|HttpHeaders
operator|.
name|ACCEPT
argument_list|,
name|acceptedType
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**      *       * @param queryFactory      * @param jsonQueryString      * @param acceptedMediaType used to add the accept header to Error responses      * @return      * @throws JSONException      * @throws WebApplicationException      */
specifier|public
specifier|static
name|FieldQuery
name|fromJSON
parameter_list|(
name|String
name|jsonQueryString
parameter_list|,
name|MediaType
name|acceptedMediaType
parameter_list|)
throws|throws
name|JSONException
throws|,
name|WebApplicationException
block|{
if|if
condition|(
name|jsonQueryString
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed JSON object MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|JSONObject
name|jQuery
init|=
operator|new
name|JSONObject
argument_list|(
name|jsonQueryString
argument_list|)
decl_stmt|;
name|FieldQuery
name|query
decl_stmt|;
if|if
condition|(
name|jQuery
operator|.
name|has
argument_list|(
literal|"ldpath"
argument_list|)
condition|)
block|{
comment|//STANBOL-417: support for using LDPath as select
name|LDPathFieldQueryImpl
name|ldPathQuery
init|=
operator|new
name|LDPathFieldQueryImpl
argument_list|()
decl_stmt|;
name|ldPathQuery
operator|.
name|setLDPathSelect
argument_list|(
name|jQuery
operator|.
name|getString
argument_list|(
literal|"ldpath"
argument_list|)
argument_list|)
expr_stmt|;
name|query
operator|=
name|ldPathQuery
expr_stmt|;
block|}
else|else
block|{
name|query
operator|=
operator|new
name|FieldQueryImpl
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|jQuery
operator|.
name|has
argument_list|(
literal|"constraints"
argument_list|)
condition|)
block|{
name|StringBuilder
name|message
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|message
operator|.
name|append
argument_list|(
literal|"The parsed Field Query MUST contain at least a single 'constraints'\n"
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
literal|"Parsed Query:\n"
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
name|jQuery
operator|.
name|toString
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|warn
argument_list|(
name|message
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|WebApplicationException
argument_list|(
name|Response
operator|.
name|status
argument_list|(
name|Status
operator|.
name|BAD_REQUEST
argument_list|)
operator|.
name|entity
argument_list|(
name|message
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|header
argument_list|(
name|HttpHeaders
operator|.
name|ACCEPT
argument_list|,
name|acceptedMediaType
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
throw|;
block|}
name|JSONArray
name|constraints
init|=
name|jQuery
operator|.
name|getJSONArray
argument_list|(
literal|"constraints"
argument_list|)
decl_stmt|;
comment|//collect all parsing Errors to report a complete set of all errors
name|boolean
name|parsingError
init|=
literal|false
decl_stmt|;
name|StringBuilder
name|parsingErrorMessages
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|parsingErrorMessages
operator|.
name|append
argument_list|(
literal|"Constraint parsing Errors:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|constraints
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|JSONObject
name|jConstraint
init|=
name|constraints
operator|.
name|getJSONObject
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|jConstraint
operator|.
name|has
argument_list|(
literal|"field"
argument_list|)
condition|)
block|{
name|String
name|field
init|=
name|jConstraint
operator|.
name|getString
argument_list|(
literal|"field"
argument_list|)
decl_stmt|;
comment|//check if there is already a constraint for that field
if|if
condition|(
name|field
operator|==
literal|null
operator|||
name|field
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//                    log.warn("The value of the key \"field\" MUST NOT be NULL nor emtpy!");
comment|//                    log.warn("Constraint:\n {}",jConstraint.toString(4));
name|parsingErrorMessages
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|parsingErrorMessages
operator|.
name|append
argument_list|(
literal|"Each Field Query Constraint MUST define a value for 'field'\n"
argument_list|)
expr_stmt|;
name|parsingErrorMessages
operator|.
name|append
argument_list|(
literal|"Parsed Constraint:\n"
argument_list|)
expr_stmt|;
name|parsingErrorMessages
operator|.
name|append
argument_list|(
name|jConstraint
operator|.
name|toString
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|parsingErrorMessages
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|parsingError
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|query
operator|.
name|isConstrained
argument_list|(
name|field
argument_list|)
condition|)
block|{
comment|//                   log.warn("Multiple constraints for field {} in parsed FieldQuery!",field);
name|parsingErrorMessages
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|parsingErrorMessages
operator|.
name|append
argument_list|(
literal|"The parsed Query defines multiple constraints fr the field '"
operator|+
name|field
operator|+
literal|"'!\n"
argument_list|)
expr_stmt|;
name|parsingErrorMessages
operator|.
name|append
argument_list|(
literal|"FieldQuery allows only a single Constraint for a field\n"
argument_list|)
expr_stmt|;
name|parsingErrorMessages
operator|.
name|append
argument_list|(
literal|"Parsed Constraints:\n"
argument_list|)
expr_stmt|;
name|parsingErrorMessages
operator|.
name|append
argument_list|(
name|constraints
operator|.
name|toString
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|parsingErrorMessages
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|parsingError
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
else|else
block|{
try|try
block|{
name|query
operator|.
name|setConstraint
argument_list|(
name|field
argument_list|,
name|parseConstraint
argument_list|(
name|jConstraint
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|parsingErrorMessages
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|parsingErrorMessages
operator|.
name|append
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|parsingErrorMessages
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|parsingError
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
block|}
block|}
else|else
block|{
comment|//empty field
name|parsingErrorMessages
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|parsingErrorMessages
operator|.
name|append
argument_list|(
literal|"Constraints MUST define a value for 'field'\n"
argument_list|)
expr_stmt|;
name|parsingErrorMessages
operator|.
name|append
argument_list|(
literal|"Parsed Constraint:\n"
argument_list|)
expr_stmt|;
name|parsingErrorMessages
operator|.
name|append
argument_list|(
name|jConstraint
operator|.
name|toString
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|parsingErrorMessages
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|parsingError
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|parsingError
condition|)
block|{
name|String
name|message
init|=
name|parsingErrorMessages
operator|.
name|toString
argument_list|()
decl_stmt|;
name|log
operator|.
name|warn
argument_list|(
name|message
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|WebApplicationException
argument_list|(
name|Response
operator|.
name|status
argument_list|(
name|Status
operator|.
name|BAD_REQUEST
argument_list|)
operator|.
name|entity
argument_list|(
name|message
argument_list|)
operator|.
name|header
argument_list|(
name|HttpHeaders
operator|.
name|ACCEPT
argument_list|,
name|acceptedMediaType
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
throw|;
block|}
comment|//parse selected fields
name|JSONArray
name|selected
init|=
name|jQuery
operator|.
name|optJSONArray
argument_list|(
literal|"selected"
argument_list|)
decl_stmt|;
if|if
condition|(
name|selected
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|selected
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|selectedField
init|=
name|selected
operator|.
name|getString
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|selectedField
operator|!=
literal|null
operator|&&
operator|!
name|selectedField
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|query
operator|.
name|addSelectedField
argument_list|(
name|selectedField
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//else no selected fields -> funny but maybe someone do need only the ids
comment|//parse limit and offset
if|if
condition|(
name|jQuery
operator|.
name|has
argument_list|(
literal|"limit"
argument_list|)
operator|&&
operator|!
name|jQuery
operator|.
name|isNull
argument_list|(
literal|"limit"
argument_list|)
condition|)
block|{
try|try
block|{
name|query
operator|.
name|setLimit
argument_list|(
name|jQuery
operator|.
name|getInt
argument_list|(
literal|"limit"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|JSONException
name|e
parameter_list|)
block|{
name|parsingErrorMessages
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|parsingErrorMessages
operator|.
name|append
argument_list|(
literal|"Property \"limit\" MUST BE a valid integer number!\n"
argument_list|)
expr_stmt|;
name|parsingErrorMessages
operator|.
name|append
argument_list|(
literal|"Parsed Value:"
argument_list|)
expr_stmt|;
name|parsingErrorMessages
operator|.
name|append
argument_list|(
name|jQuery
operator|.
name|get
argument_list|(
literal|"init"
argument_list|)
argument_list|)
expr_stmt|;
name|parsingErrorMessages
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|parsingError
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|jQuery
operator|.
name|has
argument_list|(
literal|"offset"
argument_list|)
operator|&&
operator|!
name|jQuery
operator|.
name|isNull
argument_list|(
literal|"offset"
argument_list|)
condition|)
block|{
try|try
block|{
name|query
operator|.
name|setOffset
argument_list|(
name|jQuery
operator|.
name|getInt
argument_list|(
literal|"offset"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|JSONException
name|e
parameter_list|)
block|{
name|parsingErrorMessages
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|parsingErrorMessages
operator|.
name|append
argument_list|(
literal|"Property \"offset\" MUST BE a valid integer number!\n"
argument_list|)
expr_stmt|;
name|parsingErrorMessages
operator|.
name|append
argument_list|(
literal|"Parsed Value:"
argument_list|)
expr_stmt|;
name|parsingErrorMessages
operator|.
name|append
argument_list|(
name|jQuery
operator|.
name|get
argument_list|(
literal|"init"
argument_list|)
argument_list|)
expr_stmt|;
name|parsingErrorMessages
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|parsingError
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|query
return|;
block|}
specifier|private
specifier|static
name|Constraint
name|parseConstraint
parameter_list|(
name|JSONObject
name|jConstraint
parameter_list|)
throws|throws
name|JSONException
block|{
if|if
condition|(
name|jConstraint
operator|.
name|has
argument_list|(
literal|"type"
argument_list|)
operator|&&
operator|!
name|jConstraint
operator|.
name|isNull
argument_list|(
literal|"type"
argument_list|)
condition|)
block|{
name|String
name|type
init|=
name|jConstraint
operator|.
name|getString
argument_list|(
literal|"type"
argument_list|)
decl_stmt|;
comment|//Event that internally "reference" is not part of the
comment|//ConstraintType enum it is still present in the serialisation
comment|//ant the Java API (see ReferenceConstraint class)
comment|//Value constraints with the dataType Reference and AnyURI are
comment|//considered to represent reference constraints
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
literal|"reference"
argument_list|)
condition|)
block|{
return|return
name|parseReferenceConstraint
argument_list|(
name|jConstraint
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
name|ConstraintType
operator|.
name|value
operator|.
name|name
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|parseValueConstraint
argument_list|(
name|jConstraint
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
name|ConstraintType
operator|.
name|text
operator|.
name|name
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|parseTextConstraint
argument_list|(
name|jConstraint
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
name|ConstraintType
operator|.
name|range
operator|.
name|name
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|parseRangeConstraint
argument_list|(
name|jConstraint
argument_list|)
return|;
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unknown Constraint Type %s. Supported values are %s"
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"reference"
argument_list|,
name|ConstraintType
operator|.
name|values
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|StringBuilder
name|message
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|message
operator|.
name|append
argument_list|(
literal|"Parsed Constraint uses an unknown value for 'type'!\n"
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
literal|"Supported values: "
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
name|ConstraintType
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
literal|"Parsed Constraint: \n"
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
name|jConstraint
operator|.
name|toString
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|message
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Earch Constraint MUST HAVE the \"type\" key set to one of the values %s"
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"reference"
argument_list|,
name|ConstraintType
operator|.
name|values
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|StringBuilder
name|message
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|message
operator|.
name|append
argument_list|(
literal|"Parsed Constraint does not define a value for the field 'type'!\n"
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
literal|"Supported values: "
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
name|ConstraintType
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
literal|"Parsed Constraint: \n"
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
name|jConstraint
operator|.
name|toString
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|message
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**      * @param jConstraint      * @return      * @throws JSONException      */
specifier|private
specifier|static
name|Constraint
name|parseRangeConstraint
parameter_list|(
name|JSONObject
name|jConstraint
parameter_list|)
throws|throws
name|JSONException
block|{
name|Constraint
name|constraint
decl_stmt|;
name|boolean
name|inclusive
decl_stmt|;
if|if
condition|(
name|jConstraint
operator|.
name|has
argument_list|(
literal|"inclusive"
argument_list|)
condition|)
block|{
name|inclusive
operator|=
name|jConstraint
operator|.
name|getBoolean
argument_list|(
literal|"inclusive"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"RangeConstraint does not define the field 'inclusive'. Use false as default!"
argument_list|)
expr_stmt|;
name|inclusive
operator|=
literal|false
expr_stmt|;
block|}
name|Object
name|upperBound
init|=
name|jConstraint
operator|.
name|opt
argument_list|(
literal|"upperBound"
argument_list|)
decl_stmt|;
name|Object
name|lowerBound
init|=
name|jConstraint
operator|.
name|opt
argument_list|(
literal|"lowerBound"
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|String
argument_list|>
name|datatypes
init|=
name|parseDatatypeProperty
argument_list|(
name|jConstraint
argument_list|)
decl_stmt|;
if|if
condition|(
name|datatypes
operator|!=
literal|null
operator|&&
operator|!
name|datatypes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Iterator
argument_list|<
name|String
argument_list|>
name|it
init|=
name|datatypes
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|String
name|datatype
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|datatypes
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|//write warning in case of multiple values
name|log
operator|.
name|warn
argument_list|(
literal|"Multiple datatypes are not supported by RangeConstriants!"
argument_list|)
expr_stmt|;
name|log
operator|.
name|warn
argument_list|(
literal|"  used: {}"
argument_list|,
name|datatype
argument_list|)
expr_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"  ignored: {}"
argument_list|,
name|it
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|StringBuilder
name|convertingError
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|upperBound
operator|!=
literal|null
condition|)
block|{
name|Object
name|convertedUpperBound
init|=
name|converterFactory
operator|.
name|convert
argument_list|(
name|upperBound
argument_list|,
name|datatype
argument_list|,
name|valueFactory
argument_list|)
decl_stmt|;
if|if
condition|(
name|convertedUpperBound
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to convert upper bound {} to data type {}"
argument_list|,
name|upperBound
argument_list|,
name|datatype
argument_list|)
expr_stmt|;
name|convertingError
operator|=
operator|new
name|StringBuilder
argument_list|()
expr_stmt|;
name|convertingError
operator|.
name|append
argument_list|(
literal|"Unable to convert the parsed upper bound value "
argument_list|)
operator|.
name|append
argument_list|(
name|upperBound
argument_list|)
operator|.
name|append
argument_list|(
literal|" to data type "
argument_list|)
operator|.
name|append
argument_list|(
name|datatype
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//set the converted upper bound
name|upperBound
operator|=
name|convertedUpperBound
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lowerBound
operator|!=
literal|null
condition|)
block|{
name|Object
name|convertedLowerBound
init|=
name|converterFactory
operator|.
name|convert
argument_list|(
name|lowerBound
argument_list|,
name|datatype
argument_list|,
name|valueFactory
argument_list|)
decl_stmt|;
if|if
condition|(
name|convertedLowerBound
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to convert lower bound {} to data type {}"
argument_list|,
name|lowerBound
argument_list|,
name|datatype
argument_list|)
expr_stmt|;
if|if
condition|(
name|convertingError
operator|==
literal|null
condition|)
block|{
name|convertingError
operator|=
operator|new
name|StringBuilder
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|convertingError
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|convertingError
operator|.
name|append
argument_list|(
literal|"Unable to convert the parsed value "
argument_list|)
operator|.
name|append
argument_list|(
name|lowerBound
argument_list|)
operator|.
name|append
argument_list|(
literal|" to data type "
argument_list|)
operator|.
name|append
argument_list|(
name|datatype
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//set the converted lower bound
name|lowerBound
operator|=
name|convertedLowerBound
expr_stmt|;
block|}
block|}
if|if
condition|(
name|convertingError
operator|!=
literal|null
condition|)
block|{
comment|//if there was an error throw an exception
name|convertingError
operator|.
name|append
argument_list|(
literal|"Parsed Constraint: \n"
argument_list|)
expr_stmt|;
name|convertingError
operator|.
name|append
argument_list|(
name|jConstraint
operator|.
name|toString
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|convertingError
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|upperBound
operator|==
literal|null
operator|&&
name|lowerBound
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Range Constraint does not define an 'upperBound' nor an 'lowerBound'! "
operator|+
literal|"At least one of the two MUST BE parsed for a valid RangeConstraint."
argument_list|)
expr_stmt|;
name|StringBuilder
name|message
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|message
operator|.
name|append
argument_list|(
literal|"Range Constraint does not define an 'upperBound' nor an 'lowerBound'!"
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
literal|" At least one of the two MUST BE parsed for a valid RangeConstraint.\n"
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
literal|"Parsed Constraint: \n"
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
name|jConstraint
operator|.
name|toString
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|message
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
name|constraint
operator|=
operator|new
name|RangeConstraint
argument_list|(
name|lowerBound
argument_list|,
name|upperBound
argument_list|,
name|inclusive
argument_list|)
expr_stmt|;
block|}
return|return
name|constraint
return|;
block|}
comment|/**      * @param jConstraint      * @return      * @throws JSONException      */
specifier|private
specifier|static
name|Constraint
name|parseTextConstraint
parameter_list|(
name|JSONObject
name|jConstraint
parameter_list|)
throws|throws
name|JSONException
block|{
name|Constraint
name|constraint
decl_stmt|;
name|boolean
name|caseSensitive
init|=
name|jConstraint
operator|.
name|optBoolean
argument_list|(
literal|"caseSensitive"
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|//parse patternType
name|PatternType
name|patternType
decl_stmt|;
name|String
name|jPatternType
init|=
name|jConstraint
operator|.
name|optString
argument_list|(
literal|"patternType"
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|jPatternType
operator|==
literal|null
condition|)
block|{
name|patternType
operator|=
name|PatternType
operator|.
name|none
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|patternType
operator|=
name|PatternType
operator|.
name|valueOf
argument_list|(
name|jPatternType
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Encountered unknown patternType for TextConstraint!"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|patternType
operator|=
name|PatternType
operator|.
name|none
expr_stmt|;
name|StringBuilder
name|message
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|message
operator|.
name|append
argument_list|(
literal|"Illegal value for field 'patternType'.\n"
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
literal|"Supported values are: "
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
name|Arrays
operator|.
name|toString
argument_list|(
name|PatternType
operator|.
name|values
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
literal|"Parsed Constraint: \n"
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
name|jConstraint
operator|.
name|toString
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|message
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|//parse languages
name|Collection
argument_list|<
name|String
argument_list|>
name|languages
decl_stmt|;
name|String
name|languageKey
init|=
literal|null
decl_stmt|;
comment|//support both "languages" and "language"
if|if
condition|(
name|jConstraint
operator|.
name|has
argument_list|(
literal|"language"
argument_list|)
condition|)
block|{
name|languageKey
operator|=
literal|"language"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|jConstraint
operator|.
name|has
argument_list|(
literal|"languages"
argument_list|)
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"The key \"languages\" is deprecated. Use \"language\" instead."
argument_list|)
expr_stmt|;
name|languageKey
operator|=
literal|"languages"
expr_stmt|;
block|}
if|if
condition|(
name|languageKey
operator|!=
literal|null
condition|)
block|{
name|JSONArray
name|jLanguages
init|=
name|jConstraint
operator|.
name|optJSONArray
argument_list|(
name|languageKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|jLanguages
operator|!=
literal|null
operator|&&
name|jLanguages
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|languages
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|jLanguages
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|jLanguages
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|lang
init|=
name|jLanguages
operator|.
name|getString
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|lang
operator|!=
literal|null
operator|&&
operator|!
name|lang
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|languages
operator|.
name|add
argument_list|(
name|lang
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|languages
operator|.
name|contains
argument_list|(
literal|null
argument_list|)
condition|)
block|{
name|languages
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|languages
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|languages
operator|=
literal|null
expr_stmt|;
comment|//if no one was successfully added set the list back to null
block|}
block|}
else|else
block|{
name|String
name|language
init|=
name|jConstraint
operator|.
name|getString
argument_list|(
name|languageKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|language
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|languages
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
comment|//add the single language
name|languages
operator|=
name|Collections
operator|.
name|singletonList
argument_list|(
name|language
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|languages
operator|=
literal|null
expr_stmt|;
block|}
comment|//parse text and create constraint
if|if
condition|(
name|jConstraint
operator|.
name|has
argument_list|(
literal|"text"
argument_list|)
operator|&&
operator|!
name|jConstraint
operator|.
name|isNull
argument_list|(
literal|"text"
argument_list|)
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|textConstraints
decl_stmt|;
name|JSONArray
name|jTextConstraints
init|=
name|jConstraint
operator|.
name|optJSONArray
argument_list|(
literal|"text"
argument_list|)
decl_stmt|;
if|if
condition|(
name|jTextConstraints
operator|!=
literal|null
condition|)
block|{
name|textConstraints
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|jTextConstraints
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|jTextConstraints
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|text
init|=
name|jTextConstraints
operator|.
name|getString
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|text
operator|!=
literal|null
operator|&&
operator|!
name|text
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|textConstraints
operator|.
name|add
argument_list|(
name|jTextConstraints
operator|.
name|getString
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|String
name|text
init|=
name|jConstraint
operator|.
name|getString
argument_list|(
literal|"text"
argument_list|)
decl_stmt|;
if|if
condition|(
name|text
operator|==
literal|null
operator|||
name|text
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|textConstraints
operator|=
name|Collections
operator|.
name|emptyList
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|textConstraints
operator|=
name|Collections
operator|.
name|singletonList
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|textConstraints
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|StringBuilder
name|message
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|message
operator|.
name|append
argument_list|(
literal|"Parsed TextConstraint doese not define a valid (none empty) value for the 'text' property !\n"
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
literal|"Parsed Constraint: \n"
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
name|jConstraint
operator|.
name|toString
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|message
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
name|constraint
operator|=
operator|new
name|TextConstraint
argument_list|(
name|textConstraints
argument_list|,
name|patternType
argument_list|,
name|caseSensitive
argument_list|,
name|languages
operator|==
literal|null
condition|?
literal|null
else|:
name|languages
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|languages
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|StringBuilder
name|message
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|message
operator|.
name|append
argument_list|(
literal|"Parsed TextConstraint doese not define the required field 'text'!\n"
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
literal|"Parsed Constraint: \n"
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
name|jConstraint
operator|.
name|toString
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|message
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|constraint
return|;
block|}
comment|/**      * @param jConstraint      * @return      * @throws JSONException      */
specifier|private
specifier|static
name|Constraint
name|parseValueConstraint
parameter_list|(
name|JSONObject
name|jConstraint
parameter_list|)
throws|throws
name|JSONException
block|{
name|Constraint
name|constraint
decl_stmt|;
name|Collection
argument_list|<
name|String
argument_list|>
name|dataTypes
init|=
name|parseDatatypeProperty
argument_list|(
name|jConstraint
argument_list|)
decl_stmt|;
if|if
condition|(
name|jConstraint
operator|.
name|has
argument_list|(
literal|"value"
argument_list|)
operator|&&
operator|!
name|jConstraint
operator|.
name|isNull
argument_list|(
literal|"value"
argument_list|)
condition|)
block|{
name|constraint
operator|=
operator|new
name|ValueConstraint
argument_list|(
name|jConstraint
operator|.
name|get
argument_list|(
literal|"value"
argument_list|)
argument_list|,
name|dataTypes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Parsed ValueConstraint does not define the required field \"value\"!"
argument_list|)
expr_stmt|;
name|StringBuilder
name|message
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|message
operator|.
name|append
argument_list|(
literal|"Parsed ValueConstraint does not define the required field 'value'!\n"
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
literal|"Parsed Constraint: \n"
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
name|jConstraint
operator|.
name|toString
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|message
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|constraint
return|;
block|}
comment|/**      * @param jConstraint      * @return      * @throws JSONException      */
specifier|private
specifier|static
name|Collection
argument_list|<
name|String
argument_list|>
name|parseDatatypeProperty
parameter_list|(
name|JSONObject
name|jConstraint
parameter_list|)
throws|throws
name|JSONException
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|dataTypes
decl_stmt|;
name|String
name|dataTypeKey
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|jConstraint
operator|.
name|has
argument_list|(
literal|"datatype"
argument_list|)
condition|)
block|{
name|dataTypeKey
operator|=
literal|"datatype"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|jConstraint
operator|.
name|has
argument_list|(
literal|"dataTypes"
argument_list|)
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"The use of \"dataTypes\" is deprecated. Please use \"dataType\" instead"
argument_list|)
expr_stmt|;
name|dataTypeKey
operator|=
literal|"dataTypes"
expr_stmt|;
block|}
if|if
condition|(
name|dataTypeKey
operator|!=
literal|null
condition|)
block|{
name|JSONArray
name|jDataTypes
init|=
name|jConstraint
operator|.
name|optJSONArray
argument_list|(
name|dataTypeKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|jDataTypes
operator|!=
literal|null
operator|&&
name|jDataTypes
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|dataTypes
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|jDataTypes
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|jDataTypes
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|dataType
init|=
name|jDataTypes
operator|.
name|getString
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|dataType
operator|!=
literal|null
operator|&&
operator|!
name|dataType
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//convert prefix:localName to fill URI
name|dataTypes
operator|.
name|add
argument_list|(
name|NamespaceEnum
operator|.
name|getFullName
argument_list|(
name|dataType
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dataTypes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|dataTypes
operator|=
literal|null
expr_stmt|;
comment|//if no one was successfully added set the list back to null
block|}
block|}
else|else
block|{
name|String
name|dataType
init|=
name|jConstraint
operator|.
name|getString
argument_list|(
name|dataTypeKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|dataType
operator|!=
literal|null
operator|&&
operator|!
name|dataType
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|dataTypes
operator|=
name|Collections
operator|.
name|singleton
argument_list|(
name|NamespaceEnum
operator|.
name|getFullName
argument_list|(
name|dataType
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dataTypes
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|dataTypes
operator|=
literal|null
expr_stmt|;
block|}
return|return
name|dataTypes
return|;
block|}
comment|/**      * @param jConstraint      * @return      * @throws JSONException      */
specifier|private
specifier|static
name|Constraint
name|parseReferenceConstraint
parameter_list|(
name|JSONObject
name|jConstraint
parameter_list|)
throws|throws
name|JSONException
block|{
name|Constraint
name|constraint
decl_stmt|;
if|if
condition|(
name|jConstraint
operator|.
name|has
argument_list|(
literal|"value"
argument_list|)
operator|&&
operator|!
name|jConstraint
operator|.
name|isNull
argument_list|(
literal|"value"
argument_list|)
condition|)
block|{
name|constraint
operator|=
operator|new
name|ReferenceConstraint
argument_list|(
name|jConstraint
operator|.
name|getString
argument_list|(
literal|"value"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Parsed ReferenceConstraint does not define the required field \"value\"!"
argument_list|)
expr_stmt|;
name|StringBuilder
name|message
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|message
operator|.
name|append
argument_list|(
literal|"Parsed ReferenceConstraint does not define the required field 'value'!\n"
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
literal|"Parsed Constraint: \n"
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
name|jConstraint
operator|.
name|toString
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|message
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|constraint
return|;
block|}
block|}
end_class

end_unit

