begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|query
operator|.
name|clerezza
package|;
end_package

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|DateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Triple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|TripleCollection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|UriRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|impl
operator|.
name|util
operator|.
name|W3CDateFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|core
operator|.
name|utils
operator|.
name|AdaptingIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|model
operator|.
name|clerezza
operator|.
name|RdfRepresentation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|model
operator|.
name|clerezza
operator|.
name|RdfValueFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|defaults
operator|.
name|DataTypeEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Reference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|rdf
operator|.
name|RdfResourceEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|Constraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|RangeConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|TextConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|ValueConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|TextConstraint
operator|.
name|PatternType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|util
operator|.
name|PatternUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Utility Class to create SPARQL Queries for {@link SparqlFieldQuery} instances.<p>  * Thanks to ogrisel for pointing me to his<a href="http://hg.nuxeo.org/sandbox/scribo/raw-file/b57ada956947/scribo-annotator-recognizer-sparql-ep/src/main/java/ws/scribo/annotators/recognizer/SparqlEndpointInstanceRecognizer.java">  * SparqlEndpointInstanceRecognizer</a> implementation for the query optimisations  * for Virtuoso and LARQ!  * @author Rupert Westenthaler  *  */
end_comment

begin_class
specifier|public
specifier|final
class|class
name|SparqlQueryUtils
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SparqlQueryUtils
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
enum|enum
name|EndpointTypeEnum
block|{
name|Standard
block|,
name|Virtuoso
block|,
name|LARQ
block|,
name|ARQ
block|}
specifier|private
specifier|static
specifier|final
name|String
name|XSD_DATE_TIME
init|=
literal|"http://www.w3.org/2001/XMLSchema#dateTime"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|DateFormat
name|DATE_FORMAT
init|=
operator|new
name|W3CDateFormat
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|RdfValueFactory
name|valueFavtory
init|=
name|RdfValueFactory
operator|.
name|getInstance
argument_list|()
decl_stmt|;
comment|/**      * {@link UriRef} constant for {@link RdfResourceEnum#queryResult}      * @see RdfResourceEnum.fieldQueryResult      */
specifier|public
specifier|static
specifier|final
name|UriRef
name|FIELD_QUERY_RESULT
init|=
operator|new
name|UriRef
argument_list|(
name|RdfResourceEnum
operator|.
name|queryResult
operator|.
name|getUri
argument_list|()
argument_list|)
decl_stmt|;
comment|/**      * {@link UriRef} constant for {@link RdfResourceEnum#QueryResultSet}      * @see RdfResourceEnum.FieldQueryResultSet      */
specifier|public
specifier|static
specifier|final
name|UriRef
name|FIELD_QUERY_RESULT_SET
init|=
operator|new
name|UriRef
argument_list|(
name|RdfResourceEnum
operator|.
name|QueryResultSet
operator|.
name|getUri
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
name|SparqlQueryUtils
parameter_list|()
block|{}
comment|/**      * Creates a SPARWL CONSTRUCT query that creates triples for all the selected      * fields of representations in the result set.<p>      * In addition the query also constructs<code>entityhub-query:ieldQueryResultSet      * entityhub-query:fieldQueryResult ?representation</code> triples that can be      * used to create an iterator over the results of the query      * @param query the field query      * @param endpointType The type of the Endpoint (used to write optimized      *    queries for endpoint type specific extensions      * @param additionalFields This allows to parse additional fields that are      *    optionally selected in the data set and added to the CONSTRUCT part      *    of the query      * @return the SPARQL CONSTRUCT Query      */
specifier|public
specifier|static
name|String
name|createSparqlConstructQuery
parameter_list|(
name|SparqlFieldQuery
name|query
parameter_list|,
name|EndpointTypeEnum
name|endpointType
parameter_list|,
name|String
modifier|...
name|additionalFields
parameter_list|)
block|{
return|return
name|createSparqlConstructQuery
argument_list|(
name|query
argument_list|,
operator|-
literal|1
argument_list|,
name|endpointType
argument_list|,
name|additionalFields
argument_list|)
return|;
block|}
comment|/**      * Creates a SPARWL CONSTRUCT query that creates triples for all the selected      * fields of representations in the result set.<p>      * In addition the query also constructs<code>entityhub-query:ieldQueryResultSet      * entityhub-query:fieldQueryResult ?representation</code> triples that can be      * used to create an iterator over the results of the query      * @param query the field query      * @param limit if a value> 0 is parsed, than this value overwrites the limit      *    defined by the query.      * @param endpointType The type of the Endpoint (used to write optimized      *    queries for endpoint type specific extensions      * @param additionalFields This allows to parse additional fields that are      *    optionally selected in the data set and added to the CONSTRUCT part      *    of the query      * @return the SPARQL CONSTRUCT Query      */
specifier|public
specifier|static
name|String
name|createSparqlConstructQuery
parameter_list|(
name|SparqlFieldQuery
name|query
parameter_list|,
name|int
name|limit
parameter_list|,
name|EndpointTypeEnum
name|endpointType
parameter_list|,
name|String
modifier|...
name|additionalFields
parameter_list|)
block|{
comment|//1)INIT
specifier|final
name|StringBuilder
name|queryString
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
comment|//We need a copy to delete all fields that are already covered by some added
comment|//graph pattern.
if|if
condition|(
name|additionalFields
operator|!=
literal|null
operator|&&
name|additionalFields
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|query
operator|=
name|query
operator|.
name|clone
argument_list|()
expr_stmt|;
name|query
operator|.
name|addSelectedFields
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|additionalFields
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|selectedFields
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|selectedFields
operator|.
name|putAll
argument_list|(
name|query
operator|.
name|getFieldVariableMappings
argument_list|()
argument_list|)
expr_stmt|;
comment|//also add the root variable
name|selectedFields
operator|.
name|put
argument_list|(
literal|null
argument_list|,
name|query
operator|.
name|getRootVariableName
argument_list|()
argument_list|)
expr_stmt|;
comment|//2)CONSTRUCT
name|createConstruct
argument_list|(
name|queryString
argument_list|,
name|selectedFields
argument_list|)
expr_stmt|;
comment|//3)WHERE
name|queryString
operator|.
name|append
argument_list|(
literal|"WHERE { \n"
argument_list|)
expr_stmt|;
name|addFieldConstraint
argument_list|(
name|queryString
argument_list|,
name|query
argument_list|,
name|selectedFields
argument_list|,
name|endpointType
argument_list|)
expr_stmt|;
comment|//4)add Entity Ranking (if needed)
if|if
condition|(
name|query
operator|.
name|getLimit
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|//we need also to add the sorting stuff to get the top rated entities
comment|//within the resulting graph
name|addRankingConstraints
argument_list|(
name|endpointType
argument_list|,
name|queryString
argument_list|,
name|selectedFields
operator|.
name|get
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|queryString
operator|.
name|append
argument_list|(
literal|"} \n"
argument_list|)
expr_stmt|;
name|addRankingOrder
argument_list|(
name|endpointType
argument_list|,
name|queryString
argument_list|,
name|selectedFields
operator|.
name|get
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//if no limit is given, than we do not need that stuff
comment|//so just close the where
name|queryString
operator|.
name|append
argument_list|(
literal|"} \n"
argument_list|)
expr_stmt|;
block|}
comment|//5) Limit and Offset
if|if
condition|(
name|limit
operator|>
literal|0
condition|)
block|{
name|addLimit
argument_list|(
name|limit
argument_list|,
name|queryString
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addLimit
argument_list|(
name|query
operator|.
name|getLimit
argument_list|()
operator|!=
literal|null
condition|?
name|query
operator|.
name|getLimit
argument_list|()
else|:
literal|0
argument_list|,
name|queryString
argument_list|)
expr_stmt|;
block|}
name|addOffset
argument_list|(
name|query
argument_list|,
name|queryString
argument_list|)
expr_stmt|;
return|return
name|queryString
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Creates the CONSTRUCT part of the query including the      *<code>entityhub-query:ieldQueryResultSet entityhub-query:fieldQueryResult ?representation</code>      * triples that are used to build the iterator over the results      * @param queryString The query to add the construct fields      * @param selectedFields the field name 2 variable name mapping used by the      *    query. This mapping MUST also contain the<code>null</code> key that      *    is mapped to the variable name used for the representations to be selected      */
specifier|private
specifier|static
name|void
name|createConstruct
parameter_list|(
specifier|final
name|StringBuilder
name|queryString
parameter_list|,
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|selectedFields
parameter_list|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|"CONSTRUCT { \n"
argument_list|)
expr_stmt|;
name|String
name|rootVar
init|=
name|selectedFields
operator|.
name|get
argument_list|(
literal|null
argument_list|)
decl_stmt|;
comment|//the null element has the root variable mapping
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|mapping
range|:
name|selectedFields
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|mapping
operator|.
name|getKey
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|"    ?"
argument_list|)
operator|.
name|append
argument_list|(
name|rootVar
argument_list|)
operator|.
name|append
argument_list|(
literal|"<"
argument_list|)
expr_stmt|;
name|queryString
operator|.
name|append
argument_list|(
name|mapping
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"> ?"
argument_list|)
expr_stmt|;
name|queryString
operator|.
name|append
argument_list|(
name|mapping
operator|.
name|getValue
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" .\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|//add the triples for the Representation type
comment|//add the triples that form the result set
name|queryString
operator|.
name|append
argument_list|(
literal|"<"
argument_list|)
operator|.
name|append
argument_list|(
name|RdfResourceEnum
operator|.
name|QueryResultSet
argument_list|)
operator|.
name|append
argument_list|(
literal|"><"
argument_list|)
expr_stmt|;
name|queryString
operator|.
name|append
argument_list|(
name|RdfResourceEnum
operator|.
name|queryResult
argument_list|)
operator|.
name|append
argument_list|(
literal|"> ?"
argument_list|)
expr_stmt|;
name|queryString
operator|.
name|append
argument_list|(
name|rootVar
argument_list|)
operator|.
name|append
argument_list|(
literal|" . \n"
argument_list|)
expr_stmt|;
name|queryString
operator|.
name|append
argument_list|(
literal|"} \n"
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates the SPARQL representation of the parse field query.      * @param query A field query implementation that additionally supports a field      *    to variable mapping      * @param endpointType The type of the Endpoint (used to write optimized      *    queries for endpoint type specific extensions      * @return the SPARQL query as String      */
specifier|public
specifier|static
name|String
name|createSparqlSelectQuery
parameter_list|(
name|SparqlFieldQuery
name|query
parameter_list|,
name|EndpointTypeEnum
name|endpointType
parameter_list|)
block|{
return|return
name|createSparqlSelectQuery
argument_list|(
name|query
argument_list|,
literal|true
argument_list|,
operator|-
literal|1
argument_list|,
name|endpointType
argument_list|)
return|;
block|}
comment|/**      * Creates the SPARQL representation of the parse field query.      * @param query A field query implementation that additionally supports a field      *    to variable mapping      * @param limit If> 0, than the limit parsed by the query is overriden by this      *    value      * @param endpointType The type of the Endpoint (used to write optimized      *    queries for endpoint type specific extensions      * @return the SPARQL query as String      */
specifier|public
specifier|static
name|String
name|createSparqlSelectQuery
parameter_list|(
name|SparqlFieldQuery
name|query
parameter_list|,
name|int
name|limit
parameter_list|,
name|EndpointTypeEnum
name|endpointType
parameter_list|)
block|{
return|return
name|createSparqlSelectQuery
argument_list|(
name|query
argument_list|,
literal|true
argument_list|,
name|limit
argument_list|,
name|endpointType
argument_list|)
return|;
block|}
comment|/**      * Creates the SPARQL representation of the parse field query.      * @param query A field query implementation that additionally supports a field      *    to variable mapping      * @param includeFields if<code>false</code> only the root is selected (selected fields are ignored)      * @param endpointType The type of the Endpoint (used to write optimized      *    queries for endpoint type specific extensions      * @return the SPARQL query as String      */
specifier|public
specifier|static
name|String
name|createSparqlSelectQuery
parameter_list|(
name|SparqlFieldQuery
name|query
parameter_list|,
name|boolean
name|includeFields
parameter_list|,
name|EndpointTypeEnum
name|endpointType
parameter_list|)
block|{
return|return
name|createSparqlSelectQuery
argument_list|(
name|query
argument_list|,
name|includeFields
argument_list|,
operator|-
literal|1
argument_list|,
name|endpointType
argument_list|)
return|;
block|}
comment|/**      * Creates the SPARQL representation of the parse field query.      * @param query A field query implementation that additionally supports a field      *    to variable mapping      * @param includeFields if<code>false</code> only the root is selected (selected fields are ignored)      * @param limit if> 0 than the limit defined by the query is overridden by      *    the parsed value      * @param endpointType The type of the Endpoint (used to write optimized      *    queries for endpoint type specific extensions      * @return the SPARQL query as String      */
specifier|public
specifier|static
name|String
name|createSparqlSelectQuery
parameter_list|(
name|SparqlFieldQuery
name|query
parameter_list|,
name|boolean
name|includeFields
parameter_list|,
name|int
name|limit
parameter_list|,
name|EndpointTypeEnum
name|endpointType
parameter_list|)
block|{
comment|//1) INIT
specifier|final
name|StringBuilder
name|queryString
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
comment|//We need a copy to delete all fields that are already covered by some added
comment|//graph pattern.
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|selectedFields
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|selectedFields
operator|.
name|putAll
argument_list|(
name|query
operator|.
name|getFieldVariableMappings
argument_list|()
argument_list|)
expr_stmt|;
comment|//also add the root variable
name|selectedFields
operator|.
name|put
argument_list|(
literal|null
argument_list|,
name|query
operator|.
name|getRootVariableName
argument_list|()
argument_list|)
expr_stmt|;
comment|//2) SELECT
name|createSelect
argument_list|(
name|queryString
argument_list|,
name|query
argument_list|,
name|includeFields
argument_list|,
name|selectedFields
argument_list|)
expr_stmt|;
comment|//3) WHERE
name|queryString
operator|.
name|append
argument_list|(
literal|"WHERE { \n"
argument_list|)
expr_stmt|;
name|addFieldConstraint
argument_list|(
name|queryString
argument_list|,
name|query
argument_list|,
name|selectedFields
argument_list|,
name|endpointType
argument_list|)
expr_stmt|;
comment|//4) Add Stuff to rank results based on the "page rank" of entities
name|addRankingConstraints
argument_list|(
name|endpointType
argument_list|,
name|queryString
argument_list|,
name|selectedFields
operator|.
name|get
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|queryString
operator|.
name|append
argument_list|(
literal|"} \n"
argument_list|)
expr_stmt|;
name|addRankingOrder
argument_list|(
name|endpointType
argument_list|,
name|queryString
argument_list|,
name|selectedFields
operator|.
name|get
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
comment|//5) Limit and Offset
if|if
condition|(
name|limit
operator|>
literal|0
condition|)
block|{
name|addLimit
argument_list|(
name|limit
argument_list|,
name|queryString
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addLimit
argument_list|(
name|query
operator|.
name|getLimit
argument_list|()
operator|!=
literal|null
condition|?
name|query
operator|.
name|getLimit
argument_list|()
else|:
literal|0
argument_list|,
name|queryString
argument_list|)
expr_stmt|;
block|}
name|addOffset
argument_list|(
name|query
argument_list|,
name|queryString
argument_list|)
expr_stmt|;
return|return
name|queryString
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * @param endpointType      * @param queryString      * @param selectedFields      */
specifier|private
specifier|static
name|void
name|addRankingConstraints
parameter_list|(
name|EndpointTypeEnum
name|endpointType
parameter_list|,
specifier|final
name|StringBuilder
name|queryString
parameter_list|,
specifier|final
name|String
name|rootFieldName
parameter_list|)
block|{
if|if
condition|(
name|endpointType
operator|==
name|EndpointTypeEnum
operator|.
name|ARQ
operator|||
name|endpointType
operator|==
name|EndpointTypeEnum
operator|.
name|LARQ
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"   { ?incoming ?p ?%s . } \n"
argument_list|,
name|rootFieldName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//else ... for Virtuoso we need not count incoming links, because it has a
comment|//page rank like feature we can use to rank entities!
comment|//all others do not support sorting
block|}
comment|/**      * @param endpointType      * @param queryString      */
specifier|private
specifier|static
name|void
name|addRankingOrder
parameter_list|(
name|EndpointTypeEnum
name|endpointType
parameter_list|,
specifier|final
name|StringBuilder
name|queryString
parameter_list|,
name|String
name|rootVarName
parameter_list|)
block|{
if|if
condition|(
name|endpointType
operator|==
name|EndpointTypeEnum
operator|.
name|Virtuoso
condition|)
block|{
comment|//is that still SPARQL ... wondering about the syntax ^
name|queryString
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"ORDER BY DESC (<LONG::IRI_RANK> (?%s) ) \n"
argument_list|,
name|rootVarName
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|endpointType
operator|==
name|EndpointTypeEnum
operator|.
name|ARQ
operator|||
name|endpointType
operator|==
name|EndpointTypeEnum
operator|.
name|LARQ
condition|)
block|{
comment|//TODO: COUNT is not part of the SPARQL 1.0 specification!
comment|// see http://www.w3.org/2009/sparql/wiki/Feature:AggregateFunctions
name|queryString
operator|.
name|append
argument_list|(
literal|"ORDER BY DESC (COUNT (?incoming) ) \n"
argument_list|)
expr_stmt|;
block|}
comment|//else not supported ... add nothing
block|}
comment|/**      * @param query      * @param queryString      */
specifier|private
specifier|static
name|void
name|addOffset
parameter_list|(
name|SparqlFieldQuery
name|query
parameter_list|,
specifier|final
name|StringBuilder
name|queryString
parameter_list|)
block|{
if|if
condition|(
name|query
operator|.
name|getOffset
argument_list|()
operator|>
literal|0
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"OFFSET %d \n"
argument_list|,
name|query
operator|.
name|getOffset
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * @param query      * @param queryString      */
specifier|private
specifier|static
name|void
name|addLimit
parameter_list|(
name|int
name|limit
parameter_list|,
specifier|final
name|StringBuilder
name|queryString
parameter_list|)
block|{
if|if
condition|(
name|limit
operator|>
literal|0
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"LIMIT %d \n"
argument_list|,
name|limit
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * @param queryString      * @param query      * @param includeFields      * @param selectedFields      */
specifier|private
specifier|static
name|void
name|createSelect
parameter_list|(
specifier|final
name|StringBuilder
name|queryString
parameter_list|,
name|SparqlFieldQuery
name|query
parameter_list|,
name|boolean
name|includeFields
parameter_list|,
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|selectedFields
parameter_list|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|"SELECT DISTINCT"
argument_list|)
expr_stmt|;
name|queryString
operator|.
name|append
argument_list|(
literal|" ?"
operator|+
name|query
operator|.
name|getRootVariableName
argument_list|()
argument_list|)
expr_stmt|;
comment|//select the representation ID
comment|//now the variables for the selected fields!
if|if
condition|(
name|includeFields
condition|)
block|{
for|for
control|(
name|String
name|varName
range|:
name|selectedFields
operator|.
name|values
argument_list|()
control|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|" ?"
argument_list|)
expr_stmt|;
name|queryString
operator|.
name|append
argument_list|(
name|varName
argument_list|)
expr_stmt|;
block|}
block|}
name|queryString
operator|.
name|append
argument_list|(
literal|" \n"
argument_list|)
expr_stmt|;
block|}
comment|/**      * @param queryString      * @param query      * @param selectedFields      * @param endpointType The type of the Endpoint (used to write optimized      *    queries for endpoint type specific extensions      */
specifier|private
specifier|static
name|void
name|addFieldConstraint
parameter_list|(
specifier|final
name|StringBuilder
name|queryString
parameter_list|,
name|SparqlFieldQuery
name|query
parameter_list|,
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|selectedFields
parameter_list|,
name|EndpointTypeEnum
name|endpointType
parameter_list|)
block|{
comment|//we need temporary variables with unique names
name|String
name|varPrefix
init|=
literal|"tmp"
decl_stmt|;
name|int
index|[]
name|varNum
init|=
operator|new
name|int
index|[]
block|{
literal|1
block|}
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Constraint
argument_list|>
name|fieldConstraint
range|:
name|query
control|)
block|{
name|String
name|field
init|=
name|fieldConstraint
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Constraint
name|constraint
init|=
name|fieldConstraint
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|queryString
operator|.
name|append
argument_list|(
literal|"   { "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|constraint
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|value
case|:
name|addValueConstraint
argument_list|(
name|queryString
argument_list|,
name|field
argument_list|,
operator|(
name|ValueConstraint
operator|)
name|constraint
argument_list|,
name|selectedFields
argument_list|,
name|varPrefix
argument_list|,
name|varNum
argument_list|)
expr_stmt|;
break|break;
case|case
name|text
case|:
name|String
name|var
init|=
name|addFieldGraphPattern
argument_list|(
name|queryString
argument_list|,
name|field
argument_list|,
name|selectedFields
argument_list|,
name|varPrefix
argument_list|,
name|varNum
argument_list|)
decl_stmt|;
name|addTextConstraint
argument_list|(
name|queryString
argument_list|,
name|var
argument_list|,
operator|(
name|TextConstraint
operator|)
name|constraint
argument_list|,
name|endpointType
argument_list|)
expr_stmt|;
break|break;
case|case
name|range
case|:
name|var
operator|=
name|addFieldGraphPattern
argument_list|(
name|queryString
argument_list|,
name|field
argument_list|,
name|selectedFields
argument_list|,
name|varPrefix
argument_list|,
name|varNum
argument_list|)
expr_stmt|;
name|addRangeConstriant
argument_list|(
name|queryString
argument_list|,
name|var
argument_list|,
operator|(
name|RangeConstraint
operator|)
name|constraint
argument_list|)
expr_stmt|;
break|break;
default|default:
name|log
operator|.
name|warn
argument_list|(
literal|"Please update this Implementation to support the Constraint Type "
operator|+
name|fieldConstraint
operator|.
name|getValue
argument_list|()
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
name|queryString
operator|.
name|append
argument_list|(
literal|"} \n"
argument_list|)
expr_stmt|;
block|}
comment|//we need to add graph pattern for selected field that are not covered by
comment|//graph pattern written for the constraint.
comment|//Implementation Note: selectedFields contains the null key for the root variable
while|while
condition|(
name|selectedFields
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|//if this is the only left element we are done
name|Iterator
argument_list|<
name|String
argument_list|>
name|it
init|=
name|selectedFields
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|String
name|actField
decl_stmt|;
comment|//we need to get a non null value from the map
do|do
block|{
comment|//the outer while ensures an non null value so we need not to use hasNext
name|actField
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|actField
operator|==
literal|null
condition|)
do|;
name|queryString
operator|.
name|append
argument_list|(
literal|"   { OPTIONAL { "
argument_list|)
expr_stmt|;
comment|// NOTE the following Method removes the written mapping from the Map
name|addFieldGraphPattern
argument_list|(
name|queryString
argument_list|,
name|actField
argument_list|,
name|selectedFields
argument_list|,
name|varPrefix
argument_list|,
name|varNum
argument_list|)
expr_stmt|;
name|queryString
operator|.
name|append
argument_list|(
literal|". } }\n"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|void
name|addValueConstraint
parameter_list|(
name|StringBuilder
name|queryString
parameter_list|,
name|String
name|field
parameter_list|,
name|ValueConstraint
name|constraint
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|selectedFields
parameter_list|,
name|String
name|varPrefix
parameter_list|,
name|int
index|[]
name|varNum
parameter_list|)
block|{
name|String
name|rootVarName
init|=
name|selectedFields
operator|.
name|get
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|String
argument_list|>
name|dataTypes
init|=
name|constraint
operator|.
name|getDataTypes
argument_list|()
decl_stmt|;
if|if
condition|(
name|dataTypes
operator|==
literal|null
condition|)
block|{
comment|//we need not to distinguish between empty and null
comment|//because SPARQL includes support for automatic detection of dataTypes
comment|//see http://www.w3.org/TR/rdf-sparql-query/#QSynLiterals
name|dataTypes
operator|=
name|Collections
operator|.
name|emptySet
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|constraint
operator|.
name|getValue
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|dataTypes
operator|.
name|size
argument_list|()
operator|<
literal|1
condition|)
block|{
name|addDataTypeValueConstraint
argument_list|(
name|queryString
argument_list|,
name|rootVarName
argument_list|,
name|field
argument_list|,
name|dataTypes
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|dataTypes
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|,
name|constraint
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//we have multiple dataTypes -> ned to use union!
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|String
argument_list|>
name|it
init|=
name|dataTypes
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|String
name|dataType
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|first
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|"} UNION \n     {"
argument_list|)
expr_stmt|;
block|}
name|addDataTypeValueConstraint
argument_list|(
name|queryString
argument_list|,
name|rootVarName
argument_list|,
name|field
argument_list|,
name|dataType
argument_list|,
name|constraint
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|queryString
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// no constraint for the value
comment|// filter all instances that define any value for the given dataTypes
comment|// see http://www.w3.org/TR/rdf-sparql-query/#func-datatype
comment|//first we need to select the Variable to filter
name|String
name|var
init|=
name|addFieldGraphPattern
argument_list|(
name|queryString
argument_list|,
name|field
argument_list|,
name|selectedFields
argument_list|,
name|varPrefix
argument_list|,
name|varNum
argument_list|)
decl_stmt|;
name|queryString
operator|.
name|append
argument_list|(
literal|". \n     "
argument_list|)
expr_stmt|;
comment|//now we need to write the filter
if|if
condition|(
name|dataTypes
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|addDataTypeFilter
argument_list|(
name|queryString
argument_list|,
name|var
argument_list|,
name|dataTypes
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|String
argument_list|>
name|it
init|=
name|dataTypes
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|String
name|dataType
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|"( "
argument_list|)
expr_stmt|;
name|first
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|" || \n       "
argument_list|)
expr_stmt|;
block|}
name|addDataTypeFilter
argument_list|(
name|queryString
argument_list|,
name|var
argument_list|,
name|dataType
argument_list|)
expr_stmt|;
block|}
name|queryString
operator|.
name|append
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Adds a filter that restricts the data type to an variable      * @param queryString the query String to add the filter. MUST NOT be<code>null</code>      * @param var the variable to add the filter. MUST NOT be<code>null</code>      * @param dataTypes the data type uri for the filter. MUST NOT be<code>null</code>      */
specifier|private
specifier|static
name|void
name|addDataTypeFilter
parameter_list|(
name|StringBuilder
name|queryString
parameter_list|,
name|String
name|var
parameter_list|,
name|String
name|dataType
parameter_list|)
block|{
name|queryString
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"(FILTER(datatype(?%s) =<%s>)"
argument_list|,
name|var
argument_list|,
name|dataType
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Adds a value constraint for a field including the dataType      * @param queryString the query string to add the constraint.  MUST NOT be<code>null</code>      * @param rootVarName the variable name of the subject.  MUST NOT be<code>null</code>      * @param field the property name of the field. MUST NOT be<code>null</code>      * @param dataType the dataType constraint or<code>null</code> if none      * @param value the value. MUST NOT be<code>null</code>.      */
specifier|private
specifier|static
name|void
name|addDataTypeValueConstraint
parameter_list|(
name|StringBuilder
name|queryString
parameter_list|,
name|String
name|rootVarName
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|dataType
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|DataTypeEnum
operator|.
name|Reference
operator|.
name|getUri
argument_list|()
operator|.
name|equals
argument_list|(
name|dataType
argument_list|)
operator|||
name|value
operator|instanceof
name|Reference
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"?%s<%s><%s> "
argument_list|,
name|rootVarName
argument_list|,
name|field
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|queryString
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"?%s<%s> \"%s\"%s "
argument_list|,
name|rootVarName
argument_list|,
name|field
argument_list|,
name|value
argument_list|,
name|dataType
operator|!=
literal|null
condition|?
name|String
operator|.
name|format
argument_list|(
literal|"^^<%s>"
argument_list|,
name|dataType
argument_list|)
else|:
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Adds an text constraint to the SPARQL query string      * @param queryString the query string to add the constraint      * @param var the variable name to constrain      * @param constraint the constraint      * @param endpointType The type of the Endpoint (used to write optimized      *    queries for endpoint type specific extensions      */
specifier|private
specifier|static
name|void
name|addTextConstraint
parameter_list|(
name|StringBuilder
name|queryString
parameter_list|,
name|String
name|var
parameter_list|,
name|TextConstraint
name|constraint
parameter_list|,
name|EndpointTypeEnum
name|endpointType
parameter_list|)
block|{
name|boolean
name|filterAdded
init|=
literal|false
decl_stmt|;
name|boolean
name|isTextValueConstraint
init|=
name|constraint
operator|.
name|getText
argument_list|()
operator|!=
literal|null
operator|&&
name|constraint
operator|.
name|getText
argument_list|()
operator|.
name|length
argument_list|()
operator|>
literal|0
decl_stmt|;
if|if
condition|(
name|isTextValueConstraint
condition|)
block|{
if|if
condition|(
name|constraint
operator|.
name|getPatternType
argument_list|()
operator|==
name|PatternType
operator|.
name|regex
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|" \n     FILTER("
argument_list|)
expr_stmt|;
name|filterAdded
operator|=
literal|true
expr_stmt|;
name|addRegexFilter
argument_list|(
name|queryString
argument_list|,
name|var
argument_list|,
name|constraint
operator|.
name|getText
argument_list|()
argument_list|,
name|constraint
operator|.
name|isCaseSensitive
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//TODO: This optimised versions for Virtuoso and LARQ might not
comment|//      respect case sensitive queries. Need more testing!
if|if
condition|(
name|EndpointTypeEnum
operator|.
name|Virtuoso
operator|==
name|endpointType
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|". \n"
argument_list|)
expr_stmt|;
name|queryString
operator|.
name|append
argument_list|(
literal|"     "
argument_list|)
expr_stmt|;
name|queryString
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"?%s bif:contains '\"%s\"' . "
argument_list|,
name|var
argument_list|,
name|constraint
operator|.
name|getText
argument_list|()
operator|.
name|replace
argument_list|(
literal|"'"
argument_list|,
literal|" "
argument_list|)
comment|//escape search string to avoid breaking the SPARQL query!
operator|.
name|replace
argument_list|(
literal|" "
argument_list|,
literal|" AND "
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|//q.append("ORDER BY DESC (<LONG::IRI_RANK> (?uri) ) ");
block|}
elseif|else
if|if
condition|(
name|EndpointTypeEnum
operator|.
name|LARQ
operator|==
name|endpointType
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|". \n"
argument_list|)
expr_stmt|;
name|queryString
operator|.
name|append
argument_list|(
literal|"     "
argument_list|)
expr_stmt|;
name|queryString
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"?%s<http://jena.hpl.hp.com/ARQ/property#textMatch> '+%s' . "
argument_list|,
name|var
argument_list|,
name|constraint
operator|.
name|getText
argument_list|()
operator|.
name|replace
argument_list|(
literal|"'"
argument_list|,
literal|" "
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|//q.append("?incoming ?p ?uri . } ");
comment|//q.append("ORDER BY DESC (COUNT (?incoming) ) ");
block|}
else|else
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|" \n     FILTER("
argument_list|)
expr_stmt|;
name|filterAdded
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|constraint
operator|.
name|getPatternType
argument_list|()
operator|==
name|PatternType
operator|.
name|none
condition|)
block|{
if|if
condition|(
name|constraint
operator|.
name|isCaseSensitive
argument_list|()
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"(str(?%s) = \"%s\")"
argument_list|,
name|var
argument_list|,
name|constraint
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|regexQueryText
init|=
name|PatternUtils
operator|.
name|value2Regex
argument_list|(
name|constraint
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|addRegexFilter
argument_list|(
name|queryString
argument_list|,
name|var
argument_list|,
name|regexQueryText
argument_list|,
name|constraint
operator|.
name|isCaseSensitive
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|constraint
operator|.
name|getPatternType
argument_list|()
operator|==
name|PatternType
operator|.
name|wildcard
condition|)
block|{
comment|//parse false, because that is more in line with the expectations of users!
name|String
name|regexQueryText
init|=
name|PatternUtils
operator|.
name|wildcardToRegex
argument_list|(
name|constraint
operator|.
name|getText
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|addRegexFilter
argument_list|(
name|queryString
argument_list|,
name|var
argument_list|,
name|regexQueryText
argument_list|,
name|constraint
operator|.
name|isCaseSensitive
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unspported Patterntype "
operator|+
name|constraint
operator|.
name|getPatternType
argument_list|()
operator|+
literal|"! Change this impplementation to support this type! -> treat constaint \""
operator|+
name|constraint
operator|.
name|getText
argument_list|()
operator|+
literal|"\"as REGEX"
argument_list|)
expr_stmt|;
name|addRegexFilter
argument_list|(
name|queryString
argument_list|,
name|var
argument_list|,
name|constraint
operator|.
name|getText
argument_list|()
argument_list|,
name|constraint
operator|.
name|isCaseSensitive
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|//else nothing to do
comment|//add language Filters
comment|//TODO check if FILTER ( is already written!
if|if
condition|(
name|constraint
operator|.
name|getLanguages
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|constraint
operator|.
name|getLanguages
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|filterAdded
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|" \n     FILTER("
argument_list|)
expr_stmt|;
name|filterAdded
operator|=
literal|true
expr_stmt|;
name|writeLanguagesFilter
argument_list|(
name|queryString
argument_list|,
name|constraint
operator|.
name|getLanguages
argument_list|()
argument_list|,
name|var
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writeLanguagesFilter
argument_list|(
name|queryString
argument_list|,
name|constraint
operator|.
name|getLanguages
argument_list|()
argument_list|,
name|var
argument_list|,
literal|"&& "
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|filterAdded
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
comment|//close the FILTER and the graph pattern
block|}
block|}
comment|/**      * Adds a SPARQL regex filter to the parsed query string      * @param queryString the string builder to add the constraint      * @param var the variable to constrain      * @param regexQueryText the regex encoded search string      * @param isCasesensitive if the constraint is case sensitive or not      */
specifier|private
specifier|static
name|void
name|addRegexFilter
parameter_list|(
name|StringBuilder
name|queryString
parameter_list|,
name|String
name|var
parameter_list|,
name|String
name|regexQueryText
parameter_list|,
name|boolean
name|isCasesensitive
parameter_list|)
block|{
name|queryString
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"regex(str(?%s),\"%s\"%s)"
argument_list|,
name|var
argument_list|,
name|regexQueryText
argument_list|,
name|isCasesensitive
condition|?
literal|""
else|:
literal|",\"i\""
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Adds an RangeConstraint to the parsed query String      * @param queryString the query to add the constraint      * @param var the variable to constrain      * @param constraint the constraint      */
specifier|private
specifier|static
name|void
name|addRangeConstriant
parameter_list|(
name|StringBuilder
name|queryString
parameter_list|,
name|String
name|var
parameter_list|,
name|RangeConstraint
name|constraint
parameter_list|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|"\n     FILTER "
argument_list|)
expr_stmt|;
comment|//start the FILTER
name|boolean
name|closedRange
init|=
name|constraint
operator|.
name|getLowerBound
argument_list|()
operator|!=
literal|null
operator|&&
name|constraint
operator|.
name|getUpperBound
argument_list|()
operator|!=
literal|null
decl_stmt|;
if|if
condition|(
name|closedRange
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
block|}
comment|//write lower and upper bounds
if|if
condition|(
name|constraint
operator|.
name|getLowerBound
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|addRangeBound
argument_list|(
name|queryString
argument_list|,
name|var
argument_list|,
literal|true
argument_list|,
name|constraint
operator|.
name|isInclusive
argument_list|()
argument_list|,
name|constraint
operator|.
name|getLowerBound
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|closedRange
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|"&& "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|constraint
operator|.
name|getUpperBound
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|addRangeBound
argument_list|(
name|queryString
argument_list|,
name|var
argument_list|,
literal|false
argument_list|,
name|constraint
operator|.
name|isInclusive
argument_list|()
argument_list|,
name|constraint
operator|.
name|getUpperBound
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|closedRange
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Adds a lower/upper bound constraint to the query String      * @param queryString the query string      * @param var the variable      * @param lowerBound<code>true</code> to add the lower bound and      *<code>false</code> to add the upper bound      * @param inclusive if the bound is inclusive (>= or<=)      * @param value the value representing the bound.      */
specifier|private
specifier|static
name|void
name|addRangeBound
parameter_list|(
name|StringBuilder
name|queryString
parameter_list|,
name|String
name|var
parameter_list|,
name|boolean
name|lowerBound
parameter_list|,
name|boolean
name|inclusive
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|String
name|stringValue
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Date
condition|)
block|{
comment|//for dates add the data type!
name|stringValue
operator|=
name|String
operator|.
name|format
argument_list|(
literal|"%s^^<%s>"
argument_list|,
name|DATE_FORMAT
operator|.
name|format
argument_list|(
operator|(
name|Date
operator|)
name|value
argument_list|)
argument_list|,
name|XSD_DATE_TIME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//add additional  "if" for special types if necessary
name|stringValue
operator|=
name|value
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
comment|//adds (?var>/<[=] valueString)
name|queryString
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"(?%s %c%s %s)"
argument_list|,
name|var
argument_list|,
name|lowerBound
condition|?
literal|'>'
else|:
literal|'<'
argument_list|,
name|inclusive
condition|?
literal|"="
else|:
literal|""
argument_list|,
name|stringValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Adds a S P O pattern to the query by using the root as subject, the parsed      * field as predicate and the returned variable as object. This method doese      * not open a '{' nor close the pattern with any of '.', ',' or ';'      * @param queryString the {@link StringBuilder} to add the pattern      * @param field the field      * @param selectedFields the map field -> var of the selected variables. If      *    the parsed field is selected, the field is removed from the list and      *    the mapped variable name is returned      * @param varPrefix the default prefix for newly created variable names      * @param varNum The first element of the array is used to get the number of      *    the created variable. If one is created the value of the first element is      *    increased by one      * @return The variable name used for the object of the pattern      */
specifier|private
specifier|static
name|String
name|addFieldGraphPattern
parameter_list|(
name|StringBuilder
name|queryString
parameter_list|,
name|String
name|field
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|selectedFields
parameter_list|,
name|String
name|varPrefix
parameter_list|,
name|int
index|[]
name|varNum
parameter_list|)
block|{
name|String
name|var
init|=
name|selectedFields
operator|.
name|remove
argument_list|(
name|field
argument_list|)
decl_stmt|;
comment|//check if the field is selected
if|if
condition|(
name|var
operator|==
literal|null
condition|)
block|{
comment|//this field is not selected
comment|//we need to generate a temp var
name|var
operator|=
name|varPrefix
operator|+
name|varNum
index|[
literal|0
index|]
expr_stmt|;
name|varNum
index|[
literal|0
index|]
operator|++
expr_stmt|;
block|}
name|queryString
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"?%s<%s> ?%s "
argument_list|,
name|selectedFields
operator|.
name|get
argument_list|(
literal|null
argument_list|)
argument_list|,
name|field
argument_list|,
name|var
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|var
return|;
block|}
comment|/**      * Writes the SPARQL FILTER for the parsed languages.      * This Method writes      *<code><pre>      *      prefix ((lang(?var) = "lang1") [|| (lang(?var) = "lang2..n")])      *</pre></code>      * @param queryString the query string to add the FILTER      * @param languages the languages to filter for (may contain<code>null</code> as element)      * @param var the name of the variable to filter.      * @param prefix The prefix is written in front of the filter expression (if any is created).      *        Typically this will be<ul>      *<li> FILTER if this is the only filter for an variable      *<li>&& if this filter is combined with AND to an other filter or      *<li> || if this filter is combined wit OR to an other filter      *</ul>      */
specifier|private
specifier|static
name|void
name|writeLanguagesFilter
parameter_list|(
name|StringBuilder
name|queryString
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|languages
parameter_list|,
name|String
name|var
parameter_list|,
name|String
name|prefix
parameter_list|)
block|{
if|if
condition|(
name|languages
operator|!=
literal|null
operator|&&
operator|!
name|languages
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|prefix
operator|!=
literal|null
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|languages
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
block|}
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|String
name|language
range|:
name|languages
control|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|" || "
argument_list|)
expr_stmt|;
block|}
name|queryString
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"(lang(?%s) = \"%s\")"
argument_list|,
name|var
argument_list|,
name|language
operator|!=
literal|null
condition|?
name|language
else|:
literal|""
argument_list|)
argument_list|)
expr_stmt|;
comment|/*                  * NOTE: the lang() returns "" for literals without an language                  *       tag. Because of that if the language == null we need                  *       to parse "" as an argument                  */
block|}
if|if
condition|(
name|languages
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*    public static void main(String[] args) {         SparqlFieldQuery query = SparqlFieldQueryFactory.getInstance().createFieldQuery();         query.setConstraint("urn:field1", new ReferenceConstraint("urn:testReference"));         query.setConstraint("urn:field1a", new ValueConstraint(null, Arrays.asList(                 DataTypeEnum.Float.getUri())));         query.setConstraint("urn:field1b", new ValueConstraint(9, Arrays.asList(                 DataTypeEnum.Float.getUri())));         query.setConstraint("urn:field1c", new ValueConstraint(null, Arrays.asList(                 DataTypeEnum.Float.getUri(),DataTypeEnum.Double.getUri(),DataTypeEnum.Decimal.getUri())));         query.setConstraint("urn:field1d", new ValueConstraint(9, Arrays.asList(                 DataTypeEnum.Float.getUri(),DataTypeEnum.Double.getUri(),DataTypeEnum.Decimal.getUri()))); //        query.setConstraint("urn:field2", new TextConstraint("test value")); //        query.setConstraint("urn:field3", new TextConstraint("text value",true)); //        query.setConstraint("urn:field2a", new TextConstraint(":-]")); //tests escaping of REGEX //        query.setConstraint("urn:field3", new TextConstraint("language text","en")); //        query.setConstraint("urn:field4", new TextConstraint("multi language text","en","de",null)); //        query.setConstraint("urn:field5", new TextConstraint("wildcar*",PatternType.wildcard,false,"en")); //        query.setConstraint("urn:field6", new TextConstraint("^regex",PatternType.REGEX,true)); //        query.setConstraint("urn:field7", new TextConstraint("par*",PatternType.WildCard,false,"en","de",null)); //        query.setConstraint("urn:field8", new TextConstraint(null,"en","de",null)); //        query.setConstraint("urn:field9", new RangeConstraint((int)5, (int)10, true)); //        query.setConstraint("urn:field10", new RangeConstraint((int)5, (int)10, false)); //        query.setConstraint("urn:field11", new RangeConstraint(null, (int)10, true)); //        query.setConstraint("urn:field12", new RangeConstraint((int)5, null, true)); //        query.setConstraint("urn:field12", new RangeConstraint(new Date(), null, true)); //        query.addSelectedField("urn:field2a"); //        query.addSelectedField("urn:field3");         query.setLimit(5);         query.setOffset(5);         System.out.println(createSparqlSelectQuery(query,true,0,EndpointTypeEnum.LARQ));         System.out.println();         System.out.println(createSparqlSelectQuery(query,true,0,EndpointTypeEnum.Virtuoso));         System.out.println();         System.out.println(createSparqlSelectQuery(query,true,0,EndpointTypeEnum.Standard));         System.out.println();         System.out.println(createSparqlConstructQuery(query,0,EndpointTypeEnum.Virtuoso));     }*/
comment|/**      * @param query      * @param resultGraph      * @return      */
specifier|public
specifier|static
name|Iterator
argument_list|<
name|RdfRepresentation
argument_list|>
name|parseQueryResultsFromMGraph
parameter_list|(
specifier|final
name|TripleCollection
name|resultGraph
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|resultTripleIterator
init|=
name|resultGraph
operator|.
name|filter
argument_list|(
name|FIELD_QUERY_RESULT_SET
argument_list|,
name|FIELD_QUERY_RESULT
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|RdfRepresentation
argument_list|>
name|resultIterator
init|=
operator|new
name|AdaptingIterator
argument_list|<
name|Triple
argument_list|,
name|RdfRepresentation
argument_list|>
argument_list|(
name|resultTripleIterator
argument_list|,
operator|new
name|AdaptingIterator
operator|.
name|Adapter
argument_list|<
name|Triple
argument_list|,
name|RdfRepresentation
argument_list|>
argument_list|()
block|{
comment|/*                      * Anonymous implementation of an Adapter that converts the filtered                      * Triples of the resulting graph to RdfRepresentations                      */
annotation|@
name|Override
specifier|public
name|RdfRepresentation
name|adapt
parameter_list|(
name|Triple
name|value
parameter_list|,
name|Class
argument_list|<
name|RdfRepresentation
argument_list|>
name|type
parameter_list|)
block|{
name|Resource
name|object
init|=
name|value
operator|.
name|getObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|object
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|object
operator|instanceof
name|UriRef
condition|)
block|{
return|return
name|valueFavtory
operator|.
name|createRdfRepresentation
argument_list|(
operator|(
name|UriRef
operator|)
name|object
argument_list|,
name|resultGraph
argument_list|)
return|;
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to create representation for FieldQueryResult "
operator|+
name|object
operator|+
literal|" because this Resource is not of Type UriRef (type: "
operator|+
name|object
operator|.
name|getClass
argument_list|()
operator|+
literal|") -> result gets ignored"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
block|}
argument_list|,
name|RdfRepresentation
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|resultIterator
return|;
block|}
block|}
end_class

end_unit

