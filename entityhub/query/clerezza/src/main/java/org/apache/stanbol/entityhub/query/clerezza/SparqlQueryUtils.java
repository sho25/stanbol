begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|query
operator|.
name|clerezza
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|defaults
operator|.
name|SpecialFieldEnum
operator|.
name|isSpecialField
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|DateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Triple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|TripleCollection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|UriRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|impl
operator|.
name|util
operator|.
name|W3CDateFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|core
operator|.
name|utils
operator|.
name|AdaptingIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|model
operator|.
name|clerezza
operator|.
name|RdfRepresentation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|model
operator|.
name|clerezza
operator|.
name|RdfValueFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|defaults
operator|.
name|DataTypeEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|defaults
operator|.
name|NamespaceEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|defaults
operator|.
name|SpecialFieldEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Reference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|rdf
operator|.
name|RdfResourceEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|Constraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|RangeConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|ReferenceConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|TextConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|ValueConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|TextConstraint
operator|.
name|PatternType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|ValueConstraint
operator|.
name|MODE
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|util
operator|.
name|PatternUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Utility Class to create SPARQL Queries for {@link SparqlFieldQuery} instances.  *<p>  * Thanks to ogrisel for pointing me to his<a href=  * "http://hg.nuxeo.org/sandbox/scribo/raw-file/b57ada956947/scribo-annotator-recognizer-sparql-ep/src/main/java/ws/scribo/annotators/recognizer/SparqlEndpointInstanceRecognizer.java"  *> SparqlEndpointInstanceRecognizer</a> implementation for the query optimisations for Virtuoso and LARQ!  *   * @author Rupert Westenthaler  *   */
end_comment

begin_class
specifier|public
specifier|final
class|class
name|SparqlQueryUtils
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SparqlQueryUtils
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
enum|enum
name|EndpointTypeEnum
block|{
name|Standard
block|,
name|Virtuoso
argument_list|(
literal|true
argument_list|)
block|,
name|LARQ
block|,
name|ARQ
block|;
name|boolean
name|supportsSparql11SubSelect
decl_stmt|;
comment|/**          * Default feature set (SPARQL 1.0)          */
name|EndpointTypeEnum
parameter_list|()
block|{
name|this
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**          * Allows to enable SPARQL 1.1 features          *           * @param supportsSparql11SubSelect          */
name|EndpointTypeEnum
parameter_list|(
name|boolean
name|supportsSparql11SubSelect
parameter_list|)
block|{
name|this
operator|.
name|supportsSparql11SubSelect
operator|=
name|supportsSparql11SubSelect
expr_stmt|;
block|}
specifier|public
specifier|final
name|boolean
name|supportsSubSelect
parameter_list|()
block|{
return|return
name|supportsSparql11SubSelect
return|;
block|}
block|}
specifier|private
specifier|static
specifier|final
name|String
name|XSD_DATE_TIME
init|=
literal|"http://www.w3.org/2001/XMLSchema#dateTime"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|DateFormat
name|DATE_FORMAT
init|=
operator|new
name|W3CDateFormat
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|RdfValueFactory
name|valueFavtory
init|=
name|RdfValueFactory
operator|.
name|getInstance
argument_list|()
decl_stmt|;
comment|/**      * {@link UriRef} constant for {@link RdfResourceEnum#queryResult}      *       * @see RdfResourceEnum.fieldQueryResult      */
specifier|public
specifier|static
specifier|final
name|UriRef
name|FIELD_QUERY_RESULT
init|=
operator|new
name|UriRef
argument_list|(
name|RdfResourceEnum
operator|.
name|queryResult
operator|.
name|getUri
argument_list|()
argument_list|)
decl_stmt|;
comment|/**      * {@link UriRef} constant for {@link RdfResourceEnum#QueryResultSet}      *       * @see RdfResourceEnum.FieldQueryResultSet      */
specifier|public
specifier|static
specifier|final
name|UriRef
name|FIELD_QUERY_RESULT_SET
init|=
operator|new
name|UriRef
argument_list|(
name|RdfResourceEnum
operator|.
name|QueryResultSet
operator|.
name|getUri
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
name|SparqlQueryUtils
parameter_list|()
block|{}
comment|/**      * Creates a SPARWL CONSTRUCT query that creates triples for all the selected fields of representations in      * the result set.      *<p>      * In addition the query also constructs<code>entityhub-query:ieldQueryResultSet      * entityhub-query:fieldQueryResult ?representation</code> triples that can be used to create an iterator      * over the results of the query      *       * @param query      *            the field query      * @param endpointType      *            The type of the Endpoint (used to write optimized queries for endpoint type specific      *            extensions      * @param additionalFields      *            This allows to parse additional fields that are optionally selected in the data set and      *            added to the CONSTRUCT part of the query      * @return the SPARQL CONSTRUCT Query      */
specifier|public
specifier|static
name|String
name|createSparqlConstructQuery
parameter_list|(
name|SparqlFieldQuery
name|query
parameter_list|,
name|EndpointTypeEnum
name|endpointType
parameter_list|,
name|String
modifier|...
name|additionalFields
parameter_list|)
block|{
return|return
name|createSparqlConstructQuery
argument_list|(
name|query
argument_list|,
operator|-
literal|1
argument_list|,
name|endpointType
argument_list|,
name|additionalFields
argument_list|)
return|;
block|}
comment|/**      * Creates a SPARWL CONSTRUCT query that creates triples for all the selected fields of representations in      * the result set.      *<p>      * In addition the query also constructs<code>entityhub-query:ieldQueryResultSet      * entityhub-query:fieldQueryResult ?representation</code> triples that can be used to create an iterator      * over the results of the query      *       * @param query      *            the field query      * @param limit      *            if a value> 0 is parsed, than this value overwrites the limit defined by the query.      * @param endpointType      *            The type of the Endpoint (used to write optimized queries for endpoint type specific      *            extensions      * @param additionalFields      *            This allows to parse additional fields that are optionally selected in the data set and      *            added to the CONSTRUCT part of the query      * @return the SPARQL CONSTRUCT Query      */
specifier|public
specifier|static
name|String
name|createSparqlConstructQuery
parameter_list|(
name|SparqlFieldQuery
name|query
parameter_list|,
name|int
name|limit
parameter_list|,
name|EndpointTypeEnum
name|endpointType
parameter_list|,
name|String
modifier|...
name|additionalFields
parameter_list|)
block|{
comment|// 1)INIT
specifier|final
name|StringBuilder
name|queryString
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
comment|// clone the query and reconfigure the clone
name|query
operator|=
name|initLocalQuery
argument_list|(
name|query
argument_list|,
name|limit
argument_list|,
name|additionalFields
argument_list|)
expr_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|selectedFields
init|=
name|initSelectedFieldsMap
argument_list|(
name|query
argument_list|)
decl_stmt|;
comment|// 2)CONSTRUCT
name|createConstruct
argument_list|(
name|queryString
argument_list|,
name|selectedFields
argument_list|)
expr_stmt|;
comment|// 3)WHERE
name|queryString
operator|.
name|append
argument_list|(
literal|"WHERE { \n"
argument_list|)
expr_stmt|;
name|addFieldConstraint
argument_list|(
name|queryString
argument_list|,
name|query
argument_list|,
name|selectedFields
argument_list|,
name|endpointType
argument_list|)
expr_stmt|;
name|queryString
operator|.
name|append
argument_list|(
literal|"} \n"
argument_list|)
expr_stmt|;
comment|// 5) Limit and Offset
if|if
condition|(
operator|!
name|isSubSelectState
argument_list|(
name|endpointType
argument_list|,
name|selectedFields
argument_list|)
condition|)
block|{
comment|// 4)add Entity Ranking (if needed)
name|addRankingOrder
argument_list|(
name|endpointType
argument_list|,
name|queryString
argument_list|,
name|selectedFields
operator|.
name|get
argument_list|(
literal|null
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|addLimit
argument_list|(
name|query
operator|.
name|getLimit
argument_list|()
operator|!=
literal|null
condition|?
name|query
operator|.
name|getLimit
argument_list|()
else|:
literal|0
argument_list|,
name|queryString
argument_list|)
expr_stmt|;
name|addOffset
argument_list|(
name|query
argument_list|,
name|queryString
argument_list|)
expr_stmt|;
block|}
return|return
name|queryString
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Determines if the current query uses sub selects. Activated if the SPARQL endpoint supports the SPARQL      * 1.1 sub select feature and the query selects more than the enttiy id.      *       * @param endpoint      *            the used endpoint type      * @param selectedFields      *            the map with the selected fields      * @return the state      */
specifier|private
specifier|static
name|boolean
name|isSubSelectState
parameter_list|(
name|EndpointTypeEnum
name|endpoint
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|selectedFields
parameter_list|)
block|{
return|return
name|endpoint
operator|.
name|supportsSubSelect
argument_list|()
operator|&&
name|selectedFields
operator|.
name|size
argument_list|()
operator|>
literal|1
return|;
block|}
comment|/**      * Creates a clone of the parsed query and applies the parsed limit and additional fields      *       * @param query      *            the query      * @param limit      *            the limit (if&gt; 0)      * @param additionalFields      *            additional fields to select      * @return a clone of the parsed query with the set limit and added fields      */
specifier|private
specifier|static
name|SparqlFieldQuery
name|initLocalQuery
parameter_list|(
name|SparqlFieldQuery
name|query
parameter_list|,
name|int
name|limit
parameter_list|,
name|String
modifier|...
name|additionalFields
parameter_list|)
block|{
name|query
operator|=
name|query
operator|.
name|clone
argument_list|()
expr_stmt|;
if|if
condition|(
name|limit
operator|>
literal|0
condition|)
block|{
name|query
operator|.
name|setLimit
argument_list|(
name|limit
argument_list|)
expr_stmt|;
block|}
comment|// We need a copy to delete all fields that are already covered by some
comment|// added
comment|// graph pattern.
if|if
condition|(
name|additionalFields
operator|!=
literal|null
operator|&&
name|additionalFields
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|query
operator|.
name|addSelectedFields
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|additionalFields
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|query
return|;
block|}
comment|/**      * Creates the CONSTRUCT part of the query including the      *<code>entityhub-query:ieldQueryResultSet entityhub-query:fieldQueryResult ?representation</code>      * triples that are used to build the iterator over the results      *       * @param queryString      *            The query to add the construct fields      * @param selectedFields      *            the field name 2 variable name mapping used by the query. This mapping MUST also contain the      *<code>null</code> key that is mapped to the variable name used for the representations to be      *            selected      */
specifier|private
specifier|static
name|void
name|createConstruct
parameter_list|(
specifier|final
name|StringBuilder
name|queryString
parameter_list|,
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|selectedFields
parameter_list|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|"CONSTRUCT { \n"
argument_list|)
expr_stmt|;
name|String
name|rootVar
init|=
name|selectedFields
operator|.
name|get
argument_list|(
literal|null
argument_list|)
decl_stmt|;
comment|// the null element has the
comment|// root variable mapping
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|mapping
range|:
name|selectedFields
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|mapping
operator|.
name|getKey
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|"  ?"
argument_list|)
operator|.
name|append
argument_list|(
name|rootVar
argument_list|)
operator|.
name|append
argument_list|(
literal|"<"
argument_list|)
expr_stmt|;
name|queryString
operator|.
name|append
argument_list|(
name|mapping
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"> ?"
argument_list|)
expr_stmt|;
name|queryString
operator|.
name|append
argument_list|(
name|mapping
operator|.
name|getValue
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" .\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// add the triples for the Representation type
comment|// add the triples that form the result set
name|queryString
operator|.
name|append
argument_list|(
literal|"<"
argument_list|)
operator|.
name|append
argument_list|(
name|RdfResourceEnum
operator|.
name|QueryResultSet
argument_list|)
operator|.
name|append
argument_list|(
literal|"><"
argument_list|)
expr_stmt|;
name|queryString
operator|.
name|append
argument_list|(
name|RdfResourceEnum
operator|.
name|queryResult
argument_list|)
operator|.
name|append
argument_list|(
literal|"> ?"
argument_list|)
expr_stmt|;
name|queryString
operator|.
name|append
argument_list|(
name|rootVar
argument_list|)
operator|.
name|append
argument_list|(
literal|" . \n"
argument_list|)
expr_stmt|;
name|queryString
operator|.
name|append
argument_list|(
literal|"} "
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates the SPARQL representation of the parse field query.      *       * @param query      *            A field query implementation that additionally supports a field to variable mapping      * @param endpointType      *            The type of the Endpoint (used to write optimized queries for endpoint type specific      *            extensions      * @return the SPARQL query as String      */
specifier|public
specifier|static
name|String
name|createSparqlSelectQuery
parameter_list|(
name|SparqlFieldQuery
name|query
parameter_list|,
name|EndpointTypeEnum
name|endpointType
parameter_list|)
block|{
return|return
name|createSparqlSelectQuery
argument_list|(
name|query
argument_list|,
literal|true
argument_list|,
operator|-
literal|1
argument_list|,
name|endpointType
argument_list|)
return|;
block|}
comment|/**      * Creates the SPARQL representation of the parse field query.      *       * @param query      *            A field query implementation that additionally supports a field to variable mapping      * @param limit      *            If> 0, than the limit parsed by the query is overriden by this value      * @param endpointType      *            The type of the Endpoint (used to write optimized queries for endpoint type specific      *            extensions      * @return the SPARQL query as String      */
specifier|public
specifier|static
name|String
name|createSparqlSelectQuery
parameter_list|(
name|SparqlFieldQuery
name|query
parameter_list|,
name|int
name|limit
parameter_list|,
name|EndpointTypeEnum
name|endpointType
parameter_list|)
block|{
return|return
name|createSparqlSelectQuery
argument_list|(
name|query
argument_list|,
literal|true
argument_list|,
name|limit
argument_list|,
name|endpointType
argument_list|)
return|;
block|}
comment|/**      * Creates the SPARQL representation of the parse field query.      *       * @param query      *            A field query implementation that additionally supports a field to variable mapping      * @param includeFields      *            if<code>false</code> only the root is selected (selected fields are ignored)      * @param endpointType      *            The type of the Endpoint (used to write optimized queries for endpoint type specific      *            extensions      * @return the SPARQL query as String      */
specifier|public
specifier|static
name|String
name|createSparqlSelectQuery
parameter_list|(
name|SparqlFieldQuery
name|query
parameter_list|,
name|boolean
name|includeFields
parameter_list|,
name|EndpointTypeEnum
name|endpointType
parameter_list|)
block|{
return|return
name|createSparqlSelectQuery
argument_list|(
name|query
argument_list|,
name|includeFields
argument_list|,
operator|-
literal|1
argument_list|,
name|endpointType
argument_list|)
return|;
block|}
comment|/**      * Creates the SPARQL representation of the parse field query.      *       * @param query      *            A field query implementation that additionally supports a field to variable mapping      * @param includeFields      *            if<code>false</code> only the root is selected (selected fields are ignored)      * @param limit      *            if> 0 than the limit defined by the query is overridden by the parsed value      * @param endpointType      *            The type of the Endpoint (used to write optimized queries for endpoint type specific      *            extensions      * @return the SPARQL query as String      */
specifier|public
specifier|static
name|String
name|createSparqlSelectQuery
parameter_list|(
name|SparqlFieldQuery
name|query
parameter_list|,
name|boolean
name|includeFields
parameter_list|,
name|int
name|limit
parameter_list|,
name|EndpointTypeEnum
name|endpointType
parameter_list|)
block|{
comment|// 1) INIT
specifier|final
name|StringBuilder
name|queryString
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|query
operator|=
name|initLocalQuery
argument_list|(
name|query
argument_list|,
name|limit
argument_list|)
expr_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|selectedFields
init|=
name|initSelectedFieldsMap
argument_list|(
name|query
argument_list|)
decl_stmt|;
comment|// 2) SELECT
name|createSelect
argument_list|(
name|queryString
argument_list|,
name|includeFields
argument_list|,
name|selectedFields
argument_list|)
expr_stmt|;
comment|// 3) WHERE
name|queryString
operator|.
name|append
argument_list|(
literal|"WHERE { \n"
argument_list|)
expr_stmt|;
name|addFieldConstraint
argument_list|(
name|queryString
argument_list|,
name|query
argument_list|,
name|selectedFields
argument_list|,
name|endpointType
argument_list|)
expr_stmt|;
name|log
operator|.
name|trace
argument_list|(
literal|"After adding field constrains the query string is [{}]."
argument_list|,
name|queryString
argument_list|)
expr_stmt|;
name|queryString
operator|.
name|append
argument_list|(
literal|"} \n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isSubSelectState
argument_list|(
name|endpointType
argument_list|,
name|selectedFields
argument_list|)
condition|)
block|{
comment|// 4) Add Stuff to rank results based on the "page rank" of entities
name|addRankingOrder
argument_list|(
name|endpointType
argument_list|,
name|queryString
argument_list|,
name|selectedFields
operator|.
name|get
argument_list|(
literal|null
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|// 5) Limit and Offset
name|addLimit
argument_list|(
name|query
operator|.
name|getLimit
argument_list|()
operator|!=
literal|null
condition|?
name|query
operator|.
name|getLimit
argument_list|()
else|:
literal|0
argument_list|,
name|queryString
argument_list|)
expr_stmt|;
name|addOffset
argument_list|(
name|query
argument_list|,
name|queryString
argument_list|)
expr_stmt|;
block|}
return|return
name|queryString
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Initialise the field -&gt; variable name mappings including the root variable name by adding      *<code>null</code> as key      *       * @param query      *            the query      * @return the mappings      */
specifier|private
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|initSelectedFieldsMap
parameter_list|(
name|SparqlFieldQuery
name|query
parameter_list|)
block|{
comment|// We need a copy to delete all fields that are already covered by some
comment|// added
comment|// graph pattern.
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|selectedFields
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|selectedFields
operator|.
name|putAll
argument_list|(
name|query
operator|.
name|getFieldVariableMappings
argument_list|()
argument_list|)
expr_stmt|;
comment|// also add the root variable
name|selectedFields
operator|.
name|put
argument_list|(
literal|null
argument_list|,
name|query
operator|.
name|getRootVariableName
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|selectedFields
return|;
block|}
comment|/**      * For some {@link EndpointTypeEnum SPARQL endpoint types} we need to add an additional constraint to      * determine the ranking information based on incoming relations to the Entities.      *<p>      * Currently this done for {@link EndpointTypeEnum#ARQ ARQ} and {@link EndpointTypeEnum#LARQ LARQ}.      *       * @param endpointType      *            the endpoint type      * @param queryString      *            the SPARQL query string to add the ranking constraint      * @param rootFieldName      *            the variable name used to select entities      */
specifier|private
specifier|static
name|void
name|addRankingConstraints
parameter_list|(
name|EndpointTypeEnum
name|endpointType
parameter_list|,
specifier|final
name|StringBuilder
name|queryString
parameter_list|,
specifier|final
name|String
name|rootFieldName
parameter_list|)
block|{
if|if
condition|(
name|endpointType
operator|==
name|EndpointTypeEnum
operator|.
name|ARQ
operator|||
name|endpointType
operator|==
name|EndpointTypeEnum
operator|.
name|LARQ
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"  { \n    ?incoming ?p ?%s . \n  } \n"
argument_list|,
name|rootFieldName
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// else ... for Virtuoso we need not count incoming links, because it
comment|// has a
comment|// page rank like feature we can use to rank entities!
comment|// all others do not support sorting
block|}
comment|/**      * @param endpointType      * @param queryString      */
specifier|private
specifier|static
name|void
name|addRankingOrder
parameter_list|(
name|EndpointTypeEnum
name|endpointType
parameter_list|,
specifier|final
name|StringBuilder
name|queryString
parameter_list|,
name|String
name|rootVarName
parameter_list|,
name|String
name|intend
parameter_list|)
block|{
if|if
condition|(
name|endpointType
operator|==
name|EndpointTypeEnum
operator|.
name|Virtuoso
condition|)
block|{
comment|// is that still SPARQL ... wondering about the syntax ^
name|queryString
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"%sORDER BY DESC (<LONG::IRI_RANK> (?%s) ) \n"
argument_list|,
name|intend
operator|!=
literal|null
condition|?
name|intend
else|:
literal|""
argument_list|,
name|rootVarName
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|endpointType
operator|==
name|EndpointTypeEnum
operator|.
name|ARQ
operator|||
name|endpointType
operator|==
name|EndpointTypeEnum
operator|.
name|LARQ
condition|)
block|{
comment|// TODO: COUNT is not part of the SPARQL 1.0 specification!
comment|// see http://www.w3.org/2009/sparql/wiki/Feature:AggregateFunctions
name|queryString
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"%sORDER BY DESC (COUNT (?incoming) ) \n"
argument_list|,
name|intend
operator|!=
literal|null
condition|?
name|intend
else|:
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// else not supported ... add nothing
block|}
comment|/**      * @param query      * @param queryString      */
specifier|private
specifier|static
name|void
name|addOffset
parameter_list|(
name|SparqlFieldQuery
name|query
parameter_list|,
specifier|final
name|StringBuilder
name|queryString
parameter_list|)
block|{
if|if
condition|(
name|query
operator|.
name|getOffset
argument_list|()
operator|>
literal|0
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"OFFSET %d \n"
argument_list|,
name|query
operator|.
name|getOffset
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * @param query      * @param queryString      */
specifier|private
specifier|static
name|void
name|addLimit
parameter_list|(
name|Integer
name|limit
parameter_list|,
specifier|final
name|StringBuilder
name|queryString
parameter_list|)
block|{
if|if
condition|(
name|limit
operator|!=
literal|null
operator|&&
name|limit
operator|>
literal|0
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"LIMIT %d \n"
argument_list|,
name|limit
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Adds the SELECT part to the SPARQL query      *       * @param queryString      * @param query      * @param includeFields      * @param selectedFields      */
specifier|private
specifier|static
name|void
name|createSelect
parameter_list|(
specifier|final
name|StringBuilder
name|queryString
parameter_list|,
name|boolean
name|includeFields
parameter_list|,
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|selectedFields
parameter_list|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|"SELECT DISTINCT"
argument_list|)
expr_stmt|;
comment|// REMOVED: The root variable is already in the selected fields map!
comment|// queryString.append(" ?"+query.getRootVariableName()); //select the
comment|// representation ID
comment|// now the variables for the selected fields!
if|if
condition|(
name|includeFields
condition|)
block|{
for|for
control|(
name|String
name|varName
range|:
name|selectedFields
operator|.
name|values
argument_list|()
control|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|" ?"
argument_list|)
expr_stmt|;
name|queryString
operator|.
name|append
argument_list|(
name|varName
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// else add only the root variable (stored under key null)
name|queryString
operator|.
name|append
argument_list|(
literal|" ?"
argument_list|)
expr_stmt|;
name|queryString
operator|.
name|append
argument_list|(
name|selectedFields
operator|.
name|get
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|queryString
operator|.
name|append
argument_list|(
literal|" \n"
argument_list|)
expr_stmt|;
block|}
comment|/**      * Adds the WHERE clause of the SPARQL query.      *<p>      * If the {@link EndpointTypeEnum SPARQL endpoint} supports SPARQL 1.1 subqueries, than this adds also the      * LIMIT and OFFSET to in inner SELECT that only selects the id.      *       * @param queryString      *            the SPARQL query string to add the WHERE      * @param query      *            the query      * @param selectedFields      *            the selected fields      * @param endpointType      *            The type of the endpoint (used to write optimised queries for endpoint type specific      *            extensions      */
specifier|private
specifier|static
name|void
name|addFieldConstraint
parameter_list|(
specifier|final
name|StringBuilder
name|queryString
parameter_list|,
name|SparqlFieldQuery
name|query
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|selectedFields
parameter_list|,
name|EndpointTypeEnum
name|endpointType
parameter_list|)
block|{
comment|// we need temporary variables with unique names
name|String
name|varPrefix
init|=
literal|"tmp"
decl_stmt|;
name|int
index|[]
name|varNum
init|=
operator|new
name|int
index|[]
block|{
literal|1
block|}
decl_stmt|;
comment|// used to open brackets for the select part of the constraints
name|boolean
name|first
init|=
literal|true
decl_stmt|;
comment|// determine if sub-selects are supported and if we need a sub-select
comment|// (more than the id is selected)
name|boolean
name|subSelectState
init|=
name|isSubSelectState
argument_list|(
name|endpointType
argument_list|,
name|selectedFields
argument_list|)
decl_stmt|;
name|log
operator|.
name|trace
argument_list|(
literal|"add field constraints is in a sub-select-state [{}]."
argument_list|,
operator|(
name|subSelectState
condition|?
literal|"yes"
else|:
literal|"no"
operator|)
argument_list|)
expr_stmt|;
comment|// if we uses a sub query to select the ids, we need to add the graph
comment|// pattern
comment|// of all selected fields outside of the sub query
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|tmpSelectedFields
init|=
name|subSelectState
condition|?
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|(
name|selectedFields
argument_list|)
else|:
literal|null
decl_stmt|;
name|String
name|intend
decl_stmt|;
if|if
condition|(
name|subSelectState
condition|)
block|{
name|intend
operator|=
literal|"      "
expr_stmt|;
comment|// additional intend because of sub query (3*2)
block|}
else|else
block|{
name|intend
operator|=
literal|"    "
expr_stmt|;
comment|// normal intend (2*2)
block|}
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|Constraint
argument_list|>
argument_list|>
name|constraintIterator
init|=
name|query
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|constraintIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
argument_list|<
name|String
argument_list|,
name|Constraint
argument_list|>
name|fieldConstraint
init|=
name|constraintIterator
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// for (Entry<String, Constraint> fieldConstraint : query) {
if|if
condition|(
name|first
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|"  { \n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|subSelectState
condition|)
block|{
name|String
name|rootVarName
init|=
name|selectedFields
operator|.
name|get
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|queryString
operator|.
name|append
argument_list|(
literal|"    SELECT ?"
argument_list|)
operator|.
name|append
argument_list|(
name|rootVarName
argument_list|)
operator|.
name|append
argument_list|(
literal|" \n"
argument_list|)
expr_stmt|;
name|queryString
operator|.
name|append
argument_list|(
literal|"    WHERE { \n"
argument_list|)
expr_stmt|;
block|}
name|first
operator|=
literal|false
expr_stmt|;
block|}
name|String
name|field
init|=
name|fieldConstraint
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Constraint
name|constraint
init|=
name|fieldConstraint
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|log
operator|.
name|trace
argument_list|(
literal|"adding a constraint [type :: {}][field :: {}][prefix :: {}][intent :: {}]."
argument_list|,
operator|new
name|Object
index|[]
block|{
name|constraint
operator|.
name|getType
argument_list|()
block|,
name|field
block|,
name|varPrefix
block|,
name|intend
block|}
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|constraint
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|value
case|:
name|addValueConstraint
argument_list|(
name|queryString
argument_list|,
name|field
argument_list|,
operator|(
name|ValueConstraint
operator|)
name|constraint
argument_list|,
name|selectedFields
argument_list|,
name|varPrefix
argument_list|,
name|varNum
argument_list|,
name|intend
argument_list|)
expr_stmt|;
break|break;
case|case
name|text
case|:
name|String
name|var
init|=
name|addFieldGraphPattern
argument_list|(
name|queryString
argument_list|,
name|field
argument_list|,
name|selectedFields
argument_list|,
name|varPrefix
argument_list|,
name|varNum
argument_list|,
name|intend
argument_list|)
decl_stmt|;
name|addTextConstraint
argument_list|(
name|queryString
argument_list|,
name|var
argument_list|,
operator|(
name|TextConstraint
operator|)
name|constraint
argument_list|,
name|endpointType
argument_list|,
name|intend
argument_list|)
expr_stmt|;
break|break;
case|case
name|range
case|:
name|var
operator|=
name|addFieldGraphPattern
argument_list|(
name|queryString
argument_list|,
name|field
argument_list|,
name|selectedFields
argument_list|,
name|varPrefix
argument_list|,
name|varNum
argument_list|,
name|intend
argument_list|)
expr_stmt|;
name|addRangeConstriant
argument_list|(
name|queryString
argument_list|,
name|var
argument_list|,
operator|(
name|RangeConstraint
operator|)
name|constraint
argument_list|,
name|intend
argument_list|)
expr_stmt|;
break|break;
default|default:
name|log
operator|.
name|warn
argument_list|(
literal|"Please update this Implementation to support the Constraint Type "
operator|+
name|fieldConstraint
operator|.
name|getValue
argument_list|()
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
name|queryString
operator|.
name|append
argument_list|(
literal|" . \n"
argument_list|)
expr_stmt|;
block|}
comment|// for some endpoints we need to add an additional constraints used for
comment|// ranking. If sub-queries are used this need to be in the select part
comment|// of the query (to rank results of the inner query)
comment|// otherwise it is better to have it in outside if the select part to
comment|// only
comment|// rank the graph selected by the query
if|if
condition|(
name|subSelectState
condition|)
block|{
name|addRankingConstraints
argument_list|(
name|endpointType
argument_list|,
name|queryString
argument_list|,
name|selectedFields
operator|.
name|get
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|first
condition|)
block|{
if|if
condition|(
name|subSelectState
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|"    } \n"
argument_list|)
expr_stmt|;
comment|// re-add all selected fields to be added as selects because in
comment|// the sub-query we only select the ID!
name|selectedFields
operator|=
name|tmpSelectedFields
expr_stmt|;
comment|// ranking needs also to be added to the sub-query (to correctly
comment|// process LIMIT and OFFSET
name|addRankingOrder
argument_list|(
name|endpointType
argument_list|,
name|queryString
argument_list|,
name|selectedFields
operator|.
name|get
argument_list|(
literal|null
argument_list|)
argument_list|,
literal|"    "
argument_list|)
expr_stmt|;
comment|// add LIMIT and OFFSET to the sub-query!
comment|// TODO: add link to the email
name|queryString
operator|.
name|append
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
name|addLimit
argument_list|(
name|query
operator|.
name|getLimit
argument_list|()
argument_list|,
name|queryString
argument_list|)
expr_stmt|;
name|queryString
operator|.
name|append
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
name|addOffset
argument_list|(
name|query
argument_list|,
name|queryString
argument_list|)
expr_stmt|;
name|queryString
operator|.
name|append
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
block|}
name|queryString
operator|.
name|append
argument_list|(
literal|"  } \n"
argument_list|)
expr_stmt|;
block|}
comment|// All the followig Graphpattern are only processed for the parts
comment|// selected
comment|// by the above constraints
comment|// if no subqueries are used we need now to add the ranking constraints
if|if
condition|(
operator|!
name|subSelectState
condition|)
block|{
name|addRankingConstraints
argument_list|(
name|endpointType
argument_list|,
name|queryString
argument_list|,
name|selectedFields
operator|.
name|get
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// we need to add graph pattern for selected field that are not covered
comment|// by
comment|// graph pattern written for the constraint.
comment|// Implementation Note: selectedFields contains the null key for the
comment|// root variable
while|while
condition|(
name|selectedFields
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|// if this is the only left element
comment|// we are done
name|Iterator
argument_list|<
name|String
argument_list|>
name|it
init|=
name|selectedFields
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|String
name|actField
decl_stmt|;
comment|// we need to get a non null value from the map
do|do
block|{
comment|// the outer while ensures an non null value so we need not to
comment|// use hasNext
name|actField
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|actField
operator|==
literal|null
condition|)
do|;
name|queryString
operator|.
name|append
argument_list|(
literal|"  OPTIONAL { "
argument_list|)
expr_stmt|;
comment|// NOTE the following Method removes the written mapping from the
comment|// Map
name|addFieldGraphPattern
argument_list|(
name|queryString
argument_list|,
name|actField
argument_list|,
name|selectedFields
argument_list|,
name|varPrefix
argument_list|,
name|varNum
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|queryString
operator|.
name|append
argument_list|(
literal|". } \n"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|void
name|addValueConstraint
parameter_list|(
name|StringBuilder
name|queryString
parameter_list|,
name|String
name|field
parameter_list|,
name|ValueConstraint
name|constraint
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|selectedFields
parameter_list|,
name|String
name|varPrefix
parameter_list|,
name|int
index|[]
name|varNum
parameter_list|,
name|String
name|intend
parameter_list|)
block|{
name|String
name|rootVarName
init|=
name|selectedFields
operator|.
name|get
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|String
argument_list|>
name|dataTypes
init|=
name|constraint
operator|.
name|getDataTypes
argument_list|()
decl_stmt|;
if|if
condition|(
name|dataTypes
operator|==
literal|null
condition|)
block|{
comment|// we need not to distinguish between empty and null
comment|// because SPARQL includes support for automatic detection of
comment|// dataTypes
comment|// see http://www.w3.org/TR/rdf-sparql-query/#QSynLiterals
name|dataTypes
operator|=
name|Collections
operator|.
name|emptySet
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|constraint
operator|.
name|getValues
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|dataTypes
operator|.
name|size
argument_list|()
operator|<=
literal|1
condition|)
block|{
name|addDataTypeValueConstraint
argument_list|(
name|queryString
argument_list|,
name|rootVarName
argument_list|,
name|field
argument_list|,
name|dataTypes
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|dataTypes
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|,
name|constraint
operator|.
name|getValues
argument_list|()
argument_list|,
name|constraint
operator|.
name|getMode
argument_list|()
argument_list|,
name|varPrefix
argument_list|,
name|varNum
argument_list|,
name|intend
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// we have multiple dataTypes -> need to use union!
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|String
argument_list|>
name|it
init|=
name|dataTypes
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|String
name|dataType
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|first
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|"} UNION {\n"
argument_list|)
expr_stmt|;
block|}
name|addDataTypeValueConstraint
argument_list|(
name|queryString
argument_list|,
name|rootVarName
argument_list|,
name|field
argument_list|,
name|dataType
argument_list|,
name|constraint
operator|.
name|getValues
argument_list|()
argument_list|,
name|constraint
operator|.
name|getMode
argument_list|()
argument_list|,
name|varPrefix
argument_list|,
name|varNum
argument_list|,
name|intend
argument_list|)
expr_stmt|;
block|}
name|queryString
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// no constraint for the value
comment|// filter all instances that define any value for the given
comment|// dataTypes
comment|// see http://www.w3.org/TR/rdf-sparql-query/#func-datatype
comment|// first we need to select the Variable to filter
name|String
name|var
init|=
name|addFieldGraphPattern
argument_list|(
name|queryString
argument_list|,
name|field
argument_list|,
name|selectedFields
argument_list|,
name|varPrefix
argument_list|,
name|varNum
argument_list|,
name|intend
argument_list|)
decl_stmt|;
name|queryString
operator|.
name|append
argument_list|(
literal|". \n"
argument_list|)
operator|.
name|append
argument_list|(
name|intend
argument_list|)
expr_stmt|;
comment|// now we need to write the filter
if|if
condition|(
name|dataTypes
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|addDataTypeFilter
argument_list|(
name|queryString
argument_list|,
name|var
argument_list|,
name|dataTypes
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|String
argument_list|>
name|it
init|=
name|dataTypes
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|String
name|dataType
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|"( \n  "
argument_list|)
operator|.
name|append
argument_list|(
name|intend
argument_list|)
expr_stmt|;
name|first
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|" || \n  "
argument_list|)
operator|.
name|append
argument_list|(
name|intend
argument_list|)
expr_stmt|;
block|}
name|addDataTypeFilter
argument_list|(
name|queryString
argument_list|,
name|var
argument_list|,
name|dataType
argument_list|)
expr_stmt|;
block|}
name|queryString
operator|.
name|append
argument_list|(
literal|" \n"
argument_list|)
operator|.
name|append
argument_list|(
name|intend
argument_list|)
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Adds a filter that restricts the data type to an variable      *       * @param queryString      *            the query String to add the filter. MUST NOT be<code>null</code>      * @param var      *            the variable to add the filter. MUST NOT be<code>null</code>      * @param dataTypes      *            the data type uri for the filter. MUST NOT be<code>null</code>      */
specifier|private
specifier|static
name|void
name|addDataTypeFilter
parameter_list|(
name|StringBuilder
name|queryString
parameter_list|,
name|String
name|var
parameter_list|,
name|String
name|dataType
parameter_list|)
block|{
name|queryString
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"FILTER(datatype(?%s) =<%s>)"
argument_list|,
name|var
argument_list|,
name|dataType
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Adds a value constraint for a field including the dataType      *       * @param queryString      *            the query string to add the constraint. MUST NOT be<code>null</code>      * @param rootVarName      *            the variable name of the subject. MUST NOT be<code>null</code>      * @param field      *            the property name of the field. MUST NOT be<code>null</code>      * @param dataType      *            the dataType constraint or<code>null</code> if none      * @param value      *            the value. MUST NOT be<code>null</code>.      */
specifier|private
specifier|static
name|void
name|addDataTypeValueConstraint
parameter_list|(
name|StringBuilder
name|queryString
parameter_list|,
name|String
name|rootVarName
parameter_list|,
name|String
name|field
parameter_list|,
name|String
name|dataType
parameter_list|,
name|Collection
argument_list|<
name|Object
argument_list|>
name|values
parameter_list|,
name|MODE
name|mode
parameter_list|,
name|String
name|varPrefix
parameter_list|,
name|int
index|[]
name|varNum
parameter_list|,
name|String
name|intend
parameter_list|)
block|{
name|String
name|addIntend
init|=
name|intend
decl_stmt|;
name|queryString
operator|.
name|append
argument_list|(
name|intend
argument_list|)
expr_stmt|;
if|if
condition|(
name|values
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|"{ "
argument_list|)
expr_stmt|;
name|addIntend
operator|=
name|intend
operator|+
literal|"  "
expr_stmt|;
block|}
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Object
name|value
range|:
name|values
control|)
block|{
if|if
condition|(
name|first
condition|)
block|{
comment|// only add bracket if multiple values are parsed (STANBOL-697)
if|if
condition|(
name|mode
operator|==
name|MODE
operator|.
name|any
operator|&&
name|values
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
block|}
name|first
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mode
operator|==
name|MODE
operator|.
name|any
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|"} UNION {\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|" .\n"
argument_list|)
expr_stmt|;
block|}
name|queryString
operator|.
name|append
argument_list|(
name|addIntend
argument_list|)
expr_stmt|;
block|}
name|String
name|fieldVar
decl_stmt|;
if|if
condition|(
name|isSpecialField
argument_list|(
name|field
argument_list|)
condition|)
block|{
comment|// in case of a special field replace the field URI with an
comment|// variable to allow searching all outgoing properties
name|fieldVar
operator|=
name|varPrefix
operator|+
name|varNum
index|[
literal|0
index|]
expr_stmt|;
name|varNum
index|[
literal|0
index|]
operator|++
expr_stmt|;
block|}
else|else
block|{
name|fieldVar
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|DataTypeEnum
operator|.
name|Reference
operator|.
name|getUri
argument_list|()
operator|.
name|equals
argument_list|(
name|dataType
argument_list|)
operator|||
name|value
operator|instanceof
name|Reference
condition|)
block|{
if|if
condition|(
name|fieldVar
operator|!=
literal|null
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"?%s ?%s<%s>"
argument_list|,
name|rootVarName
argument_list|,
name|fieldVar
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|queryString
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"?%s<%s><%s>"
argument_list|,
name|rootVarName
argument_list|,
name|field
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|fieldVar
operator|!=
literal|null
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"?%s ?%s \"%s\"%s"
argument_list|,
name|rootVarName
argument_list|,
name|fieldVar
argument_list|,
name|value
argument_list|,
name|dataType
operator|!=
literal|null
condition|?
name|String
operator|.
name|format
argument_list|(
literal|"^^<%s>"
argument_list|,
name|dataType
argument_list|)
else|:
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|queryString
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"?%s<%s> \"%s\"%s"
argument_list|,
name|rootVarName
argument_list|,
name|field
argument_list|,
name|value
argument_list|,
name|dataType
operator|!=
literal|null
condition|?
name|String
operator|.
name|format
argument_list|(
literal|"^^<%s>"
argument_list|,
name|dataType
argument_list|)
else|:
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|values
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|MODE
operator|.
name|any
condition|)
block|{
comment|// close the union
name|queryString
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
name|queryString
operator|.
name|append
argument_list|(
literal|" }"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Adds an text constraint to the SPARQL query string      *       * @param queryString      *            the query string to add the constraint      * @param var      *            the variable name to constraint      * @param constraint      *            the constraint      * @param endpointType      *            The type of the Endpoint (used to write optimized queries for endpoint type specific      *            extensions      */
specifier|private
specifier|static
name|void
name|addTextConstraint
parameter_list|(
name|StringBuilder
name|queryString
parameter_list|,
name|String
name|var
parameter_list|,
name|TextConstraint
name|constraint
parameter_list|,
name|EndpointTypeEnum
name|endpointType
parameter_list|,
name|String
name|intend
parameter_list|)
block|{
name|boolean
name|filterAdded
init|=
literal|false
decl_stmt|;
name|boolean
name|isTextValueConstraint
init|=
name|constraint
operator|.
name|getTexts
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|constraint
operator|.
name|getTexts
argument_list|()
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
name|log
operator|.
name|trace
argument_list|(
literal|"Constraint is text-value constrain [{}][var :: {}][intent :: {}]."
argument_list|,
operator|new
name|Object
index|[]
block|{
operator|(
name|isTextValueConstraint
condition|?
literal|"yes"
else|:
literal|"no"
operator|)
block|,
name|var
block|,
name|intend
block|}
argument_list|)
expr_stmt|;
if|if
condition|(
name|isTextValueConstraint
condition|)
block|{
if|if
condition|(
name|constraint
operator|.
name|getPatternType
argument_list|()
operator|==
name|PatternType
operator|.
name|regex
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|" \n"
argument_list|)
operator|.
name|append
argument_list|(
name|intend
argument_list|)
operator|.
name|append
argument_list|(
literal|"  FILTER("
argument_list|)
expr_stmt|;
name|filterAdded
operator|=
literal|true
expr_stmt|;
name|addRegexFilter
argument_list|(
name|queryString
argument_list|,
name|var
argument_list|,
name|constraint
operator|.
name|getTexts
argument_list|()
argument_list|,
name|constraint
operator|.
name|isCaseSensitive
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// TODO: This optimised versions for Virtuoso and LARQ might not
comment|// respect case sensitive queries. Need more testing!
if|if
condition|(
name|EndpointTypeEnum
operator|.
name|Virtuoso
operator|==
name|endpointType
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|". \n  "
argument_list|)
operator|.
name|append
argument_list|(
name|intend
argument_list|)
expr_stmt|;
name|queryString
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"?%s bif:contains '%s'"
argument_list|,
name|var
argument_list|,
name|createFullTextQueryString
argument_list|(
name|constraint
operator|.
name|getTexts
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|EndpointTypeEnum
operator|.
name|LARQ
operator|==
name|endpointType
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|". \n  "
argument_list|)
operator|.
name|append
argument_list|(
name|intend
argument_list|)
expr_stmt|;
name|queryString
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"?%s<http://jena.hpl.hp.com/ARQ/property#textMatch> '%s'"
argument_list|,
name|var
argument_list|,
name|createFullTextQueryString
argument_list|(
name|constraint
operator|.
name|getTexts
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|" \n"
argument_list|)
operator|.
name|append
argument_list|(
name|intend
argument_list|)
operator|.
name|append
argument_list|(
literal|"  FILTER("
argument_list|)
expr_stmt|;
name|filterAdded
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|constraint
operator|.
name|getPatternType
argument_list|()
operator|==
name|PatternType
operator|.
name|none
condition|)
block|{
if|if
condition|(
name|constraint
operator|.
name|isCaseSensitive
argument_list|()
condition|)
block|{
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|String
name|textConstraint
range|:
name|constraint
operator|.
name|getTexts
argument_list|()
control|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|" || "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|textConstraint
operator|!=
literal|null
operator|&&
operator|!
name|textConstraint
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"(str(?%s) = \"%s\")"
argument_list|,
name|var
argument_list|,
name|textConstraint
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|regexQueryTexts
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|constraint
operator|.
name|getTexts
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|textConstraint
range|:
name|constraint
operator|.
name|getTexts
argument_list|()
control|)
block|{
if|if
condition|(
name|textConstraint
operator|!=
literal|null
operator|&&
operator|!
name|textConstraint
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|regexQueryTexts
operator|.
name|add
argument_list|(
name|PatternUtils
operator|.
name|value2Regex
argument_list|(
name|textConstraint
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|addRegexFilter
argument_list|(
name|queryString
argument_list|,
name|var
argument_list|,
name|regexQueryTexts
argument_list|,
name|constraint
operator|.
name|isCaseSensitive
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|constraint
operator|.
name|getPatternType
argument_list|()
operator|==
name|PatternType
operator|.
name|wildcard
condition|)
block|{
comment|// parse false, because that is more in line with the
comment|// expectations of users!
name|Collection
argument_list|<
name|String
argument_list|>
name|regexQueryTexts
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|constraint
operator|.
name|getTexts
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|textConstraint
range|:
name|constraint
operator|.
name|getTexts
argument_list|()
control|)
block|{
if|if
condition|(
name|textConstraint
operator|!=
literal|null
operator|&&
operator|!
name|textConstraint
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|regexQueryTexts
operator|.
name|add
argument_list|(
name|PatternUtils
operator|.
name|wildcardToRegex
argument_list|(
name|textConstraint
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|addRegexFilter
argument_list|(
name|queryString
argument_list|,
name|var
argument_list|,
name|regexQueryTexts
argument_list|,
name|constraint
operator|.
name|isCaseSensitive
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unspported Patterntype "
operator|+
name|constraint
operator|.
name|getPatternType
argument_list|()
operator|+
literal|"! Change this impplementation to support this type! -> treat constaint \""
operator|+
name|constraint
operator|.
name|getTexts
argument_list|()
operator|+
literal|"\"as REGEX"
argument_list|)
expr_stmt|;
name|addRegexFilter
argument_list|(
name|queryString
argument_list|,
name|var
argument_list|,
name|constraint
operator|.
name|getTexts
argument_list|()
argument_list|,
name|constraint
operator|.
name|isCaseSensitive
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// else nothing to do
comment|// add language Filters
comment|// TODO check if FILTER ( is already written!
if|if
condition|(
name|constraint
operator|.
name|getLanguages
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|constraint
operator|.
name|getLanguages
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"Constraint has languages [filter-added :: {}]."
argument_list|,
operator|(
name|filterAdded
condition|?
literal|"yes"
else|:
literal|"no"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|filterAdded
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|" . \n"
argument_list|)
operator|.
name|append
argument_list|(
name|intend
argument_list|)
operator|.
name|append
argument_list|(
literal|"  FILTER("
argument_list|)
expr_stmt|;
name|filterAdded
operator|=
literal|true
expr_stmt|;
name|writeLanguagesFilter
argument_list|(
name|queryString
argument_list|,
name|constraint
operator|.
name|getLanguages
argument_list|()
argument_list|,
name|var
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writeLanguagesFilter
argument_list|(
name|queryString
argument_list|,
name|constraint
operator|.
name|getLanguages
argument_list|()
argument_list|,
name|var
argument_list|,
literal|"&& "
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|filterAdded
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
comment|// close the FILTER and the graph pattern
block|}
block|}
comment|/**      * (Creates AND Text) OR (Query AND String) like queries based on the parsed TextConstraint as used by      * {@link EndpointTypeEnum#LARQ LARQ} and {@link EndpointTypeEnum#Virtuoso VIRTUOSO} SPARQL endpoints to      * speed up full text queries.      *       * @param constraints      *            the as returned by {@link TextConstraint#getTexts()}      * @return the full text query string      */
specifier|protected
specifier|static
name|String
name|createFullTextQueryString
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|constraints
parameter_list|)
block|{
name|StringBuilder
name|textQuery
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|boolean
name|firstText
init|=
literal|true
decl_stmt|;
for|for
control|(
name|String
name|constraintText
range|:
name|constraints
control|)
block|{
if|if
condition|(
name|constraintText
operator|!=
literal|null
operator|&&
operator|!
name|constraintText
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|firstText
condition|)
block|{
name|firstText
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|textQuery
operator|.
name|append
argument_list|(
literal|" OR "
argument_list|)
expr_stmt|;
block|}
comment|// TODO: maybe we should use a word tokenizer here
name|String
index|[]
name|words
init|=
name|constraintText
operator|.
name|split
argument_list|(
literal|"\\s"
argument_list|)
decl_stmt|;
if|if
condition|(
name|words
operator|.
name|length
operator|>
literal|1
condition|)
block|{
comment|// not perfect because words might contain empty string, but
comment|// it will eliminate most unnecessary brackets .
name|textQuery
operator|.
name|append
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
block|}
name|boolean
name|firstAndWord
init|=
literal|true
decl_stmt|;
for|for
control|(
name|String
name|word
range|:
name|words
control|)
block|{
name|word
operator|=
name|word
operator|.
name|trim
argument_list|()
expr_stmt|;
name|boolean
name|hasAlphaNumeric
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|word
operator|.
name|length
argument_list|()
operator|&&
operator|!
name|hasAlphaNumeric
condition|;
name|i
operator|++
control|)
block|{
name|char
name|ch
init|=
name|word
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|Character
operator|.
name|isLetter
argument_list|(
name|ch
argument_list|)
operator|||
name|Character
operator|.
name|isDigit
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|hasAlphaNumeric
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hasAlphaNumeric
condition|)
block|{
if|if
condition|(
name|firstAndWord
condition|)
block|{
name|firstAndWord
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|textQuery
operator|.
name|append
argument_list|(
literal|" AND "
argument_list|)
expr_stmt|;
block|}
comment|// we need to double the backslashes because of
comment|// replaceAll takes a regular expression
comment|// as input.
name|String
name|escapedWord
init|=
name|word
operator|.
name|replaceAll
argument_list|(
literal|"\\\""
argument_list|,
literal|"\\\\\""
argument_list|)
decl_stmt|;
name|textQuery
operator|.
name|append
argument_list|(
literal|'"'
argument_list|)
operator|.
name|append
argument_list|(
name|escapedWord
argument_list|)
operator|.
name|append
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|words
operator|.
name|length
operator|>
literal|1
condition|)
block|{
name|textQuery
operator|.
name|append
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
block|}
comment|// end if not null and not empty
block|}
return|return
name|textQuery
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Adds a SPARQL regex filter to the parsed query string      *       * @param queryString      *            the string builder to add the constraint      * @param var      *            the variable to constrain      * @param regexContraints      *            the regex encoded search strings (connected with '||' (OR))      * @param isCasesensitive      *            if the constraint is case sensitive or not      */
specifier|private
specifier|static
name|void
name|addRegexFilter
parameter_list|(
name|StringBuilder
name|queryString
parameter_list|,
name|String
name|var
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|regexContraints
parameter_list|,
name|boolean
name|isCasesensitive
parameter_list|)
block|{
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|String
name|regex
range|:
name|regexContraints
control|)
block|{
if|if
condition|(
name|regex
operator|!=
literal|null
operator|&&
operator|!
name|regex
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|" || "
argument_list|)
expr_stmt|;
block|}
name|queryString
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"regex(str(?%s),\"%s\"%s)"
argument_list|,
name|var
argument_list|,
name|regex
argument_list|,
name|isCasesensitive
condition|?
literal|""
else|:
literal|",\"i\""
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Adds an RangeConstraint to the parsed query String      *       * @param queryString      *            the query to add the constraint      * @param var      *            the variable to constrain      * @param constraint      *            the constraint      */
specifier|private
specifier|static
name|void
name|addRangeConstriant
parameter_list|(
name|StringBuilder
name|queryString
parameter_list|,
name|String
name|var
parameter_list|,
name|RangeConstraint
name|constraint
parameter_list|,
name|String
name|intend
parameter_list|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
operator|.
name|append
argument_list|(
name|intend
argument_list|)
operator|.
name|append
argument_list|(
literal|"FILTER "
argument_list|)
expr_stmt|;
comment|// start the
comment|// FILTER
name|boolean
name|closedRange
init|=
name|constraint
operator|.
name|getLowerBound
argument_list|()
operator|!=
literal|null
operator|&&
name|constraint
operator|.
name|getUpperBound
argument_list|()
operator|!=
literal|null
decl_stmt|;
if|if
condition|(
name|closedRange
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
block|}
comment|// write lower and upper bounds
if|if
condition|(
name|constraint
operator|.
name|getLowerBound
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|addRangeBound
argument_list|(
name|queryString
argument_list|,
name|var
argument_list|,
literal|true
argument_list|,
name|constraint
operator|.
name|isInclusive
argument_list|()
argument_list|,
name|constraint
operator|.
name|getLowerBound
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|closedRange
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|"&& "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|constraint
operator|.
name|getUpperBound
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|addRangeBound
argument_list|(
name|queryString
argument_list|,
name|var
argument_list|,
literal|false
argument_list|,
name|constraint
operator|.
name|isInclusive
argument_list|()
argument_list|,
name|constraint
operator|.
name|getUpperBound
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|closedRange
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Adds a lower/upper bound constraint to the query String      *       * @param queryString      *            the query string      * @param var      *            the variable      * @param lowerBound      *<code>true</code> to add the lower bound and<code>false</code> to add the upper bound      * @param inclusive      *            if the bound is inclusive (>= or<=)      * @param value      *            the value representing the bound.      */
specifier|private
specifier|static
name|void
name|addRangeBound
parameter_list|(
name|StringBuilder
name|queryString
parameter_list|,
name|String
name|var
parameter_list|,
name|boolean
name|lowerBound
parameter_list|,
name|boolean
name|inclusive
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|String
name|stringValue
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Date
condition|)
block|{
comment|// for dates add the data type!
name|stringValue
operator|=
name|String
operator|.
name|format
argument_list|(
literal|"%s^^<%s>"
argument_list|,
name|DATE_FORMAT
operator|.
name|format
argument_list|(
operator|(
name|Date
operator|)
name|value
argument_list|)
argument_list|,
name|XSD_DATE_TIME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// add additional "if" for special types if necessary
name|stringValue
operator|=
name|value
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
comment|// adds (?var>/<[=] valueString)
name|queryString
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"(?%s %c%s %s)"
argument_list|,
name|var
argument_list|,
name|lowerBound
condition|?
literal|'>'
else|:
literal|'<'
argument_list|,
name|inclusive
condition|?
literal|"="
else|:
literal|""
argument_list|,
name|stringValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Adds a S P O pattern to the query by using the root as subject, the parsed field as predicate and the      * returned variable as object. This method doese not open a '{' nor close the pattern with any of '.',      * ',' or ';'      *       * @param queryString      *            the {@link StringBuilder} to add the pattern      * @param field      *            the field      * @param selectedFields      *            the map field -> var of the selected variables. If the parsed field is selected, the field      *            is removed from the list and the mapped variable name is returned      * @param varPrefix      *            the default prefix for newly created variable names      * @param varNum      *            The first element of the array is used to get the number of the created variable. If one is      *            created the value of the first element is increased by one      * @return The variable name used for the object of the pattern      */
specifier|private
specifier|static
name|String
name|addFieldGraphPattern
parameter_list|(
name|StringBuilder
name|queryString
parameter_list|,
name|String
name|field
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|selectedFields
parameter_list|,
name|String
name|varPrefix
parameter_list|,
name|int
index|[]
name|varNum
parameter_list|,
name|String
name|intend
parameter_list|)
block|{
name|String
name|var
init|=
name|selectedFields
operator|.
name|remove
argument_list|(
name|field
argument_list|)
decl_stmt|;
comment|// check if the field is
comment|// selected
if|if
condition|(
name|var
operator|==
literal|null
condition|)
block|{
comment|// this field is not selected
comment|// we need to generate a temp var
name|var
operator|=
name|varPrefix
operator|+
name|varNum
index|[
literal|0
index|]
expr_stmt|;
name|varNum
index|[
literal|0
index|]
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|isSpecialField
argument_list|(
name|field
argument_list|)
condition|)
block|{
comment|// in case of a special field replace the field URI with an
comment|// variable to allow searching all outgoing properties
name|String
name|fieldVar
init|=
name|varPrefix
operator|+
name|varNum
index|[
literal|0
index|]
decl_stmt|;
name|varNum
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|queryString
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"%s?%s ?%s ?%s "
argument_list|,
name|intend
argument_list|,
name|selectedFields
operator|.
name|get
argument_list|(
literal|null
argument_list|)
argument_list|,
name|fieldVar
argument_list|,
name|var
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|queryString
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"%s?%s<%s> ?%s "
argument_list|,
name|intend
argument_list|,
name|selectedFields
operator|.
name|get
argument_list|(
literal|null
argument_list|)
argument_list|,
name|field
argument_list|,
name|var
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|var
return|;
block|}
comment|/**      * Writes the SPARQL FILTER for the parsed languages. This Method writes<code><pre>      *      prefix ((lang(?var) = "lang1") [|| (lang(?var) = "lang2..n")])      *</pre></code>      *       * @param queryString      *            the query string to add the FILTER      * @param languages      *            the languages to filter for (may contain<code>null</code> as element)      * @param var      *            the name of the variable to filter.      * @param prefix      *            The prefix is written in front of the filter expression (if any is created). Typically this      *            will be      *<ul>      *<li>FILTER if this is the only filter for an variable      *<li>&& if this filter is combined with AND to an other filter or      *<li>|| if this filter is combined wit OR to an other filter      *</ul>      */
specifier|private
specifier|static
name|void
name|writeLanguagesFilter
parameter_list|(
name|StringBuilder
name|queryString
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|languages
parameter_list|,
name|String
name|var
parameter_list|,
name|String
name|prefix
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|languages
operator|||
name|languages
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|log
operator|.
name|trace
argument_list|(
literal|"Writing languages filter [var :: {}][prefix :: {}][languages :: {}]."
argument_list|,
operator|new
name|Object
index|[]
block|{
name|var
block|,
name|prefix
block|,
name|languages
operator|.
name|size
argument_list|()
block|}
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
operator|!=
literal|null
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|languages
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
block|}
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|String
name|language
range|:
name|languages
control|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|" || "
argument_list|)
expr_stmt|;
block|}
name|queryString
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"(lang(?%s) = \"%s\")"
argument_list|,
name|var
argument_list|,
name|language
operator|!=
literal|null
condition|?
name|language
else|:
literal|""
argument_list|)
argument_list|)
expr_stmt|;
comment|/*              * NOTE: the lang() returns "" for literals without an language tag. Because of that if the              * language == null we need to parse "" as an argument              */
block|}
if|if
condition|(
name|languages
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|SparqlFieldQuery
name|query
init|=
name|SparqlFieldQueryFactory
operator|.
name|getInstance
argument_list|()
operator|.
name|createFieldQuery
argument_list|()
decl_stmt|;
comment|// query.setConstraint("urn:field1", new
comment|// ReferenceConstraint("urn:testReference"));
comment|// query.setConstraint("urn:field1", new ReferenceConstraint(
comment|// Arrays.asList("urn:testReference","urn:testReference1","urn:testReference3"),MODE.any));
comment|// query.setConstraint(SpecialFieldEnum.references.getUri(), new
comment|// ReferenceConstraint(
comment|// Arrays.asList("urn:testReference","urn:testReference1","urn:testReference3")));
comment|// query.setConstraint("urn:field1a", new ValueConstraint(null,
comment|// Arrays.asList(
comment|// DataTypeEnum.Float.getUri())));
comment|// query.addSelectedField("urn:field1a");
comment|// query.setConstraint("urn:field1b", new ValueConstraint(9, Arrays.asList(
comment|// DataTypeEnum.Float.getUri())));
comment|// query.setConstraint("urn:field1b", new ValueConstraint(Arrays.asList(9,10,11), Arrays.asList(
comment|// DataTypeEnum.Float.getUri()),MODE.any));
comment|// query.setConstraint("urn:field1c", new ValueConstraint(null, Arrays.asList(
comment|// DataTypeEnum.Float.getUri(),DataTypeEnum.Double.getUri(),DataTypeEnum.Decimal.getUri())));
comment|// query.addSelectedField("urn:field1c");
comment|// query.setConstraint("urn:field1d", new ValueConstraint(9, Arrays.asList(
comment|// DataTypeEnum.Float.getUri(),DataTypeEnum.Double.getUri(),DataTypeEnum.Decimal.getUri())));
comment|// query.setConstraint("urn:field1d", new ValueConstraint(Arrays.asList(9,10,11), Arrays.asList(
comment|// DataTypeEnum.Float.getUri(),DataTypeEnum.Double.getUri(),DataTypeEnum.Decimal.getUri())));
comment|// query.setConstraint("urn:field2", new TextConstraint("test value"));
comment|// query.setConstraint("urn:field3", new TextConstraint(Arrays.asList(
comment|// "text value","anothertest","some more values"),true));
comment|// query.setConstraint(SpecialFieldEnum.fullText.getUri(), new TextConstraint(Arrays.asList(
comment|// "text value","anothertest","some more values"),true));
comment|// query.setConstraint("urn:field2a", new TextConstraint(":-]"));
comment|// //tests escaping of REGEX
comment|// query.setConstraint("urn:field3", new TextConstraint("language text","en"));
name|query
operator|.
name|setConstraint
argument_list|(
literal|"urn:field4"
argument_list|,
operator|new
name|TextConstraint
argument_list|(
literal|"multi language text"
argument_list|,
literal|"en"
argument_list|,
literal|"de"
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
comment|// query.setConstraint("urn:field5", new
comment|// TextConstraint("wildcar*",PatternType.wildcard,false,"en","de"));
comment|// query.addSelectedField("urn:field5");
comment|// query.setConstraint("urn:field6", new TextConstraint("^regex",PatternType.REGEX,true));
comment|// query.setConstraint("urn:field7", new
comment|// TextConstraint("par*",PatternType.WildCard,false,"en","de",null));
comment|// query.setConstraint("urn:field8", new TextConstraint(null,"en","de",null));
comment|// query.setConstraint("urn:field9", new RangeConstraint((int)5, (int)10, true));
comment|// query.setConstraint("urn:field10", new RangeConstraint((int)5, (int)10, false));
comment|// query.setConstraint("urn:field11", new RangeConstraint(null, (int)10, true));
comment|// query.setConstraint("urn:field12", new RangeConstraint((int)5, null, true));
comment|// query.setConstraint("urn:field12", new RangeConstraint(new Date(), null, true));
comment|// query.addSelectedField("urn:field2a");
comment|// query.addSelectedField("urn:field3");
name|query
operator|.
name|setLimit
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|query
operator|.
name|setOffset
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|createSparqlSelectQuery
argument_list|(
name|query
argument_list|,
literal|true
argument_list|,
literal|0
argument_list|,
name|EndpointTypeEnum
operator|.
name|LARQ
argument_list|)
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|createSparqlSelectQuery
argument_list|(
name|query
argument_list|,
literal|true
argument_list|,
literal|0
argument_list|,
name|EndpointTypeEnum
operator|.
name|Virtuoso
argument_list|)
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|createSparqlSelectQuery
argument_list|(
name|query
argument_list|,
literal|true
argument_list|,
literal|0
argument_list|,
name|EndpointTypeEnum
operator|.
name|Standard
argument_list|)
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|createSparqlConstructQuery
argument_list|(
name|query
argument_list|,
literal|0
argument_list|,
name|EndpointTypeEnum
operator|.
name|Virtuoso
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * @param query      * @param resultGraph      * @return      */
specifier|public
specifier|static
name|Iterator
argument_list|<
name|RdfRepresentation
argument_list|>
name|parseQueryResultsFromMGraph
parameter_list|(
specifier|final
name|TripleCollection
name|resultGraph
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|resultTripleIterator
init|=
name|resultGraph
operator|.
name|filter
argument_list|(
name|FIELD_QUERY_RESULT_SET
argument_list|,
name|FIELD_QUERY_RESULT
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|RdfRepresentation
argument_list|>
name|resultIterator
init|=
operator|new
name|AdaptingIterator
argument_list|<
name|Triple
argument_list|,
name|RdfRepresentation
argument_list|>
argument_list|(
name|resultTripleIterator
argument_list|,
operator|new
name|AdaptingIterator
operator|.
name|Adapter
argument_list|<
name|Triple
argument_list|,
name|RdfRepresentation
argument_list|>
argument_list|()
block|{
comment|/*                      * Anonymous implementation of an Adapter that converts the filtered Triples of the                      * resulting graph to RdfRepresentations                      */
annotation|@
name|Override
specifier|public
name|RdfRepresentation
name|adapt
parameter_list|(
name|Triple
name|value
parameter_list|,
name|Class
argument_list|<
name|RdfRepresentation
argument_list|>
name|type
parameter_list|)
block|{
name|Resource
name|object
init|=
name|value
operator|.
name|getObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|object
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|object
operator|instanceof
name|UriRef
condition|)
block|{
return|return
name|valueFavtory
operator|.
name|createRdfRepresentation
argument_list|(
operator|(
name|UriRef
operator|)
name|object
argument_list|,
name|resultGraph
argument_list|)
return|;
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to create representation for FieldQueryResult "
operator|+
name|object
operator|+
literal|" because this Resource is not of Type UriRef (type: "
operator|+
name|object
operator|.
name|getClass
argument_list|()
operator|+
literal|") -> result gets ignored"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
block|}
argument_list|,
name|RdfRepresentation
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|resultIterator
return|;
block|}
block|}
end_class

end_unit

