begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
package|package
name|eu
operator|.
name|iksproject
operator|.
name|kres
operator|.
name|manager
operator|.
name|ontology
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|apibinding
operator|.
name|OWLManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|io
operator|.
name|RDFXMLOntologyFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|io
operator|.
name|StringDocumentSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|io
operator|.
name|StringDocumentTarget
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|IRI
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLImportsDeclaration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLOntology
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLOntologyAlreadyExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLOntologyCreationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLOntologyID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLOntologyLoaderListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLOntologyManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLOntologyStorageException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|RemoveImport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|kres
operator|.
name|api
operator|.
name|manager
operator|.
name|ontology
operator|.
name|IrremovableOntologyException
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|kres
operator|.
name|api
operator|.
name|manager
operator|.
name|ontology
operator|.
name|MissingOntologyException
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|kres
operator|.
name|api
operator|.
name|manager
operator|.
name|ontology
operator|.
name|OntologyInputSource
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|kres
operator|.
name|api
operator|.
name|manager
operator|.
name|ontology
operator|.
name|OntologyScope
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|kres
operator|.
name|api
operator|.
name|manager
operator|.
name|ontology
operator|.
name|OntologySpace
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|kres
operator|.
name|api
operator|.
name|manager
operator|.
name|ontology
operator|.
name|OntologySpaceListener
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|kres
operator|.
name|api
operator|.
name|manager
operator|.
name|ontology
operator|.
name|OntologySpaceModificationException
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|kres
operator|.
name|api
operator|.
name|manager
operator|.
name|ontology
operator|.
name|SessionOntologySpace
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|kres
operator|.
name|api
operator|.
name|manager
operator|.
name|ontology
operator|.
name|UnmodifiableOntologySpaceException
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|kres
operator|.
name|api
operator|.
name|storage
operator|.
name|OntologyStorage
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|kres
operator|.
name|manager
operator|.
name|ONManager
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|kres
operator|.
name|manager
operator|.
name|io
operator|.
name|RootOntologySource
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|kres
operator|.
name|manager
operator|.
name|util
operator|.
name|OntologyUtils
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|kres
operator|.
name|manager
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_comment
comment|/**  * Abstract implementation of an ontology space. While it still leaves it up to  * developers to decide what locking policies to adopt for subclasses (in the  *<code>setUp()</code> method), it provides default implementations of all  * other interface methods.<br>  *<br>  * NOTE: By default, an ontology space is NOT write-locked. Developers need to  * set the<code>locked</code> variable to true to make the space read-only.  *   * @author alessandro  *   */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|AbstractOntologySpaceImpl
implements|implements
name|OntologySpace
block|{
specifier|protected
name|IRI
name|_id
init|=
literal|null
decl_stmt|;
specifier|private
name|Set
argument_list|<
name|OntologySpaceListener
argument_list|>
name|listeners
init|=
operator|new
name|HashSet
argument_list|<
name|OntologySpaceListener
argument_list|>
argument_list|()
decl_stmt|;
comment|/** 	 * Indicates whether this ontology space is marked as read-only. Default 	 * value is false. 	 */
specifier|protected
name|boolean
name|locked
init|=
literal|false
decl_stmt|;
comment|/** 	 * Each ontology space comes with its OWL ontology manager. By default, it 	 * is not available to the outside world, unless subclasses implement 	 * methods to return it. 	 */
specifier|protected
name|OWLOntologyManager
name|ontologyManager
decl_stmt|;
specifier|protected
name|IRI
name|parentID
init|=
literal|null
decl_stmt|;
specifier|protected
name|OWLOntology
name|rootOntology
init|=
literal|null
decl_stmt|;
specifier|protected
name|boolean
name|silent
init|=
literal|false
decl_stmt|;
specifier|protected
name|AbstractOntologySpaceImpl
parameter_list|(
name|IRI
name|spaceID
parameter_list|,
name|IRI
name|parentID
parameter_list|)
block|{
name|this
argument_list|(
name|spaceID
argument_list|,
name|parentID
argument_list|,
name|OWLManager
operator|.
name|createOWLOntologyManager
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * TODO: manage IDs properly 	 *  	 * @param rootOntology 	 */
specifier|public
name|AbstractOntologySpaceImpl
parameter_list|(
name|IRI
name|spaceID
parameter_list|,
name|IRI
name|parentID
parameter_list|,
name|OntologyInputSource
name|rootOntology
parameter_list|)
block|{
name|this
argument_list|(
name|spaceID
argument_list|,
name|parentID
argument_list|,
name|OWLManager
operator|.
name|createOWLOntologyManager
argument_list|()
argument_list|,
name|rootOntology
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Creates a new ontology space with the supplied ontology manager as the 	 * default manager for this space. 	 *  	 * @param spaceID 	 *            the IRI that will uniquely identify this space. 	 * @param ontologyManager 	 *            the default ontology manager for this space. 	 */
specifier|protected
name|AbstractOntologySpaceImpl
parameter_list|(
name|IRI
name|spaceID
parameter_list|,
name|IRI
name|parentID
parameter_list|,
name|OWLOntologyManager
name|ontologyManager
parameter_list|)
block|{
name|this
operator|.
name|parentID
operator|=
name|parentID
expr_stmt|;
comment|// FIXME: ensure that this is not null
name|OntologyScope
name|ps
init|=
name|ONManager
operator|.
name|get
argument_list|()
operator|.
name|getScopeRegistry
argument_list|()
operator|.
name|getScope
argument_list|(
name|parentID
argument_list|)
decl_stmt|;
if|if
condition|(
name|ps
operator|!=
literal|null
operator|&&
name|ps
operator|instanceof
name|OntologySpaceListener
condition|)
name|this
operator|.
name|addOntologySpaceListener
argument_list|(
operator|(
name|OntologySpaceListener
operator|)
name|ps
argument_list|)
expr_stmt|;
name|this
operator|.
name|_id
operator|=
name|spaceID
expr_stmt|;
if|if
condition|(
name|ontologyManager
operator|!=
literal|null
condition|)
name|this
operator|.
name|ontologyManager
operator|=
name|ontologyManager
expr_stmt|;
else|else
name|this
operator|.
name|ontologyManager
operator|=
name|OWLManager
operator|.
name|createOWLOntologyManager
argument_list|()
expr_stmt|;
name|this
operator|.
name|ontologyManager
operator|.
name|addOntologyLoaderListener
argument_list|(
operator|new
name|OWLOntologyLoaderListener
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|finishedLoadingOntology
parameter_list|(
name|LoadingFinishedEvent
name|arg0
parameter_list|)
block|{
if|if
condition|(
name|arg0
operator|.
name|isSuccessful
argument_list|()
condition|)
block|{
name|fireOntologyAdded
argument_list|(
name|arg0
operator|.
name|getOntologyID
argument_list|()
operator|.
name|getOntologyIRI
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|startedLoadingOntology
parameter_list|(
name|LoadingStartedEvent
name|arg0
parameter_list|)
block|{
comment|// TODO Auto-generated method stub
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Creates a new ontology space with the supplied ontology set as its top 	 * ontology and the supplied ontology manager as the default manager for 	 * this space. 	 *  	 * @param spaceID 	 *            the IRI that will uniquely identify this space. 	 * @param ontologyManager 	 *            the default ontology manager for this space. 	 * @param rootSource 	 *            the root ontology for this space. 	 */
specifier|public
name|AbstractOntologySpaceImpl
parameter_list|(
name|IRI
name|spaceID
parameter_list|,
name|IRI
name|parentID
parameter_list|,
name|OWLOntologyManager
name|ontologyManager
parameter_list|,
name|OntologyInputSource
name|rootSource
parameter_list|)
block|{
name|this
argument_list|(
name|spaceID
argument_list|,
name|parentID
argument_list|,
name|ontologyManager
argument_list|)
expr_stmt|;
comment|// Set the supplied ontology's parent as the root for this space.
try|try
block|{
name|this
operator|.
name|setTopOntology
argument_list|(
name|rootSource
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnmodifiableOntologySpaceException
name|e
parameter_list|)
block|{
name|ONManager
operator|.
name|get
argument_list|()
operator|.
name|log
operator|.
name|error
argument_list|(
literal|"KReS :: Ontology space "
operator|+
name|spaceID
operator|+
literal|" found locked at creation time!"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 	 * TODO: manage import statements 	 *  	 * TODO 2 : manage anonymous ontologies. 	 */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|addOntology
parameter_list|(
name|OntologyInputSource
name|ontologySource
parameter_list|)
throws|throws
name|UnmodifiableOntologySpaceException
block|{
if|if
condition|(
name|locked
condition|)
throw|throw
operator|new
name|UnmodifiableOntologySpaceException
argument_list|(
name|this
argument_list|)
throw|;
name|Logger
name|log
init|=
name|ONManager
operator|.
name|get
argument_list|()
operator|.
name|log
decl_stmt|;
comment|// if (ontologySource != null&& parentID != null)
comment|// // rewrite the source
comment|// ontologySource = new ScopeOntologySource(parentID,
comment|// ontologySource.getRootOntology(), ontologySource
comment|// .getPhysicalIRI());
name|OWLOntology
name|ontology
init|=
name|ontologySource
operator|!=
literal|null
condition|?
name|ontologySource
operator|.
name|getRootOntology
argument_list|()
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|getTopOntology
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// If no top ontology has been set, we must create one first.
name|IRI
name|rootIri
init|=
literal|null
decl_stmt|;
try|try
block|{
name|rootIri
operator|=
name|IRI
operator|.
name|create
argument_list|(
name|StringUtils
operator|.
name|stripIRITerminator
argument_list|(
name|getID
argument_list|()
argument_list|)
operator|+
literal|"/root.owl"
argument_list|)
expr_stmt|;
name|OntologyInputSource
name|src
init|=
operator|new
name|RootOntologySource
argument_list|(
name|ontologyManager
operator|.
name|createOntology
argument_list|(
name|rootIri
argument_list|)
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// Don't bother about the ontology to be added right now.
name|setTopOntology
argument_list|(
name|src
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OWLOntologyCreationException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"KReS :: Exception caught when creating top ontology "
operator|+
name|rootIri
operator|+
literal|" for space "
operator|+
name|this
operator|.
name|getID
argument_list|()
operator|+
literal|"."
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// No point in continuing if we can't even create the root...
return|return;
block|}
block|}
comment|// Now add the new ontology.
if|if
condition|(
name|ontology
operator|!=
literal|null
condition|)
block|{
name|OWLOntologyID
name|id
init|=
name|ontology
operator|.
name|getOntologyID
argument_list|()
decl_stmt|;
try|try
block|{
comment|// if (ontologySource != null&& parentID != null)
comment|// // rewrite the source
comment|// ontologySource = new ScopeOntologySource(parentID,
comment|// ontologySource.getRootOntology(), ontologySource
comment|// .getPhysicalIRI());
name|OntologyUtils
operator|.
name|appendOntology
argument_list|(
operator|new
name|RootOntologySource
argument_list|(
name|getTopOntology
argument_list|()
argument_list|,
literal|null
argument_list|)
argument_list|,
name|ontologySource
argument_list|,
name|ontologyManager
comment|/* ,parentID */
argument_list|)
expr_stmt|;
name|StringDocumentTarget
name|tgt
init|=
operator|new
name|StringDocumentTarget
argument_list|()
decl_stmt|;
name|ontologyManager
operator|.
name|saveOntology
argument_list|(
name|ontology
argument_list|,
operator|new
name|RDFXMLOntologyFormat
argument_list|()
argument_list|,
name|tgt
argument_list|)
expr_stmt|;
name|ontologyManager
operator|.
name|loadOntologyFromOntologyDocument
argument_list|(
operator|new
name|StringDocumentSource
argument_list|(
name|tgt
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
comment|// Store the top ontology
if|if
condition|(
operator|!
operator|(
name|this
operator|instanceof
name|SessionOntologySpace
operator|)
condition|)
block|{
name|OntologyStorage
name|storage
init|=
name|ONManager
operator|.
name|get
argument_list|()
operator|.
name|getOntologyStore
argument_list|()
decl_stmt|;
if|if
condition|(
name|storage
operator|==
literal|null
condition|)
name|log
operator|.
name|error
argument_list|(
literal|"KReS :: [NONFATAL] no ontology storage found. Ontology "
operator|+
name|ontology
operator|.
name|getOntologyID
argument_list|()
operator|+
literal|" will be stored in-memory only."
argument_list|)
expr_stmt|;
else|else
name|storage
operator|.
name|store
argument_list|(
name|ontology
argument_list|)
expr_stmt|;
block|}
comment|// ONManager.get().getOntologyStore().load(rootOntology.getOntologyID().getOntologyIRI());
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"KReS :: [NONFATAL] An error occurred while storing ontology "
operator|+
name|ontology
operator|+
literal|" . Ontology management will be volatile!"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|fireOntologyAdded
argument_list|(
name|id
operator|.
name|getOntologyIRI
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OWLOntologyAlreadyExistsException
name|e
parameter_list|)
block|{
comment|// Could happen if we supplied an ontology manager that already
comment|// knows this ontology. Nothing to do then.
name|log
operator|.
name|warn
argument_list|(
literal|"KReS : [NONFATAL] Tried to copy ontology "
operator|+
name|id
operator|+
literal|" to existing one."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OWLOntologyCreationException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Unexpected exception caught while copying ontology "
operator|+
name|id
operator|+
literal|" across managers"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OWLOntologyStorageException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"KReS : [FATAL] Failed to store ontology "
operator|+
name|id
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|addOntologySpaceListener
parameter_list|(
name|OntologySpaceListener
name|listener
parameter_list|)
block|{
name|listeners
operator|.
name|add
argument_list|(
name|listener
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|clearOntologySpaceListeners
parameter_list|()
block|{
name|listeners
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|containsOntology
parameter_list|(
name|IRI
name|ontologyIri
parameter_list|)
block|{
return|return
name|ontologyManager
operator|.
name|contains
argument_list|(
name|ontologyIri
argument_list|)
return|;
block|}
specifier|protected
name|void
name|fireOntologyAdded
parameter_list|(
name|IRI
name|ontologyIri
parameter_list|)
block|{
for|for
control|(
name|OntologySpaceListener
name|listener
range|:
name|listeners
control|)
name|listener
operator|.
name|onOntologyAdded
argument_list|(
name|this
operator|.
name|getID
argument_list|()
argument_list|,
name|ontologyIri
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|fireOntologyRemoved
parameter_list|(
name|IRI
name|ontologyIri
parameter_list|)
block|{
for|for
control|(
name|OntologySpaceListener
name|listener
range|:
name|listeners
control|)
name|listener
operator|.
name|onOntologyRemoved
argument_list|(
name|this
operator|.
name|getID
argument_list|()
argument_list|,
name|ontologyIri
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|IRI
name|getID
parameter_list|()
block|{
return|return
name|_id
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|Set
argument_list|<
name|OWLOntology
argument_list|>
name|getOntologies
parameter_list|()
block|{
return|return
name|ontologyManager
operator|.
name|getOntologies
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|OWLOntology
name|getOntology
parameter_list|(
name|IRI
name|ontologyIri
parameter_list|)
block|{
return|return
name|ontologyManager
operator|.
name|getOntology
argument_list|(
name|ontologyIri
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|OntologySpaceListener
argument_list|>
name|getOntologyScopeListeners
parameter_list|()
block|{
return|return
name|listeners
return|;
block|}
annotation|@
name|Override
specifier|public
name|OWLOntology
name|getTopOntology
parameter_list|()
block|{
return|return
name|rootOntology
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasOntology
parameter_list|(
name|IRI
name|ontologyIri
parameter_list|)
block|{
return|return
name|this
operator|.
name|getOntology
argument_list|(
name|ontologyIri
argument_list|)
operator|!=
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isLocked
parameter_list|()
block|{
return|return
name|locked
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isSilentMissingOntologyHandling
parameter_list|()
block|{
return|return
name|silent
return|;
block|}
comment|/** 	 * TODO 1 : optimize addition/removal<br> 	 * TODO 2 : set import statements 	 */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|removeOntology
parameter_list|(
name|OntologyInputSource
name|src
parameter_list|)
throws|throws
name|OntologySpaceModificationException
block|{
if|if
condition|(
name|locked
condition|)
throw|throw
operator|new
name|UnmodifiableOntologySpaceException
argument_list|(
name|this
argument_list|)
throw|;
else|else
block|{
comment|// TODO : find a way to remove anonymous ontologies.
name|OWLOntology
name|o
init|=
name|src
operator|.
name|getRootOntology
argument_list|()
decl_stmt|;
name|IRI
name|logicalID
init|=
literal|null
decl_stmt|,
name|physicalIRI
init|=
literal|null
decl_stmt|;
try|try
block|{
name|logicalID
operator|=
name|o
operator|.
name|getOntologyID
argument_list|()
operator|.
name|getOntologyIRI
argument_list|()
expr_stmt|;
name|physicalIRI
operator|=
name|src
operator|.
name|getPhysicalIRI
argument_list|()
expr_stmt|;
if|if
condition|(
name|physicalIRI
operator|==
literal|null
condition|)
if|if
condition|(
name|isSilentMissingOntologyHandling
argument_list|()
condition|)
return|return;
else|else
throw|throw
operator|new
name|MissingOntologyException
argument_list|(
name|this
argument_list|,
literal|null
argument_list|)
throw|;
if|if
condition|(
name|logicalID
operator|==
literal|null
condition|)
name|logicalID
operator|=
name|physicalIRI
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|ex
parameter_list|)
block|{
if|if
condition|(
name|isSilentMissingOntologyHandling
argument_list|()
condition|)
return|return;
else|else
throw|throw
operator|new
name|MissingOntologyException
argument_list|(
name|this
argument_list|,
literal|null
argument_list|)
throw|;
block|}
if|if
condition|(
name|o
operator|.
name|equals
argument_list|(
name|getTopOntology
argument_list|()
argument_list|)
condition|)
comment|// setTopOntology(null, false);
throw|throw
operator|new
name|IrremovableOntologyException
argument_list|(
name|this
argument_list|,
name|logicalID
argument_list|)
throw|;
try|try
block|{
name|OWLImportsDeclaration
name|imp
init|=
name|ontologyManager
operator|.
name|getOWLDataFactory
argument_list|()
operator|.
name|getOWLImportsDeclaration
argument_list|(
name|physicalIRI
argument_list|)
decl_stmt|;
name|ontologyManager
operator|.
name|applyChange
argument_list|(
operator|new
name|RemoveImport
argument_list|(
name|getTopOntology
argument_list|()
argument_list|,
name|imp
argument_list|)
argument_list|)
expr_stmt|;
name|ontologyManager
operator|.
name|removeOntology
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|fireOntologyRemoved
argument_list|(
name|logicalID
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|OntologySpaceModificationException
argument_list|(
name|this
argument_list|)
throw|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeOntologySpaceListener
parameter_list|(
name|OntologySpaceListener
name|listener
parameter_list|)
block|{
name|listeners
operator|.
name|remove
argument_list|(
name|listener
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setSilentMissingOntologyHandling
parameter_list|(
name|boolean
name|silent
parameter_list|)
block|{
name|this
operator|.
name|silent
operator|=
name|silent
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|setTopOntology
parameter_list|(
name|OntologyInputSource
name|ontologySource
parameter_list|)
throws|throws
name|UnmodifiableOntologySpaceException
block|{
name|setTopOntology
argument_list|(
name|ontologySource
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * TODO 1 : Attention: ontology is NOT added to ontology manager! 	 */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|setTopOntology
parameter_list|(
name|OntologyInputSource
name|ontologySource
parameter_list|,
name|boolean
name|createParent
parameter_list|)
throws|throws
name|UnmodifiableOntologySpaceException
block|{
name|Logger
name|log
init|=
name|ONManager
operator|.
name|get
argument_list|()
operator|.
name|log
decl_stmt|;
comment|// TODO : implement or avoid passing of OWLOntology objects across
comment|// managers
comment|// Clear the ontology manager
for|for
control|(
name|OWLOntology
name|o
range|:
name|ontologyManager
operator|.
name|getOntologies
argument_list|()
control|)
block|{
name|ontologyManager
operator|.
name|removeOntology
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|fireOntologyRemoved
argument_list|(
name|o
operator|.
name|getOntologyID
argument_list|()
operator|.
name|getOntologyIRI
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|OWLOntologyID
name|id
init|=
operator|new
name|OWLOntologyID
argument_list|(
name|IRI
operator|.
name|create
argument_list|(
name|StringUtils
operator|.
name|stripIRITerminator
argument_list|(
name|_id
argument_list|)
operator|+
literal|"/root.owl"
argument_list|)
argument_list|)
decl_stmt|;
name|OWLOntology
name|ontology
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ontologySource
operator|!=
literal|null
condition|)
block|{
name|ontology
operator|=
name|ontologySource
operator|.
name|getRootOntology
argument_list|()
expr_stmt|;
block|}
name|OWLOntology
comment|/* oTarget = null, */
name|oParent
init|=
literal|null
decl_stmt|;
comment|// If set to create a parent ontology or this one is anonymous, create
comment|// the parent
if|if
condition|(
name|createParent
operator|||
name|ontology
operator|==
literal|null
operator|||
name|ontology
operator|.
name|isAnonymous
argument_list|()
condition|)
block|{
try|try
block|{
name|oParent
operator|=
name|ontologyManager
operator|.
name|createOntology
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OWLOntologyAlreadyExistsException
name|e
parameter_list|)
block|{
name|oParent
operator|=
name|ontologyManager
operator|.
name|getOntology
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OWLOntologyCreationException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"KReS :: Failed to copy ontology "
operator|+
name|ontology
operator|.
name|getOntologyID
argument_list|()
operator|+
literal|" across ontology managers."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// If we don't have to create a parent, assign the original ontology
comment|// to it.
name|oParent
operator|=
name|ontology
expr_stmt|;
block|}
if|if
condition|(
name|ontologySource
operator|!=
literal|null
condition|)
try|try
block|{
comment|// if (ontologySource != null&& parentID != null)
comment|// // rewrite the source
comment|// ontologySource = new ScopeOntologySource(parentID,
comment|// ontologySource.getRootOntology(), ontologySource
comment|// .getPhysicalIRI());
comment|// Append the supplied ontology to the parent.
name|oParent
operator|=
name|OntologyUtils
operator|.
name|appendOntology
argument_list|(
operator|new
name|RootOntologySource
argument_list|(
name|oParent
argument_list|,
literal|null
argument_list|)
argument_list|,
name|ontologySource
argument_list|,
name|ontologyManager
comment|/* 																		 * ,parentID 																		 */
argument_list|)
expr_stmt|;
comment|// Save and reload it to make sure the whole import closure is
comment|// loaded in memory.
name|StringDocumentTarget
name|tgt
init|=
operator|new
name|StringDocumentTarget
argument_list|()
decl_stmt|;
name|ontologyManager
operator|.
name|saveOntology
argument_list|(
name|oParent
argument_list|,
operator|new
name|RDFXMLOntologyFormat
argument_list|()
argument_list|,
name|tgt
argument_list|)
expr_stmt|;
name|ontologyManager
operator|.
name|removeOntology
argument_list|(
name|oParent
argument_list|)
expr_stmt|;
name|ontologyManager
operator|.
name|loadOntologyFromOntologyDocument
argument_list|(
operator|new
name|StringDocumentSource
argument_list|(
name|tgt
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OWLOntologyAlreadyExistsException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"KReS : [NONFATAL] Tried to copy ontology "
operator|+
name|id
operator|+
literal|" to existing one."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OWLOntologyCreationException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"KReS : [FATAL] Failed to create ontology "
operator|+
name|id
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OWLOntologyStorageException
name|e
parameter_list|)
block|{
comment|// Shouldn't be a problem to save it in memory as RDF/XML...
name|log
operator|.
name|error
argument_list|(
literal|"KReS : [FATAL] In-memory store failed for ontology "
operator|+
name|id
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// Assign the ontology and fire the corresponding event.
name|rootOntology
operator|=
name|oParent
operator|!=
literal|null
condition|?
name|oParent
else|:
name|ontology
expr_stmt|;
try|try
block|{
comment|// Store the top ontology
if|if
condition|(
operator|!
operator|(
name|this
operator|instanceof
name|SessionOntologySpace
operator|)
condition|)
block|{
name|OntologyStorage
name|storage
init|=
name|ONManager
operator|.
name|get
argument_list|()
operator|.
name|getOntologyStore
argument_list|()
decl_stmt|;
if|if
condition|(
name|storage
operator|==
literal|null
condition|)
name|log
operator|.
name|error
argument_list|(
literal|"KReS :: [NONFATAL] no ontology storage found. Ontology "
operator|+
name|rootOntology
operator|.
name|getOntologyID
argument_list|()
operator|+
literal|" will be stored in-memory only."
argument_list|)
expr_stmt|;
else|else
name|storage
operator|.
name|store
argument_list|(
name|rootOntology
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"KReS :: [NONFATAL] An error occurred while storing root ontology "
operator|+
name|rootOntology
operator|+
literal|" . Ontology management will be volatile!"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|fireOntologyAdded
argument_list|(
name|rootOntology
operator|.
name|getOntologyID
argument_list|()
operator|.
name|getOntologyIRI
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

