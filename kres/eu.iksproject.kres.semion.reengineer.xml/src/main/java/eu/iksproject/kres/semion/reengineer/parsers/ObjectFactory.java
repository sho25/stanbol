begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2001-2005 The Apache Software Foundation.  *   * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *   *      http://www.apache.org/licenses/LICENSE-2.0  *   * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|eu
operator|.
name|iksproject
operator|.
name|kres
operator|.
name|semion
operator|.
name|reengineer
operator|.
name|parsers
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_comment
comment|/**  * This class is duplicated for each JAXP subpackage so keep it in sync.  * It is package private and therefore is not exposed as part of the JAXP  * API.  *<p>  * This code is designed to implement the JAXP 1.1 spec pluggability  * feature and is designed to run on JDK version 1.1 and  * later, and to compile on JDK 1.2 and onward.  * The code also runs both as part of an unbundled jar file and  * when bundled as part of the JDK.  *<p>  *  * @version $Id$  */
end_comment

begin_class
specifier|final
class|class
name|ObjectFactory
block|{
comment|//
comment|// Constants
comment|//
comment|// name of default properties file to look for in JDK's jre/lib directory
specifier|private
specifier|static
specifier|final
name|String
name|DEFAULT_PROPERTIES_FILENAME
init|=
literal|"xerces.properties"
decl_stmt|;
comment|/** Set to true for debugging */
specifier|private
specifier|static
specifier|final
name|boolean
name|DEBUG
init|=
literal|false
decl_stmt|;
comment|/**      * Default columns per line.      */
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_LINE_LENGTH
init|=
literal|80
decl_stmt|;
comment|/** cache the contents of the xerces.properties file.      *  Until an attempt has been made to read this file, this will      * be null; if the file does not exist or we encounter some other error      * during the read, this will be empty.      */
specifier|private
specifier|static
name|Properties
name|fXercesProperties
init|=
literal|null
decl_stmt|;
comment|/***      * Cache the time stamp of the xerces.properties file so      * that we know if it's been modified and can invalidate      * the cache when necessary.      */
specifier|private
specifier|static
name|long
name|fLastModified
init|=
operator|-
literal|1
decl_stmt|;
comment|//
comment|// static methods
comment|//
comment|/**      * Finds the implementation Class object in the specified order.  The      * specified order is the following:      *<ol>      *<li>query the system property using<code>System.getProperty</code>      *<li>read<code>META-INF/services/<i>factoryId</i></code> file      *<li>use fallback classname      *</ol>      *      * @return Class object of factory, never null      *      * @param factoryId             Name of the factory to find, same as      *                              a property name      * @param fallbackClassName     Implementation class name, if nothing else      *                              is found.  Use null to mean no fallback.      *      * @exception ObjectFactory.ConfigurationError      */
specifier|static
name|Object
name|createObject
parameter_list|(
name|String
name|factoryId
parameter_list|,
name|String
name|fallbackClassName
parameter_list|)
throws|throws
name|ConfigurationError
block|{
return|return
name|createObject
argument_list|(
name|factoryId
argument_list|,
literal|null
argument_list|,
name|fallbackClassName
argument_list|)
return|;
block|}
comment|// createObject(String,String):Object
comment|/**      * Finds the implementation Class object in the specified order.  The      * specified order is the following:      *<ol>      *<li>query the system property using<code>System.getProperty</code>      *<li>read<code>$java.home/lib/<i>propertiesFilename</i></code> file      *<li>read<code>META-INF/services/<i>factoryId</i></code> file      *<li>use fallback classname      *</ol>      *      * @return Class object of factory, never null      *      * @param factoryId             Name of the factory to find, same as      *                              a property name      * @param propertiesFilename The filename in the $java.home/lib directory      *                           of the properties file.  If none specified,      *                           ${java.home}/lib/xerces.properties will be used.      * @param fallbackClassName     Implementation class name, if nothing else      *                              is found.  Use null to mean no fallback.      *      * @exception ObjectFactory.ConfigurationError      */
specifier|static
name|Object
name|createObject
parameter_list|(
name|String
name|factoryId
parameter_list|,
name|String
name|propertiesFilename
parameter_list|,
name|String
name|fallbackClassName
parameter_list|)
throws|throws
name|ConfigurationError
block|{
if|if
condition|(
name|DEBUG
condition|)
name|debugPrintln
argument_list|(
literal|"debug is on"
argument_list|)
expr_stmt|;
name|SecuritySupport
name|ss
init|=
name|SecuritySupport
operator|.
name|getInstance
argument_list|()
decl_stmt|;
name|ClassLoader
name|cl
init|=
name|findClassLoader
argument_list|()
decl_stmt|;
comment|// Use the system property first
try|try
block|{
name|String
name|systemProp
init|=
name|ss
operator|.
name|getSystemProperty
argument_list|(
name|factoryId
argument_list|)
decl_stmt|;
if|if
condition|(
name|systemProp
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|debugPrintln
argument_list|(
literal|"found system property, value="
operator|+
name|systemProp
argument_list|)
expr_stmt|;
return|return
name|newInstance
argument_list|(
name|systemProp
argument_list|,
name|cl
argument_list|,
literal|true
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|SecurityException
name|se
parameter_list|)
block|{
comment|// Ignore and continue w/ next location
block|}
comment|// Try to read from propertiesFilename, or $java.home/lib/xerces.properties
name|String
name|factoryClassName
init|=
literal|null
decl_stmt|;
comment|// no properties file name specified; use $JAVA_HOME/lib/xerces.properties:
if|if
condition|(
name|propertiesFilename
operator|==
literal|null
condition|)
block|{
name|File
name|propertiesFile
init|=
literal|null
decl_stmt|;
name|boolean
name|propertiesFileExists
init|=
literal|false
decl_stmt|;
try|try
block|{
name|String
name|javah
init|=
name|ss
operator|.
name|getSystemProperty
argument_list|(
literal|"java.home"
argument_list|)
decl_stmt|;
name|propertiesFilename
operator|=
name|javah
operator|+
name|File
operator|.
name|separator
operator|+
literal|"lib"
operator|+
name|File
operator|.
name|separator
operator|+
name|DEFAULT_PROPERTIES_FILENAME
expr_stmt|;
name|propertiesFile
operator|=
operator|new
name|File
argument_list|(
name|propertiesFilename
argument_list|)
expr_stmt|;
name|propertiesFileExists
operator|=
name|ss
operator|.
name|getFileExists
argument_list|(
name|propertiesFile
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|e
parameter_list|)
block|{
comment|// try again...
name|fLastModified
operator|=
operator|-
literal|1
expr_stmt|;
name|fXercesProperties
operator|=
literal|null
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|ObjectFactory
operator|.
name|class
init|)
block|{
name|boolean
name|loadProperties
init|=
literal|false
decl_stmt|;
name|FileInputStream
name|fis
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// file existed last time
if|if
condition|(
name|fLastModified
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|propertiesFileExists
operator|&&
operator|(
name|fLastModified
operator|<
operator|(
name|fLastModified
operator|=
name|ss
operator|.
name|getLastModified
argument_list|(
name|propertiesFile
argument_list|)
operator|)
operator|)
condition|)
block|{
name|loadProperties
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// file has stopped existing...
if|if
condition|(
operator|!
name|propertiesFileExists
condition|)
block|{
name|fLastModified
operator|=
operator|-
literal|1
expr_stmt|;
name|fXercesProperties
operator|=
literal|null
expr_stmt|;
block|}
comment|// else, file wasn't modified!
block|}
block|}
else|else
block|{
comment|// file has started to exist:
if|if
condition|(
name|propertiesFileExists
condition|)
block|{
name|loadProperties
operator|=
literal|true
expr_stmt|;
name|fLastModified
operator|=
name|ss
operator|.
name|getLastModified
argument_list|(
name|propertiesFile
argument_list|)
expr_stmt|;
block|}
comment|// else, nothing's changed
block|}
if|if
condition|(
name|loadProperties
condition|)
block|{
comment|// must never have attempted to read xerces.properties before (or it's outdeated)
name|fXercesProperties
operator|=
operator|new
name|Properties
argument_list|()
expr_stmt|;
name|fis
operator|=
name|ss
operator|.
name|getFileInputStream
argument_list|(
name|propertiesFile
argument_list|)
expr_stmt|;
name|fXercesProperties
operator|.
name|load
argument_list|(
name|fis
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|x
parameter_list|)
block|{
name|fXercesProperties
operator|=
literal|null
expr_stmt|;
name|fLastModified
operator|=
operator|-
literal|1
expr_stmt|;
comment|// assert(x instanceof FileNotFoundException
comment|//        || x instanceof SecurityException)
comment|// In both cases, ignore and continue w/ next location
block|}
finally|finally
block|{
comment|// try to close the input stream if one was opened.
if|if
condition|(
name|fis
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|fis
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// Ignore the exception.
catch|catch
parameter_list|(
name|IOException
name|exc
parameter_list|)
block|{}
block|}
block|}
block|}
if|if
condition|(
name|fXercesProperties
operator|!=
literal|null
condition|)
block|{
name|factoryClassName
operator|=
name|fXercesProperties
operator|.
name|getProperty
argument_list|(
name|factoryId
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|FileInputStream
name|fis
init|=
literal|null
decl_stmt|;
try|try
block|{
name|fis
operator|=
name|ss
operator|.
name|getFileInputStream
argument_list|(
operator|new
name|File
argument_list|(
name|propertiesFilename
argument_list|)
argument_list|)
expr_stmt|;
name|Properties
name|props
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|props
operator|.
name|load
argument_list|(
name|fis
argument_list|)
expr_stmt|;
name|factoryClassName
operator|=
name|props
operator|.
name|getProperty
argument_list|(
name|factoryId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|x
parameter_list|)
block|{
comment|// assert(x instanceof FileNotFoundException
comment|//        || x instanceof SecurityException)
comment|// In both cases, ignore and continue w/ next location
block|}
finally|finally
block|{
comment|// try to close the input stream if one was opened.
if|if
condition|(
name|fis
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|fis
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// Ignore the exception.
catch|catch
parameter_list|(
name|IOException
name|exc
parameter_list|)
block|{}
block|}
block|}
block|}
if|if
condition|(
name|factoryClassName
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|debugPrintln
argument_list|(
literal|"found in "
operator|+
name|propertiesFilename
operator|+
literal|", value="
operator|+
name|factoryClassName
argument_list|)
expr_stmt|;
return|return
name|newInstance
argument_list|(
name|factoryClassName
argument_list|,
name|cl
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|// Try Jar Service Provider Mechanism
name|Object
name|provider
init|=
name|findJarServiceProvider
argument_list|(
name|factoryId
argument_list|)
decl_stmt|;
if|if
condition|(
name|provider
operator|!=
literal|null
condition|)
block|{
return|return
name|provider
return|;
block|}
if|if
condition|(
name|fallbackClassName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ConfigurationError
argument_list|(
literal|"Provider for "
operator|+
name|factoryId
operator|+
literal|" cannot be found"
argument_list|,
literal|null
argument_list|)
throw|;
block|}
if|if
condition|(
name|DEBUG
condition|)
name|debugPrintln
argument_list|(
literal|"using fallback, value="
operator|+
name|fallbackClassName
argument_list|)
expr_stmt|;
return|return
name|newInstance
argument_list|(
name|fallbackClassName
argument_list|,
name|cl
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|// createObject(String,String,String):Object
comment|//
comment|// Private static methods
comment|//
comment|/** Prints a message to standard error if debugging is enabled. */
specifier|private
specifier|static
name|void
name|debugPrintln
parameter_list|(
name|String
name|msg
parameter_list|)
block|{
if|if
condition|(
name|DEBUG
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"JAXP: "
operator|+
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
comment|// debugPrintln(String)
comment|/**      * Figure out which ClassLoader to use.  For JDK 1.2 and later use      * the context ClassLoader.      */
specifier|static
name|ClassLoader
name|findClassLoader
parameter_list|()
throws|throws
name|ConfigurationError
block|{
name|SecuritySupport
name|ss
init|=
name|SecuritySupport
operator|.
name|getInstance
argument_list|()
decl_stmt|;
comment|// Figure out which ClassLoader to use for loading the provider
comment|// class.  If there is a Context ClassLoader then use it.
name|ClassLoader
name|context
init|=
name|ss
operator|.
name|getContextClassLoader
argument_list|()
decl_stmt|;
name|ClassLoader
name|system
init|=
name|ss
operator|.
name|getSystemClassLoader
argument_list|()
decl_stmt|;
name|ClassLoader
name|chain
init|=
name|system
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|context
operator|==
name|chain
condition|)
block|{
comment|// Assert: we are on JDK 1.1 or we have no Context ClassLoader
comment|// or any Context ClassLoader in chain of system classloader
comment|// (including extension ClassLoader) so extend to widest
comment|// ClassLoader (always look in system ClassLoader if Xerces
comment|// is in boot/extension/system classpath and in current
comment|// ClassLoader otherwise); normal classloaders delegate
comment|// back to system ClassLoader first so this widening doesn't
comment|// change the fact that context ClassLoader will be consulted
name|ClassLoader
name|current
init|=
name|ObjectFactory
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
decl_stmt|;
name|chain
operator|=
name|system
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|current
operator|==
name|chain
condition|)
block|{
comment|// Assert: Current ClassLoader in chain of
comment|// boot/extension/system ClassLoaders
return|return
name|system
return|;
block|}
if|if
condition|(
name|chain
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|chain
operator|=
name|ss
operator|.
name|getParentClassLoader
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
comment|// Assert: Current ClassLoader not in chain of
comment|// boot/extension/system ClassLoaders
return|return
name|current
return|;
block|}
if|if
condition|(
name|chain
operator|==
literal|null
condition|)
block|{
comment|// boot ClassLoader reached
break|break;
block|}
comment|// Check for any extension ClassLoaders in chain up to
comment|// boot ClassLoader
name|chain
operator|=
name|ss
operator|.
name|getParentClassLoader
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|// Assert: Context ClassLoader not in chain of
comment|// boot/extension/system ClassLoaders
return|return
name|context
return|;
block|}
comment|// findClassLoader():ClassLoader
comment|/**      * Create an instance of a class using the specified ClassLoader      */
specifier|static
name|Object
name|newInstance
parameter_list|(
name|String
name|className
parameter_list|,
name|ClassLoader
name|cl
parameter_list|,
name|boolean
name|doFallback
parameter_list|)
throws|throws
name|ConfigurationError
block|{
comment|// assert(className != null);
try|try
block|{
name|Class
name|providerClass
init|=
name|findProviderClass
argument_list|(
name|className
argument_list|,
name|cl
argument_list|,
name|doFallback
argument_list|)
decl_stmt|;
name|Object
name|instance
init|=
name|providerClass
operator|.
name|newInstance
argument_list|()
decl_stmt|;
if|if
condition|(
name|DEBUG
condition|)
name|debugPrintln
argument_list|(
literal|"created new instance of "
operator|+
name|providerClass
operator|+
literal|" using ClassLoader: "
operator|+
name|cl
argument_list|)
expr_stmt|;
return|return
name|instance
return|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|x
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationError
argument_list|(
literal|"Provider "
operator|+
name|className
operator|+
literal|" not found"
argument_list|,
name|x
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|x
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationError
argument_list|(
literal|"Provider "
operator|+
name|className
operator|+
literal|" could not be instantiated: "
operator|+
name|x
argument_list|,
name|x
argument_list|)
throw|;
block|}
block|}
comment|/**      * Find a Class using the specified ClassLoader      */
specifier|static
name|Class
name|findProviderClass
parameter_list|(
name|String
name|className
parameter_list|,
name|ClassLoader
name|cl
parameter_list|,
name|boolean
name|doFallback
parameter_list|)
throws|throws
name|ClassNotFoundException
throws|,
name|ConfigurationError
block|{
comment|//throw security exception if the calling thread is not allowed to access the package
comment|//restrict the access to package as speicified in java.security policy
name|SecurityManager
name|security
init|=
name|System
operator|.
name|getSecurityManager
argument_list|()
decl_stmt|;
if|if
condition|(
name|security
operator|!=
literal|null
condition|)
block|{
specifier|final
name|int
name|lastDot
init|=
name|className
operator|.
name|lastIndexOf
argument_list|(
literal|"."
argument_list|)
decl_stmt|;
name|String
name|packageName
init|=
name|className
decl_stmt|;
if|if
condition|(
name|lastDot
operator|!=
operator|-
literal|1
condition|)
name|packageName
operator|=
name|className
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|lastDot
argument_list|)
expr_stmt|;
name|security
operator|.
name|checkPackageAccess
argument_list|(
name|packageName
argument_list|)
expr_stmt|;
block|}
name|Class
name|providerClass
decl_stmt|;
if|if
condition|(
name|cl
operator|==
literal|null
condition|)
block|{
comment|// XXX Use the bootstrap ClassLoader.  There is no way to
comment|// load a class using the bootstrap ClassLoader that works
comment|// in both JDK 1.1 and Java 2.  However, this should still
comment|// work b/c the following should be true:
comment|//
comment|// (cl == null) iff current ClassLoader == null
comment|//
comment|// Thus Class.forName(String) will use the current
comment|// ClassLoader which will be the bootstrap ClassLoader.
name|providerClass
operator|=
name|Class
operator|.
name|forName
argument_list|(
name|className
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|providerClass
operator|=
name|cl
operator|.
name|loadClass
argument_list|(
name|className
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|x
parameter_list|)
block|{
if|if
condition|(
name|doFallback
condition|)
block|{
comment|// Fall back to current classloader
name|ClassLoader
name|current
init|=
name|ObjectFactory
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
decl_stmt|;
if|if
condition|(
name|current
operator|==
literal|null
condition|)
block|{
name|providerClass
operator|=
name|Class
operator|.
name|forName
argument_list|(
name|className
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|!=
name|current
condition|)
block|{
name|cl
operator|=
name|current
expr_stmt|;
name|providerClass
operator|=
name|cl
operator|.
name|loadClass
argument_list|(
name|className
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|x
throw|;
block|}
block|}
else|else
block|{
throw|throw
name|x
throw|;
block|}
block|}
block|}
return|return
name|providerClass
return|;
block|}
comment|/*      * Try to find provider using Jar Service Provider Mechanism      *      * @return instance of provider class if found or null      */
specifier|private
specifier|static
name|Object
name|findJarServiceProvider
parameter_list|(
name|String
name|factoryId
parameter_list|)
throws|throws
name|ConfigurationError
block|{
name|SecuritySupport
name|ss
init|=
name|SecuritySupport
operator|.
name|getInstance
argument_list|()
decl_stmt|;
name|String
name|serviceId
init|=
literal|"META-INF/services/"
operator|+
name|factoryId
decl_stmt|;
name|InputStream
name|is
init|=
literal|null
decl_stmt|;
comment|// First try the Context ClassLoader
name|ClassLoader
name|cl
init|=
name|findClassLoader
argument_list|()
decl_stmt|;
name|is
operator|=
name|ss
operator|.
name|getResourceAsStream
argument_list|(
name|cl
argument_list|,
name|serviceId
argument_list|)
expr_stmt|;
comment|// If no provider found then try the current ClassLoader
if|if
condition|(
name|is
operator|==
literal|null
condition|)
block|{
name|ClassLoader
name|current
init|=
name|ObjectFactory
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
decl_stmt|;
if|if
condition|(
name|cl
operator|!=
name|current
condition|)
block|{
name|cl
operator|=
name|current
expr_stmt|;
name|is
operator|=
name|ss
operator|.
name|getResourceAsStream
argument_list|(
name|cl
argument_list|,
name|serviceId
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|is
operator|==
literal|null
condition|)
block|{
comment|// No provider found
return|return
literal|null
return|;
block|}
if|if
condition|(
name|DEBUG
condition|)
name|debugPrintln
argument_list|(
literal|"found jar resource="
operator|+
name|serviceId
operator|+
literal|" using ClassLoader: "
operator|+
name|cl
argument_list|)
expr_stmt|;
comment|// Read the service provider name in UTF-8 as specified in
comment|// the jar spec.  Unfortunately this fails in Microsoft
comment|// VJ++, which does not implement the UTF-8
comment|// encoding. Theoretically, we should simply let it fail in
comment|// that case, since the JVM is obviously broken if it
comment|// doesn't support such a basic standard.  But since there
comment|// are still some users attempting to use VJ++ for
comment|// development, we have dropped in a fallback which makes a
comment|// second attempt using the platform's default encoding. In
comment|// VJ++ this is apparently ASCII, which is a subset of
comment|// UTF-8... and since the strings we'll be reading here are
comment|// also primarily limited to the 7-bit ASCII range (at
comment|// least, in English versions), this should work well
comment|// enough to keep us on the air until we're ready to
comment|// officially decommit from VJ++. [Edited comment from
comment|// jkesselm]
name|BufferedReader
name|rd
decl_stmt|;
try|try
block|{
name|rd
operator|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|is
argument_list|,
literal|"UTF-8"
argument_list|)
argument_list|,
name|DEFAULT_LINE_LENGTH
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
name|e
parameter_list|)
block|{
name|rd
operator|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|is
argument_list|)
argument_list|,
name|DEFAULT_LINE_LENGTH
argument_list|)
expr_stmt|;
block|}
name|String
name|factoryClassName
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// XXX Does not handle all possible input as specified by the
comment|// Jar Service Provider specification
name|factoryClassName
operator|=
name|rd
operator|.
name|readLine
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|x
parameter_list|)
block|{
comment|// No provider found
return|return
literal|null
return|;
block|}
finally|finally
block|{
try|try
block|{
comment|// try to close the reader.
name|rd
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// Ignore the exception.
catch|catch
parameter_list|(
name|IOException
name|exc
parameter_list|)
block|{}
block|}
if|if
condition|(
name|factoryClassName
operator|!=
literal|null
operator|&&
operator|!
literal|""
operator|.
name|equals
argument_list|(
name|factoryClassName
argument_list|)
condition|)
block|{
if|if
condition|(
name|DEBUG
condition|)
name|debugPrintln
argument_list|(
literal|"found in resource, value="
operator|+
name|factoryClassName
argument_list|)
expr_stmt|;
comment|// Note: here we do not want to fall back to the current
comment|// ClassLoader because we want to avoid the case where the
comment|// resource file was found using one ClassLoader and the
comment|// provider class was instantiated using a different one.
return|return
name|newInstance
argument_list|(
name|factoryClassName
argument_list|,
name|cl
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|// No provider found
return|return
literal|null
return|;
block|}
comment|//
comment|// Classes
comment|//
comment|/**      * A configuration error.      */
specifier|static
specifier|final
class|class
name|ConfigurationError
extends|extends
name|Error
block|{
comment|/** Serialization version. */
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
operator|-
literal|7285495612271660427L
decl_stmt|;
comment|//
comment|// Data
comment|//
comment|/** Exception. */
specifier|private
name|Exception
name|exception
decl_stmt|;
comment|//
comment|// Constructors
comment|//
comment|/**          * Construct a new instance with the specified detail string and          * exception.          */
name|ConfigurationError
parameter_list|(
name|String
name|msg
parameter_list|,
name|Exception
name|x
parameter_list|)
block|{
name|super
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|this
operator|.
name|exception
operator|=
name|x
expr_stmt|;
block|}
comment|//<init>(String,Exception)
comment|//
comment|// methods
comment|//
comment|/** Returns the exception associated to this error. */
name|Exception
name|getException
parameter_list|()
block|{
return|return
name|exception
return|;
block|}
comment|// getException():Exception
block|}
comment|// class ConfigurationError
block|}
end_class

begin_comment
comment|// class ObjectFactory
end_comment

end_unit

