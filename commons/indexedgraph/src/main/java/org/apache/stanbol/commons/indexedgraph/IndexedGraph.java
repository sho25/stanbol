begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|indexedgraph
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|commons
operator|.
name|rdf
operator|.
name|BlankNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|commons
operator|.
name|rdf
operator|.
name|Language
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|commons
operator|.
name|rdf
operator|.
name|Literal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|commons
operator|.
name|rdf
operator|.
name|BlankNodeOrIRI
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|commons
operator|.
name|rdf
operator|.
name|RDFTerm
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|commons
operator|.
name|rdf
operator|.
name|Triple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|commons
operator|.
name|rdf
operator|.
name|Graph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|commons
operator|.
name|rdf
operator|.
name|IRI
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|commons
operator|.
name|rdf
operator|.
name|ImmutableGraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|commons
operator|.
name|rdf
operator|.
name|impl
operator|.
name|utils
operator|.
name|AbstractGraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|commons
operator|.
name|rdf
operator|.
name|impl
operator|.
name|utils
operator|.
name|TripleImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * {@link Graph} implementation that uses indexes for<ul>  *<li> subject, predicate, object [SPO]  *<li> predicate, object, subject [POS]  *<li> object, subject, predicate [OSP]  *</ul>  * Indexes are maintained in {@link TreeSet}s with according {@link Comparator}  * instances ({@link #spoComparator}, {@link #posComparator} ,  * {@link #ospComparator}). {@link RDFTerm}s are compared first using the  * {@link RDFTerm}#hashCode() and only if this matches by using  * {@link RDFTerm}{@link #toString()}  * .<p>  * The {@link #filter(BlankNodeOrIRI, IRI, RDFTerm)} implementation is based on  * {@link TreeSet#subSet(Object, Object)}. All Iterators returned directly  * operate on top of one of the internal indexes.  *<p>  * This class is not public, implementations should use {@link IndexedGraph} or  * {@link IndexedGraph}.  *  * @author rwesten  */
end_comment

begin_class
specifier|public
class|class
name|IndexedGraph
extends|extends
name|AbstractGraph
implements|implements
name|Graph
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|IndexedGraph
operator|.
name|class
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|ImmutableGraph
name|getImmutableGraph
parameter_list|()
block|{
return|return
operator|new
name|IndexedImmutableGraph
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**      * This map is used to ensure constant ordering for {@link BlankNode} that      * do have the same hashcode (and therefore result to have the same      * {@link BlankNode#toString()} value.      */
specifier|private
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|RDFTerm
argument_list|>
argument_list|>
name|hashCodeConflictMap
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|RDFTerm
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * Compares Triples based on Subject, Predicate, Object      */
specifier|private
specifier|final
name|Comparator
argument_list|<
name|Triple
argument_list|>
name|spoComparator
init|=
operator|new
name|Comparator
argument_list|<
name|Triple
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Triple
name|a
parameter_list|,
name|Triple
name|b
parameter_list|)
block|{
name|int
name|c
init|=
name|IndexedGraph
operator|.
name|compare
argument_list|(
name|a
operator|.
name|getSubject
argument_list|()
argument_list|,
name|b
operator|.
name|getSubject
argument_list|()
argument_list|,
name|hashCodeConflictMap
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|IndexedGraph
operator|.
name|compare
argument_list|(
name|a
operator|.
name|getPredicate
argument_list|()
argument_list|,
name|b
operator|.
name|getPredicate
argument_list|()
argument_list|,
name|hashCodeConflictMap
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|IndexedGraph
operator|.
name|compare
argument_list|(
name|a
operator|.
name|getObject
argument_list|()
argument_list|,
name|b
operator|.
name|getObject
argument_list|()
argument_list|,
name|hashCodeConflictMap
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|c
return|;
block|}
block|}
decl_stmt|;
comment|/**      * The SPO index      */
specifier|private
specifier|final
name|NavigableSet
argument_list|<
name|Triple
argument_list|>
name|spo
init|=
operator|new
name|TreeSet
argument_list|<
name|Triple
argument_list|>
argument_list|(
name|spoComparator
argument_list|)
decl_stmt|;
comment|/**      * Compares Triples based on Predicate, Object, Subject      */
specifier|private
specifier|final
name|Comparator
argument_list|<
name|Triple
argument_list|>
name|posComparator
init|=
operator|new
name|Comparator
argument_list|<
name|Triple
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Triple
name|a
parameter_list|,
name|Triple
name|b
parameter_list|)
block|{
name|int
name|c
init|=
name|IndexedGraph
operator|.
name|compare
argument_list|(
name|a
operator|.
name|getPredicate
argument_list|()
argument_list|,
name|b
operator|.
name|getPredicate
argument_list|()
argument_list|,
name|hashCodeConflictMap
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|IndexedGraph
operator|.
name|compare
argument_list|(
name|a
operator|.
name|getObject
argument_list|()
argument_list|,
name|b
operator|.
name|getObject
argument_list|()
argument_list|,
name|hashCodeConflictMap
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|IndexedGraph
operator|.
name|compare
argument_list|(
name|a
operator|.
name|getSubject
argument_list|()
argument_list|,
name|b
operator|.
name|getSubject
argument_list|()
argument_list|,
name|hashCodeConflictMap
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|c
return|;
block|}
block|}
decl_stmt|;
comment|/**      * The POS index      */
specifier|private
specifier|final
name|NavigableSet
argument_list|<
name|Triple
argument_list|>
name|pos
init|=
operator|new
name|TreeSet
argument_list|<
name|Triple
argument_list|>
argument_list|(
name|posComparator
argument_list|)
decl_stmt|;
comment|/**      * Compares Triples based on Object, Subject, Predicate      */
specifier|private
specifier|final
name|Comparator
argument_list|<
name|Triple
argument_list|>
name|ospComparator
init|=
operator|new
name|Comparator
argument_list|<
name|Triple
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Triple
name|a
parameter_list|,
name|Triple
name|b
parameter_list|)
block|{
name|int
name|c
init|=
name|IndexedGraph
operator|.
name|compare
argument_list|(
name|a
operator|.
name|getObject
argument_list|()
argument_list|,
name|b
operator|.
name|getObject
argument_list|()
argument_list|,
name|hashCodeConflictMap
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|IndexedGraph
operator|.
name|compare
argument_list|(
name|a
operator|.
name|getSubject
argument_list|()
argument_list|,
name|b
operator|.
name|getSubject
argument_list|()
argument_list|,
name|hashCodeConflictMap
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|IndexedGraph
operator|.
name|compare
argument_list|(
name|a
operator|.
name|getPredicate
argument_list|()
argument_list|,
name|b
operator|.
name|getPredicate
argument_list|()
argument_list|,
name|hashCodeConflictMap
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|c
return|;
block|}
block|}
decl_stmt|;
comment|/**      * The OSP index      */
specifier|private
specifier|final
name|NavigableSet
argument_list|<
name|Triple
argument_list|>
name|osp
init|=
operator|new
name|TreeSet
argument_list|<
name|Triple
argument_list|>
argument_list|(
name|ospComparator
argument_list|)
decl_stmt|;
comment|/**      * Creates an empty {@link IndexedGraph}      */
specifier|public
name|IndexedGraph
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
comment|/**      * Creates a {@link IndexedGraph} using the passed iterator, the iterator is      * consumed before the constructor returns      *      * @param iterator Triple Iterator      */
specifier|public
name|IndexedGraph
parameter_list|(
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|iterator
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Triple
name|triple
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|performAdd
argument_list|(
name|triple
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Creates a {@link IndexedGraph} for the specified collection of triples,      * subsequent modification of baseSet do not affect the created instance.      *      * @param baseCollection collection of triples      */
specifier|public
name|IndexedGraph
parameter_list|(
name|Collection
argument_list|<
name|Triple
argument_list|>
name|baseCollection
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|spo
operator|.
name|addAll
argument_list|(
name|baseCollection
argument_list|)
expr_stmt|;
comment|//use internal index to fill the other indexes, because the parsed
comment|//collection might be slow
name|pos
operator|.
name|addAll
argument_list|(
name|spo
argument_list|)
expr_stmt|;
name|osp
operator|.
name|addAll
argument_list|(
name|spo
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|performFilter
parameter_list|(
specifier|final
name|BlankNodeOrIRI
name|subject
parameter_list|,
specifier|final
name|IRI
name|predicate
parameter_list|,
specifier|final
name|RDFTerm
name|object
parameter_list|)
block|{
if|if
condition|(
name|subject
operator|==
literal|null
operator|&&
name|predicate
operator|==
literal|null
operator|&&
name|object
operator|==
literal|null
condition|)
block|{
comment|//[n,n,n]
return|return
name|createIterator
argument_list|(
name|spo
argument_list|,
name|spo
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
specifier|final
name|Triple
name|low
init|=
operator|new
name|TripleImpl
argument_list|(
name|subject
operator|==
literal|null
condition|?
name|MIN
else|:
name|subject
argument_list|,
name|predicate
operator|==
literal|null
condition|?
name|MIN
else|:
name|predicate
argument_list|,
name|object
operator|==
literal|null
condition|?
name|MIN
else|:
name|object
argument_list|)
decl_stmt|;
specifier|final
name|Triple
name|high
init|=
operator|new
name|TripleImpl
argument_list|(
name|subject
operator|==
literal|null
condition|?
name|MAX
else|:
name|subject
argument_list|,
name|predicate
operator|==
literal|null
condition|?
name|MAX
else|:
name|predicate
argument_list|,
name|object
operator|==
literal|null
condition|?
name|MAX
else|:
name|object
argument_list|)
decl_stmt|;
if|if
condition|(
name|subject
operator|!=
literal|null
operator|&&
name|predicate
operator|!=
literal|null
operator|&&
name|object
operator|!=
literal|null
condition|)
block|{
comment|// [S,P,O]
comment|//NOTE: low.equals(high) in that case!
return|return
name|createIterator
argument_list|(
name|spo
argument_list|,
name|spo
operator|.
name|subSet
argument_list|(
name|low
argument_list|,
literal|true
argument_list|,
name|low
argument_list|,
literal|true
argument_list|)
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|subject
operator|!=
literal|null
operator|&&
name|object
operator|==
literal|null
condition|)
block|{
comment|//[S,n,n], [S,P,n]
return|return
name|createIterator
argument_list|(
name|spo
argument_list|,
name|spo
operator|.
name|subSet
argument_list|(
name|low
argument_list|,
name|high
argument_list|)
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|predicate
operator|!=
literal|null
condition|)
block|{
comment|//[n,P,n], [n,P,O]
return|return
name|createIterator
argument_list|(
name|pos
argument_list|,
name|pos
operator|.
name|subSet
argument_list|(
name|low
argument_list|,
name|high
argument_list|)
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
comment|//[n,n,O] , [S,n,O]
return|return
name|createIterator
argument_list|(
name|osp
argument_list|,
name|osp
operator|.
name|subSet
argument_list|(
name|low
argument_list|,
name|high
argument_list|)
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|performAdd
parameter_list|(
name|Triple
name|triple
parameter_list|)
block|{
if|if
condition|(
name|spo
operator|.
name|add
argument_list|(
name|triple
argument_list|)
condition|)
block|{
name|osp
operator|.
name|add
argument_list|(
name|triple
argument_list|)
expr_stmt|;
return|return
name|pos
operator|.
name|add
argument_list|(
name|triple
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|performRemove
parameter_list|(
name|Object
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|instanceof
name|Triple
condition|)
block|{
name|Triple
name|triple
init|=
operator|(
name|Triple
operator|)
name|t
decl_stmt|;
if|if
condition|(
name|spo
operator|.
name|remove
argument_list|(
name|triple
argument_list|)
condition|)
block|{
name|osp
operator|.
name|remove
argument_list|(
name|triple
argument_list|)
expr_stmt|;
return|return
name|pos
operator|.
name|remove
argument_list|(
name|triple
argument_list|)
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|performSize
parameter_list|()
block|{
return|return
name|spo
operator|.
name|size
argument_list|()
return|;
block|}
comment|//    @Override
comment|//    public Iterator<Triple> iterator() {
comment|//        return createIterator(spo, spo.iterator());
comment|//    }
comment|/**      * Returns an Iterator that ensures that calls to {@link Iterator#remove()}      * remove items from all three indexes      *      * @param index      * @param base      * @return      */
specifier|private
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|createIterator
parameter_list|(
specifier|final
name|SortedSet
argument_list|<
name|Triple
argument_list|>
name|index
parameter_list|,
specifier|final
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|base
parameter_list|)
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|Triple
argument_list|>
argument_list|()
block|{
name|Triple
name|current
init|=
literal|null
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|base
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Triple
name|next
parameter_list|()
block|{
name|current
operator|=
name|base
operator|.
name|next
argument_list|()
expr_stmt|;
return|return
name|current
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|base
operator|.
name|remove
argument_list|()
expr_stmt|;
if|if
condition|(
name|current
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|index
operator|==
name|spo
operator|)
condition|)
block|{
name|spo
operator|.
name|remove
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|index
operator|==
name|pos
operator|)
condition|)
block|{
name|pos
operator|.
name|remove
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|index
operator|==
name|osp
operator|)
condition|)
block|{
name|osp
operator|.
name|remove
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|;
block|}
specifier|protected
specifier|static
name|IRI
name|MIN
init|=
operator|new
name|IRI
argument_list|(
literal|""
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Integer
operator|.
name|MIN_VALUE
return|;
block|}
empty_stmt|;
block|}
decl_stmt|;
specifier|protected
specifier|static
name|IRI
name|MAX
init|=
operator|new
name|IRI
argument_list|(
literal|""
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Integer
operator|.
name|MAX_VALUE
return|;
block|}
empty_stmt|;
block|}
decl_stmt|;
comment|//    /**
comment|//     * Compares two resources with special support for {@link #MIN} and
comment|//     * {@link #MAX} to allow building {@link SortedSet#subSet(Object, Object)}
comment|//     * for<code>null</code> values parsed to
comment|//     * {@link #filter(BlankNodeOrIRI, IRI, RDFTerm)}
comment|//     * @param a
comment|//     * @param b
comment|//     * @return
comment|//     */
comment|//    protected static int compareHash(RDFTerm a, RDFTerm b, Map<Integer,List<RDFTerm>> confictsMap) {
comment|//        int hashA = a.hashCode();
comment|//        int hashB = b.hashCode();
comment|//        if (hashA != hashB) {
comment|//            return hashA> hashB ? 1 : -1;
comment|//        }
comment|//        //those resources might be equals
comment|//        //(1) Check for MIN, MAX (used to build sub-sets). Other resources might
comment|//        //    have a similar hasCode
comment|//        int state = a == MIN || b == MAX ? -1 :
comment|//            a == MAX || b == MIN ? 1 : 0;
comment|//        if(state == 0){
comment|//            if(a.equals(b)){ //check of the resources are equals
comment|//                return 0; //return zero
comment|//            } else if(//we need to care about HashCode conflicts
comment|//                a instanceof BlankNode&& b instanceof BlankNode){ // of BlankNodes
comment|//                log.info("HashCode conflict for {} and {}",a,b); //we have a conflict
comment|//                return resolveBlankNodeHashConflict(a, b, confictsMap);
comment|//            } else { //same hashCode but not equals
comment|//                //use the String representation of the Resources to sort them
comment|//                String as = resource2String(a);
comment|//                String bs = resource2String(b);
comment|//                log.info("same hash code {} - compare Strings a: {}, b: {}",
comment|//                    new Object[]{a.hashCode(),as,bs});
comment|//                return as.compareTo(bs);
comment|//            }
comment|//        }
comment|//       return state;
comment|//    }
comment|/**      * Resolved BlankNode hasConflics, by storing the correct order for the affected      * {@link Integer} in a {@link List} of RDFTerm instances.      * @param a the first {@link BlankNode}      * @param b the second {@link BlankNode}      * @param confictsMap the Map used to store the order of BlankNodes with conflicts      * @return the decision taken based on the confictsMap.      */
specifier|private
specifier|static
name|int
name|resolveBlankNodeHashConflict
parameter_list|(
name|RDFTerm
name|a
parameter_list|,
name|RDFTerm
name|b
parameter_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|RDFTerm
argument_list|>
argument_list|>
name|confictsMap
parameter_list|)
block|{
comment|//This is not a bad thing. We need just to ensure constant ordering
comment|//and as there is nothing we can use to distinguish we need to keep
comment|//this information in a list.
name|Integer
name|hash
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|a
operator|.
name|hashCode
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|RDFTerm
argument_list|>
name|resources
init|=
name|confictsMap
operator|.
name|get
argument_list|(
name|hash
argument_list|)
decl_stmt|;
if|if
condition|(
name|resources
operator|==
literal|null
condition|)
block|{
comment|//new conflict ... just add and return
name|resources
operator|=
operator|new
name|ArrayList
argument_list|<
name|RDFTerm
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|confictsMap
operator|.
name|put
argument_list|(
name|hash
argument_list|,
name|resources
argument_list|)
expr_stmt|;
name|resources
operator|.
name|add
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|resources
operator|.
name|add
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|//already conflicting resource for this hash present
name|int
name|aIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|bIndex
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|resources
operator|.
name|size
argument_list|()
operator|&&
operator|(
name|aIndex
operator|<
literal|0
operator|||
name|bIndex
operator|<
literal|0
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|RDFTerm
name|r
init|=
name|resources
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|aIndex
operator|<
literal|0
operator|&&
name|r
operator|.
name|equals
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|aIndex
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|bIndex
operator|<
literal|0
operator|&&
name|r
operator|.
name|equals
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|bIndex
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|aIndex
operator|<
literal|0
condition|)
block|{
comment|//a not found
name|aIndex
operator|=
name|resources
operator|.
name|size
argument_list|()
expr_stmt|;
name|resources
operator|.
name|add
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bIndex
operator|<
literal|0
condition|)
block|{
comment|//b not found
name|bIndex
operator|=
name|resources
operator|.
name|size
argument_list|()
expr_stmt|;
name|resources
operator|.
name|add
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
return|return
name|aIndex
operator|<
name|bIndex
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
comment|/**      * Compares Resources to correctly sort them within the index.<p>      * Sort criteria are:<ol>      *<li> URIs are sorted by the {@link IRI#getUnicodeString()} unicode      * string)      *<li> Literals      *<ol>      *<li> sort by the {@link Literal#getLexicalForm() lixical form}      *<li> sort by {@link Literal#getLanguage() language}      * (<code>null</code> value first)      *<li> sort by {@link Literal#getDataType() type} (<code>null</code>      * value fist      *</ol>      *<li> BlankNode      *<ol>      *<li> sorted by their      * {@link System#identityHashCode(Object) Object hasCode}      *<li> on hasCode conflicts (same hasCode but not equals) a random order is      * chosen and kept in the parsed conflictsMap      *</ol>      *</ol>      *<b>NOTEs</b><ul>      *<li> parsed {@link RDFTerm} are not required to correctly implement      * {@link Object#hashCode() hashCode} and      * {@link Object#equals(Object) equals}      *<li> parsed {@link IRI} and {@link BlankNode} and {@link Literal} MUST      * NOT extend/implement any of the other classes/interfaces. This means that      * an {@link IRI} MUST NOT implement {@link BlankNode} nor {@link Literal}      *<li> parsed {@link Literal}s MAY implement PlainLiteral AND      * TypedLiteral. This allows wrappers over frameworks that do not      * distinguish between those two literal types to be used with the      * {@link IndexedGraph}.      *</ul>      *      * @param a the first resource to compare      * @param b the second resource to compare      * @param confictsMap the map used to resolve BlankNodes with hasCode      * conflicts      * @return       */
specifier|protected
specifier|static
name|int
name|compare
parameter_list|(
name|RDFTerm
name|a
parameter_list|,
name|RDFTerm
name|b
parameter_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|RDFTerm
argument_list|>
argument_list|>
name|confictsMap
parameter_list|)
block|{
comment|//Handle special cases for MAX and MIN values
if|if
condition|(
name|a
operator|==
name|MIN
operator|||
name|b
operator|==
name|MAX
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|a
operator|==
name|MAX
operator|||
name|b
operator|==
name|MIN
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|//sort (0) IRIs< (1) Literals (PlainLiterals& TypedLiterals)< (3) BlankNodes
name|int
name|at
init|=
name|a
operator|instanceof
name|IRI
condition|?
literal|0
else|:
name|a
operator|instanceof
name|Literal
condition|?
literal|1
else|:
literal|2
decl_stmt|;
name|int
name|bt
init|=
name|b
operator|instanceof
name|IRI
condition|?
literal|0
else|:
name|b
operator|instanceof
name|Literal
condition|?
literal|1
else|:
literal|2
decl_stmt|;
if|if
condition|(
name|at
operator|==
name|bt
condition|)
block|{
comment|//same type sort the different types
if|if
condition|(
name|at
operator|<
literal|2
condition|)
block|{
comment|//no BlankNode
comment|//sort in alphabetic order of the string representation
name|String
name|as
init|=
name|at
operator|==
literal|0
condition|?
operator|(
operator|(
name|IRI
operator|)
name|a
operator|)
operator|.
name|getUnicodeString
argument_list|()
else|:
operator|(
operator|(
name|Literal
operator|)
name|a
operator|)
operator|.
name|getLexicalForm
argument_list|()
decl_stmt|;
name|String
name|bs
init|=
name|bt
operator|==
literal|0
condition|?
operator|(
operator|(
name|IRI
operator|)
name|b
operator|)
operator|.
name|getUnicodeString
argument_list|()
else|:
operator|(
operator|(
name|Literal
operator|)
name|b
operator|)
operator|.
name|getLexicalForm
argument_list|()
decl_stmt|;
name|int
name|sc
init|=
name|as
operator|.
name|compareTo
argument_list|(
name|bs
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|==
literal|0
operator|&&
name|at
operator|==
literal|1
condition|)
block|{
comment|//same string value and Literals
comment|//check if the language and types are the same
name|Language
name|al
init|=
name|a
operator|instanceof
name|Literal
condition|?
operator|(
operator|(
name|Literal
operator|)
name|a
operator|)
operator|.
name|getLanguage
argument_list|()
else|:
literal|null
decl_stmt|;
name|Language
name|bl
init|=
name|b
operator|instanceof
name|Literal
condition|?
operator|(
operator|(
name|Literal
operator|)
name|b
operator|)
operator|.
name|getLanguage
argument_list|()
else|:
literal|null
decl_stmt|;
comment|//first try to sort by language
if|if
condition|(
name|al
operator|==
literal|null
condition|)
block|{
name|sc
operator|=
name|bl
operator|==
literal|null
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bl
operator|==
literal|null
condition|)
block|{
name|sc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|=
name|al
operator|.
name|toString
argument_list|()
operator|.
name|compareTo
argument_list|(
name|bl
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|==
literal|0
condition|)
block|{
comment|//if still equals look at the dataType
name|IRI
name|adt
init|=
name|a
operator|instanceof
name|Literal
condition|?
operator|(
operator|(
name|Literal
operator|)
name|a
operator|)
operator|.
name|getDataType
argument_list|()
else|:
literal|null
decl_stmt|;
name|IRI
name|bdt
init|=
name|b
operator|instanceof
name|Literal
condition|?
operator|(
operator|(
name|Literal
operator|)
name|b
operator|)
operator|.
name|getDataType
argument_list|()
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|adt
operator|==
literal|null
condition|)
block|{
name|sc
operator|=
name|bdt
operator|==
literal|null
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bdt
operator|==
literal|null
condition|)
block|{
name|sc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|=
name|adt
operator|.
name|getUnicodeString
argument_list|()
operator|.
name|compareTo
argument_list|(
name|bdt
operator|.
name|getUnicodeString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sc
return|;
block|}
else|else
block|{
comment|//for IRIs return the string compare
return|return
name|sc
return|;
block|}
block|}
else|else
block|{
comment|//handle BlankNodes
comment|//sort BlankNodes based on hashCode
name|int
name|ah
init|=
name|a
operator|.
name|hashCode
argument_list|()
decl_stmt|;
name|int
name|bh
init|=
name|b
operator|.
name|hashCode
argument_list|()
decl_stmt|;
if|if
condition|(
name|ah
operator|==
name|bh
condition|)
block|{
if|if
condition|(
operator|!
name|a
operator|.
name|equals
argument_list|(
name|b
argument_list|)
condition|)
block|{
comment|//if implementations hash is the same, but the instances
comment|//are not equals, try to sort them by identity hash code
name|int
name|ash
init|=
name|System
operator|.
name|identityHashCode
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|int
name|bsh
init|=
name|System
operator|.
name|identityHashCode
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|ash
operator|==
name|bsh
condition|)
block|{
comment|//if those are still the same, we need
comment|//to resolve the hashCode conflict by memorise the
comment|//decision in a confilctMap
return|return
name|resolveBlankNodeHashConflict
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|confictsMap
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|ash
operator|<
name|bsh
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
block|}
else|else
block|{
comment|//same hash and equals
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
comment|//sort by hash
return|return
name|ah
operator|<
name|bh
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
block|}
block|}
else|else
block|{
return|return
name|at
operator|<
name|bt
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
block|}
block|}
end_class

end_unit

