begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|indexedgraph
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|BNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Language
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Literal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|NonLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|PlainLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Triple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|TripleCollection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|TypedLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|UriRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|impl
operator|.
name|AbstractTripleCollection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|impl
operator|.
name|TripleImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * {@link TripleCollection} implementation that uses indexes for<ul>  *<li> subject, predicate, object [SPO]  *<li> predicate, object, subject [POS]  *<li> object, subject, predicate [OSP]  *</ul>  * Indexes are maintained in {@link TreeSet}s with according {@link Comparator}  * instances ({@link #spoComparator}, {@link #posComparator} ,  * {@link #ospComparator}). {@link Resource}s are compared first using the  * {@link Resource#hashCode()} and only if this matches by using  * {@link Resource}{@link #toString()}.<p>  * The {@link #filter(NonLiteral, UriRef, Resource)} implementation is based  * on {@link TreeSet#subSet(Object, Object)}. All Iterators returned directly  * operate on top of one of the internal indexes.  *<p>  * This class is not public, implementations should use {@link IndexedGraph} or  * {@link IndexedMGraph}.  *  * @author rwesten  */
end_comment

begin_class
class|class
name|IndexedTripleCollection
extends|extends
name|AbstractTripleCollection
implements|implements
name|TripleCollection
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|IndexedTripleCollection
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * This map is used to ensure constant ordering for {@link BNode} that do      * have the same hashcode (and therefore result to have the same      * {@link BNode#toString()} value.      */
specifier|private
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|Resource
argument_list|>
argument_list|>
name|hashCodeConflictMap
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|Resource
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * Compares Triples based on Subject, Predicate, Object      */
specifier|private
specifier|final
name|Comparator
argument_list|<
name|Triple
argument_list|>
name|spoComparator
init|=
operator|new
name|Comparator
argument_list|<
name|Triple
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Triple
name|a
parameter_list|,
name|Triple
name|b
parameter_list|)
block|{
name|int
name|c
init|=
name|IndexedTripleCollection
operator|.
name|compare
argument_list|(
name|a
operator|.
name|getSubject
argument_list|()
argument_list|,
name|b
operator|.
name|getSubject
argument_list|()
argument_list|,
name|hashCodeConflictMap
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|IndexedTripleCollection
operator|.
name|compare
argument_list|(
name|a
operator|.
name|getPredicate
argument_list|()
argument_list|,
name|b
operator|.
name|getPredicate
argument_list|()
argument_list|,
name|hashCodeConflictMap
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|IndexedTripleCollection
operator|.
name|compare
argument_list|(
name|a
operator|.
name|getObject
argument_list|()
argument_list|,
name|b
operator|.
name|getObject
argument_list|()
argument_list|,
name|hashCodeConflictMap
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|c
return|;
block|}
block|}
decl_stmt|;
comment|/**      * The SPO index      */
specifier|private
specifier|final
name|NavigableSet
argument_list|<
name|Triple
argument_list|>
name|spo
init|=
operator|new
name|TreeSet
argument_list|<
name|Triple
argument_list|>
argument_list|(
name|spoComparator
argument_list|)
decl_stmt|;
comment|/**      * Compares Triples based on Predicate, Object, Subject      */
specifier|private
specifier|final
name|Comparator
argument_list|<
name|Triple
argument_list|>
name|posComparator
init|=
operator|new
name|Comparator
argument_list|<
name|Triple
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Triple
name|a
parameter_list|,
name|Triple
name|b
parameter_list|)
block|{
name|int
name|c
init|=
name|IndexedTripleCollection
operator|.
name|compare
argument_list|(
name|a
operator|.
name|getPredicate
argument_list|()
argument_list|,
name|b
operator|.
name|getPredicate
argument_list|()
argument_list|,
name|hashCodeConflictMap
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|IndexedTripleCollection
operator|.
name|compare
argument_list|(
name|a
operator|.
name|getObject
argument_list|()
argument_list|,
name|b
operator|.
name|getObject
argument_list|()
argument_list|,
name|hashCodeConflictMap
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|IndexedTripleCollection
operator|.
name|compare
argument_list|(
name|a
operator|.
name|getSubject
argument_list|()
argument_list|,
name|b
operator|.
name|getSubject
argument_list|()
argument_list|,
name|hashCodeConflictMap
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|c
return|;
block|}
block|}
decl_stmt|;
comment|/**      * The POS index      */
specifier|private
specifier|final
name|NavigableSet
argument_list|<
name|Triple
argument_list|>
name|pos
init|=
operator|new
name|TreeSet
argument_list|<
name|Triple
argument_list|>
argument_list|(
name|posComparator
argument_list|)
decl_stmt|;
comment|/**      * Compares Triples based on Object, Subject, Predicate      */
specifier|private
specifier|final
name|Comparator
argument_list|<
name|Triple
argument_list|>
name|ospComparator
init|=
operator|new
name|Comparator
argument_list|<
name|Triple
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Triple
name|a
parameter_list|,
name|Triple
name|b
parameter_list|)
block|{
name|int
name|c
init|=
name|IndexedTripleCollection
operator|.
name|compare
argument_list|(
name|a
operator|.
name|getObject
argument_list|()
argument_list|,
name|b
operator|.
name|getObject
argument_list|()
argument_list|,
name|hashCodeConflictMap
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|IndexedTripleCollection
operator|.
name|compare
argument_list|(
name|a
operator|.
name|getSubject
argument_list|()
argument_list|,
name|b
operator|.
name|getSubject
argument_list|()
argument_list|,
name|hashCodeConflictMap
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|IndexedTripleCollection
operator|.
name|compare
argument_list|(
name|a
operator|.
name|getPredicate
argument_list|()
argument_list|,
name|b
operator|.
name|getPredicate
argument_list|()
argument_list|,
name|hashCodeConflictMap
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|c
return|;
block|}
block|}
decl_stmt|;
comment|/**      * The OSP index      */
specifier|private
specifier|final
name|NavigableSet
argument_list|<
name|Triple
argument_list|>
name|osp
init|=
operator|new
name|TreeSet
argument_list|<
name|Triple
argument_list|>
argument_list|(
name|ospComparator
argument_list|)
decl_stmt|;
comment|/**      * Creates an empty {@link IndexedTripleCollection}      */
specifier|public
name|IndexedTripleCollection
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
comment|/**      * Creates a {@link IndexedTripleCollection} using the passed iterator, the iterator       * is consumed before the constructor returns      *       * @param iterator      */
specifier|public
name|IndexedTripleCollection
parameter_list|(
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|iterator
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Triple
name|triple
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|performAdd
argument_list|(
name|triple
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Creates a {@link IndexedTripleCollection} for the specified collection of triples,      * subsequent modification of baseSet do not affect the created instance.      *      * @param iterable over triples      */
specifier|public
name|IndexedTripleCollection
parameter_list|(
name|Collection
argument_list|<
name|Triple
argument_list|>
name|baseCollection
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|spo
operator|.
name|addAll
argument_list|(
name|baseCollection
argument_list|)
expr_stmt|;
comment|//use internal index to fill the other indexes, because the parsed
comment|//collection might be slow
name|pos
operator|.
name|addAll
argument_list|(
name|spo
argument_list|)
expr_stmt|;
name|osp
operator|.
name|addAll
argument_list|(
name|spo
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|performFilter
parameter_list|(
specifier|final
name|NonLiteral
name|subject
parameter_list|,
specifier|final
name|UriRef
name|predicate
parameter_list|,
specifier|final
name|Resource
name|object
parameter_list|)
block|{
if|if
condition|(
name|subject
operator|==
literal|null
operator|&&
name|predicate
operator|==
literal|null
operator|&&
name|object
operator|==
literal|null
condition|)
block|{
comment|//[n,n,n]
return|return
name|createIterator
argument_list|(
name|spo
argument_list|,
name|spo
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
specifier|final
name|Triple
name|low
init|=
operator|new
name|TripleImpl
argument_list|(
name|subject
operator|==
literal|null
condition|?
name|MIN
else|:
name|subject
argument_list|,
name|predicate
operator|==
literal|null
condition|?
name|MIN
else|:
name|predicate
argument_list|,
name|object
operator|==
literal|null
condition|?
name|MIN
else|:
name|object
argument_list|)
decl_stmt|;
specifier|final
name|Triple
name|high
init|=
operator|new
name|TripleImpl
argument_list|(
name|subject
operator|==
literal|null
condition|?
name|MAX
else|:
name|subject
argument_list|,
name|predicate
operator|==
literal|null
condition|?
name|MAX
else|:
name|predicate
argument_list|,
name|object
operator|==
literal|null
condition|?
name|MAX
else|:
name|object
argument_list|)
decl_stmt|;
if|if
condition|(
name|subject
operator|!=
literal|null
operator|&&
name|predicate
operator|!=
literal|null
operator|&&
name|object
operator|!=
literal|null
condition|)
block|{
comment|// [S,P,O]
comment|//NOTE: low.equals(high) in that case!
return|return
name|createIterator
argument_list|(
name|spo
argument_list|,
name|spo
operator|.
name|subSet
argument_list|(
name|low
argument_list|,
literal|true
argument_list|,
name|low
argument_list|,
literal|true
argument_list|)
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|subject
operator|!=
literal|null
operator|&&
name|object
operator|==
literal|null
condition|)
block|{
comment|//[S,n,n], [S,P,n]
return|return
name|createIterator
argument_list|(
name|spo
argument_list|,
name|spo
operator|.
name|subSet
argument_list|(
name|low
argument_list|,
name|high
argument_list|)
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|predicate
operator|!=
literal|null
condition|)
block|{
comment|//[n,P,n], [n,P,O]
return|return
name|createIterator
argument_list|(
name|pos
argument_list|,
name|pos
operator|.
name|subSet
argument_list|(
name|low
argument_list|,
name|high
argument_list|)
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
comment|//[n,n,O] , [S,n,O]
return|return
name|createIterator
argument_list|(
name|osp
argument_list|,
name|osp
operator|.
name|subSet
argument_list|(
name|low
argument_list|,
name|high
argument_list|)
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|performAdd
parameter_list|(
name|Triple
name|triple
parameter_list|)
block|{
if|if
condition|(
name|spo
operator|.
name|add
argument_list|(
name|triple
argument_list|)
condition|)
block|{
name|osp
operator|.
name|add
argument_list|(
name|triple
argument_list|)
expr_stmt|;
return|return
name|pos
operator|.
name|add
argument_list|(
name|triple
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|performRemove
parameter_list|(
name|Triple
name|triple
parameter_list|)
block|{
if|if
condition|(
name|spo
operator|.
name|remove
argument_list|(
name|triple
argument_list|)
condition|)
block|{
name|osp
operator|.
name|remove
argument_list|(
name|triple
argument_list|)
expr_stmt|;
return|return
name|pos
operator|.
name|remove
argument_list|(
name|triple
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|spo
operator|.
name|size
argument_list|()
return|;
block|}
comment|//    @Override
comment|//    public Iterator<Triple> iterator() {
comment|//        return createIterator(spo, spo.iterator());
comment|//    }
comment|/**      * Returns an Iterator that ensures that calls to {@link Iterator#remove()}      * remove items from all three indexes      * @param index      * @param base      * @return      */
specifier|private
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|createIterator
parameter_list|(
specifier|final
name|SortedSet
argument_list|<
name|Triple
argument_list|>
name|index
parameter_list|,
specifier|final
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|base
parameter_list|)
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|Triple
argument_list|>
argument_list|()
block|{
name|Triple
name|current
init|=
literal|null
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|base
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Triple
name|next
parameter_list|()
block|{
name|current
operator|=
name|base
operator|.
name|next
argument_list|()
expr_stmt|;
return|return
name|current
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|base
operator|.
name|remove
argument_list|()
expr_stmt|;
if|if
condition|(
name|current
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|index
operator|==
name|spo
operator|)
condition|)
block|{
name|spo
operator|.
name|remove
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|index
operator|==
name|pos
operator|)
condition|)
block|{
name|pos
operator|.
name|remove
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|index
operator|==
name|osp
operator|)
condition|)
block|{
name|osp
operator|.
name|remove
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|;
block|}
specifier|protected
specifier|static
name|UriRef
name|MIN
init|=
operator|new
name|UriRef
argument_list|(
literal|""
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Integer
operator|.
name|MIN_VALUE
return|;
block|}
empty_stmt|;
block|}
decl_stmt|;
specifier|protected
specifier|static
name|UriRef
name|MAX
init|=
operator|new
name|UriRef
argument_list|(
literal|""
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Integer
operator|.
name|MAX_VALUE
return|;
block|}
empty_stmt|;
block|}
decl_stmt|;
comment|//    /**
comment|//     * Compares two resources with special support for {@link #MIN} and
comment|//     * {@link #MAX} to allow building {@link SortedSet#subSet(Object, Object)}
comment|//     * for<code>null</code> values parsed to
comment|//     * {@link #filter(NonLiteral, UriRef, Resource)}
comment|//     * @param a
comment|//     * @param b
comment|//     * @return
comment|//     */
comment|//    protected static int compareHash(Resource a, Resource b, Map<Integer,List<Resource>> confictsMap) {
comment|//        int hashA = a.hashCode();
comment|//        int hashB = b.hashCode();
comment|//        if (hashA != hashB) {
comment|//            return hashA> hashB ? 1 : -1;
comment|//        }
comment|//        //those resources might be equals
comment|//        //(1) Check for MIN, MAX (used to build sub-sets). Other resources might
comment|//        //    have a similar hasCode
comment|//        int state = a == MIN || b == MAX ? -1 :
comment|//            a == MAX || b == MIN ? 1 : 0;
comment|//        if(state == 0){
comment|//            if(a.equals(b)){ //check of the resources are equals
comment|//                return 0; //return zero
comment|//            } else if(//we need to care about HashCode conflicts
comment|//                a instanceof BNode&& b instanceof BNode){ // of BNodes
comment|//                log.info("HashCode conflict for {} and {}",a,b); //we have a conflict
comment|//                return resolveBNodeHashConflict(a, b, confictsMap);
comment|//            } else { //same hashCode but not equals
comment|//                //use the String representation of the Resources to sort them
comment|//                String as = resource2String(a);
comment|//                String bs = resource2String(b);
comment|//                log.info("same hash code {} - compare Strings a: {}, b: {}",
comment|//                    new Object[]{a.hashCode(),as,bs});
comment|//                return as.compareTo(bs);
comment|//            }
comment|//        }
comment|//       return state;
comment|//    }
comment|/**      * Resolved BNode hasConflics, by storing the correct order for the affected      * {@link Integer} in a {@link List} of Resource instances.      * @param a the first {@link BNode}      * @param b the second {@link BNode}      * @param confictsMap the Map used to store the order of BNodes with conflicts      * @return the decision taken based on the confictsMap.      */
specifier|private
specifier|static
name|int
name|resolveBNodeHashConflict
parameter_list|(
name|Resource
name|a
parameter_list|,
name|Resource
name|b
parameter_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|Resource
argument_list|>
argument_list|>
name|confictsMap
parameter_list|)
block|{
comment|//This is not a bad thing. We need just to ensure constant ordering
comment|//and as there is nothing we can use to distinguish we need to keep
comment|//this information in a list.
name|Integer
name|hash
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|a
operator|.
name|hashCode
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Resource
argument_list|>
name|resources
init|=
name|confictsMap
operator|.
name|get
argument_list|(
name|hash
argument_list|)
decl_stmt|;
if|if
condition|(
name|resources
operator|==
literal|null
condition|)
block|{
comment|//new conflict ... just add and return
name|resources
operator|=
operator|new
name|ArrayList
argument_list|<
name|Resource
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|confictsMap
operator|.
name|put
argument_list|(
name|hash
argument_list|,
name|resources
argument_list|)
expr_stmt|;
name|resources
operator|.
name|add
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|resources
operator|.
name|add
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|//already conflicting resource for this hash present
name|int
name|aIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|bIndex
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|resources
operator|.
name|size
argument_list|()
operator|&&
operator|(
name|aIndex
operator|<
literal|0
operator|||
name|bIndex
operator|<
literal|0
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|Resource
name|r
init|=
name|resources
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|aIndex
operator|<
literal|0
operator|&&
name|r
operator|.
name|equals
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|aIndex
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|bIndex
operator|<
literal|0
operator|&&
name|r
operator|.
name|equals
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|bIndex
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|aIndex
operator|<
literal|0
condition|)
block|{
comment|//a not found
name|aIndex
operator|=
name|resources
operator|.
name|size
argument_list|()
expr_stmt|;
name|resources
operator|.
name|add
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bIndex
operator|<
literal|0
condition|)
block|{
comment|//b not found
name|bIndex
operator|=
name|resources
operator|.
name|size
argument_list|()
expr_stmt|;
name|resources
operator|.
name|add
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
return|return
name|aIndex
operator|<
name|bIndex
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
comment|/**      * Compares Resources to correctly sort them within the index.<p>      * Sort criteria are:<ol>      *<li> URIs are sorted by the {@link UriRef#getUnicodeString()} unicode string)      *<li> Literals       *<ol>      *<li> sort by the {@link Literal#getLexicalForm() lixical form}      *<li> sort by {@link PlainLiteral#getLanguage() language} (<code>null</code> value first)      *<li> sort by {@link TypedLiteral#getDataType() type} (<code>null</code> value fist      *</ol>      *<li> BNode       *<ol>      *<li> sorted by their {@link System#identityHashCode(Object) Object hasCode}      *<li> on hasCode conflicts (same hasCode but not equals) a random order is chosen      *      and kept in the parsed conflictsMap      *</ol>       *</ol>      *<b>NOTEs</b><ul>      *<li> parsed {@link Resource} are not required to correctly implement       * {@link Object#hashCode() hashCode} and {@link Object#equals(Object) equals}      *<li> parsed {@link UriRef} and {@link BNode} and {@link Literal} MUST NOT      * extend/implement any of the other classes/interfaces. This means that an      * {@link UriRef} MUST NOT implement {@link BNode} nor {@link Literal}      *<li> parsed {@link Literal}s MAY implement {@link PlainLiteral} AND      * {@link TypedLiteral}. This allows wrappers over frameworks that do not      * distinguish between those two literal types to be used with the      * {@link IndexedTripleCollection}.      *</ul>      *       * @param a the first resource to compare      * @param b the second resource to compare      * @param confictsMap the map used to resolve BNodes with hasCode conflicts       * @return       */
specifier|protected
specifier|static
name|int
name|compare
parameter_list|(
name|Resource
name|a
parameter_list|,
name|Resource
name|b
parameter_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|Resource
argument_list|>
argument_list|>
name|confictsMap
parameter_list|)
block|{
comment|//Handle special cases for MAX and MIN values
if|if
condition|(
name|a
operator|==
name|MIN
operator|||
name|b
operator|==
name|MAX
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|a
operator|==
name|MAX
operator|||
name|b
operator|==
name|MIN
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|//sort (0) UriRefs< (1) Literals (PlainLiterals& TypedLiterals)< (3) BNodes
name|int
name|at
init|=
name|a
operator|instanceof
name|UriRef
condition|?
literal|0
else|:
name|a
operator|instanceof
name|Literal
condition|?
literal|1
else|:
literal|2
decl_stmt|;
name|int
name|bt
init|=
name|b
operator|instanceof
name|UriRef
condition|?
literal|0
else|:
name|b
operator|instanceof
name|Literal
condition|?
literal|1
else|:
literal|2
decl_stmt|;
if|if
condition|(
name|at
operator|==
name|bt
condition|)
block|{
comment|//same type sort the different types
if|if
condition|(
name|at
operator|<
literal|2
condition|)
block|{
comment|//no BNode
comment|//sort in alphabetic order of the string representation
name|String
name|as
init|=
name|at
operator|==
literal|0
condition|?
operator|(
operator|(
name|UriRef
operator|)
name|a
operator|)
operator|.
name|getUnicodeString
argument_list|()
else|:
operator|(
operator|(
name|Literal
operator|)
name|a
operator|)
operator|.
name|getLexicalForm
argument_list|()
decl_stmt|;
name|String
name|bs
init|=
name|bt
operator|==
literal|0
condition|?
operator|(
operator|(
name|UriRef
operator|)
name|b
operator|)
operator|.
name|getUnicodeString
argument_list|()
else|:
operator|(
operator|(
name|Literal
operator|)
name|b
operator|)
operator|.
name|getLexicalForm
argument_list|()
decl_stmt|;
name|int
name|sc
init|=
name|as
operator|.
name|compareTo
argument_list|(
name|bs
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|==
literal|0
operator|&&
name|at
operator|==
literal|1
condition|)
block|{
comment|//same string value and Literals
comment|//check if the language and types are the same
name|Language
name|al
init|=
name|a
operator|instanceof
name|PlainLiteral
condition|?
operator|(
operator|(
name|PlainLiteral
operator|)
name|a
operator|)
operator|.
name|getLanguage
argument_list|()
else|:
literal|null
decl_stmt|;
name|Language
name|bl
init|=
name|b
operator|instanceof
name|PlainLiteral
condition|?
operator|(
operator|(
name|PlainLiteral
operator|)
name|b
operator|)
operator|.
name|getLanguage
argument_list|()
else|:
literal|null
decl_stmt|;
comment|//first try to sort by language
if|if
condition|(
name|al
operator|==
literal|null
condition|)
block|{
name|sc
operator|=
name|bl
operator|==
literal|null
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bl
operator|==
literal|null
condition|)
block|{
name|sc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|=
name|al
operator|.
name|toString
argument_list|()
operator|.
name|compareTo
argument_list|(
name|bl
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|==
literal|0
condition|)
block|{
comment|//if still equals look at the dataType
name|UriRef
name|adt
init|=
name|a
operator|instanceof
name|TypedLiteral
condition|?
operator|(
operator|(
name|TypedLiteral
operator|)
name|a
operator|)
operator|.
name|getDataType
argument_list|()
else|:
literal|null
decl_stmt|;
name|UriRef
name|bdt
init|=
name|b
operator|instanceof
name|TypedLiteral
condition|?
operator|(
operator|(
name|TypedLiteral
operator|)
name|b
operator|)
operator|.
name|getDataType
argument_list|()
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|adt
operator|==
literal|null
condition|)
block|{
name|sc
operator|=
name|bdt
operator|==
literal|null
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bdt
operator|==
literal|null
condition|)
block|{
name|sc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|=
name|adt
operator|.
name|getUnicodeString
argument_list|()
operator|.
name|compareTo
argument_list|(
name|bdt
operator|.
name|getUnicodeString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sc
return|;
block|}
else|else
block|{
comment|//for UriRefs return the string compare
return|return
name|sc
return|;
block|}
block|}
else|else
block|{
comment|//handle BNodes
comment|//sort BNodes based on hashCode
name|int
name|ah
init|=
name|System
operator|.
name|identityHashCode
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|int
name|bh
init|=
name|System
operator|.
name|identityHashCode
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|ah
operator|==
name|bh
condition|)
block|{
if|if
condition|(
operator|!
name|a
operator|.
name|equals
argument_list|(
name|b
argument_list|)
condition|)
block|{
return|return
name|resolveBNodeHashConflict
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|confictsMap
argument_list|)
return|;
block|}
else|else
block|{
comment|//same hash and equals
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
comment|//sort by hash
return|return
name|ah
operator|<
name|bh
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
block|}
block|}
else|else
block|{
return|return
name|at
operator|<
name|bt
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
block|}
block|}
end_class

end_unit

