begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|stanboltools
operator|.
name|datafileprovider
operator|.
name|impl
operator|.
name|tracking
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_comment
comment|//DO NOT REMOVE - workaround for FELIX-2906
end_comment

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|Integer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Activate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Component
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Deactivate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Property
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Reference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|ReferenceCardinality
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|ReferencePolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|ReferenceStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Service
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|stanboltools
operator|.
name|datafileprovider
operator|.
name|DataFileListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|stanboltools
operator|.
name|datafileprovider
operator|.
name|DataFileProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|stanboltools
operator|.
name|datafileprovider
operator|.
name|DataFileTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|framework
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|service
operator|.
name|component
operator|.
name|ComponentContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Implementation of the {@link DataFileTracker} interface. This implementation  * can work within and outside of an OSGI Environment.<p>  * When within an OSGI Environment tracking in started by   * {@link #activate(ComponentContext)}and stopped by   * {@link #deactivate(ComponentContext)} the required {@link DataFileProvider} is  * injected.<p>  * Outside an OSGI Environment the {@link DataFileProvider} needs to be  * provided by the constructor (DO NOT use the default constructor).  * Tracking is started and stopped by calls to the {@link #startTracking()} and  * {@link #stopTracking()} methods.  * @author Rupert Westenthaler.  *  */
end_comment

begin_class
annotation|@
name|Component
argument_list|(
name|immediate
operator|=
literal|true
argument_list|,
name|metatype
operator|=
literal|true
argument_list|)
annotation|@
name|Service
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|Constants
operator|.
name|SERVICE_RANKING
argument_list|,
name|intValue
operator|=
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
specifier|public
specifier|final
class|class
name|DataFileTrackerImpl
implements|implements
name|DataFileTracker
block|{
specifier|protected
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|DataFileTrackerImpl
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * The default interval set to five seconds.      */
specifier|public
specifier|static
specifier|final
name|long
name|DEFAULT_INTERVAL
init|=
literal|5000
decl_stmt|;
comment|/**      * The minimum interval between two polls is set to 0.5 seconds.      */
specifier|private
specifier|static
specifier|final
name|long
name|MIN_INTERVAL
init|=
literal|500
decl_stmt|;
annotation|@
name|Property
argument_list|(
name|longValue
operator|=
name|DEFAULT_INTERVAL
argument_list|)
specifier|public
specifier|static
specifier|final
name|String
name|PROPERTY_TRACKING_INTERVAL
init|=
literal|"data.files.tracking.interval"
decl_stmt|;
comment|/**      * The {@link DataFileProvider} used for tracking. Injected by OSGI or      * paresed by the constructor (outside OSGI).<p>      * Do not directly access (use {@link #getDataFileProvider()}) and store      * a local reference in case of multiple requests because within OSGI this       * uses {@link ReferencePolicy#DYNAMIC} and      * {@link ReferenceStrategy#EVENT} to avoid a service restart      * on a change of the {@link DataFileProvider} with the highest      * {@link Constants#SERVICE_RANKING}. Service restarts cause all existing       * registrations to track data files to be lost!.      */
annotation|@
name|Reference
argument_list|(
name|cardinality
operator|=
name|ReferenceCardinality
operator|.
name|MANDATORY_UNARY
argument_list|,
name|policy
operator|=
name|ReferencePolicy
operator|.
name|DYNAMIC
argument_list|,
name|strategy
operator|=
name|ReferenceStrategy
operator|.
name|EVENT
argument_list|,
name|bind
operator|=
literal|"bindDataFileProvider"
argument_list|,
name|unbind
operator|=
literal|"unbindDataFileProvider"
argument_list|)
specifier|protected
name|DataFileProvider
name|_dataFileProvider
decl_stmt|;
comment|/**      * Getter for the current {@link DataFileProvider} instance used to track      * data files. This value may change dynamically without a restart of this      * Service.      * @return The current {@link DataFileProvider} instance      * @see #_dataFileProvider      */
specifier|protected
name|DataFileProvider
name|getDataFileProvider
parameter_list|()
block|{
return|return
name|_dataFileProvider
return|;
block|}
comment|/**      * Bind and Update method for {@link #_dataFileProvider}      * @param dfp      */
specifier|protected
name|void
name|bindDataFileProvider
parameter_list|(
name|DataFileProvider
name|dfp
parameter_list|)
block|{
name|_dataFileProvider
operator|=
name|dfp
expr_stmt|;
block|}
comment|/**      * Unbind method for {@link #_dataFileProvider}      * @param dfp      */
specifier|protected
name|void
name|unbindDataFileProvider
parameter_list|(
name|DataFileProvider
name|dfp
parameter_list|)
block|{
if|if
condition|(
name|dfp
operator|!=
literal|null
operator|&&
name|dfp
operator|.
name|equals
argument_list|(
name|_dataFileProvider
argument_list|)
condition|)
block|{
name|_dataFileProvider
operator|=
literal|null
expr_stmt|;
block|}
comment|//else ignore
block|}
comment|/**      * The current interval inbetween the end of the previous and the start of      * the next poll for tracked resources.       */
specifier|protected
name|long
name|interval
decl_stmt|;
comment|/**      * Internally used to shutdown the {@link TrackingDaemon}      */
specifier|protected
name|boolean
name|active
init|=
literal|false
decl_stmt|;
comment|/**      * Default constructor used by OSGI. This expects that the      * {@link #_dataFileProvider} is injected during activation      */
specifier|public
name|DataFileTrackerImpl
parameter_list|()
block|{     }
comment|/**      * Constructor to be used outside an OSGI environment to manually      * instantiate a {@link DataFileTracker} for a given provider      * @param provider the provider used to track data files      */
specifier|public
name|DataFileTrackerImpl
parameter_list|(
name|DataFileProvider
name|provider
parameter_list|)
block|{
if|if
condition|(
name|provider
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed DataFileProvider MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|bindDataFileProvider
argument_list|(
name|provider
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Activate
specifier|protected
name|void
name|activate
parameter_list|(
name|ComponentContext
name|context
parameter_list|)
block|{
name|Object
name|value
init|=
name|context
operator|.
name|getProperties
argument_list|()
operator|.
name|get
argument_list|(
name|PROPERTY_TRACKING_INTERVAL
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Number
condition|)
block|{
name|setInterval
argument_list|(
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|setInterval
argument_list|(
operator|new
name|BigDecimal
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Value of property '"
operator|+
name|value
operator|+
literal|"' can not be converted into a LONG"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArithmeticException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Value of property '"
operator|+
name|value
operator|+
literal|"' can not be converted into a LONG"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|//do not start here ... only if the first resource is added
comment|//startTracking();
block|}
annotation|@
name|Deactivate
specifier|protected
name|void
name|deactivate
parameter_list|(
name|ComponentContext
name|context
parameter_list|)
block|{
name|stopTracking
argument_list|()
expr_stmt|;
name|setInterval
argument_list|(
name|DEFAULT_INTERVAL
argument_list|)
expr_stmt|;
name|trackedResources
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**      * @return the interval      */
specifier|public
specifier|final
name|long
name|getInterval
parameter_list|()
block|{
return|return
name|interval
return|;
block|}
comment|/**      * Setter for the interval between two polls. If the parsed interval is      * smaller equals zero the interval is set to the {@link #DEFAULT_INTERVAL}.      * If the parsed interval bigger than zero but lower than the       * {@link #MIN_INTERVAL} the value is set to MIN_INTERVAL.      * @param interval the interval to set      */
specifier|public
specifier|final
name|void
name|setInterval
parameter_list|(
name|long
name|interval
parameter_list|)
block|{
if|if
condition|(
name|interval
operator|<=
literal|0
condition|)
block|{
name|this
operator|.
name|interval
operator|=
name|DEFAULT_INTERVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|interval
operator|<
name|MIN_INTERVAL
condition|)
block|{
name|this
operator|.
name|interval
operator|=
name|MIN_INTERVAL
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|interval
operator|=
name|interval
expr_stmt|;
block|}
block|}
specifier|private
specifier|final
name|Map
argument_list|<
name|DataFileReference
argument_list|,
name|TrackingState
argument_list|>
name|trackedResources
init|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|HashMap
argument_list|<
name|DataFileReference
argument_list|,
name|TrackingState
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|/* (non-Javadoc)      * @see org.apache.stanbol.commons.stanboltools.datafileprovider.impl.ResourceTracker#add(org.apache.stanbol.commons.stanboltools.datafileprovider.impl.ResourceTrackerImpl.ResourceListener, java.lang.String)      */
annotation|@
name|Override
specifier|public
name|void
name|add
parameter_list|(
name|DataFileListener
name|resourceListener
parameter_list|,
name|String
name|name
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|properties
parameter_list|)
block|{
name|add
argument_list|(
name|resourceListener
argument_list|,
literal|null
argument_list|,
name|name
argument_list|,
name|properties
argument_list|)
expr_stmt|;
block|}
comment|/* (non-Javadoc)      * @see org.apache.stanbol.commons.stanboltools.datafileprovider.impl.ResourceTracker#add(org.apache.stanbol.commons.stanboltools.datafileprovider.impl.ResourceTrackerImpl.ResourceListener, java.lang.String, java.lang.String)      */
annotation|@
name|Override
specifier|public
name|void
name|add
parameter_list|(
name|DataFileListener
name|resourceListener
parameter_list|,
name|String
name|bundleSymbolicName
parameter_list|,
name|String
name|name
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|properties
parameter_list|)
block|{
if|if
condition|(
name|resourceListener
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed ResourceListener MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|DataFileReference
name|r
init|=
operator|new
name|DataFileReference
argument_list|(
name|bundleSymbolicName
argument_list|,
name|name
argument_list|,
name|properties
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|trackedResources
init|)
block|{
name|TrackingState
name|trackingState
init|=
name|trackedResources
operator|.
name|get
argument_list|(
name|r
argument_list|)
decl_stmt|;
if|if
condition|(
name|trackingState
operator|==
literal|null
condition|)
block|{
comment|//add new
name|trackingState
operator|=
operator|new
name|TrackingState
argument_list|()
expr_stmt|;
name|trackedResources
operator|.
name|put
argument_list|(
name|r
argument_list|,
name|trackingState
argument_list|)
expr_stmt|;
block|}
name|trackingState
operator|.
name|addListener
argument_list|(
name|resourceListener
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|trackedResources
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//maybe this was the first added RDFTerm
name|startTracking
argument_list|()
expr_stmt|;
comment|//so me might want to start tracking
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isTracked
parameter_list|(
name|String
name|bundleSymbolicName
parameter_list|,
name|String
name|resourceName
parameter_list|)
block|{
return|return
name|trackedResources
operator|.
name|containsKey
argument_list|(
operator|new
name|DataFileReference
argument_list|(
name|bundleSymbolicName
argument_list|,
name|resourceName
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isTracked
parameter_list|(
name|DataFileListener
name|resourceListener
parameter_list|,
name|String
name|bundleSymbolicName
parameter_list|,
name|String
name|resourceName
parameter_list|)
block|{
name|TrackingState
name|state
init|=
name|trackedResources
operator|.
name|get
argument_list|(
operator|new
name|DataFileReference
argument_list|(
name|bundleSymbolicName
argument_list|,
name|resourceName
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|state
operator|!=
literal|null
condition|?
name|state
operator|.
name|isListener
argument_list|(
name|resourceListener
argument_list|)
else|:
literal|false
return|;
block|}
comment|/* (non-Javadoc)      * @see org.apache.stanbol.commons.stanboltools.datafileprovider.impl.ResourceTracker#remove(org.apache.stanbol.commons.stanboltools.datafileprovider.impl.ResourceTrackerImpl.ResourceListener, java.lang.String)      */
specifier|public
name|void
name|remove
parameter_list|(
name|DataFileListener
name|resourceListener
parameter_list|,
name|String
name|resource
parameter_list|)
block|{
name|remove
argument_list|(
name|resourceListener
argument_list|,
literal|null
argument_list|,
name|resource
argument_list|)
expr_stmt|;
block|}
comment|/* (non-Javadoc)      * @see org.apache.stanbol.commons.stanboltools.datafileprovider.impl.ResourceTracker#remove(org.apache.stanbol.commons.stanboltools.datafileprovider.impl.ResourceTrackerImpl.ResourceListener, java.lang.String, java.lang.String)      */
specifier|public
name|void
name|remove
parameter_list|(
name|DataFileListener
name|resourceListener
parameter_list|,
name|String
name|bundleSymbolicName
parameter_list|,
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|resourceListener
operator|!=
literal|null
operator|&&
name|name
operator|!=
literal|null
operator|&&
operator|!
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|DataFileReference
name|r
init|=
operator|new
name|DataFileReference
argument_list|(
name|bundleSymbolicName
argument_list|,
name|name
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|trackedResources
init|)
block|{
name|TrackingState
name|state
init|=
name|trackedResources
operator|.
name|get
argument_list|(
name|r
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|!=
literal|null
operator|&&
name|state
operator|.
name|removeListener
argument_list|(
name|resourceListener
argument_list|)
operator|!=
literal|null
operator|&&
name|state
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|trackedResources
operator|.
name|remove
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trackedResources
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//no tracked resources left?
name|stopTracking
argument_list|()
expr_stmt|;
comment|//stop tracking until others are added
block|}
block|}
block|}
comment|//else ignore
block|}
comment|/* (non-Javadoc)      * @see org.apache.stanbol.commons.stanboltools.datafileprovider.impl.ResourceTracker#removeAll(org.apache.stanbol.commons.stanboltools.datafileprovider.impl.ResourceTrackerImpl.ResourceListener)      */
specifier|public
name|void
name|removeAll
parameter_list|(
name|DataFileListener
name|resourceListener
parameter_list|)
block|{
if|if
condition|(
name|resourceListener
operator|!=
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|trackedResources
init|)
block|{
comment|//try to remove the listener for all tracked resources
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|DataFileReference
argument_list|,
name|TrackingState
argument_list|>
argument_list|>
name|entries
init|=
name|trackedResources
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|entries
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
argument_list|<
name|DataFileReference
argument_list|,
name|TrackingState
argument_list|>
name|entry
init|=
name|entries
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|removeListener
argument_list|(
name|resourceListener
argument_list|)
operator|!=
literal|null
operator|&&
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//and remove tracked resources if no others are listening
name|entries
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|trackedResources
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//no tracked resources left?
name|stopTracking
argument_list|()
expr_stmt|;
comment|//stop tracking until others are added
block|}
block|}
block|}
block|}
comment|/**      * used to start a new {@link TrackingDaemon} e.g. if the first resource      * to be tracked was added to {@link #trackedResources}.      * If tracking is already active this method has no effect      */
specifier|private
name|void
name|startTracking
parameter_list|()
block|{
if|if
condition|(
operator|!
name|active
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"start Tracking ..."
argument_list|)
expr_stmt|;
name|active
operator|=
literal|true
expr_stmt|;
name|Thread
name|t
init|=
operator|new
name|Thread
argument_list|(
operator|new
name|TrackingDaemon
argument_list|()
argument_list|,
literal|"DataFileTrackingDaemon"
argument_list|)
decl_stmt|;
name|t
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|//else already active
block|}
comment|/**      * Used to stop the {@link TrackingDaemon} e.g. if the last tracked      * resource was removed, or this component is deactivated      * @see #deactivate(ComponentContext)      * @see #close()      */
specifier|private
name|void
name|stopTracking
parameter_list|()
block|{
name|active
operator|=
literal|false
expr_stmt|;
block|}
comment|/**      * Can be used outside an OSGI environment to close this instance and      * stop tracking for all currently registered sources      */
specifier|public
name|void
name|close
parameter_list|()
block|{
name|deactivate
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|finalize
parameter_list|()
throws|throws
name|Throwable
block|{
name|close
argument_list|()
expr_stmt|;
name|super
operator|.
name|finalize
argument_list|()
expr_stmt|;
block|}
specifier|protected
class|class
name|TrackingDaemon
implements|implements
name|Runnable
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
name|active
condition|)
block|{
comment|//a clone of the tracked resource
name|Set
argument_list|<
name|DataFileReference
argument_list|>
name|resources
decl_stmt|;
synchronized|synchronized
init|(
name|trackedResources
init|)
block|{
name|resources
operator|=
operator|new
name|HashSet
argument_list|<
name|DataFileReference
argument_list|>
argument_list|(
name|trackedResources
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|DataFileProvider
name|dataFileProvider
init|=
name|getDataFileProvider
argument_list|()
decl_stmt|;
if|if
condition|(
name|dataFileProvider
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Currently no DataFileProvider available"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Track {} resources"
argument_list|,
name|resources
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|DataFileReference
name|resoruce
range|:
name|resources
control|)
block|{
name|TrackingState
name|resourceState
decl_stmt|;
synchronized|synchronized
init|(
name|trackedResources
init|)
block|{
name|resourceState
operator|=
name|trackedResources
operator|.
name|get
argument_list|(
name|resoruce
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"> {} (state:{})"
argument_list|,
name|resoruce
operator|.
name|getName
argument_list|()
argument_list|,
name|resourceState
operator|!=
literal|null
condition|?
name|resourceState
operator|.
name|getTrackingState
argument_list|()
operator|!=
literal|null
condition|?
name|resourceState
operator|.
name|getTrackingState
argument_list|()
else|:
literal|"none"
else|:
literal|null
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|resourceState
operator|!=
literal|null
condition|)
block|{
comment|//might be null if removed in the meantime
name|STATE
name|state
decl_stmt|;
if|if
condition|(
name|dataFileProvider
operator|.
name|isAvailable
argument_list|(
name|resoruce
operator|.
name|getBundleSymbolicName
argument_list|()
argument_list|,
name|resoruce
operator|.
name|getName
argument_list|()
argument_list|,
name|resoruce
operator|.
name|getProperties
argument_list|()
argument_list|)
condition|)
block|{
name|state
operator|=
name|STATE
operator|.
name|AVAILABLE
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|STATE
operator|.
name|UNAVAILABLE
expr_stmt|;
block|}
name|fire
argument_list|(
name|dataFileProvider
argument_list|,
name|resoruce
argument_list|,
name|resourceState
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
block|}
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|interval
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"interrupped"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|log
operator|.
name|info
argument_list|(
literal|" ... tracking stopped!"
argument_list|)
expr_stmt|;
block|}
comment|/**          * Processes the the tracking event and fires events to the {@link DataFileListener}          * registered for the parsed resource          * @param dataFileProvider the {@link DataFileProvider} used to get an          * {@link InputStream} per {@link DataFileListener} that needs to be notified          * @param resoruce the resource          * @param trackinState the {@link DataFileListener} and {@link STATE}s for that          * resource          * @param state the updated state of the parsed resource          * @param is the {@link InputStream} already available from the tracking          * process or<code>null</code> in case the parsed state is {@link STATE#UNAVAILABLE}.          * If parsed the stream will be {@link InputStream#close() closed} even if          * not used.          */
specifier|private
name|void
name|fire
parameter_list|(
name|DataFileProvider
name|dataFileProvider
parameter_list|,
name|DataFileReference
name|resoruce
parameter_list|,
name|TrackingState
name|trackinState
parameter_list|,
name|STATE
name|state
parameter_list|)
block|{
name|InputStream
name|is
init|=
literal|null
decl_stmt|;
comment|//iterate over clone to avoid concurrent modification exceptions
comment|//by external and/or this calls to remove(..)
for|for
control|(
name|Entry
argument_list|<
name|DataFileListener
argument_list|,
name|STATE
argument_list|>
name|listenerState
range|:
name|trackinState
control|)
block|{
if|if
condition|(
name|listenerState
operator|.
name|getValue
argument_list|()
operator|!=
name|state
condition|)
block|{
name|boolean
name|remove
init|=
literal|false
decl_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|UNAVAILABLE
case|:
try|try
block|{
name|remove
operator|=
name|listenerState
operator|.
name|getKey
argument_list|()
operator|.
name|unavailable
argument_list|(
name|resoruce
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|trackinState
operator|.
name|updateListener
argument_list|(
name|listenerState
operator|.
name|getKey
argument_list|()
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Exception from Listener '"
operator|+
name|listenerState
operator|.
name|getKey
argument_list|()
operator|+
literal|"' while calling unavailable for resource '"
operator|+
name|resoruce
operator|.
name|getName
argument_list|()
operator|+
literal|"'!"
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//the state to ERROR ... will try again on the next check
name|trackinState
operator|.
name|updateListener
argument_list|(
name|listenerState
operator|.
name|getKey
argument_list|()
argument_list|,
name|STATE
operator|.
name|ERROR
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|AVAILABLE
case|:
if|if
condition|(
name|is
operator|==
literal|null
condition|)
block|{
comment|//get a new InputStream
try|try
block|{
name|is
operator|=
name|dataFileProvider
operator|.
name|getInputStream
argument_list|(
name|resoruce
operator|.
name|getBundleSymbolicName
argument_list|()
argument_list|,
name|resoruce
operator|.
name|getName
argument_list|()
argument_list|,
name|resoruce
operator|.
name|getProperties
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|//now again unavailable ?!
comment|//Send anyway with null as stream
name|is
operator|=
literal|null
expr_stmt|;
block|}
block|}
try|try
block|{
name|remove
operator|=
name|listenerState
operator|.
name|getKey
argument_list|()
operator|.
name|available
argument_list|(
name|resoruce
operator|.
name|getName
argument_list|()
argument_list|,
name|is
argument_list|)
expr_stmt|;
name|trackinState
operator|.
name|updateListener
argument_list|(
name|listenerState
operator|.
name|getKey
argument_list|()
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Exception from Listener '"
operator|+
name|listenerState
operator|.
name|getKey
argument_list|()
operator|+
literal|"' while calling available for resource '"
operator|+
name|resoruce
operator|.
name|getName
argument_list|()
operator|+
literal|"'!"
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//the state is no changed ... will try again on the next check
name|trackinState
operator|.
name|updateListener
argument_list|(
name|listenerState
operator|.
name|getKey
argument_list|()
argument_list|,
name|STATE
operator|.
name|ERROR
argument_list|)
expr_stmt|;
block|}
name|is
operator|=
literal|null
expr_stmt|;
comment|//we need a new InputStream getName() each resource
break|break;
comment|// ignore  other values
block|}
if|if
condition|(
name|remove
condition|)
block|{
comment|//remove if requested
name|remove
argument_list|(
name|listenerState
operator|.
name|getKey
argument_list|()
argument_list|,
name|resoruce
operator|.
name|getBundleSymbolicName
argument_list|()
argument_list|,
name|resoruce
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|//else this listener is already in the notified state ... ignore
block|}
comment|//            if(is != null) { //the created InputStream was not sent to a Listener
comment|//                try {
comment|//                    is.close(); //clean up
comment|//                } catch (IOException e) {
comment|//                    //ignore
comment|//                }
comment|//            }
block|}
block|}
block|}
end_class

end_unit

