begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|opennlp
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|opennlp
operator|.
name|tools
operator|.
name|chunker
operator|.
name|Chunker
import|;
end_import

begin_import
import|import
name|opennlp
operator|.
name|tools
operator|.
name|util
operator|.
name|Sequence
import|;
end_import

begin_import
import|import
name|opennlp
operator|.
name|tools
operator|.
name|util
operator|.
name|Span
import|;
end_import

begin_comment
comment|/**  * Simple version of a {@link Chunker} that uses the POS tags to build chunks.  * It does not implement the {@link Chunker} interface because implementing  * methods other than the {@link Chunker#chunkAsSpans(String[], String[])}  * is not feasible.  *   * TODO:<ul>  *<li> Test if POS tags are the same for different languages  *<li> Check if it is possible to implement the {@link Chunker} interface  *</ul>  * @author Rupert Westenthaler  *  */
end_comment

begin_class
specifier|public
class|class
name|PosTypeChunker
block|{
comment|/**      * Set of POS tags used to build chunks of no {@link Chunker} is used.      * NOTE that all tags starting with 'N' (Nouns) are included anyway      */
specifier|public
specifier|static
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|DEFAULT_FOLLOW_POS_TYPES
init|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|"#"
argument_list|,
literal|"$"
argument_list|,
literal|" "
argument_list|,
literal|"("
argument_list|,
literal|")"
argument_list|,
literal|","
argument_list|,
literal|"."
argument_list|,
literal|":"
argument_list|,
literal|"``"
argument_list|,
literal|"POS"
argument_list|,
literal|"CD"
argument_list|,
literal|"IN"
argument_list|,
literal|"FW"
argument_list|,
literal|"NN"
argument_list|,
literal|"NNP"
argument_list|,
literal|"NNPS"
argument_list|,
literal|"NNS"
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|//,"''")));
comment|/**      * Set of POS tags used for searches.      * NOTE that all tags starting with 'N' (Nouns) are included anyway      */
specifier|public
specifier|static
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|DEFAULT_BUILD_CHUNK_POS_TYPES
init|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|"NN"
argument_list|,
literal|"NNP"
argument_list|,
literal|"NNPS"
argument_list|,
literal|"NNS"
argument_list|,
literal|"FW"
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|//,"''")));
specifier|public
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|followTypes
decl_stmt|;
specifier|public
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|buildTypes
decl_stmt|;
comment|/**      * Initialise a new PosTypeChunker with the default POS type configuration      */
specifier|public
name|PosTypeChunker
parameter_list|()
block|{
name|this
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Initialise a new PosTypeChunker for the parsed Types.<p>      * Note that buildPosTypes are not automatically followed. They need be      * explicitly added to the followPosTypes!.      * @param buildPosTypes the POS types that trigger a new Chunk      * @param followPosType the POS types followed to build Chunks      */
specifier|public
name|PosTypeChunker
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|buildPosTypes
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|followPosType
parameter_list|)
block|{
name|this
operator|.
name|buildTypes
operator|=
name|buildPosTypes
operator|==
literal|null
condition|?
name|DEFAULT_BUILD_CHUNK_POS_TYPES
else|:
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|buildPosTypes
argument_list|)
expr_stmt|;
name|this
operator|.
name|followTypes
operator|=
name|followPosType
operator|==
literal|null
condition|?
name|DEFAULT_FOLLOW_POS_TYPES
else|:
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|followPosType
argument_list|)
expr_stmt|;
block|}
comment|/**      * TODO: This might be language specific!      * @param pos      * @return      */
specifier|private
name|boolean
name|followPOS
parameter_list|(
name|String
name|pos
parameter_list|)
block|{
return|return
name|followTypes
operator|.
name|contains
argument_list|(
name|pos
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|includePOS
parameter_list|(
name|String
name|pos
parameter_list|)
block|{
return|return
name|buildTypes
operator|.
name|contains
argument_list|(
name|pos
argument_list|)
return|;
block|}
comment|/**      * Build the chunks based on the parsed tokens and tags.<p>      * This method is the equivalent to {@link Chunker#chunkAsSpans(String[], String[])}      * @param tokens the tokens      * @param tags the POS tags for the tokens      * @return the chunks as spans over the parsed tokens      */
specifier|public
name|Span
index|[]
name|chunkAsSpans
parameter_list|(
name|String
index|[]
name|tokens
parameter_list|,
name|String
index|[]
name|tags
parameter_list|)
block|{
name|int
name|consumed
init|=
operator|-
literal|1
decl_stmt|;
name|List
argument_list|<
name|Span
argument_list|>
name|chunks
init|=
operator|new
name|ArrayList
argument_list|<
name|Span
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tokens
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|includePOS
argument_list|(
name|tags
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|int
name|start
init|=
name|i
decl_stmt|;
while|while
condition|(
name|start
operator|-
literal|1
operator|>
name|consumed
operator|&&
name|followPOS
argument_list|(
name|tags
index|[
name|start
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|start
operator|--
expr_stmt|;
comment|//follow backwards until consumed
block|}
name|int
name|end
init|=
name|i
decl_stmt|;
while|while
condition|(
name|end
operator|+
literal|1
operator|<
name|tokens
operator|.
name|length
operator|&&
name|followPOS
argument_list|(
name|tags
index|[
name|end
operator|+
literal|1
index|]
argument_list|)
condition|)
block|{
name|end
operator|++
expr_stmt|;
comment|//follow forwards until consumed
block|}
name|chunks
operator|.
name|add
argument_list|(
operator|new
name|Span
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
argument_list|)
expr_stmt|;
name|consumed
operator|=
name|end
expr_stmt|;
name|i
operator|=
name|end
expr_stmt|;
block|}
comment|//build no chunk for this token
block|}
return|return
name|chunks
operator|.
name|toArray
argument_list|(
operator|new
name|Span
index|[
name|chunks
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
block|}
end_class

end_unit

