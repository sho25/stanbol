begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|managed
operator|.
name|standalone
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|managed
operator|.
name|util
operator|.
name|ManagementUtils
operator|.
name|getArchiveCoreName
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|managed
operator|.
name|util
operator|.
name|ManagementUtils
operator|.
name|getMetadata
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|managed
operator|.
name|util
operator|.
name|ManagementUtils
operator|.
name|substituteProperty
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ServiceLoader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|ParserConfigurationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|ArchiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|ArchiveInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|FileUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|FilenameUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|CoreContainer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|CoreDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrCore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|managed
operator|.
name|IndexMetadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|managed
operator|.
name|ManagedIndexState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|managed
operator|.
name|ManagedSolrServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|managed
operator|.
name|util
operator|.
name|ManagementUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|utils
operator|.
name|ConfigUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|stanboltools
operator|.
name|datafileprovider
operator|.
name|DataFileProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|SAXException
import|;
end_import

begin_comment
comment|/**  * Basic implementation of the {@link ManagedSolrServer} interface that  * can be used without an OSGI environment.  *<p>  * NOTE: {@link ServiceLoader} is used to search for DataFileProviders outside of  * OSGI. An instance of {@link ClassPathDataFileProvider} is registered by   * default that loads Index-Archives form "solr/core/". if you want to load  * Data-Files form different locations you will need to provide your own   * DataFileProvider. Extending {@link ClassPathDataFileProvider} might be the  * simplest way to do this.  *   * @author Rupert Westenthaler  *  */
end_comment

begin_class
specifier|public
class|class
name|StandaloneManagedSolrServer
implements|implements
name|ManagedSolrServer
block|{
specifier|private
specifier|static
specifier|final
name|String
name|DEFAULT_SERVER_NAME
init|=
literal|"default"
decl_stmt|;
specifier|private
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|StandaloneManagedSolrServer
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * Outside OSGI we need an instance of a data file provider that can load      * Index Configuration via the classpath      */
specifier|private
specifier|static
name|ServiceLoader
argument_list|<
name|DataFileProvider
argument_list|>
name|dataFileProviders
init|=
name|ServiceLoader
operator|.
name|load
argument_list|(
name|DataFileProvider
operator|.
name|class
argument_list|)
decl_stmt|;
comment|//private static DataFileProvider dataFileProvider = new ClassPathSolrIndexConfigProvider(null);
comment|/**      * Initialising Solr Indexes with a lot of data may take some time. Especially if the data need to be      * copied to the managed directory. Therefore it is important to wait for the initialisation to be      * complete before opening an Solr Index on it.      *<p>      * To this set all cores that are currently initialised are added. As soon as an initialisation completed      * this set is notified.      */
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|initCores
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * List with the managed Solr servers. The name is used as key       */
specifier|public
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|StandaloneManagedSolrServer
argument_list|>
name|managedServers
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|StandaloneManagedSolrServer
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * The directory on the File system used to manage this {@link CoreContainer}      */
specifier|private
name|File
name|managedSolrDir
decl_stmt|;
comment|/**      * The managed Solr server      */
specifier|private
name|CoreContainer
name|server
decl_stmt|;
specifier|private
name|String
name|serverName
decl_stmt|;
comment|/**      * Getter for the ManagedSolrServer for the parsed name. If      * {@link #getDefaultServerName()} is parsed as name the default managed      * Solr server is returned (and created if needed). For any other name       *<code>null</code> is returned if no {@link ManagedSolrServer} for this      * name is present.      * @param name the name      * @return The managed Solr server or<code>null</code> if not known.      */
specifier|public
specifier|static
name|StandaloneManagedSolrServer
name|getManagedServer
parameter_list|(
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|==
literal|null
condition|)
block|{
name|name
operator|=
name|DEFAULT_SERVER_NAME
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
name|DEFAULT_SERVER_NAME
argument_list|)
condition|)
block|{
return|return
name|createManagedServer
argument_list|(
name|name
argument_list|)
return|;
block|}
else|else
block|{
synchronized|synchronized
init|(
name|managedServers
init|)
block|{
return|return
name|managedServers
operator|.
name|get
argument_list|(
name|name
argument_list|)
return|;
block|}
block|}
block|}
comment|/**      * Getter for the name of the default managed Solr server      * @return the name of the default server      */
specifier|public
specifier|static
name|String
name|getDefaultServerName
parameter_list|()
block|{
return|return
name|DEFAULT_SERVER_NAME
return|;
block|}
comment|/**      * Shutdowns the default server      * @return      */
specifier|public
specifier|static
name|void
name|shutdownManagedServer
parameter_list|()
block|{
name|shutdownManagedServer
argument_list|(
name|DEFAULT_SERVER_NAME
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|void
name|shutdownManagedServer
parameter_list|(
name|String
name|name
parameter_list|)
block|{
synchronized|synchronized
init|(
name|managedServers
init|)
block|{
name|StandaloneManagedSolrServer
name|server
init|=
name|managedServers
operator|.
name|remove
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|server
operator|!=
literal|null
condition|)
block|{
name|server
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Getter for the default managed Solr server. This method is guaranteed to      * NOT return<code>null</code>.      * @return the default server      */
specifier|public
specifier|static
name|StandaloneManagedSolrServer
name|getManagedServer
parameter_list|()
block|{
return|return
name|getManagedServer
argument_list|(
literal|null
argument_list|)
return|;
block|}
comment|/**      * Creates a new ManagedSolrServer with the specified name      * @param name the name. MUST NOT be<code>null</code>, empty or contain      * any chars that are used as {@link File} separators, extensions. In other      * words {@link FilenameUtils#getBaseName(String)} MUST NOT change the      * parsed name!      * @return The created or already existing {@link ManagedSolrServer} for      * this name      */
specifier|public
specifier|static
name|StandaloneManagedSolrServer
name|createManagedServer
parameter_list|(
name|String
name|name
parameter_list|)
block|{
synchronized|synchronized
init|(
name|managedServers
init|)
block|{
name|StandaloneManagedSolrServer
name|server
init|=
name|managedServers
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|server
operator|==
literal|null
condition|)
block|{
name|server
operator|=
operator|new
name|StandaloneManagedSolrServer
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|//use server.getServerName(), because NULL is replaced with default
name|managedServers
operator|.
name|put
argument_list|(
name|server
operator|.
name|getServerName
argument_list|()
argument_list|,
name|server
argument_list|)
expr_stmt|;
block|}
return|return
name|server
return|;
block|}
block|}
comment|/**      * Private constructor used by the {@link #createManagedServer(String)}      * method      * @param name the name      */
specifier|private
name|StandaloneManagedSolrServer
parameter_list|(
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Name MUST be NULL!"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Name MUST be Empty!"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
operator|!
name|FilenameUtils
operator|.
name|getBaseName
argument_list|(
name|name
argument_list|)
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Name '"
operator|+
name|name
operator|+
literal|"' contains path seperator, seperator and/or extension seperator chars!"
argument_list|)
throw|;
block|}
name|this
operator|.
name|serverName
operator|=
name|name
expr_stmt|;
comment|//init the manange Solr Directory
name|String
name|configuredDataDir
init|=
name|System
operator|.
name|getProperty
argument_list|(
name|MANAGED_SOLR_DIR_PROPERTY
argument_list|,
name|DEFAULT_SOLR_DATA_DIR
argument_list|)
decl_stmt|;
comment|// property substitution
name|configuredDataDir
operator|=
name|FilenameUtils
operator|.
name|separatorsToSystem
argument_list|(
name|substituteProperty
argument_list|(
name|configuredDataDir
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
comment|// determine the directory holding the SolrIndex
name|managedSolrDir
operator|=
operator|new
name|File
argument_list|(
name|configuredDataDir
argument_list|,
name|name
argument_list|)
operator|.
name|getAbsoluteFile
argument_list|()
expr_stmt|;
try|try
block|{
name|managedSolrDir
operator|=
name|managedSolrDir
operator|.
name|getCanonicalFile
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to get the Canonical File for '"
operator|+
name|configuredDataDir
operator|+
literal|"'!"
argument_list|)
throw|;
block|}
name|initServer
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|initServer
parameter_list|()
block|{
name|File
name|solrConf
init|=
operator|new
name|File
argument_list|(
name|managedSolrDir
argument_list|,
literal|"solr.xml"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|solrConf
operator|.
name|exists
argument_list|()
condition|)
block|{
try|try
block|{
name|managedSolrDir
operator|=
name|ConfigUtils
operator|.
name|copyDefaultConfig
argument_list|(
operator|(
name|Class
argument_list|<
name|?
argument_list|>
operator|)
literal|null
argument_list|,
name|managedSolrDir
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unable to copy default configuration for the manages Solr "
operator|+
literal|"Directory to the configured path '%s'!"
argument_list|,
name|managedSolrDir
operator|.
name|getAbsoluteFile
argument_list|()
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
name|server
operator|=
operator|new
name|CoreContainer
argument_list|(
name|managedSolrDir
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
comment|//File solrXml = new File(managedSolrDir,"solr.xml");
name|server
operator|.
name|load
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|shutdown
parameter_list|()
block|{
name|server
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|IndexMetadata
name|createSolrIndex
parameter_list|(
name|String
name|name
parameter_list|,
name|ArchiveInputStream
name|ais
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isManagedIndex
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
name|updateIndex
argument_list|(
name|name
argument_list|,
name|ais
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Can not create core with name '"
operator|+
name|name
operator|+
literal|"' because a Core with that name does already exist!"
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|IndexMetadata
name|createSolrIndex
parameter_list|(
name|String
name|coreName
parameter_list|,
name|String
name|resourceName
parameter_list|,
name|Properties
name|properties
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isManagedIndex
argument_list|(
name|coreName
argument_list|)
condition|)
block|{
return|return
name|updateIndex
argument_list|(
name|coreName
argument_list|,
name|resourceName
argument_list|,
name|properties
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Can not create core with name '"
operator|+
name|coreName
operator|+
literal|"' because a Core with that name does already exist!"
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|File
name|getManagedDirectory
parameter_list|()
block|{
return|return
name|managedSolrDir
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getServerName
parameter_list|()
block|{
return|return
name|serverName
return|;
block|}
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|IndexMetadata
argument_list|>
name|getIndexes
parameter_list|(
name|ManagedIndexState
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
operator|==
name|ManagedIndexState
operator|.
name|ACTIVE
condition|)
block|{
name|Collection
argument_list|<
name|IndexMetadata
argument_list|>
name|coreMetadata
init|=
operator|new
name|ArrayList
argument_list|<
name|IndexMetadata
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|SolrCore
name|core
range|:
name|server
operator|.
name|getCores
argument_list|()
control|)
block|{
name|coreMetadata
operator|.
name|add
argument_list|(
name|getMetadata
argument_list|(
name|core
argument_list|,
name|serverName
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|coreMetadata
return|;
block|}
else|else
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|File
name|getSolrIndexDirectory
parameter_list|(
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|==
literal|null
operator|||
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed index name MUST NOT be NULL nor empty!"
argument_list|)
throw|;
block|}
name|SolrCore
name|core
init|=
name|server
operator|.
name|getCore
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|core
operator|!=
literal|null
condition|)
block|{
name|File
name|instanceDir
init|=
operator|new
name|File
argument_list|(
name|core
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getInstanceDir
argument_list|()
argument_list|)
decl_stmt|;
name|core
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|instanceDir
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|IndexMetadata
name|getIndexMetadata
parameter_list|(
name|String
name|indexName
parameter_list|)
block|{
name|IndexMetadata
name|metadata
decl_stmt|;
name|SolrCore
name|core
init|=
name|server
operator|.
name|getCore
argument_list|(
name|indexName
argument_list|)
decl_stmt|;
if|if
condition|(
name|core
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|=
name|getMetadata
argument_list|(
name|core
argument_list|,
name|serverName
argument_list|)
expr_stmt|;
name|core
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|metadata
operator|=
literal|null
expr_stmt|;
block|}
return|return
name|metadata
return|;
block|}
annotation|@
name|Override
specifier|public
name|ManagedIndexState
name|getIndexState
parameter_list|(
name|String
name|indexName
parameter_list|)
block|{
comment|//if the core is not active it does not exist
return|return
name|server
operator|.
name|getCoreNames
argument_list|()
operator|.
name|contains
argument_list|(
name|indexName
argument_list|)
condition|?
name|ManagedIndexState
operator|.
name|ACTIVE
else|:
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isManagedIndex
parameter_list|(
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|==
literal|null
operator|||
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed index name MUST NOT be NULL nor empty!"
argument_list|)
throw|;
block|}
return|return
name|server
operator|.
name|getCoreNames
argument_list|()
operator|.
name|contains
argument_list|(
name|name
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeIndex
parameter_list|(
name|String
name|name
parameter_list|,
name|boolean
name|deleteFiles
parameter_list|)
block|{
if|if
condition|(
name|name
operator|==
literal|null
operator|||
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed index name MUST NOT be NULL nor empty!"
argument_list|)
throw|;
block|}
name|SolrCore
name|core
init|=
name|server
operator|.
name|remove
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|core
operator|.
name|close
argument_list|()
expr_stmt|;
comment|//decrease reference count
if|if
condition|(
name|deleteFiles
condition|)
block|{
name|String
name|instanceDir
init|=
name|core
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getInstanceDir
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|core
operator|.
name|isClosed
argument_list|()
condition|)
block|{
comment|//ensure the core is closed!
name|core
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|FileUtils
operator|.
name|deleteDirectory
argument_list|(
operator|new
name|File
argument_list|(
name|instanceDir
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Unable to delete instance directory '"
operator|+
name|instanceDir
operator|+
literal|"' of SolrCore '"
operator|+
name|name
operator|+
literal|"'! Please delete this"
operator|+
literal|"directory manually."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|IndexMetadata
name|updateIndex
parameter_list|(
name|String
name|name
parameter_list|,
name|ArchiveInputStream
name|ais
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|updateIndex
argument_list|(
name|name
argument_list|,
name|ais
argument_list|,
literal|null
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|IndexMetadata
name|updateIndex
parameter_list|(
name|String
name|name
parameter_list|,
name|ArchiveInputStream
name|ais
parameter_list|,
name|String
name|archiveCoreName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|name
operator|==
literal|null
operator|||
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed index name MUST NOT be NULL nor empty!"
argument_list|)
throw|;
block|}
name|IndexMetadata
name|metadata
init|=
operator|new
name|IndexMetadata
argument_list|()
decl_stmt|;
name|metadata
operator|.
name|setIndexName
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|setServerName
argument_list|(
name|DEFAULT_SERVER_NAME
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|setSynchronized
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|setState
argument_list|(
name|ManagedIndexState
operator|.
name|ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|archiveCoreName
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|setArchive
argument_list|(
name|archiveCoreName
argument_list|)
expr_stmt|;
block|}
return|return
name|updateCore
argument_list|(
name|metadata
argument_list|,
name|ais
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|IndexMetadata
name|updateIndex
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|parsedResourceName
parameter_list|,
name|Properties
name|properties
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|name
operator|==
literal|null
operator|||
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed index name MUST NOT be NULL nor empty!"
argument_list|)
throw|;
block|}
name|String
name|resourceName
decl_stmt|;
if|if
condition|(
operator|!
name|ConfigUtils
operator|.
name|isValidSolrIndexFileName
argument_list|(
name|parsedResourceName
argument_list|)
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"add SolrIndexFileExtension to parsed indexArchive {}"
argument_list|,
name|parsedResourceName
argument_list|)
expr_stmt|;
name|resourceName
operator|=
name|ConfigUtils
operator|.
name|appandSolrIndexFileExtension
argument_list|(
name|parsedResourceName
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|resourceName
operator|=
name|parsedResourceName
expr_stmt|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|comments
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|properties
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|prop
range|:
name|properties
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|comments
operator|.
name|put
argument_list|(
name|prop
operator|.
name|getKey
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|prop
operator|.
name|getValue
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|InputStream
name|is
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|DataFileProvider
argument_list|>
name|it
init|=
name|dataFileProviders
operator|.
name|iterator
argument_list|()
init|;
name|is
operator|==
literal|null
operator|&&
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DataFileProvider
name|dfp
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
try|try
block|{
name|is
operator|=
name|dfp
operator|.
name|getInputStream
argument_list|(
literal|null
argument_list|,
name|resourceName
argument_list|,
name|comments
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|//not found
block|}
block|}
if|if
condition|(
name|is
operator|!=
literal|null
operator|||
operator|new
name|File
argument_list|(
name|managedSolrDir
argument_list|,
name|parsedResourceName
argument_list|)
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|ArchiveInputStream
name|ais
decl_stmt|;
try|try
block|{
name|ais
operator|=
name|ManagementUtils
operator|.
name|getArchiveInputStream
argument_list|(
name|resourceName
argument_list|,
name|is
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArchiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to open ArchiveInputStream for resource '"
operator|+
name|resourceName
operator|+
literal|"'!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|IndexMetadata
name|metadata
init|=
operator|new
name|IndexMetadata
argument_list|()
decl_stmt|;
if|if
condition|(
name|properties
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|putAll
argument_list|(
name|properties
argument_list|)
expr_stmt|;
block|}
name|metadata
operator|.
name|setIndexName
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|setServerName
argument_list|(
name|DEFAULT_SERVER_NAME
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|setSynchronized
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|setState
argument_list|(
name|ManagedIndexState
operator|.
name|ACTIVE
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|setArchive
argument_list|(
name|resourceName
argument_list|)
expr_stmt|;
return|return
name|updateCore
argument_list|(
name|metadata
argument_list|,
name|ais
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|public
name|String
name|getDefaultCore
parameter_list|()
block|{
return|return
name|server
operator|.
name|getDefaultCoreName
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|IndexMetadata
name|activateIndex
parameter_list|(
name|String
name|indexName
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
block|{
comment|//if the index is already active -> return it
name|IndexMetadata
name|metadata
init|=
name|getIndexMetadata
argument_list|(
name|indexName
argument_list|)
decl_stmt|;
if|if
condition|(
name|metadata
operator|!=
literal|null
condition|)
block|{
return|return
name|metadata
return|;
block|}
else|else
block|{
comment|//try to init an core for that directory located within the
comment|//managedDir
return|return
name|updateIndex
argument_list|(
name|indexName
argument_list|,
literal|null
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|IndexMetadata
name|deactivateIndex
parameter_list|(
name|String
name|indexName
parameter_list|)
block|{
name|IndexMetadata
name|metadata
decl_stmt|;
name|SolrCore
name|core
init|=
name|server
operator|.
name|remove
argument_list|(
name|indexName
argument_list|)
decl_stmt|;
if|if
condition|(
name|core
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|=
name|getMetadata
argument_list|(
name|core
argument_list|,
name|serverName
argument_list|)
expr_stmt|;
name|core
operator|.
name|close
argument_list|()
expr_stmt|;
name|metadata
operator|.
name|setState
argument_list|(
name|ManagedIndexState
operator|.
name|INACTIVE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|metadata
operator|=
literal|null
expr_stmt|;
block|}
return|return
name|metadata
return|;
block|}
comment|/**      * registers a {@link SolrCore} to the {@link #server} managed by this      * instance. Will replace an already existing {@link SolrCore} with the       * same name      * @param coreName the name of the {@link SolrCore} to register      * @param coreDir the directory for the Core. If<code>null</code> is parsed      * {@link #managedSolrDir}/coreName is used as default.      */
specifier|private
name|void
name|registerCore
parameter_list|(
name|String
name|coreName
parameter_list|,
name|File
name|coreDir
parameter_list|)
block|{
if|if
condition|(
name|coreName
operator|==
literal|null
condition|)
block|{
name|coreName
operator|=
name|server
operator|.
name|getDefaultCoreName
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|coreDir
operator|==
literal|null
condition|)
block|{
comment|//use the coreName as default
name|coreDir
operator|=
operator|new
name|File
argument_list|(
name|managedSolrDir
argument_list|,
name|coreName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|coreDir
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The Core Directory '"
operator|+
name|coreDir
operator|+
literal|" for the Core '"
operator|+
name|coreName
operator|+
literal|"' does not exist or is not an directory"
argument_list|)
throw|;
block|}
name|SolrCore
name|core
decl_stmt|;
name|CoreDescriptor
name|coreDescriptor
init|=
operator|new
name|CoreDescriptor
argument_list|(
name|server
argument_list|,
name|coreName
argument_list|,
name|coreDir
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
decl_stmt|;
name|core
operator|=
name|server
operator|.
name|create
argument_list|(
name|coreDescriptor
argument_list|)
expr_stmt|;
comment|//this will also replace an existing core with the same name
name|server
operator|.
name|register
argument_list|(
name|coreName
argument_list|,
name|core
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|server
operator|.
name|persist
argument_list|()
expr_stmt|;
comment|//store the new/updated SolrCore in the solr.xml
block|}
specifier|private
name|IndexMetadata
name|updateCore
parameter_list|(
name|IndexMetadata
name|metadata
parameter_list|,
name|ArchiveInputStream
name|ais
parameter_list|)
block|{
name|String
name|indexName
init|=
name|metadata
operator|.
name|getIndexName
argument_list|()
decl_stmt|;
name|File
name|coreDir
init|=
operator|new
name|File
argument_list|(
name|managedSolrDir
argument_list|,
name|indexName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|initCores
operator|.
name|contains
argument_list|(
name|indexName
argument_list|)
condition|)
block|{
synchronized|synchronized
init|(
name|initCores
init|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"> start initializing SolrIndex {}"
operator|+
name|indexName
argument_list|)
expr_stmt|;
name|initCores
operator|.
name|add
argument_list|(
name|indexName
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|ais
operator|!=
literal|null
condition|)
block|{
comment|//copy the data
comment|//not the third parameter (coreName) is not the name of this
comment|//core, but the original name within the indexArchive
name|String
name|archiveCoreName
init|=
name|getArchiveCoreName
argument_list|(
name|metadata
argument_list|)
decl_stmt|;
name|ConfigUtils
operator|.
name|copyCore
argument_list|(
name|ais
argument_list|,
name|coreDir
argument_list|,
name|archiveCoreName
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|//third register the new Core
block|}
comment|//else the data are already in place
name|registerCore
argument_list|(
name|indexName
argument_list|,
name|coreDir
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|setDirectory
argument_list|(
name|coreDir
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unable to copy default configuration for Solr Index %s to the configured path %s"
argument_list|,
name|indexName
argument_list|,
name|managedSolrDir
operator|.
name|getAbsoluteFile
argument_list|()
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
comment|// regardless what happened remove the index from the currently init
comment|// indexes and notify all other waiting for the initialisation
synchronized|synchronized
init|(
name|initCores
init|)
block|{
comment|// initialisation done
name|initCores
operator|.
name|remove
argument_list|(
name|indexName
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"   ... notify after trying to init SolrIndex {}"
argument_list|,
name|indexName
argument_list|)
expr_stmt|;
comment|// notify that the initialisation completed or failed
name|initCores
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// the core is currently initialised ... wait until complete
synchronized|synchronized
init|(
name|initCores
init|)
block|{
while|while
condition|(
name|initCores
operator|.
name|contains
argument_list|(
name|indexName
argument_list|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"> wait for initialisation of SolrIndex {}"
argument_list|,
name|indexName
argument_list|)
expr_stmt|;
try|try
block|{
name|initCores
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// a core is initialised ... back to work
block|}
block|}
name|metadata
operator|.
name|setDirectory
argument_list|(
name|coreDir
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|metadata
return|;
block|}
specifier|public
name|String
name|getCoreForDirectory
parameter_list|(
name|String
name|coreNameOrPath
parameter_list|)
block|{
if|if
condition|(
name|coreNameOrPath
operator|.
name|charAt
argument_list|(
name|coreNameOrPath
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|!=
name|File
operator|.
name|separatorChar
condition|)
block|{
name|coreNameOrPath
operator|=
name|coreNameOrPath
operator|+
name|File
operator|.
name|separatorChar
expr_stmt|;
block|}
for|for
control|(
name|SolrCore
name|core
range|:
name|server
operator|.
name|getCores
argument_list|()
control|)
block|{
name|String
name|instanceDir
init|=
name|core
operator|.
name|getCoreDescriptor
argument_list|()
operator|.
name|getInstanceDir
argument_list|()
decl_stmt|;
if|if
condition|(
name|FilenameUtils
operator|.
name|equalsNormalizedOnSystem
argument_list|(
name|coreNameOrPath
argument_list|,
name|instanceDir
argument_list|)
condition|)
block|{
return|return
name|core
operator|.
name|getName
argument_list|()
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|CoreContainer
name|getCoreContainer
parameter_list|()
block|{
return|return
name|server
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|swapIndexes
parameter_list|(
name|String
name|indexName1
parameter_list|,
name|String
name|indexName2
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|isManagedIndex
argument_list|(
name|indexName1
argument_list|)
operator|&&
name|isManagedIndex
argument_list|(
name|indexName2
argument_list|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Both core names (%s,%s) must correspond to a managed index"
argument_list|,
name|indexName1
argument_list|,
name|indexName2
argument_list|)
argument_list|)
throw|;
block|}
name|server
operator|.
name|swap
argument_list|(
name|indexName1
argument_list|,
name|indexName2
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

