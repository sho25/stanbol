begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|managed
operator|.
name|impl
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|SolrConstants
operator|.
name|PROPERTY_CORE_DIR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|SolrConstants
operator|.
name|PROPERTY_CORE_NAME
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|SolrConstants
operator|.
name|PROPERTY_SERVER_DIR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|SolrConstants
operator|.
name|PROPERTY_SERVER_NAME
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|SolrConstants
operator|.
name|PROPERTY_SERVER_PUBLISH_REST
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|SolrConstants
operator|.
name|PROPERTY_SERVER_RANKING
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|managed
operator|.
name|ManagedIndexConstants
operator|.
name|INDEX_NAME
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|managed
operator|.
name|ManagedSolrServer
operator|.
name|MANAGED_SOLR_DIR_PROPERTY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|managed
operator|.
name|impl
operator|.
name|ManagementUtils
operator|.
name|getArchiveCoreName
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|managed
operator|.
name|impl
operator|.
name|ManagementUtils
operator|.
name|substituteProperty
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|DateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|ParserConfigurationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|ArchiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|ArchiveInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|FileUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|FilenameUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Activate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Component
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|ConfigurationPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Deactivate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Property
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Reference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Service
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrCore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|IndexReference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|SolrConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|SolrServerAdapter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|SolrServerAdapter
operator|.
name|SolrCoreProperties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|SolrServerAdapter
operator|.
name|SolrServerProperties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|managed
operator|.
name|IndexMetadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|managed
operator|.
name|ManagedIndexState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|managed
operator|.
name|ManagedSolrServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|managed
operator|.
name|standalone
operator|.
name|ClassPathDataFileProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|utils
operator|.
name|ConfigUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|stanboltools
operator|.
name|datafileprovider
operator|.
name|DataFileListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|stanboltools
operator|.
name|datafileprovider
operator|.
name|DataFileProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|stanboltools
operator|.
name|datafileprovider
operator|.
name|DataFileTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|framework
operator|.
name|BundleContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|framework
operator|.
name|ServiceReference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|framework
operator|.
name|ServiceRegistration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|service
operator|.
name|cm
operator|.
name|ConfigurationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|service
operator|.
name|component
operator|.
name|ComponentContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|SAXException
import|;
end_import

begin_comment
comment|/**  * Implementation of the {@link ManagedSolrServer} interface for OSGI  * @author Rupert Westenthaler  *  */
end_comment

begin_class
annotation|@
name|Component
argument_list|(
name|configurationFactory
operator|=
literal|true
argument_list|,
name|immediate
operator|=
literal|true
argument_list|,
name|specVersion
operator|=
literal|"1.1"
argument_list|,
name|metatype
operator|=
literal|true
argument_list|,
name|policy
operator|=
name|ConfigurationPolicy
operator|.
name|REQUIRE
argument_list|)
annotation|@
name|Service
argument_list|(
name|value
operator|=
name|ManagedSolrServer
operator|.
name|class
argument_list|)
annotation|@
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Properties
argument_list|(
name|value
operator|=
block|{
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|PROPERTY_SERVER_NAME
argument_list|)
block|,
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|MANAGED_SOLR_DIR_PROPERTY
argument_list|)
block|,
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|PROPERTY_SERVER_RANKING
argument_list|,
name|intValue
operator|=
literal|0
argument_list|)
block|,
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|PROPERTY_SERVER_PUBLISH_REST
argument_list|,
name|boolValue
operator|=
literal|true
argument_list|)
block|}
argument_list|)
specifier|public
class|class
name|ManagedSolrServerImpl
implements|implements
name|ManagedSolrServer
block|{
specifier|private
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ManagedSolrServerImpl
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * The default path to root directory. All instances that do not define a       * value for {@link ManagedSolrServer#MANAGED_SOLR_DIR_PROPERTY} will      * use this path + the name of the server as {@link #managedSolrDir}.<p>      * The default is "${sling.home}indexes". '${sling.home}' ensures that indexes      * will be stored relative to the sling home directory. However if this      * property is not present indexes will be relative to the user home      * instead.      * @see ManagementUtils#substituteProperty(String, BundleContext)      */
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_ROOT_PATH
init|=
literal|"${sling.home}indexes"
decl_stmt|;
comment|/**      * Used by the {@link #indexArchiveTracker} to track index archive files      * referenced by managed indexes      * @see IndexArchiveTracker      */
annotation|@
name|Reference
specifier|private
name|DataFileTracker
name|dataFileTracker
decl_stmt|;
comment|/**      * Used by the {@link #indexArchiveTracker} to directly request      * {@link IndexMetadata#getIndexArchives() alternate index archives} in case      * the {@link IndexMetadata#getArchive() currently used} gets       * {@link DataFileListener#unavailable(String) unavailable}      * @see DataFileListener#unavailable(String)      * @see IndexMetadata#getIndexArchives()      * @see IndexMetadata#getArchive()      */
annotation|@
name|Reference
specifier|private
name|DataFileProvider
name|dataFileProvider
decl_stmt|;
comment|/**      * Listener instance used for handling {@link DataFileTracker} notifications      */
specifier|private
name|IndexArchiveTracker
name|indexArchiveTracker
decl_stmt|;
comment|/**      * The File representing the managed directory.      */
specifier|private
name|File
name|managedSolrDir
decl_stmt|;
comment|/**      * The Solr CoreContainer to OSGI adapter      */
specifier|private
name|SolrServerAdapter
name|server
decl_stmt|;
comment|/**      * The name of this server. Kept in an own variable to avoid access to      * {@link SolrServerAdapter#getServerName()} for logging reasons that would      * otherwise require to check if the {@link #server} variable != null.      */
specifier|private
name|String
name|serverName
decl_stmt|;
comment|/**      * Used to keep track if a {@link #updateCore(String, ArchiveInputStream)}      * or {@link #removeIndex(String, boolean)} operation is currently       * performing a CRUD operation on the {@link #server} instance to prevent      * calls to {@link SolrServerAdapter#shutdown()}.      * If such operations start an {@link Object token} is added to this collection      * and as soon as the opertaion completes the token is removed and the      * {@link Object#notifyAll()} is called on the list. Within the      * {@link #deactivate(ComponentContext)} method it is waited until this      * list is empty before {@link SolrServerAdapter#shutdown()} is called on      * {@link #server}.      */
specifier|private
name|Collection
argument_list|<
name|Object
argument_list|>
name|serverInUser
init|=
operator|new
name|HashSet
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
comment|//private ComponentContext context;
comment|/**      * Holds the list of cores that where installed by using      * {@link #createSolrIndex(String, String, java.util.Properties)} but the {@link DataFileProvider}      * could not yet provide the necessary data for the initialisation.      *<p>      * The list of uninitialised cores is stored within the data folder of the bundle under      * {@link #UNINITIALISED_SITE_DIRECTORY_NAME}/{@link #serverName}.<p>      * initialised during activation and cleared during deactivation. The      * property files are saved to disc on any change. Therefore the in-memory      * state is always in sync with the data on the disc.      */
specifier|private
name|ManagedIndexMetadata
name|managedCores
decl_stmt|;
comment|/**      * Initialising Solr Indexes with a lot of data may take some time. Especially if the data need to be      * copied to the managed directory. Therefore it is important to wait for the initialisation to be      * complete before opening an Solr Index on it.      * To this set all cores that are currently initialised are added. As soon as an initialisation completed      * this set is notified.<p>      * The name of the SolrIndex is used as key. The directory where the data      * are copied represents the value.      */
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|File
argument_list|>
name|initCores
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|File
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * Used to async call {@link #updateCore(String, ArchiveInputStream)}.      * Initialised in {@link #activate(ComponentContext)} and closed in      * {@link #deactivate(ComponentContext)}      */
specifier|private
name|IndexUpdateDaemon
name|updateDaemon
decl_stmt|;
comment|//    private ServiceRegistration dfpServiceRegistration;
comment|/**      * used to append suffixes to the core directories using the date of its      * creation (patter: yyyy.MM.dd)      */
specifier|private
name|DateFormat
name|coreSuffixDateFormat
init|=
operator|new
name|SimpleDateFormat
argument_list|(
literal|"yyyy.MM.dd"
argument_list|)
decl_stmt|;
annotation|@
name|Activate
specifier|protected
name|void
name|activate
parameter_list|(
name|ComponentContext
name|context
parameter_list|)
throws|throws
name|ConfigurationException
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Activate ManagedSolrServer:"
argument_list|)
expr_stmt|;
comment|//        this.context = context;
name|BundleContext
name|bc
init|=
name|context
operator|.
name|getBundleContext
argument_list|()
decl_stmt|;
comment|//first parse the configured Servername
name|Object
name|value
init|=
name|context
operator|.
name|getProperties
argument_list|()
operator|.
name|get
argument_list|(
name|PROPERTY_SERVER_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
operator|||
name|value
operator|.
name|toString
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|PROPERTY_SERVER_NAME
argument_list|,
literal|"The Server Name is a required"
operator|+
literal|"Configuration and MUST NOT be NULL nor empty!"
argument_list|)
throw|;
block|}
else|else
block|{
name|serverName
operator|=
name|value
operator|.
name|toString
argument_list|()
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"> Name = {}"
argument_list|,
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|context
operator|.
name|getProperties
argument_list|()
operator|.
name|get
argument_list|(
name|MANAGED_SOLR_DIR_PROPERTY
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
operator|||
name|value
operator|.
name|toString
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|managedSolrDir
operator|=
operator|new
name|File
argument_list|(
name|FilenameUtils
operator|.
name|separatorsToSystem
argument_list|(
name|substituteProperty
argument_list|(
name|DEFAULT_ROOT_PATH
argument_list|,
name|bc
argument_list|)
argument_list|)
argument_list|,
name|serverName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//note that property substitution is used on the parsed
comment|//PROPERTY_SERVER_DIR value
name|managedSolrDir
operator|=
operator|new
name|File
argument_list|(
name|FilenameUtils
operator|.
name|separatorsToSystem
argument_list|(
name|substituteProperty
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|,
name|bc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|managedSolrDir
operator|.
name|isAbsolute
argument_list|()
condition|)
block|{
name|managedSolrDir
operator|=
operator|new
name|File
argument_list|(
name|DEFAULT_ROOT_PATH
argument_list|,
comment|//make sure to convert '/' and '\' to the platform separator
name|FilenameUtils
operator|.
name|separatorsToSystem
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|log
operator|.
name|info
argument_list|(
literal|"> managedDir = {}"
argument_list|,
name|managedSolrDir
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|managedSolrDir
operator|.
name|isFile
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|PROPERTY_SERVER_DIR
argument_list|,
name|String
operator|.
name|format
argument_list|(
literal|"The configured managed directory '%s'(dir: %s|name:%s) "
operator|+
literal|"exists but is no Directory!"
argument_list|,
name|managedSolrDir
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|value
argument_list|,
name|serverName
argument_list|)
argument_list|)
throw|;
block|}
comment|// check if the "solr.xml" file exists in the directory
name|File
name|solrConf
init|=
operator|new
name|File
argument_list|(
name|managedSolrDir
argument_list|,
literal|"solr.xml"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|solrConf
operator|.
name|exists
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"   ... initialise managed directory '{}'"
argument_list|,
name|managedSolrDir
argument_list|)
expr_stmt|;
try|try
block|{
name|managedSolrDir
operator|=
name|ConfigUtils
operator|.
name|copyDefaultConfig
argument_list|(
name|bc
operator|.
name|getBundle
argument_list|()
argument_list|,
name|managedSolrDir
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unable to copy default configuration for the manages Solr Directory "
operator|+
literal|"to the configured path '%s'!"
argument_list|,
name|managedSolrDir
operator|.
name|getAbsoluteFile
argument_list|()
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"   .... managed directory '{}' already present and initialised"
argument_list|,
name|managedSolrDir
argument_list|)
expr_stmt|;
block|}
comment|//init the SolrServerProperties and read the other parameters form the config
name|SolrServerProperties
name|serverProperties
init|=
operator|new
name|SolrServerProperties
argument_list|(
name|managedSolrDir
argument_list|)
decl_stmt|;
name|serverProperties
operator|.
name|setServerName
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
name|value
operator|=
name|context
operator|.
name|getProperties
argument_list|()
operator|.
name|get
argument_list|(
name|PROPERTY_SERVER_RANKING
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Number
condition|)
block|{
name|serverProperties
operator|.
name|setServerRanking
argument_list|(
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
operator|!
name|value
operator|.
name|toString
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
try|try
block|{
name|serverProperties
operator|.
name|setServerRanking
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"> Ranking = {}"
argument_list|,
name|serverProperties
operator|.
name|getServerRanking
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|PROPERTY_SERVER_RANKING
argument_list|,
literal|"The configured Server Ranking '"
operator|+
name|value
operator|+
literal|" can not be converted to an Integer!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|//else not present or empty string -> do not set a ranking!
name|value
operator|=
name|context
operator|.
name|getProperties
argument_list|()
operator|.
name|get
argument_list|(
name|PROPERTY_SERVER_PUBLISH_REST
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
operator|||
name|value
operator|instanceof
name|Boolean
condition|)
block|{
name|serverProperties
operator|.
name|setPublishREST
argument_list|(
operator|(
name|Boolean
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|serverProperties
operator|.
name|setPublishREST
argument_list|(
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|server
operator|=
operator|new
name|SolrServerAdapter
argument_list|(
name|context
operator|.
name|getBundleContext
argument_list|()
argument_list|,
name|serverProperties
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ParserConfigurationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to initialise the XML parser "
operator|+
literal|"for parsing the SolrServer Configuration for Server '"
operator|+
name|serverProperties
operator|.
name|getServerName
argument_list|()
operator|+
literal|"' (dir="
operator|+
name|serverProperties
operator|.
name|getServerDir
argument_list|()
operator|+
literal|")!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|PROPERTY_SERVER_DIR
argument_list|,
literal|"Unable to initialise "
operator|+
literal|"a SolrServer based on the Directory '"
operator|+
name|serverProperties
operator|.
name|getServerDir
argument_list|()
operator|+
literal|"'!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|SAXException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|PROPERTY_SERVER_DIR
argument_list|,
literal|"Unable to initialise "
operator|+
literal|"a SolrServer based on the Directory '"
operator|+
name|serverProperties
operator|.
name|getServerDir
argument_list|()
operator|+
literal|"'!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|//        dfpServiceRegistration = context.getBundleContext().registerService(
comment|//            DataFileProvider.class.getName(),
comment|//            new ClassPathSolrIndexConfigProvider(
comment|//                context.getBundleContext().getBundle().getSymbolicName()), null);
name|managedCores
operator|=
operator|new
name|ManagedIndexMetadata
argument_list|(
name|context
argument_list|)
expr_stmt|;
comment|//After a restart of the CoreContainer we need to synchronise the state of
comment|//The cores with the state in the configs.
comment|//This may result in the activation of missing SolrCores as well as the
comment|//deactivation of unknown or inactive cores. It may also need to
comment|//change the state in the configuration in case a user has manually fixed
comment|//encountered problems while this service was deactivated.
name|Collection
argument_list|<
name|String
argument_list|>
name|activeByMetadata
init|=
name|managedCores
operator|.
name|getInState
argument_list|(
name|ManagedIndexState
operator|.
name|ACTIVE
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|String
argument_list|>
name|activeOnSolrServer
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|server
operator|.
name|getCores
argument_list|()
argument_list|)
decl_stmt|;
name|activeOnSolrServer
operator|.
name|removeAll
argument_list|(
name|activeByMetadata
argument_list|)
expr_stmt|;
name|activeByMetadata
operator|.
name|removeAll
argument_list|(
name|server
operator|.
name|getCores
argument_list|()
argument_list|)
expr_stmt|;
comment|//NOW:
comment|// - activeOnSolrServer contains all active SolrCores that are not marked
comment|//   as active in the metadata
comment|// - activeByMetadata contains all active Indexes that are not registered
comment|//   as SolrCores on the CoreContainer
comment|//(1) Try to activate missing cores on the CoreContainer
if|if
condition|(
operator|!
name|activeByMetadata
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"The following active managed Cores are not available on "
operator|+
literal|"the SolrServer: {}"
argument_list|,
name|activeByMetadata
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|indexName
range|:
name|activeByMetadata
control|)
block|{
name|IndexMetadata
name|metadata
init|=
name|managedCores
operator|.
name|getIndexMetadata
argument_list|(
name|indexName
argument_list|)
decl_stmt|;
try|try
block|{
name|activateCore
argument_list|(
name|metadata
argument_list|,
name|server
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"  ... index {} successfully started!"
argument_list|,
name|indexName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|metadata
operator|.
name|setError
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|log
operator|.
name|error
argument_list|(
literal|"Unable to activate previously active SolrIndex '"
operator|+
name|metadata
operator|.
name|getIndexReference
argument_list|()
operator|+
literal|"'!"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SAXException
name|e
parameter_list|)
block|{
name|metadata
operator|.
name|setError
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|log
operator|.
name|error
argument_list|(
literal|"Unable to activate previously active SolrIndex '"
operator|+
name|metadata
operator|.
name|getIndexReference
argument_list|()
operator|+
literal|"'!"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|metadata
operator|.
name|setError
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|log
operator|.
name|error
argument_list|(
literal|"Unable to activate previously active SolrIndex '"
operator|+
name|metadata
operator|.
name|getIndexReference
argument_list|()
operator|+
literal|"'!"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|managedCores
operator|.
name|store
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//(2) Process active SolrCores on the CoreContainer that are not active
comment|//    based on the configuration
if|if
condition|(
operator|!
name|activeOnSolrServer
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"The following Cores active on the SolrServer are not "
operator|+
literal|"marked as active in the Metadata: {}"
argument_list|,
name|activeOnSolrServer
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Based on the Metadata (UNKNOWN ... no Index for that name):"
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|indexName
range|:
name|activeOnSolrServer
control|)
block|{
name|IndexMetadata
name|metadata
init|=
name|managedCores
operator|.
name|getIndexMetadata
argument_list|(
name|indexName
argument_list|)
decl_stmt|;
name|ManagedIndexState
name|state
init|=
name|metadata
operator|!=
literal|null
condition|?
name|metadata
operator|.
name|getState
argument_list|()
else|:
literal|null
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"   - {} has state {}"
argument_list|,
name|indexName
argument_list|,
name|state
operator|!=
literal|null
condition|?
name|state
else|:
literal|"UNKNOWN"
argument_list|)
expr_stmt|;
if|if
condition|(
name|metadata
operator|==
literal|null
condition|)
block|{
comment|//unknown core ... deactivate
name|deactivateCore
argument_list|(
name|indexName
argument_list|,
name|server
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"  ... deactiaved UNKOWN SolrCore {} on managed Solr Server {}"
argument_list|,
name|indexName
argument_list|,
name|serverName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|ManagedIndexState
operator|.
name|INACTIVE
condition|)
block|{
comment|////the metadata way this core should be deactivated!
name|deactivateCore
argument_list|(
name|indexName
argument_list|,
name|server
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"  ... deactiaved INACTIVE SolrCore {} on managed Solr Server {}"
argument_list|,
name|indexName
argument_list|,
name|serverName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|ManagedIndexState
operator|.
name|ERROR
condition|)
block|{
comment|//looks like that the error was resolved ...
comment|// ... maybe someone has manually edited some files and
comment|//     restarted this server
name|metadata
operator|.
name|setState
argument_list|(
name|ManagedIndexState
operator|.
name|ACTIVE
argument_list|)
expr_stmt|;
name|managedCores
operator|.
name|store
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"  ... successfully ACTIVATED SolrCore {} on managed Solr Server {}"
argument_list|,
name|indexName
argument_list|,
name|serverName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|ManagedIndexState
operator|.
name|UNINITIALISED
condition|)
block|{
comment|//looks like someone has copied the required files manually
comment|//to the solrServer ... update the metadata an activate
name|ManagementUtils
operator|.
name|updateMetadata
argument_list|(
name|metadata
argument_list|,
name|server
operator|.
name|getCore
argument_list|(
name|indexName
argument_list|)
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|setState
argument_list|(
name|ManagedIndexState
operator|.
name|ACTIVE
argument_list|)
expr_stmt|;
name|managedCores
operator|.
name|store
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"  ... successfully ACTIVATED SolrCore {} on managed Solr Server {}"
argument_list|,
name|indexName
argument_list|,
name|serverName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//now init uninitialised cores and dataFile tracking for those
comment|//(1) start the daemon that asyc updates cores on DataFileListener events
name|updateDaemon
operator|=
operator|new
name|IndexUpdateDaemon
argument_list|()
expr_stmt|;
name|updateDaemon
operator|.
name|start
argument_list|()
expr_stmt|;
comment|//start the thread
comment|//(2) init IndexArhive tracking
name|indexArchiveTracker
operator|=
operator|new
name|IndexArchiveTracker
argument_list|(
name|dataFileTracker
argument_list|,
name|dataFileProvider
argument_list|,
name|managedCores
argument_list|,
name|updateDaemon
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"   ... Managed SolrServer '{}' successfully initialised!"
argument_list|,
name|serverName
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Deactivate
specifier|protected
name|void
name|deactivate
parameter_list|(
name|ComponentContext
name|context
parameter_list|)
block|{
if|if
condition|(
name|server
operator|!=
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|serverInUser
init|)
block|{
while|while
condition|(
operator|!
name|serverInUser
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
try|try
block|{
name|serverInUser
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Waiting for outstanding Solr server opertations Interupped: '{}' left"
argument_list|,
name|serverInUser
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|server
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
name|server
operator|=
literal|null
expr_stmt|;
block|}
comment|//        if(dfpServiceRegistration != null) {
comment|//            dfpServiceRegistration.unregister();
comment|//            dfpServiceRegistration = null;
comment|//        }
if|if
condition|(
name|indexArchiveTracker
operator|!=
literal|null
condition|)
block|{
name|indexArchiveTracker
operator|.
name|close
argument_list|()
expr_stmt|;
name|indexArchiveTracker
operator|=
literal|null
expr_stmt|;
block|}
comment|//shutting down the update daemon
if|if
condition|(
name|updateDaemon
operator|!=
literal|null
condition|)
block|{
name|updateDaemon
operator|.
name|close
argument_list|()
expr_stmt|;
name|updateDaemon
operator|=
literal|null
expr_stmt|;
block|}
comment|//stop tracking for uninitialised indexes
name|indexArchiveTracker
operator|=
literal|null
expr_stmt|;
name|managedCores
operator|=
literal|null
expr_stmt|;
comment|//serverName and managedSolrDir are not set to null to allow access
comment|//in loggings even if the component is already deactivated
comment|//managedSolrDir = null;
comment|//serverName = null;
block|}
annotation|@
name|Override
specifier|public
name|IndexMetadata
name|createSolrIndex
parameter_list|(
name|String
name|indexName
parameter_list|,
name|String
name|resourceName
parameter_list|,
name|Properties
name|properties
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|indexName
operator|==
literal|null
operator|||
name|indexName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed index name MUST NOT be NULL nor empty!"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|ConfigUtils
operator|.
name|isValidSolrIndexFileName
argument_list|(
name|resourceName
argument_list|)
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"add SolrIndexFileExtension to parsed indexArchive {}"
argument_list|,
name|resourceName
argument_list|)
expr_stmt|;
name|resourceName
operator|=
name|ConfigUtils
operator|.
name|appandSolrIndexFileExtension
argument_list|(
name|resourceName
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isManagedIndex
argument_list|(
name|indexName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"An index with the parsed name '"
operator|+
name|indexName
operator|+
literal|"' already exists on this managed Solr server '"
operator|+
name|serverName
operator|+
literal|"'!"
argument_list|)
throw|;
block|}
name|IndexMetadata
name|metadata
init|=
operator|new
name|IndexMetadata
argument_list|()
decl_stmt|;
if|if
condition|(
name|properties
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|putAll
argument_list|(
name|properties
argument_list|)
expr_stmt|;
block|}
name|metadata
operator|.
name|setServerName
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|setIndexName
argument_list|(
name|indexName
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|setIndexArchives
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|resourceName
argument_list|)
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|setState
argument_list|(
name|ManagedIndexState
operator|.
name|UNINITIALISED
argument_list|)
expr_stmt|;
comment|//TODO: we need to deal with the synchronised property!
comment|// now add the index to the list of uninitialised
name|managedCores
operator|.
name|store
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
comment|//now start tracking this archive file
name|indexArchiveTracker
operator|.
name|addTracking
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
name|dataFileTracker
operator|.
name|add
argument_list|(
name|indexArchiveTracker
argument_list|,
name|resourceName
argument_list|,
name|IndexMetadata
operator|.
name|toStringMap
argument_list|(
name|metadata
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|metadata
return|;
block|}
annotation|@
name|Override
specifier|public
name|IndexMetadata
name|createSolrIndex
parameter_list|(
name|String
name|indexName
parameter_list|,
name|ArchiveInputStream
name|ais
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
block|{
if|if
condition|(
name|indexName
operator|==
literal|null
operator|||
name|indexName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed name of the index MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|isManagedIndex
argument_list|(
name|indexName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"An index with the parsed name '"
operator|+
name|indexName
operator|+
literal|"' already exists on this managed Solr server '"
operator|+
name|serverName
operator|+
literal|"'!"
argument_list|)
throw|;
block|}
return|return
name|updateIndex
argument_list|(
name|indexName
argument_list|,
name|ais
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|File
name|getManagedDirectory
parameter_list|()
block|{
return|return
name|managedSolrDir
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getServerName
parameter_list|()
block|{
return|return
name|serverName
return|;
block|}
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|IndexMetadata
argument_list|>
name|getIndexes
parameter_list|(
name|ManagedIndexState
name|state
parameter_list|)
block|{
return|return
name|managedCores
operator|.
name|getIndexMetadata
argument_list|(
name|state
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|File
name|getSolrIndexDirectory
parameter_list|(
name|String
name|indexName
parameter_list|)
block|{
if|if
condition|(
name|indexName
operator|==
literal|null
operator|||
name|indexName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed index name MUST NOT be NULL nor empty!"
argument_list|)
throw|;
block|}
name|SolrServerAdapter
name|server
init|=
name|this
operator|.
name|server
decl_stmt|;
name|ServiceReference
name|ref
init|=
name|server
operator|.
name|getCore
argument_list|(
name|indexName
argument_list|)
decl_stmt|;
name|String
name|dirName
init|=
name|ref
operator|!=
literal|null
condition|?
operator|(
name|String
operator|)
name|ref
operator|.
name|getProperty
argument_list|(
name|SolrConstants
operator|.
name|PROPERTY_CORE_DIR
argument_list|)
else|:
literal|null
decl_stmt|;
return|return
name|dirName
operator|==
literal|null
condition|?
literal|null
else|:
operator|new
name|File
argument_list|(
name|dirName
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|ManagedIndexState
name|getIndexState
parameter_list|(
name|String
name|indexName
parameter_list|)
block|{
if|if
condition|(
name|indexName
operator|==
literal|null
operator|||
name|indexName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed index reference MUST NOT be NULL nor empty!"
argument_list|)
throw|;
block|}
return|return
name|managedCores
operator|.
name|getState
argument_list|(
name|indexName
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isManagedIndex
parameter_list|(
name|String
name|indexName
parameter_list|)
block|{
if|if
condition|(
name|indexName
operator|==
literal|null
operator|||
name|indexName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed index reference MUST NOT be NULL nor empty!"
argument_list|)
throw|;
block|}
return|return
name|managedCores
operator|.
name|isManaged
argument_list|(
name|indexName
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|removeIndex
parameter_list|(
name|String
name|indexName
parameter_list|,
name|boolean
name|deleteFiles
parameter_list|)
block|{
if|if
condition|(
name|indexName
operator|==
literal|null
operator|||
name|indexName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed index name MUST NOT be NULL nor empty!"
argument_list|)
throw|;
block|}
comment|//remove the index from the metadata
name|IndexMetadata
name|metadata
init|=
name|managedCores
operator|.
name|remove
argument_list|(
name|indexName
argument_list|)
decl_stmt|;
if|if
condition|(
name|metadata
operator|!=
literal|null
condition|)
block|{
comment|//and also tracked index archives from the DataFileTracker
name|indexArchiveTracker
operator|.
name|removeTracking
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
name|uninitialiseCore
argument_list|(
name|metadata
argument_list|,
name|deleteFiles
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Uninitialise the index referenced by the parsed metadata and also deletes      * the index data from the local file system if deleteFiles is enabled.      * Updates to the state of the index are stored within the parsed      * {@link IndexMetadata}.<p>      * If the index is {@link ManagedIndexState#ACTIVE}, than the {@link SolrCore}      * is first {@link #deactivateCore(String, SolrServerAdapter) deactivated}.       * @param metadata the metadata for the core. This instance is modified      * but not saved to {@link #managedCores} within this method.       * So depending if callers want to remove or only uninitialise this core      * the might want to store the updated version of this instance after this      * method completes!      * @param deleteFiles if the files on the local fileSystem should be deleted      * @return the parsed and modified instance of the {@link IndexMetadata}      */
specifier|protected
specifier|final
name|void
name|uninitialiseCore
parameter_list|(
name|IndexMetadata
name|metadata
parameter_list|,
name|boolean
name|deleteFiles
parameter_list|)
block|{
name|SolrServerAdapter
name|server
init|=
name|this
operator|.
name|server
decl_stmt|;
name|File
name|coreDir
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|metadata
operator|.
name|isActive
argument_list|()
condition|)
block|{
name|coreDir
operator|=
name|deactivateCore
argument_list|(
name|metadata
operator|.
name|getIndexName
argument_list|()
argument_list|,
name|server
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|coreDir
operator|==
literal|null
condition|)
block|{
name|String
name|coreDirName
init|=
name|metadata
operator|.
name|getDirectory
argument_list|()
decl_stmt|;
if|if
condition|(
name|coreDirName
operator|!=
literal|null
condition|)
block|{
name|coreDir
operator|=
operator|new
name|File
argument_list|(
name|coreDirName
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|deleteFiles
condition|)
block|{
name|metadata
operator|.
name|setDirectory
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|//no directory assigned
name|metadata
operator|.
name|setArchive
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|//no archive used for the index
if|if
condition|(
name|coreDir
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|FileUtils
operator|.
name|deleteDirectory
argument_list|(
name|coreDir
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unable to delete Directory %s of the "
operator|+
literal|"removed index '%s' of the managed SolrServer '{}'. "
operator|+
literal|"Please try to delete this directory manually!"
argument_list|,
name|coreDir
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|metadata
operator|.
name|getIndexName
argument_list|()
argument_list|,
name|serverName
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|metadata
operator|.
name|setState
argument_list|(
name|ManagedIndexState
operator|.
name|UNINITIALISED
argument_list|)
expr_stmt|;
block|}
comment|/**      * Synchronises on {@link #serverInUser} and removes the core from the      * {@link SolrServerAdapter}      * @param indexName the name of the Index      * @param server the server      * @return the directory of the deactivated core or<code>null</code> if       * no core with that name was found.      */
specifier|private
name|File
name|deactivateCore
parameter_list|(
name|String
name|indexName
parameter_list|,
name|SolrServerAdapter
name|server
parameter_list|)
block|{
name|ServiceReference
name|coreRef
init|=
name|server
operator|!=
literal|null
condition|?
name|server
operator|.
name|getCore
argument_list|(
name|indexName
argument_list|)
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|coreRef
operator|!=
literal|null
condition|)
block|{
name|Object
name|token
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|serverInUser
init|)
block|{
name|serverInUser
operator|.
name|add
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
name|File
name|coreDir
decl_stmt|;
try|try
block|{
name|coreDir
operator|=
name|getCoreDir
argument_list|(
name|coreRef
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|server
operator|.
name|removeCore
argument_list|(
name|indexName
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
synchronized|synchronized
init|(
name|serverInUser
init|)
block|{
name|serverInUser
operator|.
name|remove
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|token
operator|=
literal|null
expr_stmt|;
name|serverInUser
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|coreDir
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|IndexMetadata
name|updateIndex
parameter_list|(
name|String
name|indexName
parameter_list|,
name|ArchiveInputStream
name|ais
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
block|{
if|if
condition|(
name|indexName
operator|==
literal|null
operator|||
name|indexName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed name for the index MUST NOT"
operator|+
literal|"be NULL nor empty!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|ais
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The parsed ArchiveInputStream MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|IndexMetadata
name|metadata
init|=
operator|new
name|IndexMetadata
argument_list|()
decl_stmt|;
name|metadata
operator|.
name|setServerName
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|setIndexName
argument_list|(
name|indexName
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|setSynchronized
argument_list|(
literal|false
argument_list|)
expr_stmt|;
try|try
block|{
name|updateCore
argument_list|(
name|metadata
argument_list|,
name|ais
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|managedCores
operator|.
name|store
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
block|}
return|return
name|metadata
return|;
block|}
annotation|@
name|Override
specifier|public
name|IndexMetadata
name|updateIndex
parameter_list|(
name|String
name|indexName
parameter_list|,
name|String
name|resourceName
parameter_list|,
name|Properties
name|properties
parameter_list|)
throws|throws
name|IOException
block|{
comment|//NOTE: this does not deactivate the current index version, but only updates
comment|//the metadata and re-registers the DataFileTracking
name|IndexMetadata
name|oldMetadata
init|=
name|managedCores
operator|.
name|getIndexMetadata
argument_list|(
name|indexName
argument_list|)
decl_stmt|;
name|IndexMetadata
name|metadata
init|=
operator|new
name|IndexMetadata
argument_list|()
decl_stmt|;
if|if
condition|(
name|properties
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|putAll
argument_list|(
name|properties
argument_list|)
expr_stmt|;
block|}
name|metadata
operator|.
name|setServerName
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|setIndexName
argument_list|(
name|indexName
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|setIndexArchives
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|resourceName
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldMetadata
operator|!=
literal|null
condition|)
block|{
comment|//we need to
name|metadata
operator|.
name|setState
argument_list|(
name|oldMetadata
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
comment|//same as for the old version
name|metadata
operator|.
name|setDirectory
argument_list|(
name|oldMetadata
operator|.
name|getDirectory
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|metadata
operator|.
name|setState
argument_list|(
name|ManagedIndexState
operator|.
name|UNINITIALISED
argument_list|)
expr_stmt|;
block|}
comment|//TODO: we need to deal with the synchronised property!
comment|// now add the index to the list of uninitialised
name|managedCores
operator|.
name|store
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
name|indexArchiveTracker
operator|.
name|updateTracking
argument_list|(
name|oldMetadata
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
return|return
name|metadata
return|;
block|}
annotation|@
name|Override
specifier|public
name|IndexMetadata
name|deactivateIndex
parameter_list|(
name|String
name|indexName
parameter_list|)
block|{
name|IndexMetadata
name|metadata
init|=
name|managedCores
operator|.
name|getIndexMetadata
argument_list|(
name|indexName
argument_list|)
decl_stmt|;
if|if
condition|(
name|metadata
operator|!=
literal|null
operator|&&
name|metadata
operator|.
name|getState
argument_list|()
operator|==
name|ManagedIndexState
operator|.
name|ACTIVE
condition|)
block|{
try|try
block|{
name|deactivateCore
argument_list|(
name|indexName
argument_list|,
name|server
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|setState
argument_list|(
name|ManagedIndexState
operator|.
name|INACTIVE
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|metadata
operator|.
name|setError
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|managedCores
operator|.
name|store
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|metadata
return|;
block|}
annotation|@
name|Override
specifier|public
name|IndexMetadata
name|activateIndex
parameter_list|(
name|String
name|indexName
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
block|{
name|IndexMetadata
name|metadata
init|=
name|managedCores
operator|.
name|getIndexMetadata
argument_list|(
name|indexName
argument_list|)
decl_stmt|;
if|if
condition|(
name|metadata
operator|!=
literal|null
operator|&&
name|metadata
operator|.
name|getState
argument_list|()
operator|==
name|ManagedIndexState
operator|.
name|INACTIVE
condition|)
block|{
try|try
block|{
name|activateCore
argument_list|(
name|metadata
argument_list|,
name|server
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|setState
argument_list|(
name|ManagedIndexState
operator|.
name|ACTIVE
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|metadata
operator|.
name|setError
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|SAXException
name|e
parameter_list|)
block|{
name|metadata
operator|.
name|setError
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|metadata
operator|.
name|setError
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|managedCores
operator|.
name|store
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|metadata
return|;
block|}
annotation|@
name|Override
specifier|public
name|IndexMetadata
name|getIndexMetadata
parameter_list|(
name|String
name|indexName
parameter_list|)
block|{
if|if
condition|(
name|indexName
operator|==
literal|null
operator|||
name|indexName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed index name MUST NOT be NULL nor empty!"
argument_list|)
throw|;
block|}
return|return
name|managedCores
operator|.
name|getIndexMetadata
argument_list|(
name|indexName
argument_list|)
return|;
block|}
comment|/**      * Getter for the name of a Core based on the {@link IndexReference}.      * Checks for both path and name      * @param indexRef the indexreference      * @return the name of the core or<code>null</code> if not found      */
specifier|private
name|String
name|getCoreName
parameter_list|(
name|IndexReference
name|indexRef
parameter_list|)
block|{
name|String
name|coreName
decl_stmt|;
if|if
condition|(
name|indexRef
operator|.
name|isPath
argument_list|()
condition|)
block|{
comment|//try to convert the path to the name
name|ServiceReference
name|coreRef
init|=
name|server
operator|.
name|getCoreForDir
argument_list|(
name|indexRef
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|coreRef
operator|!=
literal|null
condition|)
block|{
name|coreName
operator|=
operator|(
name|String
operator|)
name|coreRef
operator|.
name|getProperty
argument_list|(
name|PROPERTY_CORE_NAME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|coreName
operator|=
literal|null
expr_stmt|;
block|}
block|}
else|else
block|{
name|coreName
operator|=
name|indexRef
operator|.
name|getIndex
argument_list|()
expr_stmt|;
block|}
return|return
name|coreName
return|;
block|}
comment|/**      * Updates the core with the parsed name with the data parsed within the      * ArchiveInputStream and stores updated to the state of the index within the      * parsed {@link IndexMetadata} instance.      * @param metadata the metadata of the index to update. The parsed instance      * is updated within this method      * @param ais the data      * @throws IOException On any Error while copying the data for the Index      * @throws SAXException On any Error while parsing the Solr Configuration for      */
specifier|protected
specifier|final
name|void
name|updateCore
parameter_list|(
specifier|final
name|IndexMetadata
name|metadata
parameter_list|,
name|ArchiveInputStream
name|ais
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
block|{
if|if
condition|(
name|metadata
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed metadata for the Solr index MUST NOT be NULL"
argument_list|)
throw|;
block|}
if|if
condition|(
name|metadata
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed metadata for the Solr index MUST NOT be empty"
argument_list|)
throw|;
block|}
name|String
name|coreName
init|=
name|metadata
operator|.
name|getIndexName
argument_list|()
decl_stmt|;
if|if
condition|(
name|coreName
operator|==
literal|null
operator|||
name|coreName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parse metadata do not contain a valid value for the '"
operator|+
name|INDEX_NAME
operator|+
literal|"'!"
argument_list|)
throw|;
block|}
name|SolrServerAdapter
name|server
init|=
name|this
operator|.
name|server
decl_stmt|;
if|if
condition|(
name|server
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Unable to update core '{}' because this ManagedSolrServer is already deactivated."
argument_list|)
expr_stmt|;
return|return;
block|}
name|ServiceReference
name|coreRef
init|=
name|server
operator|.
name|getCore
argument_list|(
name|coreName
argument_list|)
decl_stmt|;
name|File
name|currentCoreDir
decl_stmt|;
comment|//dir of the previous version
if|if
condition|(
name|coreRef
operator|!=
literal|null
condition|)
block|{
name|currentCoreDir
operator|=
name|getCoreDir
argument_list|(
name|coreRef
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//no old version
name|currentCoreDir
operator|=
literal|null
expr_stmt|;
block|}
name|String
name|coreDirName
decl_stmt|;
comment|//the name of the "new" core directory
synchronized|synchronized
init|(
name|coreSuffixDateFormat
init|)
block|{
comment|//SimpleDateFormat is not thread save. It may fail badly on two
comment|//concurrent calls.
name|coreDirName
operator|=
name|coreName
operator|+
literal|'-'
operator|+
name|coreSuffixDateFormat
operator|.
name|format
argument_list|(
operator|new
name|Date
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|File
name|coreDir
init|=
operator|new
name|File
argument_list|(
name|managedSolrDir
argument_list|,
name|coreDirName
argument_list|)
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|coreDir
operator|.
name|exists
argument_list|()
condition|)
block|{
comment|//if this is the second call on a day ... add a count
comment|//if directories get deleted directories with a higher count might
comment|//be older versions than directories without or with a lower count!
name|coreDir
operator|=
operator|new
name|File
argument_list|(
name|managedSolrDir
argument_list|,
name|coreDirName
operator|+
literal|"-"
operator|+
name|count
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|metadata
operator|.
name|setDirectory
argument_list|(
name|coreDir
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
comment|//TODO maybe we need to call getAbsolute path
comment|// no the initialisation/update of this core starts!
synchronized|synchronized
init|(
name|initCores
init|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"> start initializing SolrIndex {}"
operator|+
name|coreName
argument_list|)
expr_stmt|;
name|initCores
operator|.
name|put
argument_list|(
name|coreName
argument_list|,
name|coreDir
argument_list|)
expr_stmt|;
block|}
try|try
block|{
comment|//outer try for finally removal from initCores
try|try
block|{
comment|//not the third parameter (coreName) is not the name of this
comment|//core, but the original name within the indexArchive
name|String
name|archiveCoreName
init|=
name|getArchiveCoreName
argument_list|(
name|metadata
argument_list|)
decl_stmt|;
name|ConfigUtils
operator|.
name|copyCore
argument_list|(
name|ais
argument_list|,
name|coreDir
argument_list|,
name|archiveCoreName
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|=
operator|new
name|IOException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unable to copy Data for index '%s' (server '%s')"
argument_list|,
name|coreName
argument_list|,
name|serverName
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//store this Error in the metadata
name|metadata
operator|.
name|setError
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
try|try
block|{
name|activateCore
argument_list|(
name|metadata
argument_list|,
name|server
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|setState
argument_list|(
name|ManagedIndexState
operator|.
name|ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentCoreDir
operator|!=
literal|null
condition|)
block|{
comment|//remove the data of the old core
try|try
block|{
name|FileUtils
operator|.
name|deleteDirectory
argument_list|(
name|currentCoreDir
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|//only log an Error and do not throw an Exception in that case
name|log
operator|.
name|error
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unable to delete Directory %s of the "
operator|+
literal|"old (and no longer needed) version of the index '%s' "
operator|+
literal|"of the managed SolrServer '{}'. Please try to "
operator|+
literal|"delete this directory manually!"
argument_list|,
name|currentCoreDir
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|coreName
argument_list|,
name|serverName
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|//store Errors in the metadata
name|metadata
operator|.
name|setError
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|SAXException
name|e
parameter_list|)
block|{
name|metadata
operator|.
name|setError
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|metadata
operator|.
name|setError
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
finally|finally
block|{
comment|// regardless what happened remove the index from the currently init
comment|// indexes and notify all other waiting for the initialisation
synchronized|synchronized
init|(
name|initCores
init|)
block|{
comment|// initialisation done
name|initCores
operator|.
name|remove
argument_list|(
name|coreName
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"   ... notify after trying to init SolrIndex {}"
operator|+
name|coreName
argument_list|)
expr_stmt|;
comment|// notify that the initialisation completed or failed
name|initCores
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Activates the core and updates the parsed metadata accordingly      * @param metadata the metadata. Not modified by this method      * @param server the server to activate the core on      * @throws IOException On any error while accessing the core configuration files      * @throws SAXException On any error while parsing the core configuration files      * @throws IllegalStateException if a {@link ParserConfigurationException}      * is thrown by the server.      */
specifier|protected
specifier|final
name|void
name|activateCore
parameter_list|(
name|IndexMetadata
name|metadata
parameter_list|,
name|SolrServerAdapter
name|server
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
block|{
name|SolrCoreProperties
name|coreConfig
init|=
operator|new
name|SolrCoreProperties
argument_list|(
name|metadata
operator|.
name|getIndexName
argument_list|()
argument_list|)
decl_stmt|;
name|coreConfig
operator|.
name|setCoreDir
argument_list|(
operator|new
name|File
argument_list|(
name|managedSolrDir
argument_list|,
name|metadata
operator|.
name|getDirectory
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Object
name|token
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|serverInUser
init|)
block|{
comment|//prevent shutting down the server while we initialise a core
name|serverInUser
operator|.
name|add
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|server
operator|.
name|registerCore
argument_list|(
name|coreConfig
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ParserConfigurationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to configure XML parser"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unable to access the SolrCore configuration for index "
operator|+
literal|"'%s' of managed SolrServer '%s'"
argument_list|,
name|metadata
operator|.
name|getIndexName
argument_list|()
argument_list|,
name|serverName
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|SAXException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SAXException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unable to parse SolrCore configuration for  index '%s' of "
operator|+
literal|"managed SolrServer '%s'"
argument_list|,
name|metadata
operator|.
name|getIndexName
argument_list|()
argument_list|,
name|serverName
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
synchronized|synchronized
init|(
name|serverInUser
init|)
block|{
name|serverInUser
operator|.
name|remove
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|token
operator|=
literal|null
expr_stmt|;
name|serverInUser
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Getter for the CoreDir based on the ServiceReference. In addition      * it checks if the value exists and if the value is an Directory on the      * local file System.      * @param coreRef the ServiceReference to a core (MUST NOT be NULL)      * @param exists if<code>true</code> it is checked that the coreDir exists      * and is an directory. if<code>false</code> it is ensured that the      * coreDir does not yet exist      * @return the directory of this core      * @throws IllegalStateException if the reference is missing a value for      * {@link SolrConstants#PROPERTY_CORE_NAME} or if the validation based on the      * parsed exists state fails.      */
specifier|private
name|File
name|getCoreDir
parameter_list|(
name|ServiceReference
name|coreRef
parameter_list|,
name|boolean
name|exists
parameter_list|)
block|{
name|String
name|coreName
init|=
operator|(
name|String
operator|)
name|coreRef
operator|.
name|getProperty
argument_list|(
name|PROPERTY_CORE_NAME
argument_list|)
decl_stmt|;
name|File
name|coreDir
decl_stmt|;
name|String
name|dirName
init|=
operator|(
name|String
operator|)
name|coreRef
operator|.
name|getProperty
argument_list|(
name|PROPERTY_CORE_DIR
argument_list|)
decl_stmt|;
if|if
condition|(
name|dirName
operator|==
literal|null
condition|)
block|{
comment|//this should never happen -> fail early
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Required Property '"
operator|+
name|PROPERTY_CORE_DIR
operator|+
literal|"' not present in properties of Core '"
operator|+
name|coreName
operator|+
literal|" of managed SolrServer '"
operator|+
name|serverName
operator|+
literal|"'!"
argument_list|)
throw|;
block|}
name|coreDir
operator|=
operator|new
name|File
argument_list|(
name|dirName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|exists
operator|&&
operator|!
name|coreDir
operator|.
name|isDirectory
argument_list|()
operator|)
operator|||
comment|//must exist and is not a directory
operator|!
name|exists
operator|&&
name|coreDir
operator|.
name|exists
argument_list|()
condition|)
block|{
comment|//must not exist but File exists
comment|//this should never happen -> fail early
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Property '"
operator|+
name|PROPERTY_CORE_DIR
operator|+
literal|"' of Core '"
operator|+
name|coreName
operator|+
literal|" (managedSolrServer= "
operator|+
name|serverName
operator|+
literal|" points to a Directory "
operator|+
name|dirName
operator|+
literal|" that MUST "
operator|+
operator|(
name|exists
condition|?
literal|""
else|:
literal|"NOT"
operator|)
operator|+
literal|"exist!"
argument_list|)
throw|;
block|}
return|return
name|coreDir
return|;
block|}
comment|/**      * Listener for Solr Index Archives of uninitialised cores.      * @author Rupert Westenthaler      *      */
specifier|private
specifier|static
class|class
name|IndexArchiveTracker
implements|implements
name|DataFileListener
block|{
specifier|private
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|IndexArchiveTracker
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|DataFileTracker
name|tracker
decl_stmt|;
specifier|private
specifier|final
name|DataFileProvider
name|provider
decl_stmt|;
specifier|private
specifier|final
name|ManagedIndexMetadata
name|managedCores
decl_stmt|;
specifier|private
specifier|final
name|IndexUpdateDaemon
name|indexUpdateDaemon
decl_stmt|;
specifier|protected
name|IndexArchiveTracker
parameter_list|(
name|DataFileTracker
name|tracker
parameter_list|,
name|DataFileProvider
name|provider
parameter_list|,
name|ManagedIndexMetadata
name|managedCores
parameter_list|,
name|IndexUpdateDaemon
name|indexUpdateDaemon
parameter_list|)
block|{
name|this
operator|.
name|tracker
operator|=
name|tracker
expr_stmt|;
name|this
operator|.
name|provider
operator|=
name|provider
expr_stmt|;
name|this
operator|.
name|managedCores
operator|=
name|managedCores
expr_stmt|;
name|this
operator|.
name|indexUpdateDaemon
operator|=
name|indexUpdateDaemon
expr_stmt|;
for|for
control|(
name|String
name|indexName
range|:
name|managedCores
operator|.
name|getManaged
argument_list|()
control|)
block|{
name|addTracking
argument_list|(
name|managedCores
operator|.
name|getIndexMetadata
argument_list|(
name|indexName
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|updateTracking
parameter_list|(
name|IndexMetadata
name|oldMetadata
parameter_list|,
name|IndexMetadata
name|metadata
parameter_list|)
block|{
comment|//for now a simple remove/re-add implementation
name|removeTracking
argument_list|(
name|oldMetadata
argument_list|)
expr_stmt|;
name|addTracking
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
name|tracker
operator|.
name|removeAll
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|finalize
parameter_list|()
throws|throws
name|Throwable
block|{
name|close
argument_list|()
expr_stmt|;
name|super
operator|.
name|finalize
argument_list|()
expr_stmt|;
block|}
comment|/**          * @param indexName          */
specifier|public
name|void
name|addTracking
parameter_list|(
name|IndexMetadata
name|metadata
parameter_list|)
block|{
if|if
condition|(
name|metadata
operator|!=
literal|null
condition|)
block|{
comment|//may be removed in the meantime
if|if
condition|(
operator|!
name|metadata
operator|.
name|isActive
argument_list|()
operator|||
name|metadata
operator|.
name|isSynchronized
argument_list|()
condition|)
block|{
name|String
name|archive
init|=
name|metadata
operator|.
name|getArchive
argument_list|()
decl_stmt|;
name|boolean
name|found
init|=
literal|false
decl_stmt|;
comment|//only track higher priority files as the current
for|for
control|(
name|String
name|indexArchive
range|:
name|metadata
operator|.
name|getIndexArchives
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|found
condition|)
block|{
if|if
condition|(
name|indexArchive
operator|.
name|equals
argument_list|(
name|archive
argument_list|)
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
block|}
name|tracker
operator|.
name|add
argument_list|(
name|this
argument_list|,
name|indexArchive
argument_list|,
name|IndexMetadata
operator|.
name|toStringMap
argument_list|(
name|metadata
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// else higher priority archive present -> no tracking
block|}
block|}
comment|//else active and not syncronized -> no tracking
block|}
block|}
empty_stmt|;
comment|/**          * Stops tracking for Archive files of this specific index          * @param metadata          */
specifier|public
name|void
name|removeTracking
parameter_list|(
name|IndexMetadata
name|metadata
parameter_list|)
block|{
if|if
condition|(
name|metadata
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|indexArchive
range|:
name|metadata
operator|.
name|getIndexArchives
argument_list|()
control|)
block|{
comment|//check if this archive is still used by an other index
if|if
condition|(
name|managedCores
operator|.
name|getIndexNames
argument_list|(
name|indexArchive
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|tracker
operator|.
name|remove
argument_list|(
name|this
argument_list|,
name|indexArchive
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|unavailable
parameter_list|(
name|String
name|resource
parameter_list|)
block|{
for|for
control|(
name|String
name|indexName
range|:
name|managedCores
operator|.
name|getIndexNames
argument_list|(
name|resource
argument_list|)
control|)
block|{
name|IndexMetadata
name|metadata
init|=
name|managedCores
operator|.
name|getIndexMetadata
argument_list|(
name|indexName
argument_list|)
decl_stmt|;
if|if
condition|(
name|metadata
operator|!=
literal|null
condition|)
block|{
comment|//may be removed in the meantime
name|String
name|currentArchive
init|=
name|metadata
operator|.
name|getArchive
argument_list|()
decl_stmt|;
name|boolean
name|inSync
init|=
name|metadata
operator|.
name|isSynchronized
argument_list|()
decl_stmt|;
if|if
condition|(
name|resource
operator|.
name|equals
argument_list|(
name|currentArchive
argument_list|)
condition|)
block|{
comment|//current archive may be null
name|currentArchive
operator|=
literal|null
expr_stmt|;
comment|//reset the current archive to null (none)
name|ArchiveInputStream
name|ais
init|=
literal|null
decl_stmt|;
for|for
control|(
name|String
name|archive
range|:
name|metadata
operator|.
name|getIndexArchives
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|archive
operator|.
name|equals
argument_list|(
name|resource
argument_list|)
condition|)
block|{
if|if
condition|(
name|currentArchive
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|InputStream
name|is
init|=
name|provider
operator|.
name|getInputStream
argument_list|(
literal|null
argument_list|,
name|archive
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|is
operator|!=
literal|null
condition|)
block|{
name|ais
operator|=
name|ManagementUtils
operator|.
name|getArchiveInputStream
argument_list|(
name|archive
argument_list|,
name|is
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ais
operator|=
literal|null
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|//not available
name|ais
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArchiveException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Unable to open ArchiveInputStream for Resource '"
operator|+
name|archive
operator|+
literal|"'!"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|ais
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|ais
operator|!=
literal|null
condition|)
block|{
comment|//ais != null also
name|currentArchive
operator|=
name|archive
expr_stmt|;
comment|//currentArchive != null
block|}
block|}
comment|//if resource become unavailable we might need to
comment|//add resources for tracking
if|if
condition|(
operator|!
name|tracker
operator|.
name|isTracked
argument_list|(
name|this
argument_list|,
literal|null
argument_list|,
name|archive
argument_list|)
operator|&&
comment|//if not already tracked
operator|(
name|currentArchive
operator|==
literal|null
operator|||
operator|(
comment|//and no archive found
name|currentArchive
operator|!=
literal|null
operator|&&
name|inSync
operator|)
operator|)
condition|)
block|{
comment|//or found but inSync
name|tracker
operator|.
name|add
argument_list|(
name|this
argument_list|,
name|archive
argument_list|,
name|IndexMetadata
operator|.
name|toStringMap
argument_list|(
name|metadata
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// else already tracked or no tracking needed
block|}
block|}
comment|//If we have now a currentArchive and an ais we can
comment|//switch to an alternate archive.
comment|//If not we need to switch this in index in the UNAVAILABLE
comment|// state
name|metadata
operator|.
name|setArchive
argument_list|(
name|currentArchive
argument_list|)
expr_stmt|;
comment|//update the metadata
name|managedCores
operator|.
name|store
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
comment|//if the parsed ais is NULL the index will be uninitialised
name|indexUpdateDaemon
operator|.
name|update
argument_list|(
name|currentArchive
operator|==
literal|null
condition|?
name|ManagedIndexState
operator|.
name|UNINITIALISED
else|:
name|ManagedIndexState
operator|.
name|ACTIVE
argument_list|,
name|indexName
argument_list|,
name|ais
argument_list|)
expr_stmt|;
block|}
comment|// else an unused archive is no longer available -> nothing to do
block|}
comment|//else are not available -> nothing to do
block|}
comment|//end for all Indexes using the archive that is no longer available
return|return
literal|false
return|;
comment|//never remove an registration after an unavailable event
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|available
parameter_list|(
name|String
name|resourceName
parameter_list|,
name|InputStream
name|is
parameter_list|)
block|{
name|ArchiveInputStream
name|ais
decl_stmt|;
try|try
block|{
name|ais
operator|=
name|ManagementUtils
operator|.
name|getArchiveInputStream
argument_list|(
name|resourceName
argument_list|,
name|is
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArchiveException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Unable to open ArchiveInputStream for Resource '"
operator|+
name|resourceName
operator|+
literal|"'!"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|ais
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|ais
operator|!=
literal|null
condition|)
block|{
name|boolean
name|keepTracking
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|indexName
range|:
name|managedCores
operator|.
name|getIndexNames
argument_list|(
name|resourceName
argument_list|)
control|)
block|{
name|IndexMetadata
name|metadata
init|=
name|managedCores
operator|.
name|getIndexMetadata
argument_list|(
name|indexName
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|archives
init|=
name|metadata
operator|.
name|getIndexArchives
argument_list|()
decl_stmt|;
name|String
name|currentArchive
init|=
name|metadata
operator|.
name|getArchive
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentArchive
operator|==
literal|null
operator|||
name|archives
operator|.
name|indexOf
argument_list|(
name|resourceName
argument_list|)
operator|<
name|archives
operator|.
name|indexOf
argument_list|(
name|currentArchive
argument_list|)
condition|)
block|{
name|metadata
operator|.
name|setArchive
argument_list|(
name|resourceName
argument_list|)
expr_stmt|;
name|managedCores
operator|.
name|store
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
name|indexUpdateDaemon
operator|.
name|update
argument_list|(
name|ManagedIndexState
operator|.
name|ACTIVE
argument_list|,
name|indexName
argument_list|,
name|ais
argument_list|)
expr_stmt|;
comment|//if synchronised do not remove this listener
name|keepTracking
operator|=
name|keepTracking
operator|||
name|metadata
operator|.
name|isSynchronized
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|//currently used Archive is of higher priority as
comment|// this one.
comment|//keep tracking if synchronised
name|keepTracking
operator|=
name|keepTracking
operator|||
name|metadata
operator|.
name|isSynchronized
argument_list|()
expr_stmt|;
block|}
block|}
return|return
operator|!
name|keepTracking
return|;
block|}
else|else
block|{
comment|//unable to create an ArchiveInputStrem
return|return
literal|false
return|;
comment|//TODO: add support for ERROR state to the Tracker!
block|}
block|}
block|}
comment|/**      * Used to perform the potential long running update operations on Solr      * cores in an own daemon. This can also be used to create a thread pool to      * allow initialisation of n cores at the same time.       * @author Rupert Westenthaler      *      */
specifier|private
class|class
name|IndexUpdateDaemon
extends|extends
name|Thread
block|{
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|ArchiveInputStream
argument_list|>
name|toUpdate
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ArchiveInputStream
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|active
init|=
literal|true
decl_stmt|;
specifier|public
name|void
name|close
parameter_list|()
block|{
name|active
operator|=
literal|false
expr_stmt|;
synchronized|synchronized
init|(
name|toUpdate
init|)
block|{
name|toUpdate
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|update
parameter_list|(
name|ManagedIndexState
name|state
parameter_list|,
name|String
name|name
parameter_list|,
name|ArchiveInputStream
name|ais
parameter_list|)
block|{
if|if
condition|(
name|name
operator|==
literal|null
operator|||
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed index name MUST NOT be NULL"
argument_list|)
throw|;
block|}
if|if
condition|(
name|state
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed desired ManagedIndexState MUST NOT be NULL"
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|ACTIVE
case|:
if|if
condition|(
name|ais
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"If the parsed ManagedIndexState is ACTIVE, "
operator|+
literal|"than the parsed ArchiveInputStream MUST NOT be NULL!"
argument_list|)
throw|;
block|}
break|break;
case|case
name|UNINITIALISED
case|:
if|if
condition|(
name|ais
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Parsed ArchiveInputStream is NOT NULL but desired ManagedIndexState is UNINITIALISED."
operator|+
literal|"The parsed stream will not be used!"
argument_list|)
expr_stmt|;
block|}
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|ais
argument_list|)
expr_stmt|;
comment|//close the stream
name|ais
operator|=
literal|null
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The IndexUpdateDeamon only supports the ManagedIndexStates ACTIVE and UNINITIALISED!"
argument_list|)
throw|;
block|}
synchronized|synchronized
init|(
name|toUpdate
init|)
block|{
name|toUpdate
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|ais
argument_list|)
expr_stmt|;
name|toUpdate
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
name|active
condition|)
block|{
name|Entry
argument_list|<
name|String
argument_list|,
name|ArchiveInputStream
argument_list|>
name|entry
decl_stmt|;
while|while
condition|(
operator|!
name|toUpdate
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
synchronized|synchronized
init|(
name|toUpdate
init|)
block|{
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|ArchiveInputStream
argument_list|>
argument_list|>
name|it
init|=
name|toUpdate
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|//get the next element
name|entry
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
comment|//and remove it
block|}
else|else
block|{
name|entry
operator|=
literal|null
expr_stmt|;
block|}
block|}
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
name|IndexMetadata
name|metadata
init|=
name|managedCores
operator|.
name|getIndexMetadata
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|metadata
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|entry
operator|.
name|getValue
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|//desired state ACTIVE
name|log
operator|.
name|info
argument_list|(
literal|" ... start to ACTIVATE Index {} on ManagedSolrServer"
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|metadata
operator|.
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|updateCore
argument_list|(
name|metadata
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|" ... Index {} on ManagedSolrServer {} is now ACTIVE"
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|metadata
operator|.
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"IOException while activating Index '"
operator|+
name|metadata
operator|.
name|getServerName
argument_list|()
operator|+
literal|':'
operator|+
name|metadata
operator|.
name|getIndexName
argument_list|()
operator|+
literal|"'!"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|setError
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SAXException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"SAXException while activating Index '"
operator|+
name|metadata
operator|.
name|getServerName
argument_list|()
operator|+
literal|':'
operator|+
name|metadata
operator|.
name|getIndexName
argument_list|()
operator|+
literal|"'!"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|setError
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Exception while activating Index '"
operator|+
name|metadata
operator|.
name|getServerName
argument_list|()
operator|+
literal|':'
operator|+
name|metadata
operator|.
name|getIndexName
argument_list|()
operator|+
literal|"'!"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|setError
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|managedCores
operator|.
name|store
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//desired state UNINITIALISED
name|log
operator|.
name|info
argument_list|(
literal|" ... start to UNINITIALISE Index {} on ManagedSolrServer"
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|metadata
operator|.
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|uninitialiseCore
argument_list|(
name|metadata
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|" ... Index {} on ManagedSolrServer {} is now UNINITIALISED"
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|metadata
operator|.
name|getServerName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Exception while uninitialising Index '"
operator|+
name|metadata
operator|.
name|getServerName
argument_list|()
operator|+
literal|':'
operator|+
name|metadata
operator|.
name|getIndexName
argument_list|()
operator|+
literal|"'!"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|setError
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// store the updated metadata
name|managedCores
operator|.
name|store
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//else removed in the meantime -> nothing to do
block|}
block|}
synchronized|synchronized
init|(
name|toUpdate
init|)
block|{
try|try
block|{
name|toUpdate
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"interrupted to update {} core"
argument_list|,
name|toUpdate
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
end_class

end_unit

