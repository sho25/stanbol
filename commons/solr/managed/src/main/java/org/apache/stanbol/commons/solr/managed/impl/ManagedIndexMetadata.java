begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_comment
comment|/**  *   */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|managed
operator|.
name|impl
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|SolrConstants
operator|.
name|PROPERTY_SERVER_NAME
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|filefilter
operator|.
name|SuffixFileFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|SolrConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|managed
operator|.
name|IndexMetadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|managed
operator|.
name|ManagedIndexState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|managed
operator|.
name|ManagedSolrServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|utils
operator|.
name|ConfigUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|framework
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|service
operator|.
name|component
operator|.
name|ComponentContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Helper class that manages the configuration files for SolrIndexed managed  * by {@link ManagedSolrServer} implementations.<p>  * It can both operate within and outside an OSGI environment. In case a  * OSGI environment is available is uses the persistent storage area of the  * bundle and creates a subfolder based on the {@link Constants#SERVICE_PID}  * of the   * @author westei  *  */
end_comment

begin_class
specifier|public
class|class
name|ManagedIndexMetadata
block|{
specifier|private
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ManagedIndexMetadata
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * The path to the directory used to store metadata about managed indexes.      *<p>      * This directory will store properties files with the indexName as name, properties as extension and the      * properties as value      */
specifier|private
specifier|static
specifier|final
name|String
name|DEFAULT_INDEX_CONFIG_DIR
init|=
literal|".config/index-config"
decl_stmt|;
comment|/**      * This map is used synchronise access to configuration files      *         */
comment|//private Map<String,int[]> configDirSync = Collections.synchronizedMap(
comment|//    new HashMap<String,int[]>());
specifier|private
specifier|final
name|String
name|serverName
decl_stmt|;
comment|//private final ComponentContext context;
specifier|private
specifier|final
name|String
name|pid
decl_stmt|;
specifier|private
specifier|final
name|File
name|configDir
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|ManagedIndexState
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|IndexMetadata
argument_list|>
argument_list|>
name|managed
init|=
operator|new
name|EnumMap
argument_list|<
name|ManagedIndexState
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|IndexMetadata
argument_list|>
argument_list|>
argument_list|(
name|ManagedIndexState
operator|.
name|class
argument_list|)
decl_stmt|;
comment|//    private final Map<String,IndexMetadata> uninitialised = new HashMap<String,IndexMetadata>();
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Collection
argument_list|<
name|String
argument_list|>
argument_list|>
name|archiveName2CoreName
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Collection
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|//    private final Map<String, IndexMetadata> active = new HashMap<String,IndexMetadata>();
comment|/**      * The {@link #managed} is used to synchronise  while reading/writing the      * in-memory model       */
specifier|private
name|Object
name|inMemoryModelLock
init|=
name|managed
decl_stmt|;
specifier|private
name|ManagedIndexMetadata
parameter_list|(
name|String
name|serverName
parameter_list|,
name|String
name|pid
parameter_list|,
name|ComponentContext
name|context
parameter_list|)
block|{
name|this
operator|.
name|serverName
operator|=
name|serverName
expr_stmt|;
name|this
operator|.
name|pid
operator|=
name|pid
expr_stmt|;
comment|//this.context = context;
comment|//init the Maps for manageing Indexes with the different states
for|for
control|(
name|ManagedIndexState
name|state
range|:
name|ManagedIndexState
operator|.
name|values
argument_list|()
control|)
block|{
name|managed
operator|.
name|put
argument_list|(
name|state
argument_list|,
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|IndexMetadata
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|File
name|dir
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|context
operator|!=
literal|null
condition|)
block|{
name|dir
operator|=
name|context
operator|.
name|getBundleContext
argument_list|()
operator|.
name|getDataFile
argument_list|(
name|DEFAULT_INDEX_CONFIG_DIR
operator|+
literal|'/'
operator|+
name|pid
argument_list|)
expr_stmt|;
comment|//dir might be null if the OSGI environment is missing file system support
block|}
if|if
condition|(
name|dir
operator|==
literal|null
condition|)
block|{
comment|//outside OSGI or OSGI has no file system support
comment|// use config directory relative to the the Managed Solr Directory
name|dir
operator|=
operator|new
name|File
argument_list|(
name|DEFAULT_INDEX_CONFIG_DIR
argument_list|,
name|pid
argument_list|)
operator|.
name|getAbsoluteFile
argument_list|()
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"SolrYard Config Directory: "
operator|+
name|dir
argument_list|)
expr_stmt|;
name|this
operator|.
name|configDir
operator|=
name|dir
expr_stmt|;
block|}
comment|/**      * Constructor to be used outside of an OSGI context      * @param serverName the name of the Server      */
specifier|public
name|ManagedIndexMetadata
parameter_list|(
name|String
name|serverName
parameter_list|)
block|{
name|this
argument_list|(
name|serverName
argument_list|,
name|serverName
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|serverName
operator|==
literal|null
operator|||
name|serverName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed ServerName MUST NOT be NULL nor empty!"
argument_list|)
throw|;
block|}
block|}
comment|/**      * The constructor to be used inside an OSGI environment.       * The {@link #serverName} is parsed form the {@link SolrConstants#PROPERTY_SERVER_NAME}.      * @param context the context of the {@link ManagedSolrServer} implementation      * @throws IllegalStateException if the OSGI environment does not have      * FileSystem support      */
specifier|public
name|ManagedIndexMetadata
parameter_list|(
name|ComponentContext
name|context
parameter_list|)
block|{
name|this
argument_list|(
operator|(
name|String
operator|)
name|context
operator|.
name|getProperties
argument_list|()
operator|.
name|get
argument_list|(
name|PROPERTY_SERVER_NAME
argument_list|)
argument_list|,
operator|(
name|String
operator|)
name|context
operator|.
name|getProperties
argument_list|()
operator|.
name|get
argument_list|(
name|Constants
operator|.
name|SERVICE_PID
argument_list|)
argument_list|,
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|serverName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The properties of the "
operator|+
literal|"ComponentContext of the ManagedSolrServer '"
operator|+
name|serverName
operator|+
literal|"'MUST contain a '"
operator|+
name|SolrConstants
operator|.
name|PROPERTY_SERVER_NAME
operator|+
literal|"' value!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|pid
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The properties of the "
operator|+
literal|"ComponentContext of the ManagedSolrServer '"
operator|+
name|serverName
operator|+
literal|"'MUST contain a '"
operator|+
name|Constants
operator|.
name|SERVICE_PID
operator|+
literal|"' value!"
argument_list|)
throw|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|IndexMetadata
argument_list|>
name|indexConfigs
decl_stmt|;
try|try
block|{
name|indexConfigs
operator|=
name|loadIndexConfigs
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to load information about"
operator|+
literal|"uninitialised SolrCores for managed Solr server '"
operator|+
name|serverName
operator|+
literal|"'!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
synchronized|synchronized
init|(
name|inMemoryModelLock
init|)
block|{
comment|//build the in-memory model
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|IndexMetadata
argument_list|>
name|entry
range|:
name|indexConfigs
operator|.
name|entrySet
argument_list|()
control|)
block|{
comment|//read the state from the value and
comment|//put the entry to the map for the state
name|managed
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|getState
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|archiveName
range|:
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|getIndexArchives
argument_list|()
control|)
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|indexes
init|=
name|archiveName2CoreName
operator|.
name|get
argument_list|(
name|archiveName
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexes
operator|==
literal|null
condition|)
block|{
name|indexes
operator|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|archiveName2CoreName
operator|.
name|put
argument_list|(
name|archiveName
argument_list|,
name|indexes
argument_list|)
expr_stmt|;
block|}
name|indexes
operator|.
name|add
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|public
name|boolean
name|isInState
parameter_list|(
name|ManagedIndexState
name|state
parameter_list|,
name|String
name|indexName
parameter_list|)
block|{
synchronized|synchronized
init|(
name|inMemoryModelLock
init|)
block|{
return|return
name|managed
operator|.
name|get
argument_list|(
name|state
argument_list|)
operator|.
name|containsKey
argument_list|(
name|indexName
argument_list|)
return|;
block|}
block|}
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|getInState
parameter_list|(
name|ManagedIndexState
name|state
parameter_list|)
block|{
synchronized|synchronized
init|(
name|inMemoryModelLock
init|)
block|{
return|return
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|managed
operator|.
name|get
argument_list|(
name|state
argument_list|)
operator|.
name|keySet
argument_list|()
argument_list|)
return|;
block|}
block|}
specifier|public
name|boolean
name|isManaged
parameter_list|(
name|String
name|indexName
parameter_list|)
block|{
synchronized|synchronized
init|(
name|inMemoryModelLock
init|)
block|{
for|for
control|(
name|Map
argument_list|<
name|String
argument_list|,
name|IndexMetadata
argument_list|>
name|inState
range|:
name|managed
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|inState
operator|.
name|containsKey
argument_list|(
name|indexName
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getManaged
parameter_list|()
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|names
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|inMemoryModelLock
init|)
block|{
for|for
control|(
name|Map
argument_list|<
name|String
argument_list|,
name|IndexMetadata
argument_list|>
name|inState
range|:
name|managed
operator|.
name|values
argument_list|()
control|)
block|{
name|names
operator|.
name|addAll
argument_list|(
name|inState
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|names
return|;
block|}
comment|/**      * Provides the state of an index based on the managed metadata      * @param indexName the name of the index      * @return the state of<code>null</code> if the index name is not known by      * the in-memory model      */
specifier|public
name|ManagedIndexState
name|getState
parameter_list|(
name|String
name|indexName
parameter_list|)
block|{
synchronized|synchronized
init|(
name|inMemoryModelLock
init|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|ManagedIndexState
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|IndexMetadata
argument_list|>
argument_list|>
name|entry
range|:
name|managed
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|containsKey
argument_list|(
name|indexName
argument_list|)
condition|)
block|{
return|return
name|entry
operator|.
name|getKey
argument_list|()
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Getter for the metadata of all indexes in a given state. Changing the      * returned {@link Collection} or the Entries does not affect the state      * of this class.      * @param state the state      * @return the metadata of all the indexes in that state (empty if none,      *<code>null</code> if<code>null</code> was parsed as state)      */
specifier|public
name|Collection
argument_list|<
name|IndexMetadata
argument_list|>
name|getIndexMetadata
parameter_list|(
name|ManagedIndexState
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Collection
argument_list|<
name|IndexMetadata
argument_list|>
name|clones
init|=
operator|new
name|HashSet
argument_list|<
name|IndexMetadata
argument_list|>
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|inMemoryModelLock
init|)
block|{
for|for
control|(
name|IndexMetadata
name|metadata
range|:
name|managed
operator|.
name|get
argument_list|(
name|state
argument_list|)
operator|.
name|values
argument_list|()
control|)
block|{
name|IndexMetadata
name|clone
init|=
operator|new
name|IndexMetadata
argument_list|()
decl_stmt|;
name|clone
operator|.
name|putAll
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
name|clones
operator|.
name|add
argument_list|(
name|clone
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|clones
return|;
block|}
specifier|public
name|IndexMetadata
name|getIndexMetadata
parameter_list|(
name|String
name|indexName
parameter_list|)
block|{
name|IndexMetadata
name|metadata
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|inMemoryModelLock
init|)
block|{
name|Iterator
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|IndexMetadata
argument_list|>
argument_list|>
name|inStateIt
init|=
name|managed
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|metadata
operator|==
literal|null
operator|&&
name|inStateIt
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|metadata
operator|=
name|inStateIt
operator|.
name|next
argument_list|()
operator|.
name|get
argument_list|(
name|indexName
argument_list|)
expr_stmt|;
block|}
block|}
comment|//we need to return a clone to prevent changes by external changes to
comment|//the internal state!
if|if
condition|(
name|metadata
operator|!=
literal|null
condition|)
block|{
name|IndexMetadata
name|clone
init|=
operator|new
name|IndexMetadata
argument_list|()
decl_stmt|;
name|clone
operator|.
name|putAll
argument_list|(
name|metadata
argument_list|)
expr_stmt|;
return|return
name|clone
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|getIndexNames
parameter_list|(
name|String
name|archiveName
parameter_list|)
block|{
synchronized|synchronized
init|(
name|inMemoryModelLock
init|)
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|indexNames
init|=
name|archiveName2CoreName
operator|.
name|get
argument_list|(
name|archiveName
argument_list|)
decl_stmt|;
return|return
name|indexNames
operator|==
literal|null
condition|?
operator|(
name|Collection
argument_list|<
name|String
argument_list|>
operator|)
name|Collections
operator|.
name|EMPTY_LIST
else|:
name|Collections
operator|.
name|unmodifiableCollection
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|indexNames
argument_list|)
argument_list|)
return|;
block|}
block|}
specifier|public
name|void
name|addUninitialisedIndex
parameter_list|(
name|String
name|indexName
parameter_list|,
name|String
name|indexArchiveName
parameter_list|,
name|Boolean
name|sync
parameter_list|)
throws|throws
name|IOException
block|{
name|IndexMetadata
name|config
init|=
operator|new
name|IndexMetadata
argument_list|()
decl_stmt|;
name|config
operator|=
operator|new
name|IndexMetadata
argument_list|()
expr_stmt|;
name|config
operator|.
name|setIndexName
argument_list|(
name|indexName
argument_list|)
expr_stmt|;
name|config
operator|.
name|setServerName
argument_list|(
name|serverName
argument_list|)
expr_stmt|;
name|config
operator|.
name|setState
argument_list|(
name|ManagedIndexState
operator|.
name|UNINITIALISED
argument_list|)
expr_stmt|;
if|if
condition|(
name|sync
operator|!=
literal|null
condition|)
block|{
name|config
operator|.
name|setSynchronized
argument_list|(
name|sync
argument_list|)
expr_stmt|;
block|}
comment|//no need to clone, because we have created the instance
name|updateIndexProperties
argument_list|(
literal|null
argument_list|,
name|config
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|store
parameter_list|(
name|IndexMetadata
name|properties
parameter_list|)
block|{
name|updateIndexProperties
argument_list|(
literal|null
argument_list|,
name|properties
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**      * Removes the metadata of the index with that name      * @param name the name of the index to remove      * @return the removed metadata of the index of<code>null</code> if no      * matadata for an index with that name where present.      */
specifier|public
name|IndexMetadata
name|remove
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|updateIndexProperties
argument_list|(
name|name
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Adds, update and deletes index metadata      * @param name the name of the index (can be<code>null</code> of properties are parsed)      * @param properties the properties or<code>null</code> to remove      * @param clone If<code>true</code> the parsed properties are cloned. Clones      * are required for parsed properties to prevent external changes of properties      * stored in the internal lists. Only parse<code>false</code> in case the      * parsed properties are already a clone      * @return The old {@link IndexMetadata} instance (especially usefull in case of      * remove operations)      */
specifier|private
name|IndexMetadata
name|updateIndexProperties
parameter_list|(
name|String
name|name
parameter_list|,
name|IndexMetadata
name|properties
parameter_list|,
name|boolean
name|clone
parameter_list|)
block|{
if|if
condition|(
name|name
operator|==
literal|null
operator|&&
name|properties
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|name
operator|!=
literal|null
operator|&&
name|properties
operator|!=
literal|null
operator|&&
operator|!
name|name
operator|.
name|equals
argument_list|(
name|properties
operator|.
name|getIndexName
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The value of the Index-Name property '"
operator|+
name|properties
operator|.
name|getIndexName
argument_list|()
operator|+
literal|"' is not the same as the parsed name '"
operator|+
name|name
operator|+
literal|"'!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|name
operator|==
literal|null
condition|)
block|{
name|name
operator|=
name|properties
operator|.
name|getIndexName
argument_list|()
expr_stmt|;
block|}
comment|//first persist
if|if
condition|(
name|properties
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|saveIndexConfig
argument_list|(
name|name
argument_list|,
name|properties
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Unable to store Properties (see Exception below): {}"
argument_list|,
name|properties
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to save Index metadata for index '"
operator|+
name|name
operator|+
literal|"'!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|removeIndexConfig
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
comment|//clone is meaningless if properties are NULL
if|if
condition|(
name|clone
operator|&&
name|properties
operator|!=
literal|null
condition|)
block|{
name|IndexMetadata
name|tmp
init|=
name|properties
decl_stmt|;
name|properties
operator|=
operator|new
name|IndexMetadata
argument_list|()
expr_stmt|;
name|properties
operator|.
name|putAll
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|IndexMetadata
argument_list|>
name|toAdd
decl_stmt|,
name|toRemove
decl_stmt|;
name|IndexMetadata
name|oldMetadata
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|inMemoryModelLock
init|)
block|{
name|ManagedIndexState
name|currentState
init|=
name|getState
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentState
operator|!=
literal|null
condition|)
block|{
name|toRemove
operator|=
name|managed
operator|.
name|get
argument_list|(
name|currentState
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|toRemove
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|properties
operator|==
literal|null
condition|)
block|{
name|toAdd
operator|=
literal|null
expr_stmt|;
comment|//remove
block|}
else|else
block|{
name|ManagedIndexState
name|newState
init|=
name|properties
operator|.
name|getState
argument_list|()
decl_stmt|;
name|toAdd
operator|=
name|managed
operator|.
name|get
argument_list|(
name|newState
argument_list|)
expr_stmt|;
block|}
comment|//now update in-memory state
if|if
condition|(
name|toRemove
operator|!=
literal|null
condition|)
block|{
name|oldMetadata
operator|=
name|toRemove
operator|.
name|remove
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|toAdd
operator|!=
literal|null
condition|)
block|{
name|toAdd
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|properties
argument_list|)
expr_stmt|;
block|}
comment|//now update the archive name to core name mappings
if|if
condition|(
name|oldMetadata
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|indexArchive
range|:
name|oldMetadata
operator|.
name|getIndexArchives
argument_list|()
control|)
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|indexes
init|=
name|archiveName2CoreName
operator|.
name|get
argument_list|(
name|indexArchive
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexes
operator|.
name|remove
argument_list|(
name|name
argument_list|)
operator|&&
name|indexes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|archiveName2CoreName
operator|.
name|remove
argument_list|(
name|indexArchive
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|properties
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|indexArchive
range|:
name|properties
operator|.
name|getIndexArchives
argument_list|()
control|)
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|indexes
init|=
name|archiveName2CoreName
operator|.
name|get
argument_list|(
name|indexArchive
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexes
operator|==
literal|null
condition|)
block|{
name|indexes
operator|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|archiveName2CoreName
operator|.
name|put
argument_list|(
name|indexArchive
argument_list|,
name|indexes
argument_list|)
expr_stmt|;
block|}
name|indexes
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|oldMetadata
return|;
block|}
comment|/**      * Saves the configuration of an uninitialised index      *       * @param indexName      *            the name of the uninitialised index      * @param properties      *            the properties of the uninitialised index      * @throws IOException      *             on any error while saving the configuration      */
specifier|private
name|void
name|saveIndexConfig
parameter_list|(
name|String
name|indexName
parameter_list|,
name|IndexMetadata
name|properties
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|configDir
init|=
name|getIndexConfigDirectory
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|File
name|config
init|=
operator|new
name|File
argument_list|(
name|configDir
argument_list|,
name|indexName
operator|+
literal|'.'
operator|+
name|ConfigUtils
operator|.
name|SOLR_INDEX_ARCHIVE_EXTENSION
operator|+
literal|".ref"
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|pid
init|)
block|{
name|FileOutputStream
name|out
init|=
literal|null
decl_stmt|;
try|try
block|{
name|out
operator|=
operator|new
name|FileOutputStream
argument_list|(
name|config
argument_list|)
expr_stmt|;
name|properties
operator|.
name|store
argument_list|(
name|out
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Returns the directory used to store the configurations of uninitialised Solr Indexes      * @param init      *            if<code>true</code> the directory is created if needed      * @return the directory      */
specifier|private
name|File
name|getIndexConfigDirectory
parameter_list|(
name|boolean
name|init
parameter_list|)
block|{
if|if
condition|(
operator|!
name|configDir
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
name|init
condition|)
block|{
if|if
condition|(
operator|!
name|configDir
operator|.
name|mkdirs
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to create Directory "
operator|+
name|DEFAULT_INDEX_CONFIG_DIR
operator|+
literal|"for storing information of uninitialised Solr Indexes"
argument_list|)
throw|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|configDir
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"The directory "
operator|+
name|DEFAULT_INDEX_CONFIG_DIR
operator|+
literal|"for storing uninitialised Solr Indexes Information exists"
operator|+
literal|"but is not a directory!"
argument_list|)
throw|;
block|}
comment|// else -> it exists and is a dir -> nothing todo
return|return
name|configDir
return|;
block|}
comment|/**      * Loads the configurations of uninitialised Solr Indexes      *       * @return the map with the index name as key and the properties as values      * @throws IOException      *             on any error while loading the configurations      */
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|IndexMetadata
argument_list|>
name|loadIndexConfigs
parameter_list|()
throws|throws
name|IOException
block|{
name|File
name|uninstalledConfigDir
init|=
name|getIndexConfigDirectory
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|IndexMetadata
argument_list|>
name|configs
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|IndexMetadata
argument_list|>
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|pid
init|)
block|{
if|if
condition|(
name|uninstalledConfigDir
operator|.
name|exists
argument_list|()
condition|)
block|{
for|for
control|(
name|String
name|file
range|:
name|uninstalledConfigDir
operator|.
name|list
argument_list|(
operator|new
name|SuffixFileFilter
argument_list|(
name|ConfigUtils
operator|.
name|SOLR_INDEX_ARCHIVE_EXTENSION
operator|+
literal|".ref"
argument_list|)
argument_list|)
control|)
block|{
name|String
name|indexName
init|=
name|file
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|file
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|)
argument_list|)
decl_stmt|;
name|File
name|configFile
init|=
operator|new
name|File
argument_list|(
name|uninstalledConfigDir
argument_list|,
name|file
argument_list|)
decl_stmt|;
name|IndexMetadata
name|props
init|=
operator|new
name|IndexMetadata
argument_list|()
decl_stmt|;
name|InputStream
name|is
init|=
literal|null
decl_stmt|;
try|try
block|{
name|is
operator|=
operator|new
name|FileInputStream
argument_list|(
name|configFile
argument_list|)
expr_stmt|;
name|props
operator|.
name|load
argument_list|(
name|is
argument_list|)
expr_stmt|;
comment|//validate Index-Name and Server-Name properties!
if|if
condition|(
operator|!
name|indexName
operator|.
name|equals
argument_list|(
name|props
operator|.
name|getIndexName
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The IndexName '"
operator|+
name|props
operator|.
name|getIndexName
argument_list|()
operator|+
literal|"within the IndexConfig file does not correspond to the file name '"
operator|+
name|file
operator|+
literal|"'!"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|serverName
operator|.
name|equals
argument_list|(
name|props
operator|.
name|getServerName
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The Name of the Referenced Solr server '"
operator|+
name|serverName
operator|+
literal|" does not correspond with the Server-Name value '"
operator|+
name|props
operator|.
name|getServerName
argument_list|()
operator|+
literal|"' within the property file '"
operator|+
name|file
operator|+
literal|"'!"
argument_list|)
throw|;
block|}
name|configs
operator|.
name|put
argument_list|(
name|indexName
argument_list|,
name|props
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|configs
return|;
block|}
comment|/**      * Removes the configuration for the index with the parsed name form the list if uninitialised indexes      *       * @param context      *            the context used to get the data storage or<code>null</code>      *            if not available (e.g. outside an OSGI environment)      * @param serverName      *            the name of the managed solr server      * @param indexName      *            the name of the index      * @return if the file was deleted.      */
specifier|private
name|boolean
name|removeIndexConfig
parameter_list|(
name|String
name|indexName
parameter_list|)
block|{
name|File
name|configFile
init|=
operator|new
name|File
argument_list|(
name|getIndexConfigDirectory
argument_list|(
literal|false
argument_list|)
argument_list|,
name|indexName
operator|+
literal|'.'
operator|+
name|ConfigUtils
operator|.
name|SOLR_INDEX_ARCHIVE_EXTENSION
operator|+
literal|".ref"
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|pid
init|)
block|{
return|return
name|configFile
operator|.
name|delete
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|pid
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|o
operator|instanceof
name|ManagedIndexMetadata
operator|&&
operator|(
operator|(
name|ManagedIndexMetadata
operator|)
name|o
operator|)
operator|.
name|pid
operator|.
name|equals
argument_list|(
name|pid
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"ManagedCores [name:%s|pid:%s|managed:%s]"
argument_list|,
name|serverName
argument_list|,
name|pid
argument_list|,
name|managed
argument_list|)
return|;
block|}
block|}
end_class

end_unit

