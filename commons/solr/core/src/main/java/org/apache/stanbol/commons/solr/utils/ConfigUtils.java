begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|solr
operator|.
name|utils
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URLDecoder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|GZIPInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|ArchiveEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|ArchiveInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|tar
operator|.
name|TarArchiveInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|zip
operator|.
name|ZipArchiveEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|zip
operator|.
name|ZipArchiveInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|zip
operator|.
name|ZipFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|compressors
operator|.
name|bzip2
operator|.
name|BZip2CompressorInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|FileUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|FilenameUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|embedded
operator|.
name|EmbeddedSolrServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|framework
operator|.
name|Bundle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * This Utility provides Methods that copy a configuration from a {@link Bundle} and copy it to a directory.  *<p>  * This is currently used by the {@link RegisteredSolrServerProvider} to initialise the internally managed  * {@link EmbeddedSolrServer} and/or to add additional cores. There are always two variants of the methods.  * The one taking a bundle as parameter is supposed to be used when running within an OSGI environment. The  * variant taking a Class object works outside of an OSGI environment.  *   * @author Rupert Westenthaler  *   */
end_comment

begin_class
specifier|public
specifier|final
class|class
name|ConfigUtils
block|{
specifier|private
name|ConfigUtils
parameter_list|()
block|{}
comment|/**      * Use&lt;indexName&gt;.solrindex[.&lt;archiveType&gt;] as file name      */
specifier|public
specifier|static
specifier|final
name|String
name|SOLR_INDEX_ARCHIVE_EXTENSION
init|=
literal|"solrindex"
decl_stmt|;
comment|/**      * Supported archive types.      */
specifier|public
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|SUPPORTED_SOLR_ARCHIVE_FORMAT
decl_stmt|;
static|static
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|cfm
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|cfm
operator|.
name|put
argument_list|(
name|SOLR_INDEX_ARCHIVE_EXTENSION
argument_list|,
literal|"zip"
argument_list|)
expr_stmt|;
comment|// the default if not specified
name|cfm
operator|.
name|put
argument_list|(
literal|"gz"
argument_list|,
literal|"gz"
argument_list|)
expr_stmt|;
name|cfm
operator|.
name|put
argument_list|(
literal|"bz2"
argument_list|,
literal|"bz2"
argument_list|)
expr_stmt|;
name|cfm
operator|.
name|put
argument_list|(
literal|"zip"
argument_list|,
literal|"zip"
argument_list|)
expr_stmt|;
name|cfm
operator|.
name|put
argument_list|(
literal|"jar"
argument_list|,
literal|"zip"
argument_list|)
expr_stmt|;
name|cfm
operator|.
name|put
argument_list|(
literal|"ref"
argument_list|,
literal|"properties"
argument_list|)
expr_stmt|;
comment|// reference
name|cfm
operator|.
name|put
argument_list|(
literal|"properties"
argument_list|,
literal|"properties"
argument_list|)
expr_stmt|;
comment|// also accept properties as references
name|SUPPORTED_SOLR_ARCHIVE_FORMAT
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|cfm
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_ARCHIVE_FORMAT
init|=
literal|"zip"
decl_stmt|;
comment|/**      * The default extension for Solr Index Archives. This is typically added      * to configuration names that are missing the extension.      */
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_SOLR_INDEX_ARCHIVE_EXTENSION
init|=
literal|'.'
operator|+
name|SOLR_INDEX_ARCHIVE_EXTENSION
operator|+
literal|'.'
operator|+
name|DEFAULT_ARCHIVE_FORMAT
decl_stmt|;
specifier|public
specifier|static
name|boolean
name|isValidSolrIndexFileName
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|name
operator|.
name|indexOf
argument_list|(
literal|'.'
operator|+
name|SOLR_INDEX_ARCHIVE_EXTENSION
argument_list|)
operator|>=
literal|0
operator|&&
name|SUPPORTED_SOLR_ARCHIVE_FORMAT
operator|.
name|containsKey
argument_list|(
name|FilenameUtils
operator|.
name|getExtension
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|String
name|appandSolrIndexFileExtension
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|format
parameter_list|)
block|{
name|String
name|extension
decl_stmt|;
if|if
condition|(
name|SUPPORTED_SOLR_ARCHIVE_FORMAT
operator|.
name|containsKey
argument_list|(
name|format
argument_list|)
condition|)
block|{
name|extension
operator|=
name|format
expr_stmt|;
block|}
else|else
block|{
name|extension
operator|=
name|DEFAULT_ARCHIVE_FORMAT
expr_stmt|;
block|}
return|return
name|name
operator|+
literal|'.'
operator|+
name|SOLR_INDEX_ARCHIVE_EXTENSION
operator|+
literal|'.'
operator|+
name|extension
return|;
block|}
specifier|public
specifier|static
name|ArchiveInputStream
name|getArchiveInputStream
parameter_list|(
name|String
name|solrArchiveName
parameter_list|,
name|InputStream
name|is
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|archiveFormat
decl_stmt|;
name|String
name|solrArchiveExtension
init|=
name|FilenameUtils
operator|.
name|getExtension
argument_list|(
name|solrArchiveName
argument_list|)
decl_stmt|;
if|if
condition|(
name|solrArchiveExtension
operator|==
literal|null
operator|||
name|solrArchiveExtension
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|archiveFormat
operator|=
name|solrArchiveName
expr_stmt|;
comment|// assume that the archiveExtension was parsed
block|}
else|else
block|{
name|archiveFormat
operator|=
name|SUPPORTED_SOLR_ARCHIVE_FORMAT
operator|.
name|get
argument_list|(
name|solrArchiveExtension
argument_list|)
expr_stmt|;
block|}
name|ArchiveInputStream
name|ais
decl_stmt|;
if|if
condition|(
literal|"zip"
operator|.
name|equals
argument_list|(
name|archiveFormat
argument_list|)
condition|)
block|{
name|ais
operator|=
operator|new
name|ZipArchiveInputStream
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
literal|"gz"
operator|.
name|equals
argument_list|(
name|archiveFormat
argument_list|)
condition|)
block|{
name|is
operator|=
operator|new
name|GZIPInputStream
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"bz2"
operator|.
name|equals
argument_list|(
name|archiveFormat
argument_list|)
condition|)
block|{
name|is
operator|=
operator|new
name|BZip2CompressorInputStream
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unsupported compression format "
operator|+
name|archiveFormat
operator|+
literal|"!. "
operator|+
literal|"Please report this to stanbol-dev mailing list!"
argument_list|)
throw|;
block|}
name|ais
operator|=
operator|new
name|TarArchiveInputStream
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
return|return
name|ais
return|;
block|}
comment|/**      * The logger      */
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ConfigUtils
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * The name of the directoy used in the bundle to search for the default config      */
specifier|public
specifier|static
specifier|final
name|String
name|CONFIG_DIR
init|=
literal|"solr/conf"
decl_stmt|;
comment|/**      * The name of the root directoy used within an bundle to search for all cores that need to be added to an      * existing solr multi core configuration      */
specifier|public
specifier|static
specifier|final
name|String
name|CORE_CONFIG_DIR
init|=
literal|"solr/core"
decl_stmt|;
comment|/**      * Initialises the default configuration for the SolrYard based on data in the parsed bundle. The      * configuration will be copied to the parsed root directory.      *       * @param bundle      *            the bundle used to load the defaultConfiguration from the {@link #CONFIG_DIR} (value="      *            {@value #CONFIG_DIR}") directory.      * @param rootDir      *            the target directory for the configuration.      * @param override      *            if true existing configurations are overridden.      * @return the root directory of the solr configuration (same as parsed as rootDir)      * @throws IOException      *             On any IO error while coping the configuration      * @throws IllegalStateException      *             If the parsed bundle is in the {@link Bundle#UNINSTALLED} state, the parsed rootDir does      *             exist but is not a directory.      * @throws IllegalArgumentException      *             If<code>null</code> is parsed as bundle or rootDir or if the parsed bundle does not      *             contain the required information to set up an configuration      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// Enumeration<URL> required by OSGI specification
specifier|public
specifier|static
name|File
name|copyDefaultConfig
parameter_list|(
name|Bundle
name|bundle
parameter_list|,
name|File
name|rootDir
parameter_list|,
name|boolean
name|override
parameter_list|)
throws|throws
name|IOException
throws|,
name|IllegalStateException
throws|,
name|IllegalArgumentException
block|{
if|if
condition|(
name|bundle
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Bundle MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|rootDir
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed root directory MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|rootDir
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|rootDir
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"The parsed root directory "
operator|+
name|rootDir
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" extists but is not a directory!"
argument_list|)
throw|;
block|}
name|log
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Copy Default Config from Bundle %s to %s (override=%s)"
argument_list|,
name|bundle
operator|.
name|getSymbolicName
argument_list|()
argument_list|,
name|rootDir
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|override
argument_list|)
argument_list|)
expr_stmt|;
name|Enumeration
argument_list|<
name|URL
argument_list|>
name|resources
init|=
operator|(
name|Enumeration
argument_list|<
name|URL
argument_list|>
operator|)
name|bundle
operator|.
name|findEntries
argument_list|(
name|CONFIG_DIR
argument_list|,
literal|"*.*"
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// TODO: check validity of config and thorw IllegalArgumentException if not valid
while|while
condition|(
name|resources
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|URL
name|resource
init|=
name|resources
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|copyResource
argument_list|(
name|rootDir
argument_list|,
name|resource
argument_list|,
name|CONFIG_DIR
argument_list|,
name|override
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|debug
argument_list|(
literal|" ... default Configuration copied to "
operator|+
name|rootDir
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|rootDir
return|;
block|}
comment|/**      * Initialises the default configuration for the SolrYard based on data in the parsed bundle. The      * configuration will be copied to the parsed root directory.      *       * @param clazzInArchive      *            This class is used to identify the archive containing the default configuration. Parsing      *<code>null</code> causes this class to be used and therefore initialises the default      *            configuration contained by the SolrYard bundle.      * @param rootDir      *            the target directory for the configuration.      * @param override      *            if true existing configurations are overridden.      * @return the root directory of the solr configuration (same as parsed as rootDir)      * @throws IOException      *             On any IO error while coping the configuration      * @throws IllegalStateException      *             If the parsed rootDir does exist but is not a directory.      * @throws IllegalArgumentException      *             iIf<code>null</code> is parsed as rootDir or if the parsed bundle does not contain the      *             required information to set up an configuration      */
specifier|public
specifier|static
name|File
name|copyDefaultConfig
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|clazzInArchive
parameter_list|,
name|File
name|rootDir
parameter_list|,
name|boolean
name|override
parameter_list|)
throws|throws
name|IOException
throws|,
name|IllegalStateException
throws|,
name|IllegalArgumentException
block|{
if|if
condition|(
name|rootDir
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed root directory MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|rootDir
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|rootDir
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"The parsed root directory "
operator|+
name|rootDir
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" extists but is not a directory!"
argument_list|)
throw|;
block|}
name|File
name|sourceRoot
init|=
name|getSource
argument_list|(
name|clazzInArchive
operator|!=
literal|null
condition|?
name|clazzInArchive
else|:
name|ConfigUtils
operator|.
name|class
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Init Solr Managed Directory form {} to {} (override={})"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|sourceRoot
block|,
name|rootDir
block|,
name|override
block|}
argument_list|)
expr_stmt|;
if|if
condition|(
name|sourceRoot
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|ZipFile
name|archive
init|=
operator|new
name|ZipFile
argument_list|(
name|sourceRoot
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"  - read from jar-file"
argument_list|)
expr_stmt|;
try|try
block|{
for|for
control|(
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Enumeration
argument_list|<
name|ZipArchiveEntry
argument_list|>
name|entries
init|=
operator|(
name|Enumeration
argument_list|<
name|ZipArchiveEntry
argument_list|>
operator|)
name|archive
operator|.
name|getEntries
argument_list|()
init|;
name|entries
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|ZipArchiveEntry
name|entry
init|=
name|entries
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|entry
operator|.
name|isDirectory
argument_list|()
operator|&&
name|entry
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
name|CONFIG_DIR
argument_list|)
condition|)
block|{
name|copyResource
argument_list|(
name|rootDir
argument_list|,
name|archive
argument_list|,
name|entry
argument_list|,
name|CONFIG_DIR
argument_list|,
name|override
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
comment|// regardless what happens we need to close the archive!
name|ZipFile
operator|.
name|closeQuietly
argument_list|(
name|archive
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// load from file
name|log
operator|.
name|info
argument_list|(
literal|"  - read from directory"
argument_list|)
expr_stmt|;
name|File
name|source
init|=
operator|new
name|File
argument_list|(
name|sourceRoot
argument_list|,
name|CONFIG_DIR
argument_list|)
decl_stmt|;
if|if
condition|(
name|source
operator|.
name|exists
argument_list|()
operator|&&
name|source
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|FileUtils
operator|.
name|copyDirectory
argument_list|(
name|source
argument_list|,
name|rootDir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"The SolrIndex default config was not found in directory "
operator|+
name|source
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
throw|;
block|}
block|}
return|return
name|rootDir
return|;
block|}
comment|/**      * Uses the {@link ClassLoader} of the parsed {@link Class} instance to locate the jar file the class was      * loaded from.      *       * @param clazz      *            the class used as context to find the jar file      * @return the archive the parsed class was loaded from      * @throws IOException      *             In case the jar file can not be accessed.      */
specifier|private
specifier|static
name|File
name|getSource
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|classFileName
init|=
name|clazz
operator|.
name|getName
argument_list|()
operator|.
name|replace
argument_list|(
literal|'.'
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|".class"
decl_stmt|;
name|URL
name|classLocation
init|=
name|clazz
operator|.
name|getClassLoader
argument_list|()
operator|.
name|getResource
argument_list|(
name|classFileName
argument_list|)
decl_stmt|;
name|String
name|classPath
decl_stmt|;
try|try
block|{
name|classPath
operator|=
operator|new
name|File
argument_list|(
name|classLocation
operator|.
name|toURI
argument_list|()
argument_list|)
operator|.
name|getAbsolutePath
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// if we can not convert it to an URI, try directly with the URL
comment|// URLs with jar:file:/{jarPath}!{classPath} can cause problems
comment|// so try to parse manually by using the substring from the first
comment|// '/' to (including '!')
name|String
name|urlString
init|=
name|URLDecoder
operator|.
name|decode
argument_list|(
name|classLocation
operator|.
name|toString
argument_list|()
argument_list|,
literal|"UTF-8"
argument_list|)
decl_stmt|;
name|int
name|slashIndex
init|=
name|urlString
operator|.
name|indexOf
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
name|int
name|exclamationIndex
init|=
name|urlString
operator|.
name|indexOf
argument_list|(
literal|'!'
argument_list|)
decl_stmt|;
if|if
condition|(
name|slashIndex
operator|>=
literal|0
operator|&&
name|exclamationIndex
operator|>
literal|0
condition|)
block|{
name|classPath
operator|=
name|urlString
operator|.
name|substring
argument_list|(
name|slashIndex
argument_list|,
name|exclamationIndex
operator|+
literal|1
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"manually parsed classPath: {} from {}"
argument_list|,
name|classPath
argument_list|,
name|classLocation
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// looks like there is an other reason than an URL as described above
comment|// so better to throw an exception than to guess ...
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to Access Source at location "
operator|+
name|classLocation
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|classPath
operator|.
name|indexOf
argument_list|(
literal|'!'
argument_list|)
operator|>
literal|0
condition|)
block|{
return|return
operator|new
name|File
argument_list|(
name|classPath
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|classPath
operator|.
name|indexOf
argument_list|(
literal|'!'
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|File
argument_list|(
name|classPath
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|classPath
operator|.
name|length
argument_list|()
operator|-
name|classFileName
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/**      * Copies a resource (URL of an resource within a Bundle) to a file      *       * @param rootDir      *            the directory used as target      * @param resource      *            the resource URL      * @param context      *            the context used to search for the relative path within the URL      * @param override      *            if resources in the target should be overridden if they already exist      * @throws IOException      *             on any IO error      */
specifier|private
specifier|static
name|void
name|copyResource
parameter_list|(
name|File
name|rootDir
parameter_list|,
name|URL
name|resource
parameter_list|,
name|String
name|context
parameter_list|,
name|boolean
name|override
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|resourcePath
init|=
name|resource
operator|.
name|toString
argument_list|()
decl_stmt|;
name|File
name|file
init|=
name|prepairCopy
argument_list|(
name|resourcePath
argument_list|,
name|rootDir
argument_list|,
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|!=
literal|null
condition|)
block|{
name|boolean
name|overrideState
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|file
operator|.
name|exists
argument_list|()
operator|&&
name|override
condition|)
block|{
name|FileUtils
operator|.
name|deleteQuietly
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|overrideState
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|file
operator|.
name|exists
argument_list|()
condition|)
block|{
name|FileUtils
operator|.
name|copyURLToFile
argument_list|(
name|resource
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"> %s %s"
argument_list|,
name|overrideState
condition|?
literal|"override"
else|:
literal|"copy"
argument_list|,
name|file
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// else can not cppy logging already provided
block|}
comment|/**      * Variant of the copyResource method that used an entry of an archive as source.      *       * @param rootDir      *            the directory used as target      * @param archive      *            the archive containing the parsed entry      * @param entry      *            the entry to copy to the target directory      * @param context      *            the context used to calculate the relative path of the resource within the target directory      * @param override      *            if an existing resource within the target directory should be deleted      * @throws IOException      *             in case of an error while reading or writing the resource      */
specifier|private
specifier|static
name|void
name|copyResource
parameter_list|(
name|File
name|rootDir
parameter_list|,
name|ZipFile
name|archive
parameter_list|,
name|ZipArchiveEntry
name|entry
parameter_list|,
name|String
name|context
parameter_list|,
name|boolean
name|override
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|file
init|=
name|prepairCopy
argument_list|(
name|entry
operator|.
name|getName
argument_list|()
argument_list|,
name|rootDir
argument_list|,
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|!=
literal|null
condition|)
block|{
name|boolean
name|overrideState
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|file
operator|.
name|exists
argument_list|()
operator|&&
name|override
condition|)
block|{
name|FileUtils
operator|.
name|deleteQuietly
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|overrideState
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|file
operator|.
name|exists
argument_list|()
condition|)
block|{
name|OutputStream
name|os
init|=
literal|null
decl_stmt|;
name|InputStream
name|is
init|=
literal|null
decl_stmt|;
try|try
block|{
name|os
operator|=
name|FileUtils
operator|.
name|openOutputStream
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|is
operator|=
name|archive
operator|.
name|getInputStream
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|copy
argument_list|(
name|is
argument_list|,
name|os
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"> %s %s"
argument_list|,
name|overrideState
condition|?
literal|"override"
else|:
literal|"copy"
argument_list|,
name|file
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// else can not cppy logging already provided
block|}
comment|/**      * Prepares the copying of a resource. The context is used to determine the relative path of the resource.      * Than missing sub-directories are created in the target directory. Finally the file instance      * representing this resource within the target directory is returned.      *       * @param resource      *            The path to the resource. This need not be the full path. It must only be ensured that the      *            parsed context is contained. e.g. the relative path of a resource within an archive provides      *            enough context for this method to work      * @param targetDir      *            the target directory      * @param context      *            the context to determine the relative path of the resource within the target directory. The      *            context MUST be part of the parsed resource name. Otherwise this method will return      *<code>null</code>      * @return the file representing the resource within the target directory. In cases the context can not be      *         found in the parsed resource this method returns<code>null</code>      */
specifier|private
specifier|static
name|File
name|prepairCopy
parameter_list|(
name|String
name|resource
parameter_list|,
name|File
name|targetDir
parameter_list|,
name|String
name|context
parameter_list|)
block|{
name|context
operator|=
name|FilenameUtils
operator|.
name|separatorsToSystem
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|context
operator|.
name|charAt
argument_list|(
name|context
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
name|File
operator|.
name|separatorChar
operator|)
condition|)
block|{
name|context
operator|=
name|context
operator|+
name|File
operator|.
name|separatorChar
expr_stmt|;
block|}
name|resource
operator|=
name|FilenameUtils
operator|.
name|separatorsToSystem
argument_list|(
name|resource
argument_list|)
expr_stmt|;
name|int
name|contextPos
init|=
name|resource
operator|.
name|lastIndexOf
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|contextPos
operator|>=
literal|0
condition|)
block|{
name|contextPos
operator|=
name|contextPos
operator|+
name|context
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Context {} not found in resource {} -> ignored!"
argument_list|,
name|context
argument_list|,
name|resource
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|String
name|relativePath
init|=
name|resource
operator|.
name|substring
argument_list|(
name|contextPos
argument_list|)
decl_stmt|;
name|String
index|[]
name|relativePathElements
init|=
name|relativePath
operator|.
name|split
argument_list|(
name|File
operator|.
name|separator
argument_list|)
decl_stmt|;
name|File
name|parentElement
init|=
name|targetDir
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|relativePathElements
operator|.
name|length
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|File
name|pathElement
init|=
operator|new
name|File
argument_list|(
name|parentElement
argument_list|,
name|relativePathElements
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|pathElement
operator|.
name|exists
argument_list|()
condition|)
block|{
name|pathElement
operator|.
name|mkdir
argument_list|()
expr_stmt|;
block|}
name|parentElement
operator|=
name|pathElement
expr_stmt|;
block|}
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|parentElement
argument_list|,
name|relativePathElements
index|[
name|relativePathElements
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
decl_stmt|;
return|return
name|file
return|;
block|}
comment|/**      * Copy the configuration of an core.      *       * @param bundle      *            The bundle used to load the core      * @param coreDir      *            the target directory for the core      * @param coreName      *            the core name or<code>null</code> to directly load the configuration as present under      *            {@value #CONFIG_DIR} in the bundle. This property can be used if a bundle needs to provide      *            multiple core configurations      * @param override      *            if files in the target directory should be overridden      * @throws IOException      *             On any IO error while coping the configuration      * @throws IllegalStateException      *             If the parsed bundle is in the {@link Bundle#UNINSTALLED} state, the parsed coreDir does      *             exist but is not a directory.      * @throws IllegalArgumentException      *             if<code>null</code> is parsed as bundle or coreDir or if the parsed bundle does not      *             contain the required information to set up an configuration or the parsed coreName is      *             empty.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// Enumeration<URL> required by OSGI specification
specifier|public
specifier|static
name|void
name|copyCore
parameter_list|(
name|Bundle
name|bundle
parameter_list|,
name|File
name|coreDir
parameter_list|,
name|String
name|coreName
parameter_list|,
name|boolean
name|override
parameter_list|)
throws|throws
name|IOException
throws|,
name|IllegalStateException
throws|,
name|IllegalArgumentException
block|{
if|if
condition|(
name|bundle
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Bundle MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|coreDir
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed core directory MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|coreDir
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|coreDir
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"The parsed core directory "
operator|+
name|coreDir
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" extists but is not a directory!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|coreName
operator|!=
literal|null
operator|&&
name|coreName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed core name MUST NOT be empty (However NULL is supported)!"
argument_list|)
throw|;
block|}
name|String
name|context
init|=
name|CORE_CONFIG_DIR
operator|+
operator|(
name|coreName
operator|!=
literal|null
condition|?
literal|'/'
operator|+
name|coreName
else|:
literal|""
operator|)
decl_stmt|;
name|Enumeration
argument_list|<
name|URL
argument_list|>
name|resources
init|=
operator|(
name|Enumeration
argument_list|<
name|URL
argument_list|>
operator|)
name|bundle
operator|.
name|findEntries
argument_list|(
name|context
argument_list|,
literal|"*.*"
argument_list|,
literal|true
argument_list|)
decl_stmt|;
while|while
condition|(
name|resources
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|URL
name|resource
init|=
name|resources
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|copyResource
argument_list|(
name|coreDir
argument_list|,
name|resource
argument_list|,
name|context
argument_list|,
name|override
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Copies a core from the parsed archive input stream to the target location      *       * @param ais      *            The input stream of the archive (not closed by this method)      * @param coreDir      *            the directory for the core      * @param coreName      *            the name of the core (used as context when reading relative paths from the archive      * @param override      *            if existing files should be overridden      * @throws IOException      *             On any error while accessing the data of the archive      * @throws IllegalArgumentException      *             if any of the parameter is<code>null</code> or if the coreDir exists but is not an      *             directory or if the core name is empty      */
specifier|public
specifier|static
name|void
name|copyCore
parameter_list|(
name|ArchiveInputStream
name|ais
parameter_list|,
name|File
name|coreDir
parameter_list|,
name|String
name|coreName
parameter_list|,
name|boolean
name|override
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|ais
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed ArchiveInputStream MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|coreDir
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed core directory MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|coreDir
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|coreDir
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"The parsed core directory "
operator|+
name|coreDir
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" extists but is not a directory!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|coreName
operator|==
literal|null
operator|||
name|coreName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed core name MUST NOT be NULL or empty!"
argument_list|)
throw|;
block|}
name|ArchiveEntry
name|entry
decl_stmt|;
while|while
condition|(
operator|(
name|entry
operator|=
name|ais
operator|.
name|getNextEntry
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|entry
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|copyArchiveEntry
argument_list|(
name|ais
argument_list|,
name|entry
argument_list|,
name|coreDir
argument_list|,
name|coreName
argument_list|,
name|override
argument_list|)
expr_stmt|;
comment|/*                  * NOTE: Here we use the coreName as context (last argument to prepairCopy(..)). This ensures                  * that it matter if the archive contains the data directly in the root or within an folder                  * with the name of the core.                  */
block|}
comment|// else - directories are created automatically and empty directories are not needed
block|}
block|}
comment|/**      * Copy an Entry of an Archive to the target (File) within the Core Directory      *       * @param ais      *            the ArchiveInputStream      * @param entry      *            The Entry to copy      * @param coreDir      *            the root directory      * @param context      *            the context used to calculate the relative path of the resource within the target directory      * @param override      *            if an existing resource within the target directory should be deleted      * @throws IOException      *             in case of an error while reading or writing the resource      */
specifier|private
specifier|static
name|void
name|copyArchiveEntry
parameter_list|(
name|ArchiveInputStream
name|ais
parameter_list|,
name|ArchiveEntry
name|entry
parameter_list|,
name|File
name|coreDir
parameter_list|,
name|String
name|context
parameter_list|,
name|boolean
name|override
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|file
init|=
name|prepairCopy
argument_list|(
name|entry
operator|.
name|getName
argument_list|()
argument_list|,
name|coreDir
argument_list|,
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|!=
literal|null
condition|)
block|{
name|boolean
name|overrideState
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|file
operator|.
name|exists
argument_list|()
operator|&&
name|override
condition|)
block|{
name|FileUtils
operator|.
name|deleteQuietly
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|overrideState
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|file
operator|.
name|exists
argument_list|()
condition|)
block|{
name|OutputStream
name|os
init|=
literal|null
decl_stmt|;
try|try
block|{
name|os
operator|=
name|FileUtils
operator|.
name|openOutputStream
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|copy
argument_list|(
name|ais
argument_list|,
name|os
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"> %s %s"
argument_list|,
name|overrideState
condition|?
literal|"override"
else|:
literal|"copy"
argument_list|,
name|file
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// else can not cppy logging already provided
block|}
comment|/**      * Copy the configuration of an core.      *       * @param clazzInArchive      *            This class is used to identify the archive containing the default configuration. Parsing      *<code>null</code> causes this class to be used and therefore initialises the default core      *            configuration contained by the SolrYard bundle.      * @param coreDir      *            the target directory for the core      * @param coreName      *            the core name or<code>null</code> to directly load the configuration as present under      *            {@value #CONFIG_DIR} in the bundle. This property can be used if a bundle needs to provide      *            multiple core configurations      * @param override      *            if files in the target directory should be overridden      * @throws IOException      *             On any IO error while coping the configuration      * @throws IllegalStateException      *             If the parsed coreDir does exist but is not a directory.      * @throws IllegalArgumentException      *             if<code>null</code> is parsed as coreDir or if the parsed bundle does not contain the      *             required information to set up an configuration or the parsed coreName is empty.      */
specifier|public
specifier|static
name|void
name|copyCore
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|clazzInArchive
parameter_list|,
name|File
name|coreDir
parameter_list|,
name|String
name|coreName
parameter_list|,
name|boolean
name|override
parameter_list|)
throws|throws
name|IOException
throws|,
name|IllegalArgumentException
throws|,
name|IllegalStateException
block|{
if|if
condition|(
name|coreDir
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed core directory MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|coreDir
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|coreDir
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"The parsed core directory "
operator|+
name|coreDir
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" extists but is not a directory!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|coreName
operator|!=
literal|null
operator|&&
name|coreName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed core name MUST NOT be empty (However NULL is supported)!"
argument_list|)
throw|;
block|}
name|String
name|context
init|=
name|CORE_CONFIG_DIR
operator|+
operator|(
name|coreName
operator|!=
literal|null
condition|?
literal|'/'
operator|+
name|coreName
else|:
literal|""
operator|)
decl_stmt|;
name|File
name|sourceRoot
init|=
name|getSource
argument_list|(
name|clazzInArchive
operator|!=
literal|null
condition|?
name|clazzInArchive
else|:
name|ConfigUtils
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|sourceRoot
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|ZipFile
name|archive
init|=
operator|new
name|ZipFile
argument_list|(
name|sourceRoot
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Copy core %s config from jar-file %s to %s (override=%s)"
argument_list|,
operator|(
name|coreName
operator|==
literal|null
condition|?
literal|""
else|:
name|coreName
operator|)
argument_list|,
name|sourceRoot
operator|.
name|getName
argument_list|()
argument_list|,
name|coreDir
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|override
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
for|for
control|(
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Enumeration
argument_list|<
name|ZipArchiveEntry
argument_list|>
name|entries
init|=
operator|(
name|Enumeration
argument_list|<
name|ZipArchiveEntry
argument_list|>
operator|)
name|archive
operator|.
name|getEntries
argument_list|()
init|;
name|entries
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|ZipArchiveEntry
name|entry
init|=
name|entries
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
name|context
argument_list|)
condition|)
block|{
name|copyResource
argument_list|(
name|coreDir
argument_list|,
name|archive
argument_list|,
name|entry
argument_list|,
name|context
argument_list|,
name|override
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
comment|// regardless what happens we need to close the archive!
name|ZipFile
operator|.
name|closeQuietly
argument_list|(
name|archive
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// load from file
name|File
name|source
init|=
operator|new
name|File
argument_list|(
name|sourceRoot
argument_list|,
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|source
operator|.
name|exists
argument_list|()
operator|&&
name|source
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|FileUtils
operator|.
name|copyDirectory
argument_list|(
name|source
argument_list|,
name|coreDir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"The SolrIndex default config was not found in directory "
operator|+
name|source
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**      * Converts a parsed String to a File instance. The parsed string can be formatted as file URL or as path      *       * @param uriOrPath      *            the file location as URL or path      * @return the File      */
specifier|public
specifier|static
name|File
name|toFile
parameter_list|(
name|String
name|uriOrPath
parameter_list|)
block|{
name|File
name|file
init|=
literal|null
decl_stmt|;
try|try
block|{
name|URI
name|fileUri
init|=
operator|new
name|URI
argument_list|(
name|uriOrPath
argument_list|)
decl_stmt|;
name|file
operator|=
operator|new
name|File
argument_list|(
name|fileUri
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|e
parameter_list|)
block|{
comment|// not an URI -> ignore
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
comment|// this happens if it is a URI but can not be converted to a file
comment|// still we should try to work with the parsed file ...
block|}
if|if
condition|(
name|file
operator|==
literal|null
condition|)
block|{
name|file
operator|=
operator|new
name|File
argument_list|(
name|uriOrPath
argument_list|)
expr_stmt|;
block|}
return|return
name|file
return|;
block|}
comment|/**      * Parses the SolrServer name and the Core name form the parsed reference.<p>      * The following values are supported:<ol>      *<li> file URLs to the Core directory      *<li> file paths to the Core directory      *<li> [{server-name}:]{core-name} where both the server-name and the      *      core-name MUST NOT contain '/' and '\' (on windows) chars. If the       *      server-name is not specified the server with the highest       *      {@link Constants#SERVICE_RANKING} is assumed.      *</ol><p>      * @param uriOrPath the reference to the core      * @return the name of the server (or<code>null</code>) at index [0] and       * the name of the core (or<code>null</code> if not parsed) at index [1].      */
comment|//    public static String[] parseSolrServerReference(String uriOrPath) {
comment|//        String[] referencedCore = new String[2];
comment|//        if(uriOrPath.startsWith("file:")){ //file
comment|//            File file = null;
comment|//            try {
comment|//                file = FileUtils.toFile(new URL(uriOrPath));
comment|//            }catch (MalformedURLException e) {
comment|//                log.error("Unable to parse file URL '"+uriOrPath+"'!",e);
comment|//                file = null;
comment|//            }
comment|//            referencedCore[0] = null; //no server name for such values
comment|//            if(file != null){
comment|//                file = file.getAbsoluteFile();
comment|//                try {
comment|//                    referencedCore[1] = file.getCanonicalPath();
comment|//                } catch (IOException e) {
comment|//                    log.warn("Unable to create canonical path for the SolrCore reference '"+
comment|//                        file+"' -> will use this value instead!");
comment|//                    referencedCore[1] = file.getAbsolutePath();
comment|//                }
comment|//            } else {
comment|//                referencedCore[1] = null;
comment|//            }
comment|//        } else if(uriOrPath.indexOf(File.pathSeparatorChar)>=0 ||
comment|//                uriOrPath.indexOf('/')>=0){ //also support UNIX style on Windows
comment|//            //we assume a File Reference
comment|//            File file = new File(FilenameUtils.separatorsToSystem(uriOrPath));
comment|//            referencedCore[0] = null;
comment|//            file = file.getAbsoluteFile();
comment|//            try {
comment|//                referencedCore[1] = file.getCanonicalPath();
comment|//            } catch (IOException e) {
comment|//                log.warn("Unable to create canonical path for the SolrCore reference '"+
comment|//                    file+"' -> will use this value instead!");
comment|//                referencedCore[1] = file.getAbsolutePath();
comment|//            }
comment|//        } else { //reference in the style [{server-name}:]{core-name}
comment|//            int index = uriOrPath.indexOf(':');
comment|//            if(index< 0){
comment|//                referencedCore[0] = "";
comment|//                referencedCore[1] = uriOrPath;
comment|//            } else {
comment|//                referencedCore[0] = uriOrPath.substring(0,index);
comment|//                if(index+2>= uriOrPath.length()){
comment|//                    throw new IllegalArgumentException("The parsed SolrCore name '"+
comment|//                        uriOrPath+"' MUST NOT end with ':'" +
comment|//                            "used as separator between the SolrServer and the CoreName!");
comment|//                }
comment|//                referencedCore[1] = uriOrPath.substring(index+1);
comment|//            }
comment|//        }
comment|//        return referencedCore;
comment|//    }
block|}
end_class

end_unit

