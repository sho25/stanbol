begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2007 The Apache Software Foundation  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|net
operator|.
name|paoding
operator|.
name|analysis
operator|.
name|knife
package|;
end_package

begin_import
import|import
name|net
operator|.
name|paoding
operator|.
name|analysis
operator|.
name|dictionary
operator|.
name|Dictionary
import|;
end_import

begin_import
import|import
name|net
operator|.
name|paoding
operator|.
name|analysis
operator|.
name|dictionary
operator|.
name|Hit
import|;
end_import

begin_import
import|import
name|net
operator|.
name|paoding
operator|.
name|analysis
operator|.
name|dictionary
operator|.
name|Word
import|;
end_import

begin_comment
comment|/**  *   * @author Zhiliang Wang [qieqie.wang@gmail.com]  *   * @since 1.0  *   */
end_comment

begin_class
specifier|public
class|class
name|CJKKnife
implements|implements
name|Knife
implements|,
name|DictionariesWare
block|{
comment|// -------------------------------------------------
specifier|private
name|Dictionary
name|vocabulary
decl_stmt|;
specifier|private
name|Dictionary
name|noiseWords
decl_stmt|;
specifier|private
name|Dictionary
name|noiseCharactors
decl_stmt|;
specifier|private
name|Dictionary
name|units
decl_stmt|;
comment|// -------------------------------------------------
specifier|public
name|CJKKnife
parameter_list|()
block|{ 	}
specifier|public
name|CJKKnife
parameter_list|(
name|Dictionaries
name|dictionaries
parameter_list|)
block|{
name|setDictionaries
argument_list|(
name|dictionaries
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setDictionaries
parameter_list|(
name|Dictionaries
name|dictionaries
parameter_list|)
block|{
name|vocabulary
operator|=
name|dictionaries
operator|.
name|getVocabularyDictionary
argument_list|()
expr_stmt|;
name|noiseWords
operator|=
name|dictionaries
operator|.
name|getNoiseWordsDictionary
argument_list|()
expr_stmt|;
name|noiseCharactors
operator|=
name|dictionaries
operator|.
name|getNoiseCharactorsDictionary
argument_list|()
expr_stmt|;
name|units
operator|=
name|dictionaries
operator|.
name|getUnitsDictionary
argument_list|()
expr_stmt|;
block|}
comment|// -------------------------------------------------
comment|/** 	 * 分解以CJK字符开始的，后可带阿拉伯数字、英文字母、横线、下划线的字符组成的语句 	 */
specifier|public
name|int
name|assignable
parameter_list|(
name|Beef
name|beef
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|char
name|ch
init|=
name|beef
operator|.
name|charAt
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|CharSet
operator|.
name|isCjkUnifiedIdeographs
argument_list|(
name|ch
argument_list|)
condition|)
return|return
name|ASSIGNED
return|;
if|if
condition|(
name|index
operator|>
name|offset
condition|)
block|{
if|if
condition|(
name|CharSet
operator|.
name|isArabianNumber
argument_list|(
name|ch
argument_list|)
operator|||
name|CharSet
operator|.
name|isLantingLetter
argument_list|(
name|ch
argument_list|)
operator|||
name|ch
operator|==
literal|'-'
operator|||
name|ch
operator|==
literal|'_'
condition|)
block|{
return|return
name|POINT
return|;
block|}
block|}
return|return
name|LIMIT
return|;
block|}
specifier|public
name|int
name|dissect
parameter_list|(
name|Collector
name|collector
parameter_list|,
name|Beef
name|beef
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
comment|// 当point == -1时表示本次分解没有遇到POINT性质的字符；
comment|// 如果point != -1，该值表示POINT性质字符的开始位置，
comment|// 这个位置将被返回，下一个Knife将从point位置开始分词
name|int
name|point
init|=
operator|-
literal|1
decl_stmt|;
comment|// 记录同质字符分词结束极限位置(不包括limit位置的字符)-也就是assignable方法遇到LIMIT性质的字符的位置
comment|// 如果point==-1，limit将被返回，下一个Knife将从limit位置开始尝试分词
name|int
name|limit
init|=
name|offset
operator|+
literal|1
decl_stmt|;
comment|// 构建point和limit变量的值:
comment|// 往前直到遇到LIMIT字符；
comment|// 其中如果遇到第一次POINT字符，则会将它记录为point
name|GO_UNTIL_LIMIT
label|:
while|while
condition|(
literal|true
condition|)
block|{
switch|switch
condition|(
name|assignable
argument_list|(
name|beef
argument_list|,
name|offset
argument_list|,
name|limit
argument_list|)
condition|)
block|{
case|case
name|LIMIT
case|:
break|break
name|GO_UNTIL_LIMIT
break|;
case|case
name|POINT
case|:
if|if
condition|(
name|point
operator|==
operator|-
literal|1
condition|)
block|{
name|point
operator|=
name|limit
expr_stmt|;
block|}
block|}
name|limit
operator|++
expr_stmt|;
block|}
comment|// 如果从offset到beef.length()都是本次Knife的责任，则应读入更多的未读入字符，以支持一个词分在两次beef中的处理
comment|// 魔幻逻辑：
comment|// Beef承诺:如果以上GO_UNTIL_LIMIT循环最终把limit值设置为beef.length则表示还为未读入字符。
comment|// 因为beef一定会在文本全部结束后加入一个char='\0'的值作为最后一个char标志结束。
comment|// 这样以上的GO_UNTIL_LIMIT将在limit=beef.length()之前就已经break，此时limit!=beef.length
if|if
condition|(
name|offset
operator|>
literal|0
operator|&&
name|limit
operator|==
name|beef
operator|.
name|length
argument_list|()
condition|)
block|{
return|return
operator|-
name|offset
return|;
block|}
comment|// 记录当前正在检视(是否是词典词语)的字符串在beef中的始止位置(包含开始位置，不包含结束位置)
name|int
name|curSearchOffset
init|=
name|offset
decl_stmt|,
name|curSearchEnd
decl_stmt|;
comment|// 记录当前被检视的字符串的长度，它的值恒等于(curSearchEnd - curSearchOffset)
name|int
name|curSearchLength
decl_stmt|;
comment|// 当前检视的字符串的判断结果
name|Hit
name|curSearch
init|=
literal|null
decl_stmt|;
comment|// 限制要判断的字符串的最大开始位置
comment|// 这个变量不随着程序的运行而变化
specifier|final
name|int
name|offsetLimit
decl_stmt|;
if|if
condition|(
name|point
operator|!=
operator|-
literal|1
condition|)
name|offsetLimit
operator|=
name|point
expr_stmt|;
else|else
name|offsetLimit
operator|=
name|limit
expr_stmt|;
comment|// 记录到当前为止所分出的词典词语的最大结束位置
name|int
name|maxDicWordEnd
init|=
name|offset
decl_stmt|;
comment|// 记录最近的不在词典中的字符串(称为孤立字符串)在beef的位置，-1表示没有这个位置
name|int
name|isolatedOffset
init|=
operator|-
literal|1
decl_stmt|;
comment|// 记录到当前为止经由词典所切出词的最大长度。
comment|// 用于辅助判断是否调用shouldBeWord()方法，以把前后有如引号、书名号之类的，但还没有被切出的字符串当成一个词
comment|// 详见本方法后面对maxDicWordLength的应用以及shouldBeWord()的实现
name|int
name|maxDicWordLength
init|=
literal|0
decl_stmt|;
comment|// 第1个循环定位被检视字符串的开始位置
comment|// 被检视的字符串开始位置的极限是offsetLimit，而非limit
for|for
control|(
init|;
name|curSearchOffset
operator|<
name|offsetLimit
condition|;
name|curSearchOffset
operator|++
control|)
block|{
comment|// 第二个循环定位被检视字符串的结束位置(不包含该位置的字符)
comment|// 它的起始状态是：被检视的字符串一长度为1，即结束位置为开始位置+1
name|curSearchEnd
operator|=
name|curSearchOffset
operator|+
literal|1
expr_stmt|;
name|curSearchLength
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
name|curSearchEnd
operator|<=
name|limit
condition|;
name|curSearchEnd
operator|++
operator|,
name|curSearchLength
operator|++
control|)
block|{
comment|/* 				 * Fix issue 50: 中文数字解析问题  				 */
comment|//先搜索连续的中文数字
name|curSearch
operator|=
name|searchNumber
argument_list|(
name|beef
argument_list|,
name|curSearchOffset
argument_list|,
name|curSearchLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|curSearch
operator|.
name|isHit
argument_list|()
condition|)
block|{
if|if
condition|(
name|isolatedOffset
operator|>=
literal|0
condition|)
block|{
name|dissectIsolated
argument_list|(
name|collector
argument_list|,
name|beef
argument_list|,
name|isolatedOffset
argument_list|,
name|curSearchOffset
argument_list|)
expr_stmt|;
name|isolatedOffset
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|// trick: 用index返回中文数字实际结束位置
name|int
name|numberSearchEnd
init|=
name|curSearch
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|int
name|numberSearchLength
init|=
name|curSearch
operator|.
name|getIndex
argument_list|()
operator|-
name|curSearchOffset
decl_stmt|;
comment|// 1.2)
comment|// 更新最大结束位置
if|if
condition|(
name|maxDicWordEnd
operator|<
name|numberSearchEnd
condition|)
block|{
name|maxDicWordEnd
operator|=
name|numberSearchEnd
expr_stmt|;
block|}
comment|// 1.3)
comment|// 更新词语最大长度变量的值
if|if
condition|(
name|curSearchOffset
operator|==
name|offset
operator|&&
name|maxDicWordLength
operator|<
name|numberSearchLength
condition|)
block|{
name|maxDicWordLength
operator|=
name|numberSearchLength
expr_stmt|;
block|}
name|Word
name|word
init|=
name|curSearch
operator|.
name|getWord
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|word
operator|.
name|isNoise
argument_list|()
condition|)
block|{
name|dissectIsolated
argument_list|(
name|collector
argument_list|,
name|beef
argument_list|,
name|curSearchOffset
argument_list|,
name|curSearch
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|curSearchOffset
operator|=
name|numberSearchEnd
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|curSearch
operator|.
name|isUnclosed
argument_list|()
condition|)
block|{
continue|continue;
block|}
comment|// 通过词汇表判断，返回判断结果curSearch
name|curSearch
operator|=
name|vocabulary
operator|.
name|search
argument_list|(
name|beef
argument_list|,
name|curSearchOffset
argument_list|,
name|curSearchLength
argument_list|)
expr_stmt|;
comment|// ---------------分析返回的判断结果--------------------------
comment|// 1)
comment|// 从词汇表中找到了该词语...
if|if
condition|(
name|curSearch
operator|.
name|isHit
argument_list|()
condition|)
block|{
comment|// 1.1)
comment|// 确认孤立字符串的结束位置=curSearchOffset，
comment|// 并调用子方法分解把从isolatedOffset开始的到curSearchOffset之间的孤立字符串
comment|// 孤立字符串分解完毕，将孤立字符串开始位置isolatedOffset清空
if|if
condition|(
name|isolatedOffset
operator|>=
literal|0
condition|)
block|{
name|dissectIsolated
argument_list|(
name|collector
argument_list|,
name|beef
argument_list|,
name|isolatedOffset
argument_list|,
name|curSearchOffset
argument_list|)
expr_stmt|;
name|isolatedOffset
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|// 1.2)
comment|// 更新最大结束位置
if|if
condition|(
name|maxDicWordEnd
operator|<
name|curSearchEnd
condition|)
block|{
name|maxDicWordEnd
operator|=
name|curSearchEnd
expr_stmt|;
block|}
comment|// 1.3)
comment|// 更新词语最大长度变量的值
if|if
condition|(
name|curSearchOffset
operator|==
name|offset
operator|&&
name|maxDicWordLength
operator|<
name|curSearchLength
condition|)
block|{
name|maxDicWordLength
operator|=
name|curSearchLength
expr_stmt|;
block|}
comment|// 1.2)
comment|// 通知collector本次找到的词语
name|Word
name|word
init|=
name|curSearch
operator|.
name|getWord
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|word
operator|.
name|isNoise
argument_list|()
condition|)
block|{
name|collector
operator|.
name|collect
argument_list|(
name|word
operator|.
name|getText
argument_list|()
argument_list|,
name|curSearchOffset
argument_list|,
name|curSearchEnd
argument_list|)
expr_stmt|;
block|}
block|}
comment|// 若isolatedFound==true，表示词典没有该词语
name|boolean
name|isolatedFound
init|=
name|curSearch
operator|.
name|isUndefined
argument_list|()
decl_stmt|;
comment|// 若isolatedFound==false，则通过Hit的next属性检视词典没有beef的从offset到curWordEnd
comment|// + 1位置的词
comment|// 这个判断完全是为了减少一次词典检索而设计的，
comment|// 如果去掉这个if判断，并不影响程序的正确性(但是会多一次词典检索)
if|if
condition|(
operator|!
name|isolatedFound
operator|&&
operator|!
name|curSearch
operator|.
name|isHit
argument_list|()
operator|&&
name|curSearch
operator|.
name|getNext
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|isolatedFound
operator|=
name|curSearchEnd
operator|>=
name|limit
operator|||
name|beef
operator|.
name|charAt
argument_list|(
name|curSearchEnd
argument_list|)
operator|<
name|curSearch
operator|.
name|getNext
argument_list|()
operator|.
name|charAt
argument_list|(
name|curSearchLength
argument_list|)
expr_stmt|;
block|}
comment|// 2)
comment|// 词汇表中没有该词语，且没有以该词语开头的词汇...
comment|// -->将它记录为孤立词语
if|if
condition|(
name|isolatedFound
condition|)
block|{
if|if
condition|(
name|isolatedOffset
operator|<
literal|0
operator|&&
name|curSearchOffset
operator|>=
name|maxDicWordEnd
condition|)
block|{
name|isolatedOffset
operator|=
name|curSearchOffset
expr_stmt|;
block|}
break|break;
block|}
comment|// ^^^^^^^^^^^^^^^^^^分析返回的判断结果^^^^^^^^^^^^^^^^^^^^^^^^
block|}
comment|// end of the second for loop
block|}
comment|// end of the first for loop
comment|// 上面循环分词结束后，可能存在最后的几个未能从词典检索成词的孤立字符串，
comment|// 此时isolatedOffset不一定等于一个有效值(因为这些孤立字虽然不是词语，但是词典可能存在以它为开始的词语，
comment|// 只要执行到此才能知道这些虽然是前缀的字符串已经没有机会成为词语了)
comment|// 所以不能通过isolatedOffset来判断是否此时存在有孤立词，判断依据转换为：
comment|// 最后一个词典的词的结束位置是否小于offsetLimit(!!offsetLimit, not Limit!!)
if|if
condition|(
name|maxDicWordEnd
operator|<
name|offsetLimit
condition|)
block|{
name|dissectIsolated
argument_list|(
name|collector
argument_list|,
name|beef
argument_list|,
name|maxDicWordEnd
argument_list|,
name|offsetLimit
argument_list|)
expr_stmt|;
block|}
comment|// 现在是利用maxDicWordLength的时候了
comment|// 如果本次负责的所有字符串文本没有作为一个词被切分出(包括词典切词和孤立串切分)，
comment|// 那如果它被shouldBeWord方法认定为应该作为一个词切分，则将它切出来
name|int
name|len
init|=
name|limit
operator|-
name|offset
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|2
operator|&&
name|len
operator|!=
name|maxDicWordLength
operator|&&
name|shouldBeWord
argument_list|(
name|beef
argument_list|,
name|offset
argument_list|,
name|limit
argument_list|)
condition|)
block|{
name|collector
operator|.
name|collect
argument_list|(
name|beef
operator|.
name|subSequence
argument_list|(
name|offset
argument_list|,
name|limit
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|offset
argument_list|,
name|limit
argument_list|)
expr_stmt|;
block|}
comment|// 按照point和limit的语义，返回下一个Knife开始切词的开始位置
return|return
name|point
operator|==
operator|-
literal|1
condition|?
name|limit
else|:
name|point
return|;
block|}
comment|// -------------------------------------------------
specifier|protected
name|Hit
name|searchNumber
parameter_list|(
name|CharSequence
name|input
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|endPos
init|=
operator|-
literal|1
decl_stmt|;
name|StringBuilder
name|nums
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|input
operator|.
name|charAt
argument_list|(
name|offset
operator|+
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|CharSet
operator|.
name|toNumber
argument_list|(
name|c
argument_list|)
operator|<
literal|0
condition|)
block|{
break|break;
block|}
name|nums
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|endPos
operator|=
name|i
expr_stmt|;
block|}
comment|//没有中文数字了
if|if
condition|(
name|endPos
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|Hit
operator|.
name|UNDEFINED
return|;
block|}
comment|//中文数字还没结束，后面可能还有
if|if
condition|(
name|endPos
operator|==
name|count
operator|-
literal|1
condition|)
block|{
return|return
operator|new
name|Hit
argument_list|(
name|Hit
operator|.
name|UNCLOSED_INDEX
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|//只有一个中文数字，不是连续的，不处理
if|if
condition|(
name|endPos
operator|==
literal|0
condition|)
block|{
return|return
name|Hit
operator|.
name|UNDEFINED
return|;
block|}
comment|//部分含有中文数字，取这一部分出来
comment|//trick: 我们这里用index参数传递该部分中文的结束位置
return|return
operator|new
name|Hit
argument_list|(
name|offset
operator|+
name|endPos
operator|+
literal|1
argument_list|,
operator|new
name|Word
argument_list|(
name|nums
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** 	 * 对孤立字符串分词 	 *  	 * @param cellector 	 * @param beef 	 * @param offset 	 * @param count 	 */
specifier|protected
name|void
name|dissectIsolated
parameter_list|(
name|Collector
name|collector
parameter_list|,
name|Beef
name|beef
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|int
name|curSearchOffset
init|=
name|offset
decl_stmt|;
name|int
name|binOffset
init|=
name|curSearchOffset
decl_stmt|;
comment|// 进行一般二元分词的开始位置
name|int
name|tempEnd
decl_stmt|;
while|while
condition|(
name|curSearchOffset
operator|<
name|limit
condition|)
block|{
comment|// 孤立字符串如果是汉字数字，比如"五十二万"，"十三亿"，。。。
name|tempEnd
operator|=
name|collectNumber
argument_list|(
name|collector
argument_list|,
name|beef
argument_list|,
name|curSearchOffset
argument_list|,
name|limit
argument_list|,
name|binOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|tempEnd
operator|>
name|curSearchOffset
condition|)
block|{
name|curSearchOffset
operator|=
name|tempEnd
expr_stmt|;
name|binOffset
operator|=
name|tempEnd
expr_stmt|;
continue|continue;
block|}
comment|// 魔幻逻辑：
comment|// noiseWords的词在语言学上虽然也是词，但CJKKnife不会把它当成词汇表中的正常词，
comment|// 有些noise词可能没有出现词汇表，则就会被视为孤立字符串在此处理(不被视为词汇、不进行二元分词)
name|tempEnd
operator|=
name|skipNoiseWords
argument_list|(
name|collector
argument_list|,
name|beef
argument_list|,
name|curSearchOffset
argument_list|,
name|limit
argument_list|,
name|binOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|tempEnd
operator|>
name|curSearchOffset
condition|)
block|{
name|curSearchOffset
operator|=
name|tempEnd
expr_stmt|;
name|binOffset
operator|=
name|tempEnd
expr_stmt|;
continue|continue;
block|}
comment|// 如果当前字符是noise单字，其不参加二元分词
name|Hit
name|curSearch
init|=
name|noiseCharactors
operator|.
name|search
argument_list|(
name|beef
argument_list|,
name|curSearchOffset
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|curSearch
operator|.
name|isHit
argument_list|()
condition|)
block|{
name|binDissect
argument_list|(
name|collector
argument_list|,
name|beef
argument_list|,
name|binOffset
argument_list|,
name|curSearchOffset
argument_list|)
expr_stmt|;
name|binOffset
operator|=
operator|++
name|curSearchOffset
expr_stmt|;
continue|continue;
block|}
name|curSearchOffset
operator|++
expr_stmt|;
block|}
comment|//
if|if
condition|(
name|limit
operator|>
name|binOffset
condition|)
block|{
name|binDissect
argument_list|(
name|collector
argument_list|,
name|beef
argument_list|,
name|binOffset
argument_list|,
name|limit
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|int
name|collectNumber
parameter_list|(
name|Collector
name|collector
parameter_list|,
name|Beef
name|beef
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|limit
parameter_list|,
name|int
name|binOffset
parameter_list|)
block|{
comment|/* 		 * Fix : "百二十回" => 1020 		 */
comment|// 当前尝试判断的字符的位置
name|int
name|curTail
init|=
name|offset
decl_stmt|;
name|int
name|number1
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|number2
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|bitValue
init|=
literal|0
decl_stmt|;
name|int
name|minUnit
init|=
literal|0
decl_stmt|;
name|int
name|number2Start
init|=
name|curTail
decl_stmt|;
name|boolean
name|hasDigit
init|=
literal|false
decl_stmt|;
comment|// 作用：去除没有数字只有单位的汉字，如“万”，“千”
for|for
control|(
init|;
name|curTail
operator|<
name|limit
operator|&&
operator|(
name|bitValue
operator|=
name|CharSet
operator|.
name|toNumber
argument_list|(
name|beef
operator|.
name|charAt
argument_list|(
name|curTail
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
condition|;
name|curTail
operator|++
control|)
block|{
comment|//
if|if
condition|(
name|bitValue
operator|==
literal|2
operator|&&
operator|(
name|beef
operator|.
name|charAt
argument_list|(
name|curTail
argument_list|)
operator|==
literal|'两'
operator|||
name|beef
operator|.
name|charAt
argument_list|(
name|curTail
argument_list|)
operator|==
literal|'俩'
operator|||
name|beef
operator|.
name|charAt
argument_list|(
name|curTail
argument_list|)
operator|==
literal|'倆'
operator|)
condition|)
block|{
if|if
condition|(
name|curTail
operator|!=
name|offset
condition|)
block|{
break|break;
block|}
block|}
comment|// 处理连续汉字个位值的数字："三四五六" ->"3456"
if|if
condition|(
name|bitValue
operator|>=
literal|0
operator|&&
name|bitValue
operator|<
literal|10
condition|)
block|{
name|hasDigit
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|number2
operator|<
literal|0
condition|)
block|{
name|number2
operator|=
name|bitValue
expr_stmt|;
name|number2Start
operator|=
name|curTail
expr_stmt|;
block|}
else|else
block|{
name|number2
operator|*=
literal|10
expr_stmt|;
name|number2
operator|+=
name|bitValue
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|number2
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|number1
operator|<
literal|0
condition|)
block|{
name|number1
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|//"一百十" => "一百" "十"
break|break;
block|}
if|if
condition|(
name|bitValue
operator|>=
name|minUnit
condition|)
block|{
if|if
condition|(
name|minUnit
operator|==
literal|0
condition|)
block|{
name|number1
operator|*=
name|bitValue
expr_stmt|;
name|minUnit
operator|=
name|bitValue
expr_stmt|;
block|}
else|else
block|{
comment|//"一千二百三十百" => "一千二百三十" "百"
break|break;
block|}
block|}
else|else
block|{
name|minUnit
operator|=
name|bitValue
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|number1
operator|<
literal|0
condition|)
block|{
name|number1
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bitValue
operator|>=
name|minUnit
condition|)
block|{
if|if
condition|(
name|minUnit
operator|==
literal|0
condition|)
block|{
name|number1
operator|+=
name|number2
expr_stmt|;
name|number1
operator|*=
name|bitValue
expr_stmt|;
name|minUnit
operator|=
name|bitValue
expr_stmt|;
block|}
else|else
block|{
comment|//"一百二千" => "一百" "二千"
name|curTail
operator|=
name|number2Start
expr_stmt|;
name|number2
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|minUnit
operator|=
name|bitValue
expr_stmt|;
name|number1
operator|+=
name|number2
operator|*
name|bitValue
expr_stmt|;
block|}
block|}
name|number2
operator|=
operator|-
literal|1
expr_stmt|;
name|number2Start
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|hasDigit
condition|)
block|{
return|return
name|offset
return|;
block|}
if|if
condition|(
name|number2
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|number1
operator|<
literal|0
condition|)
block|{
name|number1
operator|=
name|number2
expr_stmt|;
block|}
else|else
block|{
name|number1
operator|+=
name|number2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|number1
operator|>=
literal|0
condition|)
block|{
comment|// 二元分词先
if|if
condition|(
name|offset
operator|>
name|binOffset
condition|)
block|{
name|binDissect
argument_list|(
name|collector
argument_list|,
name|beef
argument_list|,
name|binOffset
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
name|collector
operator|.
name|collect
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|number1
argument_list|)
argument_list|,
name|offset
argument_list|,
name|curTail
argument_list|)
expr_stmt|;
if|if
condition|(
name|units
operator|!=
literal|null
condition|)
block|{
comment|// 后面可能跟了计量单位
name|Hit
name|wd
init|=
literal|null
decl_stmt|;
name|Hit
name|wd2
init|=
literal|null
decl_stmt|;
name|int
name|i
init|=
name|curTail
operator|+
literal|1
decl_stmt|;
comment|/* 				 * Fix issue 48: 查找计量单位引起的高亮越界错误 				 */
while|while
condition|(
name|i
operator|<=
name|limit
operator|&&
operator|(
name|wd
operator|=
name|units
operator|.
name|search
argument_list|(
name|beef
argument_list|,
name|curTail
argument_list|,
name|i
operator|-
name|curTail
argument_list|)
operator|)
operator|.
name|isHit
argument_list|()
condition|)
block|{
name|wd2
operator|=
name|wd
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|wd
operator|.
name|isUnclosed
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|wd2
operator|!=
literal|null
condition|)
block|{
name|collector
operator|.
name|collect
argument_list|(
name|wd2
operator|.
name|getWord
argument_list|()
operator|.
name|getText
argument_list|()
argument_list|,
name|curTail
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
block|}
comment|// 返回最后一个判断失败字符的结束位置：
comment|// 该位置要么是offset，要么表示curTail之前的字符(不包括curTail字符)已经被认为是汉字数字
return|return
name|curTail
return|;
block|}
specifier|protected
name|int
name|skipNoiseWords
parameter_list|(
name|Collector
name|collector
parameter_list|,
name|Beef
name|beef
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|end
parameter_list|,
name|int
name|binOffset
parameter_list|)
block|{
name|Hit
name|word
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
name|offset
operator|+
literal|2
init|;
name|k
operator|<=
name|end
condition|;
name|k
operator|++
control|)
block|{
name|word
operator|=
name|noiseWords
operator|.
name|search
argument_list|(
name|beef
argument_list|,
name|offset
argument_list|,
name|k
operator|-
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|word
operator|.
name|isHit
argument_list|()
condition|)
block|{
comment|// 二元分词
if|if
condition|(
name|binOffset
operator|>
literal|0
operator|&&
name|offset
operator|>
name|binOffset
condition|)
block|{
name|binDissect
argument_list|(
name|collector
argument_list|,
name|beef
argument_list|,
name|binOffset
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|binOffset
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|offset
operator|=
name|k
expr_stmt|;
block|}
if|if
condition|(
name|word
operator|.
name|isUndefined
argument_list|()
operator|||
operator|!
name|word
operator|.
name|isUnclosed
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
return|return
name|offset
return|;
block|}
specifier|protected
name|void
name|binDissect
parameter_list|(
name|Collector
name|collector
parameter_list|,
name|Beef
name|beef
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
comment|// 二元分词之策略：以W、X、Y、Z表示孤立字符串中的4个汉字
comment|// X ->X 单个字的孤立字符串作为一个词
comment|// XY ->XY 只有两个字的孤立字符串作为一个词
comment|// XYZ ->XY/YZ 多个字(>=3)的孤立字符串"两两组合"作为一个词
comment|// WXYZ ->WX/XY/YZ 同上
if|if
condition|(
name|limit
operator|-
name|offset
operator|==
literal|1
condition|)
block|{
name|collector
operator|.
name|collect
argument_list|(
name|beef
operator|.
name|subSequence
argument_list|(
name|offset
argument_list|,
name|limit
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|offset
argument_list|,
name|limit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// 穷尽二元分词
for|for
control|(
name|int
name|curOffset
init|=
name|offset
init|;
name|curOffset
operator|<
name|limit
operator|-
literal|1
condition|;
name|curOffset
operator|++
control|)
block|{
name|collector
operator|.
name|collect
argument_list|(
name|beef
operator|.
name|subSequence
argument_list|(
name|curOffset
argument_list|,
name|curOffset
operator|+
literal|2
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|curOffset
argument_list|,
name|curOffset
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|protected
name|boolean
name|shouldBeWord
parameter_list|(
name|Beef
name|beef
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|char
name|prevChar
init|=
name|beef
operator|.
name|charAt
argument_list|(
name|offset
operator|-
literal|1
argument_list|)
decl_stmt|;
name|char
name|endChar
init|=
name|beef
operator|.
name|charAt
argument_list|(
name|end
argument_list|)
decl_stmt|;
comment|// 中文单双引号
if|if
condition|(
name|prevChar
operator|==
literal|'“'
operator|&&
name|endChar
operator|==
literal|'”'
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|prevChar
operator|==
literal|'‘'
operator|&&
name|endChar
operator|==
literal|'’'
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// 英文单双引号
elseif|else
if|if
condition|(
name|prevChar
operator|==
literal|'\''
operator|&&
name|endChar
operator|==
literal|'\''
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|prevChar
operator|==
literal|'\"'
operator|&&
name|endChar
operator|==
literal|'\"'
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// 中文书名号
elseif|else
if|if
condition|(
name|prevChar
operator|==
literal|'《'
operator|&&
name|endChar
operator|==
literal|'》'
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|prevChar
operator|==
literal|'〈'
operator|&&
name|endChar
operator|==
literal|'〉'
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// 英文尖括号
elseif|else
if|if
condition|(
name|prevChar
operator|==
literal|'<'
operator|&&
name|endChar
operator|==
literal|'>'
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
end_class

end_unit

