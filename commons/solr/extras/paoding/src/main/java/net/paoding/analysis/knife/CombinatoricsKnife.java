begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright 2007 The Apache Software Foundation  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|net
operator|.
name|paoding
operator|.
name|analysis
operator|.
name|knife
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|net
operator|.
name|paoding
operator|.
name|analysis
operator|.
name|dictionary
operator|.
name|Dictionary
import|;
end_import

begin_import
import|import
name|net
operator|.
name|paoding
operator|.
name|analysis
operator|.
name|dictionary
operator|.
name|Hit
import|;
end_import

begin_comment
comment|/**  * 排列组合Knife。  *<p>  *   * 该Knife把遇到的非LIMIT字符视为一个单词分出。<br>  * 同时如果有以该词语开头的字符串在x-for-combinatorics.dic出现也会切出  *   * @author Zhiliang Wang [qieqie.wang@gmail.com]  *   * @since 1.0  *   */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|CombinatoricsKnife
implements|implements
name|Knife
implements|,
name|DictionariesWare
block|{
specifier|protected
name|Dictionary
name|combinatoricsDictionary
decl_stmt|;
specifier|protected
name|HashSet
comment|/*<String> */
name|noiseTable
decl_stmt|;
specifier|public
name|CombinatoricsKnife
parameter_list|()
block|{ 	}
specifier|public
name|CombinatoricsKnife
parameter_list|(
name|String
index|[]
name|noiseWords
parameter_list|)
block|{
name|setNoiseWords
argument_list|(
name|noiseWords
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setNoiseWords
parameter_list|(
name|String
index|[]
name|noiseWords
parameter_list|)
block|{
name|noiseTable
operator|=
operator|new
name|HashSet
comment|/*<String> */
argument_list|(
call|(
name|int
call|)
argument_list|(
name|noiseWords
operator|.
name|length
operator|*
literal|1.5
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|noiseWords
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|noiseTable
operator|.
name|add
argument_list|(
name|noiseWords
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|setDictionaries
parameter_list|(
name|Dictionaries
name|dictionaries
parameter_list|)
block|{
name|combinatoricsDictionary
operator|=
name|dictionaries
operator|.
name|getCombinatoricsDictionary
argument_list|()
expr_stmt|;
block|}
specifier|public
name|int
name|dissect
parameter_list|(
name|Collector
name|collector
parameter_list|,
name|Beef
name|beef
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
comment|// 当point == -1时表示本次分解没有遇到POINT性质的字符；
comment|// 如果point != -1，该值表示POINT性质字符的开始位置，
comment|// 这个位置将被返回，下一个Knife将从point位置开始分词
name|int
name|point
init|=
operator|-
literal|1
decl_stmt|;
comment|// 记录同质字符分词结束极限位置(不包括limit位置的字符)-也就是assignable方法遇到LIMIT性质的字符的位置
comment|// 如果point==-1，limit将被返回，下一个Knife将从limit位置开始尝试分词
name|int
name|limit
init|=
name|offset
operator|+
literal|1
decl_stmt|;
comment|// 构建point和limit变量的值:
comment|// 往前直到遇到LIMIT字符；
comment|// 其中如果遇到第一次POINT字符，则会将它记录为point
name|GO_UNTIL_LIMIT
label|:
while|while
condition|(
literal|true
condition|)
block|{
switch|switch
condition|(
name|assignable
argument_list|(
name|beef
argument_list|,
name|offset
argument_list|,
name|limit
argument_list|)
condition|)
block|{
case|case
name|LIMIT
case|:
break|break
name|GO_UNTIL_LIMIT
break|;
case|case
name|POINT
case|:
if|if
condition|(
name|point
operator|==
operator|-
literal|1
condition|)
block|{
name|point
operator|=
name|limit
expr_stmt|;
block|}
block|}
name|limit
operator|++
expr_stmt|;
block|}
comment|// 如果最后一个字符也是ASSIGNED以及POINT，
comment|// 且beef之前已经被分解了一部分(从而能够腾出空间以读入新的字符)，则需要重新读入字符后再分词
if|if
condition|(
name|limit
operator|==
name|beef
operator|.
name|length
argument_list|()
operator|&&
name|offset
operator|>
literal|0
condition|)
block|{
return|return
operator|-
name|offset
return|;
block|}
comment|// 检索是否有以该词语位前缀的词典词语
comment|// 若有，则将它解出
name|int
name|dicWordVote
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|combinatoricsDictionary
operator|!=
literal|null
operator|&&
name|beef
operator|.
name|charAt
argument_list|(
name|limit
argument_list|)
operator|>
literal|0xFF
condition|)
block|{
name|dicWordVote
operator|=
name|tryDicWord
argument_list|(
name|collector
argument_list|,
name|beef
argument_list|,
name|offset
argument_list|,
name|limit
argument_list|)
expr_stmt|;
block|}
comment|// 收集从offset分别到point以及limit的词
comment|// 注意这里不收集从point到limit的词
comment|// ->当然可能从point到limit的字符也可能是一个词，不过这不是本次分解的责任
comment|// ->如果认为它应该是个词，那么只要配置对应的其它Knife实例，该Knife会有机会把它切出来的
comment|// ->因为我们会返回point作为下一个Knife分词的开始。
name|int
name|pointVote
init|=
name|collectPoint
argument_list|(
name|collector
argument_list|,
name|beef
argument_list|,
name|offset
argument_list|,
name|point
argument_list|,
name|limit
argument_list|,
name|dicWordVote
argument_list|)
decl_stmt|;
name|int
name|limitVote
init|=
name|collectLimit
argument_list|(
name|collector
argument_list|,
name|beef
argument_list|,
name|offset
argument_list|,
name|point
argument_list|,
name|limit
argument_list|,
name|dicWordVote
argument_list|)
decl_stmt|;
return|return
name|nextOffset
argument_list|(
name|beef
argument_list|,
name|offset
argument_list|,
name|point
argument_list|,
name|limit
argument_list|,
name|pointVote
argument_list|,
name|limitVote
argument_list|,
name|dicWordVote
argument_list|)
return|;
block|}
comment|/** 	 * 通知收集从offset到第一个LIMIT字符的词，并投票下一个Knife开始的分词位置。如果不存在POINT字符，则Point的值为-1。 	 *<p> 	 *  	 * 默认方法实现：如果不存在POINT性质的字符，则直接返回不做任何切词处理。 	 *  	 * @param collector 	 * @param beef 	 * @param offset 	 *            本次分解的内容在beef中的开始位置 	 * @param point 	 *            本次分解的内容的第一个POINT性质字符的位置，-1表示不存在该性质的字符 	 * @param limit 	 *            本次分解的内容的LIMIT性质字符 	 * @return 投票下一个Knife开始分词的位置；-1表示弃权。默认方法实现：弃权。 	 */
specifier|protected
name|int
name|collectPoint
parameter_list|(
name|Collector
name|collector
parameter_list|,
name|Beef
name|beef
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|point
parameter_list|,
name|int
name|limit
parameter_list|,
name|int
name|dicWordVote
parameter_list|)
block|{
if|if
condition|(
name|point
operator|!=
operator|-
literal|1
operator|&&
name|dicWordVote
operator|==
operator|-
literal|1
condition|)
block|{
name|collectIfNotNoise
argument_list|(
name|collector
argument_list|,
name|beef
argument_list|,
name|offset
argument_list|,
name|point
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/** 	 * 通知收集从offset到第一个LIMIT字符的词，并投票下一个Knife开始的分词位置。 	 *<p> 	 *  	 * 默认方法实现：把从offset位置到limit位置止(不包含边界)的字符串视为一个词切出。 	 *  	 * @param collector 	 * @param beef 	 * @param offset 	 *            本次分解的内容在beef中的开始位置 	 * @param point 	 *            本次分解的内容的第一个POINT性质字符的位置，-1表示不存在该性质的字符 	 * @param limit 	 *            本次分解的内容的LIMIT性质字符 	 *  	 * @param dicWordVote  	 *  	 * @return 投票下一个Knife开始分词的位置；-1表示弃权。默认方法实现：弃权。 	 */
specifier|protected
name|int
name|collectLimit
parameter_list|(
name|Collector
name|collector
parameter_list|,
name|Beef
name|beef
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|point
parameter_list|,
name|int
name|limit
parameter_list|,
name|int
name|dicWordVote
parameter_list|)
block|{
if|if
condition|(
name|dicWordVote
operator|==
operator|-
literal|1
condition|)
block|{
name|collectIfNotNoise
argument_list|(
name|collector
argument_list|,
name|beef
argument_list|,
name|offset
argument_list|,
name|limit
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/** 	 * 尝试从combinatorics字典中检索，如果存在以offset到limit位置止(不包含limit边界)字符串开始的词语，则切出该词语。 	 *<p> 	 * 如没有检索到这样的词语，则本方法返回-1弃权投票下一个Knife的开始分解位置。<br> 	 * 如果检索到这样的词语，在切出在词语的同时，投票返回这个词语的结束位置(词语本身不包含该结束位置的字符) 	 *<p> 	 *  	 * (for version 2.0.4+):<br> 	 * 本方法目前存在的局限：<br> 	 * 如果字典中的某个词语刚好分隔在两次beef之中，比如"U"刚好是此次beef的最后字符，而"盘"是下一次beef的第一个字符，<br> 	 * 这种情况现在 {@link CombinatoricsKnife}还没机制办法识别将之处理为一个词语 	 *  	 * @param collector 	 * @param beef 	 * @param offset 	 * @param limit 	 * @return 	 */
specifier|protected
name|int
name|tryDicWord
parameter_list|(
name|Collector
name|collector
parameter_list|,
name|Beef
name|beef
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|int
name|ret
init|=
name|limit
decl_stmt|;
for|for
control|(
name|int
name|end
init|=
name|limit
operator|+
literal|1
init|,
name|count
init|=
name|limit
operator|-
name|offset
operator|+
literal|1
init|;
name|end
operator|<=
name|beef
operator|.
name|length
argument_list|()
condition|;
name|end
operator|++
operator|,
name|count
operator|++
control|)
block|{
name|Hit
name|hit
init|=
name|combinatoricsDictionary
operator|.
name|search
argument_list|(
name|beef
argument_list|,
name|offset
argument_list|,
name|count
argument_list|)
decl_stmt|;
if|if
condition|(
name|hit
operator|.
name|isUndefined
argument_list|()
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|hit
operator|.
name|isHit
argument_list|()
condition|)
block|{
name|collectIfNotNoise
argument_list|(
name|collector
argument_list|,
name|beef
argument_list|,
name|offset
argument_list|,
name|end
argument_list|)
expr_stmt|;
comment|// 收到词语，将ret设置为该词语的end
name|ret
operator|=
name|end
expr_stmt|;
block|}
comment|// gotoNextChar为true表示在词典中存在以当前词为开头的词，
name|boolean
name|gotoNextChar
init|=
name|hit
operator|.
name|isUnclosed
argument_list|()
operator|&&
name|end
operator|<
name|beef
operator|.
name|length
argument_list|()
operator|&&
name|beef
operator|.
name|charAt
argument_list|(
name|end
argument_list|)
operator|>=
name|hit
operator|.
name|getNext
argument_list|()
operator|.
name|charAt
argument_list|(
name|count
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|gotoNextChar
condition|)
block|{
break|break;
block|}
block|}
return|return
name|ret
operator|<=
name|limit
condition|?
operator|-
literal|1
else|:
name|ret
return|;
comment|// TODO:
comment|// 存在的局限:
comment|// 刚好词语分隔在两次beef之中，比如"U"刚好是此次beef的最后字符，而"盘"是下一次beef的第一个字符
comment|// 这种情况现在CombinatoricsKnife还没机制办法识别将之处理为一个词语
block|}
comment|/** 	 * 当Knife决定切出从offset始到end位置止(不包含结束位置的字符)的词语时，本方法能够过滤掉可能是noise的词，使最终不切出。 	 *  	 * @param collector 	 * @param beef 	 * @param offset 	 * @param end 	 */
specifier|protected
name|void
name|collectIfNotNoise
parameter_list|(
name|Collector
name|collector
parameter_list|,
name|Beef
name|beef
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|end
parameter_list|)
block|{
comment|// 将offset和end之间的词(不包含end位置)创建出来给word
comment|// 如果该词语为噪音词，则重新丢弃之(设置为null)，
name|String
name|word
init|=
name|beef
operator|.
name|subSequence
argument_list|(
name|offset
argument_list|,
name|end
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|noiseTable
operator|!=
literal|null
operator|&&
name|noiseTable
operator|.
name|contains
argument_list|(
name|word
argument_list|)
condition|)
block|{
name|word
operator|=
literal|null
expr_stmt|;
block|}
comment|// 否则发送消息给collect方法，表示Knife新鲜出炉了一个内容为word的候选词语
comment|// 即：最终决定是否要把这个词语通知给collector的是collect方法
if|if
condition|(
name|word
operator|!=
literal|null
condition|)
block|{
name|doCollect
argument_list|(
name|collector
argument_list|,
name|word
argument_list|,
name|beef
argument_list|,
name|offset
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** 	 *  	 * 当Knife决定切出从offset始到end位置止(不包含结束位置的字符)的词语时，本方法直接调用{@link #doCollect(Collector, String, Beef, int, int)}切出词语(而不过滤noise词汇) 	 *  	 * @param collector 	 * @param beef 	 * @param offset 	 * @param end 	 */
specifier|protected
name|void
name|collect
parameter_list|(
name|Collector
name|collector
parameter_list|,
name|Beef
name|beef
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|String
name|word
init|=
name|beef
operator|.
name|subSequence
argument_list|(
name|offset
argument_list|,
name|end
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|doCollect
argument_list|(
name|collector
argument_list|,
name|word
argument_list|,
name|beef
argument_list|,
name|offset
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * 收集分解出的候选词语。 默认实现是将该候选词语通知给收集器collector。<br> 	 * 子类覆盖本方法可以更灵活地控制词语的收录，例如控制仅当word满足一些额外条件再决定是否收集，<br> 	 * 或依上下文环境收集更多的相关词语 	 *  	 * @param collector 	 * @param word 	 * @param beef 	 * @param offset 	 * @param end 	 */
specifier|protected
name|void
name|doCollect
parameter_list|(
name|Collector
name|collector
parameter_list|,
name|String
name|word
parameter_list|,
name|Beef
name|beef
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|collector
operator|.
name|collect
argument_list|(
name|word
argument_list|,
name|offset
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * 根据字符串性质位置，以及分词结果投票，决出下一个Knife应该从哪一个位置开始探测切词 	 *  	 * @param beef 	 * @param offset 	 *            本次分词的开始位置 	 * @param point 	 *            本次分词的第一个POINT性质的字符位置，-1表示没有该性质的字符 	 * @param limit 	 *            本次分词的第一个LIMIT性质的字符位置 	 * @param pointVote 	 *            收集从offset到第一个POINT性质字符词汇时的投票，-1表示弃权 	 * @param limitVote 	 *            收集从offset到第一个LIMIT性质字符词汇时的投票，-1表示弃权 	 * @param dicWordVote 	 *            收集combinatorics词典词语时的投票，-1表示弃权 	 * @return 	 */
specifier|protected
name|int
name|nextOffset
parameter_list|(
name|Beef
name|beef
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|point
parameter_list|,
name|int
name|limit
parameter_list|,
name|int
name|pointVote
parameter_list|,
name|int
name|limitVote
parameter_list|,
name|int
name|dicWordVote
parameter_list|)
block|{
name|int
name|max
init|=
name|pointVote
operator|>
name|limitVote
condition|?
name|pointVote
else|:
name|limitVote
decl_stmt|;
name|max
operator|=
name|max
operator|>
name|dicWordVote
condition|?
name|max
else|:
name|dicWordVote
expr_stmt|;
if|if
condition|(
name|max
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|point
operator|!=
operator|-
literal|1
condition|?
name|point
else|:
name|limit
return|;
block|}
elseif|else
if|if
condition|(
name|max
operator|>
name|limit
condition|)
block|{
return|return
name|max
return|;
block|}
else|else
block|{
return|return
name|limit
return|;
block|}
block|}
block|}
end_class

end_unit

