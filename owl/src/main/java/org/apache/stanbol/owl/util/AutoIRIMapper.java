begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|owl
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|StringTokenizer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|GZIPInputStream
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|ParserConfigurationException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|SAXParser
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|SAXParserFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|ArchiveEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|ArchiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|ArchiveInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|ArchiveStreamFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|tar
operator|.
name|TarArchiveInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|zip
operator|.
name|ZipArchiveInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|compressors
operator|.
name|bzip2
operator|.
name|BZip2CompressorInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|FilenameUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|IRI
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLOntologyIRIMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|model
operator|.
name|OWLRuntimeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|vocab
operator|.
name|Namespaces
import|;
end_import

begin_import
import|import
name|org
operator|.
name|semanticweb
operator|.
name|owlapi
operator|.
name|vocab
operator|.
name|OWLXMLVocabulary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|Attributes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|SAXException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|helpers
operator|.
name|DefaultHandler
import|;
end_import

begin_comment
comment|/**  * Author: Matthew Horridge<br>  * The University Of Manchester<br>  * Bio-Health Informatics Group<br>  * Date: 26-Apr-2007<br>  *<br>  *<p/>  * A mapper which given a root folder attempts to automatically discover and map files to ontologies. The  * mapper is only capable of mapping ontologies in RDF/XML and OWL/XML (other serialisations are not  * supported).  */
end_comment

begin_class
specifier|public
class|class
name|AutoIRIMapper
extends|extends
name|DefaultHandler
implements|implements
name|OWLOntologyIRIMapper
block|{
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|fileExtensions
decl_stmt|;
specifier|private
name|File
name|root
decl_stmt|;
specifier|private
name|boolean
name|mapped
decl_stmt|;
specifier|private
name|boolean
name|recursive
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|OntologyRootElementHandler
argument_list|>
name|handlerMap
decl_stmt|;
specifier|private
name|File
name|currentFile
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|IRI
argument_list|,
name|IRI
argument_list|>
name|ontologyIRI2PhysicalURIMap
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|IRI
argument_list|>
name|oboFileMap
decl_stmt|;
specifier|private
name|SAXParserFactory
name|parserFactory
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
index|[]
name|DEFAULT_EXTENSIONS
init|=
operator|new
name|String
index|[]
block|{
literal|"owl"
block|,
literal|"xml"
block|,
literal|"rdf"
block|,
literal|"omn"
block|}
decl_stmt|;
specifier|public
name|AutoIRIMapper
parameter_list|(
name|File
name|rootDirectory
parameter_list|,
name|boolean
name|recursive
parameter_list|)
block|{
name|this
argument_list|(
name|rootDirectory
argument_list|,
name|DEFAULT_EXTENSIONS
argument_list|,
name|recursive
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates an auto-mapper which examines ontologies that reside in the specified root folder (and possibly      * sub-folders).      *       * @param rootDirectory      *            The root directory which should be searched for ontologies.      * @param recursive      *            Sub directories will be searched recursively if<code>true</code>.      */
specifier|public
name|AutoIRIMapper
parameter_list|(
name|File
name|rootDirectory
parameter_list|,
name|String
index|[]
name|fileExts
parameter_list|,
name|boolean
name|recursive
parameter_list|)
block|{
name|this
operator|.
name|root
operator|=
name|rootDirectory
expr_stmt|;
name|this
operator|.
name|recursive
operator|=
name|recursive
expr_stmt|;
name|ontologyIRI2PhysicalURIMap
operator|=
operator|new
name|HashMap
argument_list|<
name|IRI
argument_list|,
name|IRI
argument_list|>
argument_list|()
expr_stmt|;
name|oboFileMap
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|IRI
argument_list|>
argument_list|()
expr_stmt|;
name|fileExtensions
operator|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|String
name|ext
range|:
name|fileExts
control|)
name|fileExtensions
operator|.
name|add
argument_list|(
name|ext
argument_list|)
expr_stmt|;
name|mapped
operator|=
literal|false
expr_stmt|;
name|handlerMap
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|OntologyRootElementHandler
argument_list|>
argument_list|()
expr_stmt|;
name|handlerMap
operator|.
name|put
argument_list|(
name|Namespaces
operator|.
name|RDF
operator|+
literal|"RDF"
argument_list|,
operator|new
name|RDFXMLOntologyRootElementHandler
argument_list|()
argument_list|)
expr_stmt|;
name|handlerMap
operator|.
name|put
argument_list|(
name|OWLXMLVocabulary
operator|.
name|ONTOLOGY
operator|.
name|toString
argument_list|()
argument_list|,
operator|new
name|OWLXMLOntologyRootElementHandler
argument_list|()
argument_list|)
expr_stmt|;
name|parserFactory
operator|=
name|SAXParserFactory
operator|.
name|newInstance
argument_list|()
expr_stmt|;
name|parserFactory
operator|.
name|setNamespaceAware
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**      * The mapper only examines files that have specified file extensions. This method returns the file      * extensions that cause a file to be examined.      *       * @return A<code>Set</code> of file extensions.      */
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getFileExtensions
parameter_list|()
block|{
return|return
name|fileExtensions
return|;
block|}
comment|/**      * Sets the extensions of files that are to be examined for ontological content. (By default the      * extensions are, owl, xml and rdf). Only files that have the specified extensions will be examined to      * see if they contain ontologies.      */
specifier|public
name|void
name|setFileExtensions
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|extensions
parameter_list|)
block|{
name|this
operator|.
name|fileExtensions
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|fileExtensions
operator|.
name|addAll
argument_list|(
name|extensions
argument_list|)
expr_stmt|;
block|}
comment|/**      * Gets the set of ontology IRIs that this mapper has found      *       * @return A<code>Set</code> of ontology (logical) URIs      */
specifier|public
name|Set
argument_list|<
name|IRI
argument_list|>
name|getOntologyIRIs
parameter_list|()
block|{
if|if
condition|(
operator|!
name|mapped
condition|)
block|{
name|mapFiles
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|HashSet
argument_list|<
name|IRI
argument_list|>
argument_list|(
name|ontologyIRI2PhysicalURIMap
operator|.
name|keySet
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|void
name|update
parameter_list|()
block|{
name|mapFiles
argument_list|()
expr_stmt|;
block|}
specifier|public
name|IRI
name|getDocumentIRI
parameter_list|(
name|IRI
name|ontologyIRI
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mapped
condition|)
block|{
name|mapFiles
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ontologyIRI
operator|.
name|toString
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|".obo"
argument_list|)
condition|)
block|{
name|String
name|path
init|=
name|ontologyIRI
operator|.
name|toURI
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
if|if
condition|(
name|path
operator|!=
literal|null
condition|)
block|{
name|int
name|lastSepIndex
init|=
name|path
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
name|String
name|name
init|=
name|path
operator|.
name|substring
argument_list|(
name|lastSepIndex
operator|+
literal|1
argument_list|,
name|path
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|IRI
name|documentIRI
init|=
name|oboFileMap
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|documentIRI
operator|!=
literal|null
condition|)
block|{
return|return
name|documentIRI
return|;
block|}
block|}
block|}
return|return
name|ontologyIRI2PhysicalURIMap
operator|.
name|get
argument_list|(
name|ontologyIRI
argument_list|)
return|;
block|}
specifier|private
name|void
name|mapFiles
parameter_list|()
block|{
name|mapped
operator|=
literal|true
expr_stmt|;
name|ontologyIRI2PhysicalURIMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|processFile
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|processFile
parameter_list|(
name|File
name|f
parameter_list|)
block|{
if|if
condition|(
name|f
operator|.
name|isHidden
argument_list|()
condition|)
block|{
return|return;
block|}
name|File
index|[]
name|files
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|isDirectory
argument_list|()
condition|)
name|files
operator|=
name|f
operator|.
name|listFiles
argument_list|()
expr_stmt|;
else|else
block|{
try|try
block|{
name|ArchiveInputStream
name|ais
init|=
operator|new
name|ArchiveStreamFactory
argument_list|()
operator|.
name|createArchiveInputStream
argument_list|(
operator|new
name|BufferedInputStream
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|f
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|//getArchiveInputStream(f.getName(), new FileInputStream(f));
name|ArchiveEntry
name|entry
decl_stmt|;
while|while
condition|(
operator|(
name|entry
operator|=
name|ais
operator|.
name|getNextEntry
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
comment|// TODO Auto-generated catch block
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// TODO Auto-generated catch block
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArchiveException
name|e
parameter_list|)
block|{
comment|// TODO Auto-generated catch block
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|files
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|File
name|file
range|:
name|files
control|)
block|{
if|if
condition|(
name|file
operator|.
name|isDirectory
argument_list|()
operator|&&
name|recursive
condition|)
block|{
name|processFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// boolean parsedFile = false;
if|if
condition|(
name|file
operator|.
name|getName
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|".obo"
argument_list|)
condition|)
block|{
name|oboFileMap
operator|.
name|put
argument_list|(
name|file
operator|.
name|getName
argument_list|()
argument_list|,
name|IRI
operator|.
name|create
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|file
operator|.
name|getName
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|".omn"
argument_list|)
condition|)
block|{
name|parseManchesterSyntaxFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|String
name|ext
range|:
name|fileExtensions
control|)
block|{
if|if
condition|(
name|file
operator|.
name|getName
argument_list|()
operator|.
name|endsWith
argument_list|(
name|ext
argument_list|)
condition|)
block|{
name|parseFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|// parsedFile = true;
break|break;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
specifier|private
name|void
name|parseFile
parameter_list|(
name|File
name|file
parameter_list|)
block|{
try|try
block|{
name|InputStream
name|is
init|=
operator|new
name|BufferedInputStream
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|file
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|currentFile
operator|=
name|file
expr_stmt|;
name|SAXParser
name|parser
init|=
name|parserFactory
operator|.
name|newSAXParser
argument_list|()
decl_stmt|;
name|parser
operator|.
name|parse
argument_list|(
name|is
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ParserConfigurationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|OWLRuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|SAXException
name|e
parameter_list|)
block|{
comment|// We simply aren't interested in any parsing problems - if
comment|// we can't parse a file, then we can't map it and we don't
comment|// care!
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Again - these kinds of exceptions are of no interest to us!
block|}
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
comment|// Don't care?
block|}
block|}
specifier|private
name|void
name|parseManchesterSyntaxFile
parameter_list|(
name|File
name|file
parameter_list|)
block|{
name|BufferedReader
name|br
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// Ontology:<URI>
name|br
operator|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|file
argument_list|)
argument_list|,
literal|"UTF-8"
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|line
decl_stmt|;
name|IRI
name|ontologyIRI
init|=
literal|null
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|br
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|StringTokenizer
name|tokenizer
init|=
operator|new
name|StringTokenizer
argument_list|(
name|line
argument_list|,
literal|" \r\n"
argument_list|,
literal|false
argument_list|)
decl_stmt|;
while|while
condition|(
name|tokenizer
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|String
name|tok
init|=
name|tokenizer
operator|.
name|nextToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|tok
operator|.
name|startsWith
argument_list|(
literal|"<"
argument_list|)
operator|&&
name|tok
operator|.
name|endsWith
argument_list|(
literal|">"
argument_list|)
condition|)
block|{
name|ontologyIRI
operator|=
name|IRI
operator|.
name|create
argument_list|(
name|tok
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|tok
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ontologyIRI2PhysicalURIMap
operator|.
name|put
argument_list|(
name|ontologyIRI
argument_list|,
name|IRI
operator|.
name|create
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ontologyIRI
operator|!=
literal|null
condition|)
block|{
break|break;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Ignore - don't care
block|}
finally|finally
block|{
try|try
block|{
name|br
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e2
parameter_list|)
block|{
comment|// no operation
block|}
block|}
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
specifier|public
name|void
name|startElement
parameter_list|(
name|String
name|uri
parameter_list|,
name|String
name|localName
parameter_list|,
name|String
name|qName
parameter_list|,
name|Attributes
name|attributes
parameter_list|)
throws|throws
name|SAXException
block|{
name|OntologyRootElementHandler
name|handler
init|=
name|handlerMap
operator|.
name|get
argument_list|(
name|uri
operator|+
name|localName
argument_list|)
decl_stmt|;
if|if
condition|(
name|handler
operator|!=
literal|null
condition|)
block|{
name|IRI
name|ontologyIRI
init|=
name|handler
operator|.
name|handle
argument_list|(
name|attributes
argument_list|)
decl_stmt|;
if|if
condition|(
name|ontologyIRI
operator|!=
literal|null
condition|)
block|{
name|ontologyIRI2PhysicalURIMap
operator|.
name|put
argument_list|(
name|ontologyIRI
argument_list|,
name|IRI
operator|.
name|create
argument_list|(
name|currentFile
argument_list|)
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|SAXException
argument_list|()
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"AutoURIMapper: ("
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|ontologyIRI2PhysicalURIMap
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" ontologies)\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|IRI
name|iri
range|:
name|ontologyIRI2PhysicalURIMap
operator|.
name|keySet
argument_list|()
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|iri
operator|.
name|toQuotedString
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" -> "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|ontologyIRI2PhysicalURIMap
operator|.
name|get
argument_list|(
name|iri
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * A simple interface which extracts an ontology URI from a set of element attributes.      */
specifier|private
interface|interface
name|OntologyRootElementHandler
block|{
comment|/**          * Gets the ontology URI.          *           * @param attributes          *            The attributes which will be examined for the ontology URI.          * @return The ontology URI or<code>null</code> if no ontology URI could be found.          */
name|IRI
name|handle
parameter_list|(
name|Attributes
name|attributes
parameter_list|)
function_decl|;
block|}
comment|/**      * A handler to handle RDF/XML files. The xml:base (if present) is taken to be the ontology URI of the      * ontology document being parsed.      */
specifier|private
specifier|static
class|class
name|RDFXMLOntologyRootElementHandler
implements|implements
name|OntologyRootElementHandler
block|{
specifier|public
name|RDFXMLOntologyRootElementHandler
parameter_list|()
block|{          }
specifier|public
name|IRI
name|handle
parameter_list|(
name|Attributes
name|attributes
parameter_list|)
block|{
name|String
name|baseValue
init|=
name|attributes
operator|.
name|getValue
argument_list|(
name|Namespaces
operator|.
name|XML
operator|.
name|toString
argument_list|()
argument_list|,
literal|"base"
argument_list|)
decl_stmt|;
if|if
condition|(
name|baseValue
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|IRI
operator|.
name|create
argument_list|(
name|baseValue
argument_list|)
return|;
block|}
block|}
comment|/**      * A handler that can handle OWL/XML files.      */
specifier|private
specifier|static
class|class
name|OWLXMLOntologyRootElementHandler
implements|implements
name|OntologyRootElementHandler
block|{
specifier|public
name|OWLXMLOntologyRootElementHandler
parameter_list|()
block|{          }
specifier|public
name|IRI
name|handle
parameter_list|(
name|Attributes
name|attributes
parameter_list|)
block|{
name|String
name|ontURI
init|=
name|attributes
operator|.
name|getValue
argument_list|(
name|Namespaces
operator|.
name|OWL
operator|.
name|toString
argument_list|()
argument_list|,
literal|"ontologyIRI"
argument_list|)
decl_stmt|;
if|if
condition|(
name|ontURI
operator|==
literal|null
condition|)
block|{
name|ontURI
operator|=
name|attributes
operator|.
name|getValue
argument_list|(
name|Namespaces
operator|.
name|OWL
operator|.
name|toString
argument_list|()
argument_list|,
literal|"ontologyIRI"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ontURI
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|IRI
operator|.
name|create
argument_list|(
name|ontURI
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

