begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|sentiment
operator|.
name|summarize
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|NlpAnnotations
operator|.
name|PHRASE_ANNOTATION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|NlpAnnotations
operator|.
name|POS_ANNOTATION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|NlpAnnotations
operator|.
name|SENTIMENT_ANNOTATION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|EnhancementEngineHelper
operator|.
name|createTextEnhancement
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|DC_TYPE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|ENHANCER_END
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|ENHANCER_SELECTED_TEXT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|ENHANCER_SELECTION_CONTEXT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|ENHANCER_START
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|swing
operator|.
name|DebugGraphics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Language
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|LiteralFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|MGraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|UriRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|impl
operator|.
name|PlainLiteralImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|impl
operator|.
name|TripleImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Activate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Component
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|ConfigurationPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Deactivate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Property
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Service
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|NlpAnnotations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|model
operator|.
name|AnalysedText
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|model
operator|.
name|Section
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|model
operator|.
name|Sentence
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|model
operator|.
name|Span
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|model
operator|.
name|Span
operator|.
name|SpanTypeEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|model
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|model
operator|.
name|annotation
operator|.
name|Value
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|phrase
operator|.
name|PhraseTag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|pos
operator|.
name|LexicalCategory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|pos
operator|.
name|Pos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|pos
operator|.
name|PosTag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|utils
operator|.
name|NIFHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|utils
operator|.
name|NlpEngineHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|ContentItem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|EngineException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|EnhancementEngine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|ServiceProperties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|EnhancementEngineHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|impl
operator|.
name|AbstractEnhancementEngine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|NamespaceEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|framework
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|service
operator|.
name|cm
operator|.
name|ConfigurationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|service
operator|.
name|component
operator|.
name|ComponentContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * {@link EnhancementEngine} that summarizes {@link Token} level  * Sentiment tags for NounPhraces, Sentences and the whole  * Content.  * @author Rupert Westenthaler  *  */
end_comment

begin_class
annotation|@
name|Component
argument_list|(
name|immediate
operator|=
literal|true
argument_list|,
name|metatype
operator|=
literal|true
argument_list|,
name|policy
operator|=
name|ConfigurationPolicy
operator|.
name|OPTIONAL
argument_list|,
name|configurationFactory
operator|=
literal|true
argument_list|)
comment|//allow multiple instances to be configured
annotation|@
name|Service
annotation|@
name|Properties
argument_list|(
name|value
operator|=
block|{
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|EnhancementEngine
operator|.
name|PROPERTY_NAME
argument_list|,
name|value
operator|=
name|SentimentSummarizationEngine
operator|.
name|DEFAULT_ENGINE_NAME
argument_list|)
block|,
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|SentimentSummarizationEngine
operator|.
name|PROPERTY_DOCUMENT_SENTIMENT_STATE
argument_list|,
name|boolValue
operator|=
literal|true
argument_list|)
block|,
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|SentimentSummarizationEngine
operator|.
name|PROPERTY_SENTENCE_SENTIMENT_STATE
argument_list|,
name|boolValue
operator|=
literal|true
argument_list|)
block|,
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|SentimentSummarizationEngine
operator|.
name|PROPERTY_PHRASE_SENTIMENT_STATE
argument_list|,
name|boolValue
operator|=
literal|true
argument_list|)
block|,
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|Constants
operator|.
name|SERVICE_RANKING
argument_list|,
name|intValue
operator|=
operator|-
literal|100
argument_list|)
comment|//give the default instance a ranking< 0
block|}
argument_list|)
specifier|public
class|class
name|SentimentSummarizationEngine
extends|extends
name|AbstractEnhancementEngine
argument_list|<
name|RuntimeException
argument_list|,
name|RuntimeException
argument_list|>
implements|implements
name|ServiceProperties
block|{
specifier|public
specifier|static
specifier|final
name|String
name|PROPERTY_PHRASE_SENTIMENT_STATE
init|=
literal|"enhancer.engine.sentiment.summarization.phraseSentimentState"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_PHRASE_SENTIMENT_STATE
init|=
literal|true
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|PROPERTY_SENTENCE_SENTIMENT_STATE
init|=
literal|"enhancer.engine.sentiment.summarization.sentenceSentimentState"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_SENTENCE_SENTIMENT_STATE
init|=
literal|true
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|PROPERTY_DOCUMENT_SENTIMENT_STATE
init|=
literal|"enhancer.engine.sentiment.summarization.documentSentimentState"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_DOCUMENT_SENTIMENT_STATE
init|=
literal|true
decl_stmt|;
comment|//    public static final String PROPERTY_NOUN_CONTEXT_SIZE = "enhancer.engine.sentiment.summarization.nounContextSize";
specifier|private
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|getClass
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|EnumSet
argument_list|<
name|Pos
argument_list|>
name|DEFAULT_SECTION_BORDER_TAGS
init|=
name|EnumSet
operator|.
name|of
argument_list|(
name|Pos
operator|.
name|SentenceMedialPunctuation
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|EnumSet
argument_list|<
name|Pos
argument_list|>
name|DEFAULT_NEGATION_TAGS
init|=
name|EnumSet
operator|.
name|of
argument_list|(
name|Pos
operator|.
name|NegativeAdverb
argument_list|,
name|Pos
operator|.
name|NegativeDeterminer
argument_list|,
name|Pos
operator|.
name|NegativeParticle
argument_list|,
name|Pos
operator|.
name|NegativePronoun
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|EnumSet
argument_list|<
name|LexicalCategory
argument_list|>
name|DEFAULT_COUNT_LEXICAL_CATEGORIES
init|=
name|EnumSet
operator|.
name|of
argument_list|(
name|LexicalCategory
operator|.
name|Noun
argument_list|,
name|LexicalCategory
operator|.
name|Verb
argument_list|,
name|LexicalCategory
operator|.
name|Adjective
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Double
name|ZERO
init|=
name|Double
operator|.
name|valueOf
argument_list|(
literal|0.0
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_ENGINE_NAME
init|=
literal|"sentiment-summarization"
decl_stmt|;
comment|//TODO: change this to a real sentiment ontology
comment|/**      * The property used to write the sum of all positive classified words      */
specifier|public
specifier|static
specifier|final
name|UriRef
name|POSITIVE_SENTIMENT_PROPERTY
init|=
operator|new
name|UriRef
argument_list|(
name|NamespaceEnum
operator|.
name|fise
operator|+
literal|"positive-sentiment"
argument_list|)
decl_stmt|;
comment|/**      * The property used to write the sum of all negative classified words      */
specifier|public
specifier|static
specifier|final
name|UriRef
name|NEGATIVE_SENTIMENT_PROPERTY
init|=
operator|new
name|UriRef
argument_list|(
name|NamespaceEnum
operator|.
name|fise
operator|+
literal|"negative-sentiment"
argument_list|)
decl_stmt|;
comment|/**      * The sentiment of the section (sum of positive and negative classifications)      */
specifier|public
specifier|static
specifier|final
name|UriRef
name|SENTIMENT_PROPERTY
init|=
operator|new
name|UriRef
argument_list|(
name|NamespaceEnum
operator|.
name|fise
operator|+
literal|"sentiment"
argument_list|)
decl_stmt|;
comment|/**      * The dc:type value used for fise:TextAnnotations indicating a Sentiment      */
specifier|public
specifier|static
specifier|final
name|UriRef
name|SENTIMENT_TYPE
init|=
operator|new
name|UriRef
argument_list|(
name|NamespaceEnum
operator|.
name|fise
operator|+
literal|"Sentiment"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_NEGATION_CONTEXT
init|=
literal|2
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_CONJUCTION_CONTEXT
init|=
literal|1
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_NOUN_CONTEXT
init|=
literal|4
decl_stmt|;
name|boolean
name|writeSentimentPhrases
init|=
literal|true
decl_stmt|;
name|boolean
name|writeSentencesSentimet
init|=
literal|true
decl_stmt|;
name|boolean
name|writeDocumentSentiment
init|=
literal|true
decl_stmt|;
name|boolean
name|writeSentimentData
init|=
literal|false
decl_stmt|;
specifier|private
name|EnumSet
argument_list|<
name|Pos
argument_list|>
name|negativePosTags
init|=
name|DEFAULT_NEGATION_TAGS
decl_stmt|;
specifier|private
name|EnumSet
argument_list|<
name|Pos
argument_list|>
name|sectionBorderPosTags
init|=
name|DEFAULT_SECTION_BORDER_TAGS
decl_stmt|;
specifier|private
name|EnumSet
argument_list|<
name|LexicalCategory
argument_list|>
name|countableLexCats
init|=
name|DEFAULT_COUNT_LEXICAL_CATEGORIES
decl_stmt|;
specifier|private
specifier|final
name|LiteralFactory
name|lf
init|=
name|LiteralFactory
operator|.
name|getInstance
argument_list|()
decl_stmt|;
specifier|private
name|int
name|negationContext
init|=
name|DEFAULT_NEGATION_CONTEXT
decl_stmt|;
specifier|private
name|int
name|nounContext
init|=
name|DEFAULT_NOUN_CONTEXT
decl_stmt|;
specifier|private
name|int
name|conjuctionContext
init|=
name|DEFAULT_CONJUCTION_CONTEXT
decl_stmt|;
comment|/**      * Used to sort {@link Sentiment}s before merging them to {@link SentimentPhrase}s      */
specifier|private
specifier|static
specifier|final
name|Comparator
argument_list|<
name|Sentiment
argument_list|>
name|sentimentComparator
init|=
operator|new
name|Comparator
argument_list|<
name|Sentiment
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Sentiment
name|s1
parameter_list|,
name|Sentiment
name|s2
parameter_list|)
block|{
if|if
condition|(
name|s1
operator|.
name|getStart
argument_list|()
operator|==
name|s2
operator|.
name|getStart
argument_list|()
condition|)
block|{
return|return
name|s1
operator|.
name|getEnd
argument_list|()
operator|>
name|s2
operator|.
name|getEnd
argument_list|()
condition|?
operator|-
literal|1
else|:
name|s1
operator|.
name|getEnd
argument_list|()
operator|==
name|s2
operator|.
name|getEnd
argument_list|()
condition|?
literal|0
else|:
operator|-
literal|1
return|;
block|}
else|else
block|{
return|return
name|s1
operator|.
name|getStart
argument_list|()
operator|<
name|s2
operator|.
name|getStart
argument_list|()
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
block|}
block|}
decl_stmt|;
annotation|@
name|Override
annotation|@
name|Activate
specifier|protected
name|void
name|activate
parameter_list|(
name|ComponentContext
name|ctx
parameter_list|)
throws|throws
name|ConfigurationException
block|{
name|log
operator|.
name|info
argument_list|(
literal|" activate {} with config {}"
argument_list|,
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|,
name|ctx
operator|.
name|getProperties
argument_list|()
argument_list|)
expr_stmt|;
name|super
operator|.
name|activate
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
comment|//should we write sentiment values for the document
name|Object
name|value
init|=
name|ctx
operator|.
name|getProperties
argument_list|()
operator|.
name|get
argument_list|(
name|PROPERTY_DOCUMENT_SENTIMENT_STATE
argument_list|)
decl_stmt|;
name|this
operator|.
name|writeDocumentSentiment
operator|=
name|value
operator|==
literal|null
condition|?
name|DEFAULT_DOCUMENT_SENTIMENT_STATE
else|:
name|value
operator|instanceof
name|Boolean
condition|?
operator|(
operator|(
name|Boolean
operator|)
name|value
operator|)
operator|.
name|booleanValue
argument_list|()
else|:
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|//should we write sentiment values for sentences
name|value
operator|=
name|ctx
operator|.
name|getProperties
argument_list|()
operator|.
name|get
argument_list|(
name|PROPERTY_SENTENCE_SENTIMENT_STATE
argument_list|)
expr_stmt|;
name|this
operator|.
name|writeDocumentSentiment
operator|=
name|value
operator|==
literal|null
condition|?
name|DEFAULT_SENTENCE_SENTIMENT_STATE
else|:
name|value
operator|instanceof
name|Boolean
condition|?
operator|(
operator|(
name|Boolean
operator|)
name|value
operator|)
operator|.
name|booleanValue
argument_list|()
else|:
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|//should we write sentiment values for phrases
name|value
operator|=
name|ctx
operator|.
name|getProperties
argument_list|()
operator|.
name|get
argument_list|(
name|PROPERTY_PHRASE_SENTIMENT_STATE
argument_list|)
expr_stmt|;
name|this
operator|.
name|writeDocumentSentiment
operator|=
name|value
operator|==
literal|null
condition|?
name|DEFAULT_PHRASE_SENTIMENT_STATE
else|:
name|value
operator|instanceof
name|Boolean
condition|?
operator|(
operator|(
name|Boolean
operator|)
name|value
operator|)
operator|.
name|booleanValue
argument_list|()
else|:
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
annotation|@
name|Deactivate
specifier|protected
name|void
name|deactivate
parameter_list|(
name|ComponentContext
name|ctx
parameter_list|)
block|{
name|super
operator|.
name|deactivate
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|canEnhance
parameter_list|(
name|ContentItem
name|ci
parameter_list|)
throws|throws
name|EngineException
block|{
return|return
name|NlpEngineHelper
operator|.
name|getAnalysedText
argument_list|(
name|this
argument_list|,
name|ci
argument_list|,
literal|false
argument_list|)
operator|!=
literal|null
operator|&&
name|NlpEngineHelper
operator|.
name|getLanguage
argument_list|(
name|this
argument_list|,
name|ci
argument_list|,
literal|false
argument_list|)
operator|!=
literal|null
condition|?
name|ENHANCE_ASYNC
else|:
name|CANNOT_ENHANCE
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|computeEnhancements
parameter_list|(
name|ContentItem
name|ci
parameter_list|)
throws|throws
name|EngineException
block|{
name|String
name|language
init|=
name|NlpEngineHelper
operator|.
name|getLanguage
argument_list|(
name|this
argument_list|,
name|ci
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|AnalysedText
name|at
init|=
name|NlpEngineHelper
operator|.
name|getAnalysedText
argument_list|(
name|this
argument_list|,
name|ci
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|//configure the spanTypes based on the configuration
comment|//        EnumSet<Span.SpanTypeEnum> spanTypes = EnumSet.noneOf(SpanTypeEnum.class);
comment|//        if(writeSentimentPhrases){
comment|//            spanTypes.add(SpanTypeEnum.Chunk);
comment|//        }
comment|//        if(writeSentencesSentimet){
comment|//            spanTypes.add(SpanTypeEnum.Sentence);
comment|//        }
comment|//        if(writeTextSectionSentiments){
comment|//            spanTypes.add(SpanTypeEnum.TextSection);
comment|//        }
comment|//        if(writeTextSentiments ){
comment|//            spanTypes.add(SpanTypeEnum.Text);
comment|//        }
name|List
argument_list|<
name|SentimentPhrase
argument_list|>
name|sentiments
init|=
name|extractSentiments
argument_list|(
name|at
argument_list|,
name|language
argument_list|)
decl_stmt|;
name|String
name|detectedLang
init|=
name|EnhancementEngineHelper
operator|.
name|getLanguage
argument_list|(
name|ci
argument_list|)
decl_stmt|;
name|ci
operator|.
name|getLock
argument_list|()
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|writeSentimentEnhancements
argument_list|(
name|ci
argument_list|,
name|sentiments
argument_list|,
name|at
argument_list|,
name|detectedLang
operator|==
literal|null
condition|?
literal|null
else|:
operator|new
name|Language
argument_list|(
name|detectedLang
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|ci
operator|.
name|getLock
argument_list|()
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|getServiceProperties
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|singletonMap
argument_list|(
name|ENHANCEMENT_ENGINE_ORDERING
argument_list|,
operator|(
name|Object
operator|)
name|ORDERING_EXTRACTION_ENHANCEMENT
argument_list|)
return|;
block|}
comment|/**      * Extracts {@link Sentiment}s for words with a {@link NlpAnnotations#SENTIMENT_ANNOTATION}.      * The {@link NlpAnnotations#POS_ANNOTATION}s are used to link those words with      * {@link LexicalCategory#Noun}s.      * @param at the AnalyzedText to process      * @return the {@link Sentiment} instances organised along {@link Sentence}s. If      * no {@link Sentence}s are present on the parsed {@link AnalysedText}, than all      * {@link Sentiment}s are added to the {@link AnalysedText}. Otherwise only       * {@link Sentiment}s not contained within a {@link Sentence} are added to the      * {@link AnalysedText} key.      */
specifier|private
name|List
argument_list|<
name|SentimentPhrase
argument_list|>
name|extractSentiments
parameter_list|(
name|AnalysedText
name|at
parameter_list|,
name|String
name|language
parameter_list|)
block|{
comment|//we do use Sentences (optional) and Tokens (required)
name|Iterator
argument_list|<
name|Span
argument_list|>
name|tokenIt
init|=
name|at
operator|.
name|getEnclosed
argument_list|(
name|EnumSet
operator|.
name|of
argument_list|(
name|SpanTypeEnum
operator|.
name|Sentence
argument_list|,
name|SpanTypeEnum
operator|.
name|Token
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Sentiment
argument_list|>
name|sentimentTokens
init|=
operator|new
name|ArrayList
argument_list|<
name|Sentiment
argument_list|>
argument_list|(
literal|32
argument_list|)
decl_stmt|;
name|NavigableMap
argument_list|<
name|Integer
argument_list|,
name|Token
argument_list|>
name|negations
init|=
operator|new
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|Token
argument_list|>
argument_list|()
decl_stmt|;
name|NavigableMap
argument_list|<
name|Integer
argument_list|,
name|Token
argument_list|>
name|nounsAndPronouns
init|=
operator|new
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|Token
argument_list|>
argument_list|()
decl_stmt|;
name|NavigableMap
argument_list|<
name|Integer
argument_list|,
name|Token
argument_list|>
name|verbs
init|=
operator|new
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|Token
argument_list|>
argument_list|()
decl_stmt|;
name|NavigableMap
argument_list|<
name|Integer
argument_list|,
name|Token
argument_list|>
name|conjuctions
init|=
operator|new
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|Token
argument_list|>
argument_list|()
decl_stmt|;
name|NavigableMap
argument_list|<
name|Integer
argument_list|,
name|Token
argument_list|>
name|sectionBorders
init|=
operator|new
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|Token
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|firstTokenInSentence
init|=
literal|true
decl_stmt|;
name|Sentence
name|sentence
init|=
literal|null
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SentimentPhrase
argument_list|>
name|sentimentPhrases
init|=
operator|new
name|ArrayList
argument_list|<
name|SentimentPhrase
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|tokenIt
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Span
name|span
init|=
name|tokenIt
operator|.
name|next
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|span
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|Token
case|:
name|Token
name|word
init|=
operator|(
name|Token
operator|)
name|span
decl_stmt|;
name|Integer
name|wordIndex
init|=
name|sentimentTokens
operator|.
name|size
argument_list|()
decl_stmt|;
name|Value
argument_list|<
name|Double
argument_list|>
name|sentimentAnnotation
init|=
name|span
operator|.
name|getAnnotation
argument_list|(
name|SENTIMENT_ANNOTATION
argument_list|)
decl_stmt|;
name|boolean
name|addToList
init|=
literal|false
decl_stmt|;
name|Sentiment
name|sentiment
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|sentimentAnnotation
operator|!=
literal|null
operator|&&
name|sentimentAnnotation
operator|.
name|value
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|sentimentAnnotation
operator|.
name|value
argument_list|()
operator|.
name|equals
argument_list|(
name|ZERO
argument_list|)
condition|)
block|{
name|sentiment
operator|=
operator|new
name|Sentiment
argument_list|(
name|word
argument_list|,
name|sentimentAnnotation
operator|.
name|value
argument_list|()
argument_list|,
name|sentence
operator|==
literal|null
operator|||
name|word
operator|.
name|getEnd
argument_list|()
operator|>
name|sentence
operator|.
name|getEnd
argument_list|()
condition|?
literal|null
else|:
name|sentence
argument_list|)
expr_stmt|;
name|addToList
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|isNegation
argument_list|(
operator|(
name|Token
operator|)
name|span
argument_list|,
name|language
argument_list|)
condition|)
block|{
name|addToList
operator|=
literal|true
expr_stmt|;
name|negations
operator|.
name|put
argument_list|(
name|wordIndex
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isNoun
argument_list|(
name|word
argument_list|,
name|firstTokenInSentence
argument_list|,
name|language
argument_list|)
operator|||
name|isPronoun
argument_list|(
name|word
argument_list|,
name|language
argument_list|)
condition|)
block|{
name|addToList
operator|=
literal|true
expr_stmt|;
name|nounsAndPronouns
operator|.
name|put
argument_list|(
name|wordIndex
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isSectionBorder
argument_list|(
name|word
argument_list|,
name|language
argument_list|)
condition|)
block|{
name|addToList
operator|=
literal|true
expr_stmt|;
name|sectionBorders
operator|.
name|put
argument_list|(
name|wordIndex
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isVerb
argument_list|(
name|word
argument_list|,
name|language
argument_list|)
condition|)
block|{
name|addToList
operator|=
literal|true
expr_stmt|;
name|verbs
operator|.
name|put
argument_list|(
name|wordIndex
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isCoordinatingConjuction
argument_list|(
name|word
argument_list|,
name|language
argument_list|)
condition|)
block|{
name|addToList
operator|=
literal|true
expr_stmt|;
name|conjuctions
operator|.
name|put
argument_list|(
name|wordIndex
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isCountable
argument_list|(
name|word
argument_list|,
name|language
argument_list|)
condition|)
block|{
name|addToList
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|Value
argument_list|<
name|PosTag
argument_list|>
name|pos
init|=
name|word
operator|.
name|getAnnotation
argument_list|(
name|NlpAnnotations
operator|.
name|POS_ANNOTATION
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|" [{}] '{}' pos: {}, sentiment {}"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|addToList
condition|?
name|sentimentTokens
operator|.
name|size
argument_list|()
else|:
literal|"-"
block|,
name|word
operator|.
name|getSpan
argument_list|()
block|,
name|pos
operator|.
name|value
argument_list|()
operator|.
name|getCategories
argument_list|()
block|,
name|sentiment
operator|==
literal|null
condition|?
literal|"none"
else|:
name|sentiment
operator|.
name|getValue
argument_list|()
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addToList
condition|)
block|{
name|sentimentTokens
operator|.
name|add
argument_list|(
name|sentiment
argument_list|)
expr_stmt|;
comment|//add the token
block|}
name|firstTokenInSentence
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|Sentence
case|:
comment|//cleanup the previous sentence
name|sentimentPhrases
operator|.
name|addAll
argument_list|(
name|summarizeSentence
argument_list|(
name|sentimentTokens
argument_list|,
name|negations
argument_list|,
name|nounsAndPronouns
argument_list|,
name|verbs
argument_list|,
name|conjuctions
argument_list|,
name|sectionBorders
argument_list|)
argument_list|)
expr_stmt|;
name|negations
operator|.
name|clear
argument_list|()
expr_stmt|;
name|nounsAndPronouns
operator|.
name|clear
argument_list|()
expr_stmt|;
name|sentimentTokens
operator|.
name|clear
argument_list|()
expr_stmt|;
name|verbs
operator|.
name|clear
argument_list|()
expr_stmt|;
name|sectionBorders
operator|.
name|clear
argument_list|()
expr_stmt|;
name|firstTokenInSentence
operator|=
literal|true
expr_stmt|;
name|sentence
operator|=
operator|(
name|Sentence
operator|)
name|span
expr_stmt|;
break|break;
case|case
name|TextSection
case|:
break|break;
default|default:
break|break;
block|}
block|}
name|sentimentPhrases
operator|.
name|addAll
argument_list|(
name|summarizeSentence
argument_list|(
name|sentimentTokens
argument_list|,
name|negations
argument_list|,
name|nounsAndPronouns
argument_list|,
name|verbs
argument_list|,
name|conjuctions
argument_list|,
name|sectionBorders
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sentimentPhrases
return|;
block|}
comment|/**      * @param sentimentTokens      * @param negations      * @param nounsAndPronouns      * @param verbs      * @param sectionBorders      */
specifier|private
name|List
argument_list|<
name|SentimentPhrase
argument_list|>
name|summarizeSentence
parameter_list|(
name|List
argument_list|<
name|Sentiment
argument_list|>
name|sentimentTokens
parameter_list|,
name|NavigableMap
argument_list|<
name|Integer
argument_list|,
name|Token
argument_list|>
name|negations
parameter_list|,
name|NavigableMap
argument_list|<
name|Integer
argument_list|,
name|Token
argument_list|>
name|nounsAndPronouns
parameter_list|,
name|NavigableMap
argument_list|<
name|Integer
argument_list|,
name|Token
argument_list|>
name|verbs
parameter_list|,
name|NavigableMap
argument_list|<
name|Integer
argument_list|,
name|Token
argument_list|>
name|conjunctions
parameter_list|,
name|NavigableMap
argument_list|<
name|Integer
argument_list|,
name|Token
argument_list|>
name|sectionBorders
parameter_list|)
block|{
name|List
argument_list|<
name|Sentiment
argument_list|>
name|processedSentiments
init|=
operator|new
name|ArrayList
argument_list|<
name|Sentiment
argument_list|>
argument_list|()
decl_stmt|;
name|Integer
index|[]
name|searchSpan
init|=
operator|new
name|Integer
index|[]
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sentimentTokens
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Integer
name|index
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Sentiment
name|sentiment
init|=
name|sentimentTokens
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|sentiment
operator|!=
literal|null
condition|)
block|{
comment|//check for a new section
if|if
condition|(
name|index
operator|.
name|compareTo
argument_list|(
name|searchSpan
index|[
literal|1
index|]
argument_list|)
operator|>
literal|0
condition|)
block|{
name|searchSpan
index|[
literal|0
index|]
operator|=
name|sectionBorders
operator|.
name|floorKey
argument_list|(
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|searchSpan
index|[
literal|0
index|]
operator|==
literal|null
condition|)
block|{
name|searchSpan
index|[
literal|0
index|]
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|searchSpan
index|[
literal|1
index|]
operator|=
name|sectionBorders
operator|.
name|ceilingKey
argument_list|(
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|searchSpan
index|[
literal|1
index|]
operator|==
literal|null
condition|)
block|{
name|searchSpan
index|[
literal|1
index|]
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|sentimentTokens
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|//for negation use the negation context
name|Integer
index|[]
name|context
init|=
name|getNegationContext
argument_list|(
name|index
argument_list|,
name|conjunctions
argument_list|,
name|searchSpan
argument_list|)
decl_stmt|;
for|for
control|(
name|Token
name|negationToken
range|:
name|negations
operator|.
name|subMap
argument_list|(
name|context
index|[
literal|0
index|]
argument_list|,
literal|true
argument_list|,
name|context
index|[
literal|1
index|]
argument_list|,
literal|true
argument_list|)
operator|.
name|values
argument_list|()
control|)
block|{
name|sentiment
operator|.
name|negate
argument_list|(
name|negationToken
argument_list|)
expr_stmt|;
block|}
comment|//for nouns use the sentiment context
name|context
operator|=
name|getSentimentContext
argument_list|(
name|index
argument_list|,
name|sentiment
argument_list|,
name|verbs
argument_list|,
name|conjunctions
argument_list|,
name|nounsAndPronouns
argument_list|,
name|searchSpan
argument_list|)
expr_stmt|;
for|for
control|(
name|Token
name|word
range|:
name|nounsAndPronouns
operator|.
name|subMap
argument_list|(
name|context
index|[
literal|0
index|]
argument_list|,
literal|true
argument_list|,
name|context
index|[
literal|1
index|]
argument_list|,
literal|true
argument_list|)
operator|.
name|values
argument_list|()
control|)
block|{
name|sentiment
operator|.
name|addAbout
argument_list|(
name|word
argument_list|)
expr_stmt|;
block|}
name|processedSentiments
operator|.
name|add
argument_list|(
name|sentiment
argument_list|)
expr_stmt|;
block|}
block|}
comment|//now combine the processed sentiments to SentimentPhrases
name|Collections
operator|.
name|sort
argument_list|(
name|processedSentiments
argument_list|,
name|sentimentComparator
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|SentimentPhrase
argument_list|>
name|sentimentPhrases
init|=
operator|new
name|ArrayList
argument_list|<
name|SentimentPhrase
argument_list|>
argument_list|()
decl_stmt|;
name|SentimentPhrase
name|phrase
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Sentiment
name|sentiment
range|:
name|processedSentiments
control|)
block|{
if|if
condition|(
name|phrase
operator|==
literal|null
operator|||
name|sentiment
operator|.
name|getStart
argument_list|()
operator|>
name|phrase
operator|.
name|getEndIndex
argument_list|()
condition|)
block|{
name|phrase
operator|=
operator|new
name|SentimentPhrase
argument_list|(
name|sentiment
argument_list|)
expr_stmt|;
name|sentimentPhrases
operator|.
name|add
argument_list|(
name|phrase
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|phrase
operator|.
name|addSentiment
argument_list|(
name|sentiment
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sentimentPhrases
return|;
block|}
specifier|private
name|Integer
index|[]
name|getNegationContext
parameter_list|(
name|Integer
name|index
parameter_list|,
name|NavigableMap
argument_list|<
name|Integer
argument_list|,
name|Token
argument_list|>
name|conjunctions
parameter_list|,
name|Integer
index|[]
name|sectionSpan
parameter_list|)
block|{
name|Integer
index|[]
name|context
init|=
operator|new
name|Integer
index|[]
block|{
name|Integer
operator|.
name|valueOf
argument_list|(
name|Math
operator|.
name|max
argument_list|(
name|index
operator|-
name|negationContext
argument_list|,
name|sectionSpan
index|[
literal|0
index|]
argument_list|)
argument_list|)
block|,
name|Integer
operator|.
name|valueOf
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|index
operator|+
name|negationContext
argument_list|,
name|sectionSpan
index|[
literal|1
index|]
argument_list|)
argument_list|)
block|}
decl_stmt|;
name|Integer
name|floorConjunction
init|=
name|conjunctions
operator|.
name|floorKey
argument_list|(
name|index
argument_list|)
decl_stmt|;
comment|//consider conjuction "The helmet is not comfortable and easy to use"
comment|//the "not" refers both to "comfortable" and  "easy"
if|if
condition|(
name|floorConjunction
operator|!=
literal|null
operator|&&
name|floorConjunction
operator|.
name|compareTo
argument_list|(
name|index
operator|-
name|conjuctionContext
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|context
index|[
literal|0
index|]
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|Math
operator|.
name|max
argument_list|(
name|floorConjunction
operator|-
name|negationContext
operator|-
literal|1
argument_list|,
name|sectionSpan
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|context
return|;
block|}
specifier|private
name|Integer
index|[]
name|getSentimentContext
parameter_list|(
name|Integer
name|index
parameter_list|,
name|Sentiment
name|sentiment
parameter_list|,
name|NavigableMap
argument_list|<
name|Integer
argument_list|,
name|Token
argument_list|>
name|verbs
parameter_list|,
name|NavigableMap
argument_list|<
name|Integer
argument_list|,
name|Token
argument_list|>
name|conjunctions
parameter_list|,
name|NavigableMap
argument_list|<
name|Integer
argument_list|,
name|Token
argument_list|>
name|nouns
parameter_list|,
name|Integer
index|[]
name|sectionSpan
parameter_list|)
block|{
name|Integer
index|[]
name|context
decl_stmt|;
name|PosTag
name|pos
init|=
name|sentiment
operator|.
name|getPosTag
argument_list|()
decl_stmt|;
name|boolean
name|isPredicative
decl_stmt|;
if|if
condition|(
name|pos
operator|!=
literal|null
operator|&&
name|pos
operator|.
name|getPosHierarchy
argument_list|()
operator|.
name|contains
argument_list|(
name|Pos
operator|.
name|PredicativeAdjective
argument_list|)
condition|)
block|{
name|isPredicative
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pos
operator|!=
literal|null
operator|&&
name|pos
operator|.
name|hasCategory
argument_list|(
name|LexicalCategory
operator|.
name|Adjective
argument_list|)
operator|&&
comment|//Adjective that are not directly in front of a Noun
name|nouns
operator|.
name|get
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|index
operator|+
literal|1
argument_list|)
argument_list|)
operator|==
literal|null
condition|)
block|{
name|isPredicative
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|isPredicative
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|isPredicative
condition|)
block|{
comment|//            Integer floorConjunction = conjunctions.floorKey(index);
comment|//            if(floorConjunction != null&& floorConjunction.compareTo(
comment|//                Integer.valueOf(Math.max(index-conjuctionContext,sectionSpan[0])))>= 0){
comment|//                lowIndex = Integer.valueOf(floorConjunction-1);
comment|//            }
comment|//            Integer ceilingConjunction = conjunctions.ceilingKey(index);
comment|//            if(ceilingConjunction != null&& ceilingConjunction.compareTo(
comment|//                Integer.valueOf(Math.min(index+conjuctionContext,sectionSpan[1])))<= 0){
comment|//                highIndex = Integer.valueOf(ceilingConjunction+1);
comment|//            }
comment|//use the verb as context
name|Integer
name|floorNoun
init|=
name|nouns
operator|.
name|floorKey
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|Entry
argument_list|<
name|Integer
argument_list|,
name|Token
argument_list|>
name|floorVerb
init|=
name|verbs
operator|.
name|floorEntry
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|Integer
name|ceilingNoun
init|=
name|nouns
operator|.
name|ceilingKey
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|Entry
argument_list|<
name|Integer
argument_list|,
name|Token
argument_list|>
name|ceilingVerb
init|=
name|verbs
operator|.
name|ceilingEntry
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|floorVerb
operator|=
name|floorVerb
operator|==
literal|null
operator|||
name|floorVerb
operator|.
name|getKey
argument_list|()
operator|.
name|compareTo
argument_list|(
name|sectionSpan
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
operator|||
comment|//do not use verbs with an noun in-between
operator|(
name|floorNoun
operator|!=
literal|null
operator|&&
name|floorVerb
operator|.
name|getKey
argument_list|()
operator|.
name|compareTo
argument_list|(
name|floorNoun
argument_list|)
operator|<
literal|0
operator|)
condition|?
literal|null
else|:
name|floorVerb
expr_stmt|;
name|ceilingVerb
operator|=
name|ceilingVerb
operator|==
literal|null
operator|||
name|ceilingVerb
operator|.
name|getKey
argument_list|()
operator|.
name|compareTo
argument_list|(
name|sectionSpan
index|[
literal|1
index|]
argument_list|)
operator|>
literal|0
operator|||
comment|//do not use verbs with an noun in-between
operator|(
name|ceilingNoun
operator|!=
literal|null
operator|&&
name|ceilingVerb
operator|.
name|getKey
argument_list|()
operator|.
name|compareTo
argument_list|(
name|ceilingNoun
argument_list|)
operator|>
literal|0
operator|)
condition|?
literal|null
else|:
name|ceilingVerb
expr_stmt|;
name|Entry
argument_list|<
name|Integer
argument_list|,
name|Token
argument_list|>
name|verb
decl_stmt|;
if|if
condition|(
name|ceilingVerb
operator|!=
literal|null
operator|&&
name|floorVerb
operator|!=
literal|null
condition|)
block|{
name|verb
operator|=
operator|(
name|index
operator|-
name|floorVerb
operator|.
name|getKey
argument_list|()
operator|)
operator|<
operator|(
name|ceilingVerb
operator|.
name|getKey
argument_list|()
operator|-
name|index
operator|)
condition|?
name|floorVerb
else|:
name|ceilingVerb
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ceilingVerb
operator|!=
literal|null
condition|)
block|{
name|verb
operator|=
name|ceilingVerb
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|floorVerb
operator|!=
literal|null
condition|)
block|{
name|verb
operator|=
name|floorVerb
expr_stmt|;
block|}
else|else
block|{
comment|//no verb that can be used as context ... return an area around the current pos.
name|verb
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|verb
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|verb
operator|.
name|getKey
argument_list|()
operator|.
name|compareTo
argument_list|(
name|index
argument_list|)
operator|<
literal|0
condition|)
block|{
name|Integer
name|floorConjunction
init|=
name|conjunctions
operator|.
name|floorKey
argument_list|(
name|verb
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|floorConjunction
operator|!=
literal|null
operator|&&
name|floorConjunction
operator|.
name|compareTo
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|Math
operator|.
name|max
argument_list|(
name|verb
operator|.
name|getKey
argument_list|()
operator|-
name|conjuctionContext
argument_list|,
name|sectionSpan
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|//search an other verb in the same direction
name|floorVerb
operator|=
name|verbs
operator|.
name|floorEntry
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|floorConjunction
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|floorVerb
operator|!=
literal|null
operator|&&
name|floorVerb
operator|.
name|getKey
argument_list|()
operator|.
name|compareTo
argument_list|(
name|sectionSpan
index|[
literal|0
index|]
argument_list|)
operator|>=
literal|0
operator|&&
comment|//do not step over an noun
operator|(
name|floorNoun
operator|==
literal|null
operator|||
name|floorVerb
operator|.
name|getKey
argument_list|()
operator|.
name|compareTo
argument_list|(
name|floorNoun
argument_list|)
operator|>=
literal|0
operator|)
condition|)
block|{
name|verb
operator|=
name|floorVerb
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|verb
operator|.
name|getKey
argument_list|()
operator|.
name|compareTo
argument_list|(
name|index
argument_list|)
operator|>
literal|0
condition|)
block|{
name|Integer
name|ceilingConjunction
init|=
name|conjunctions
operator|.
name|ceilingKey
argument_list|(
name|verb
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ceilingConjunction
operator|!=
literal|null
operator|&&
name|ceilingConjunction
operator|.
name|compareTo
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|verb
operator|.
name|getKey
argument_list|()
operator|+
name|conjuctionContext
argument_list|,
name|sectionSpan
index|[
literal|1
index|]
argument_list|)
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|//search an other verb in the same direction
name|ceilingVerb
operator|=
name|verbs
operator|.
name|floorEntry
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|ceilingConjunction
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ceilingVerb
operator|!=
literal|null
operator|&&
name|ceilingVerb
operator|.
name|getKey
argument_list|()
operator|.
name|compareTo
argument_list|(
name|sectionSpan
index|[
literal|1
index|]
argument_list|)
operator|<=
literal|0
operator|&&
comment|//do not step over an noun
operator|(
name|ceilingNoun
operator|==
literal|null
operator|||
name|ceilingVerb
operator|.
name|getKey
argument_list|()
operator|.
name|compareTo
argument_list|(
name|ceilingNoun
argument_list|)
operator|<=
literal|0
operator|)
condition|)
block|{
name|verb
operator|=
name|ceilingVerb
expr_stmt|;
block|}
block|}
block|}
name|context
operator|=
operator|new
name|Integer
index|[]
block|{
name|Integer
operator|.
name|valueOf
argument_list|(
name|verb
operator|.
name|getKey
argument_list|()
operator|-
name|nounContext
argument_list|)
block|,
name|Integer
operator|.
name|valueOf
argument_list|(
name|verb
operator|.
name|getKey
argument_list|()
operator|+
name|nounContext
argument_list|)
block|}
expr_stmt|;
name|sentiment
operator|.
name|setVerb
argument_list|(
name|verb
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|context
operator|=
operator|new
name|Integer
index|[]
block|{
name|Integer
operator|.
name|valueOf
argument_list|(
name|index
operator|-
name|nounContext
argument_list|)
block|,
name|Integer
operator|.
name|valueOf
argument_list|(
name|index
operator|+
name|nounContext
argument_list|)
block|}
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pos
operator|!=
literal|null
operator|&&
name|pos
operator|.
name|hasCategory
argument_list|(
name|LexicalCategory
operator|.
name|Adjective
argument_list|)
condition|)
block|{
comment|//for all other adjective the affected noun is expected directly
comment|//after the noun
name|context
operator|=
operator|new
name|Integer
index|[]
block|{
name|index
block|,
name|Integer
operator|.
name|valueOf
argument_list|(
name|index
operator|+
literal|1
argument_list|)
block|}
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pos
operator|!=
literal|null
operator|&&
name|pos
operator|.
name|hasCategory
argument_list|(
name|LexicalCategory
operator|.
name|Noun
argument_list|)
condition|)
block|{
comment|//a noun with an sentiment
name|context
operator|=
operator|new
name|Integer
index|[]
block|{
name|index
block|,
name|index
block|}
expr_stmt|;
block|}
else|else
block|{
comment|//else (includes pos == null) return default
name|context
operator|=
operator|new
name|Integer
index|[]
block|{
name|Integer
operator|.
name|valueOf
argument_list|(
name|index
operator|-
name|nounContext
argument_list|)
block|,
name|Integer
operator|.
name|valueOf
argument_list|(
name|index
operator|+
name|nounContext
argument_list|)
block|}
expr_stmt|;
block|}
comment|//ensure the returned context does not exceed the parsed sectionSpan
if|if
condition|(
name|context
index|[
literal|0
index|]
operator|.
name|compareTo
argument_list|(
name|sectionSpan
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
name|context
index|[
literal|0
index|]
operator|=
name|sectionSpan
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
name|context
index|[
literal|1
index|]
operator|.
name|compareTo
argument_list|(
name|sectionSpan
index|[
literal|1
index|]
argument_list|)
operator|>
literal|0
condition|)
block|{
name|context
index|[
literal|1
index|]
operator|=
name|sectionSpan
index|[
literal|1
index|]
expr_stmt|;
block|}
return|return
name|context
return|;
block|}
specifier|private
name|boolean
name|isPronoun
parameter_list|(
name|Token
name|token
parameter_list|,
name|String
name|language
parameter_list|)
block|{
name|Value
argument_list|<
name|PosTag
argument_list|>
name|posAnnotation
init|=
name|token
operator|.
name|getAnnotation
argument_list|(
name|NlpAnnotations
operator|.
name|POS_ANNOTATION
argument_list|)
decl_stmt|;
return|return
name|posAnnotation
operator|==
literal|null
condition|?
literal|false
else|:
name|posAnnotation
operator|.
name|value
argument_list|()
operator|.
name|getPosHierarchy
argument_list|()
operator|.
name|contains
argument_list|(
name|Pos
operator|.
name|Pronoun
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|isVerb
parameter_list|(
name|Token
name|token
parameter_list|,
name|String
name|language
parameter_list|)
block|{
name|Value
argument_list|<
name|PosTag
argument_list|>
name|posAnnotation
init|=
name|token
operator|.
name|getAnnotation
argument_list|(
name|NlpAnnotations
operator|.
name|POS_ANNOTATION
argument_list|)
decl_stmt|;
return|return
name|posAnnotation
operator|==
literal|null
condition|?
literal|false
else|:
name|posAnnotation
operator|.
name|value
argument_list|()
operator|.
name|hasCategory
argument_list|(
name|LexicalCategory
operator|.
name|Verb
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|isCoordinatingConjuction
parameter_list|(
name|Token
name|token
parameter_list|,
name|String
name|language
parameter_list|)
block|{
name|Value
argument_list|<
name|PosTag
argument_list|>
name|posAnnotation
init|=
name|token
operator|.
name|getAnnotation
argument_list|(
name|NlpAnnotations
operator|.
name|POS_ANNOTATION
argument_list|)
decl_stmt|;
return|return
name|posAnnotation
operator|==
literal|null
condition|?
literal|false
else|:
name|posAnnotation
operator|.
name|value
argument_list|()
operator|.
name|getPosHierarchy
argument_list|()
operator|.
name|contains
argument_list|(
name|Pos
operator|.
name|CoordinatingConjunction
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|isSectionBorder
parameter_list|(
name|Token
name|token
parameter_list|,
name|String
name|language
parameter_list|)
block|{
name|Value
argument_list|<
name|PosTag
argument_list|>
name|posAnnotation
init|=
name|token
operator|.
name|getAnnotation
argument_list|(
name|NlpAnnotations
operator|.
name|POS_ANNOTATION
argument_list|)
decl_stmt|;
if|if
condition|(
name|posAnnotation
operator|!=
literal|null
operator|&&
operator|!
name|Collections
operator|.
name|disjoint
argument_list|(
name|sectionBorderPosTags
argument_list|,
name|posAnnotation
operator|.
name|value
argument_list|()
operator|.
name|getPosHierarchy
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**      * Checks if the parsed {@link Token} represents an negation      * @param token the word      * @param language the language      * @return<code>true</code> if the {@link Token} represents a negation.      * Otherwise<code>false</code>      */
specifier|private
name|boolean
name|isNegation
parameter_list|(
name|Token
name|token
parameter_list|,
name|String
name|language
parameter_list|)
block|{
name|Value
argument_list|<
name|PosTag
argument_list|>
name|posAnnotation
init|=
name|token
operator|.
name|getAnnotation
argument_list|(
name|NlpAnnotations
operator|.
name|POS_ANNOTATION
argument_list|)
decl_stmt|;
if|if
condition|(
name|posAnnotation
operator|!=
literal|null
operator|&&
operator|!
name|Collections
operator|.
name|disjoint
argument_list|(
name|negativePosTags
argument_list|,
name|posAnnotation
operator|.
name|value
argument_list|()
operator|.
name|getPosHierarchy
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**      * Checks if the parsed {@link Token} represents an negation      * @param token the word      * @param index the index of the token relative to the sentence | section      * @param language the language      * @return<code>true</code> if the {@link Token} represents a negation.      * Otherwise<code>false</code>      */
specifier|private
name|boolean
name|isNoun
parameter_list|(
name|Token
name|token
parameter_list|,
name|boolean
name|firstTokenInSentence
parameter_list|,
name|String
name|language
parameter_list|)
block|{
name|String
name|word
init|=
name|token
operator|.
name|getSpan
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|firstTokenInSentence
operator|&&
operator|!
name|word
operator|.
name|isEmpty
argument_list|()
operator|&&
name|Character
operator|.
name|isUpperCase
argument_list|(
name|word
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
comment|//assume all upper case tokens are Nouns
block|}
name|Value
argument_list|<
name|PosTag
argument_list|>
name|posAnnotation
init|=
name|token
operator|.
name|getAnnotation
argument_list|(
name|NlpAnnotations
operator|.
name|POS_ANNOTATION
argument_list|)
decl_stmt|;
if|if
condition|(
name|posAnnotation
operator|!=
literal|null
operator|&&
operator|(
name|posAnnotation
operator|.
name|value
argument_list|()
operator|.
name|hasCategory
argument_list|(
name|LexicalCategory
operator|.
name|Noun
argument_list|)
operator|||
name|posAnnotation
operator|.
name|value
argument_list|()
operator|.
name|getPosHierarchy
argument_list|()
operator|.
name|contains
argument_list|(
name|Pos
operator|.
name|CardinalNumber
argument_list|)
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**      * If the current Token should be considered for counting distances to      * negations and nouns      * @param token      * @param language      * @return      */
specifier|private
name|boolean
name|isCountable
parameter_list|(
name|Token
name|token
parameter_list|,
name|String
name|language
parameter_list|)
block|{
name|Value
argument_list|<
name|PosTag
argument_list|>
name|posAnnotation
init|=
name|token
operator|.
name|getAnnotation
argument_list|(
name|NlpAnnotations
operator|.
name|POS_ANNOTATION
argument_list|)
decl_stmt|;
if|if
condition|(
name|posAnnotation
operator|!=
literal|null
operator|&&
operator|!
name|Collections
operator|.
name|disjoint
argument_list|(
name|countableLexCats
argument_list|,
name|posAnnotation
operator|.
name|value
argument_list|()
operator|.
name|getCategories
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
specifier|private
name|void
name|writeSentimentEnhancements
parameter_list|(
name|ContentItem
name|ci
parameter_list|,
name|List
argument_list|<
name|SentimentPhrase
argument_list|>
name|sentimentPhrases
parameter_list|,
name|AnalysedText
name|at
parameter_list|,
name|Language
name|lang
parameter_list|)
block|{
comment|// TODO Auto-generated method stub
name|MGraph
name|metadata
init|=
name|ci
operator|.
name|getMetadata
argument_list|()
decl_stmt|;
name|Sentence
name|currentSentence
init|=
literal|null
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SentimentPhrase
argument_list|>
name|sentencePhrases
init|=
operator|new
name|ArrayList
argument_list|<
name|SentimentPhrase
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|SentimentPhrase
name|sentPhrase
range|:
name|sentimentPhrases
control|)
block|{
name|Sentence
name|sentence
init|=
name|sentPhrase
operator|.
name|getSentence
argument_list|()
decl_stmt|;
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
comment|//debug sentiment info
name|CharSequence
name|phraseText
init|=
name|at
operator|.
name|getText
argument_list|()
operator|.
name|subSequence
argument_list|(
name|sentPhrase
operator|.
name|getStartIndex
argument_list|()
argument_list|,
name|sentPhrase
operator|.
name|getEndIndex
argument_list|()
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Write SentimentPhrase for {} (sentence: {})"
argument_list|,
name|phraseText
argument_list|,
name|sentence
operator|==
literal|null
condition|?
literal|"none"
else|:
name|sentence
operator|.
name|getSpan
argument_list|()
operator|.
name|length
argument_list|()
operator|>
literal|17
condition|?
operator|(
name|sentence
operator|.
name|getSpan
argument_list|()
operator|.
name|subSequence
argument_list|(
literal|0
argument_list|,
literal|17
argument_list|)
operator|+
literal|"..."
operator|)
else|:
name|sentence
operator|.
name|getSpan
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Sentiment
argument_list|>
name|sentiments
init|=
name|sentPhrase
operator|.
name|getSentiments
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"> {} Sentiments:"
argument_list|,
name|sentiments
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sentiments
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"    {}. {}"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|sentiments
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|writeSentimentPhrases
condition|)
block|{
name|UriRef
name|enh
init|=
name|createTextEnhancement
argument_list|(
name|ci
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|String
name|phraseText
init|=
name|at
operator|.
name|getSpan
argument_list|()
operator|.
name|substring
argument_list|(
name|sentPhrase
operator|.
name|getStartIndex
argument_list|()
argument_list|,
name|sentPhrase
operator|.
name|getEndIndex
argument_list|()
argument_list|)
decl_stmt|;
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|enh
argument_list|,
name|ENHANCER_SELECTED_TEXT
argument_list|,
operator|new
name|PlainLiteralImpl
argument_list|(
name|phraseText
argument_list|,
name|lang
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sentPhrase
operator|.
name|getSentence
argument_list|()
operator|==
literal|null
condition|)
block|{
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|enh
argument_list|,
name|ENHANCER_SELECTION_CONTEXT
argument_list|,
operator|new
name|PlainLiteralImpl
argument_list|(
name|getSelectionContext
argument_list|(
name|at
operator|.
name|getSpan
argument_list|()
argument_list|,
name|phraseText
argument_list|,
name|sentPhrase
operator|.
name|getStartIndex
argument_list|()
argument_list|)
argument_list|,
name|lang
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|enh
argument_list|,
name|ENHANCER_SELECTION_CONTEXT
argument_list|,
operator|new
name|PlainLiteralImpl
argument_list|(
name|sentPhrase
operator|.
name|getSentence
argument_list|()
operator|.
name|getSpan
argument_list|()
argument_list|,
name|lang
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|enh
argument_list|,
name|ENHANCER_START
argument_list|,
name|lf
operator|.
name|createTypedLiteral
argument_list|(
name|sentPhrase
operator|.
name|getStartIndex
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|enh
argument_list|,
name|ENHANCER_END
argument_list|,
name|lf
operator|.
name|createTypedLiteral
argument_list|(
name|sentPhrase
operator|.
name|getEndIndex
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sentPhrase
operator|.
name|getPositiveSentiment
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|enh
argument_list|,
name|POSITIVE_SENTIMENT_PROPERTY
argument_list|,
name|lf
operator|.
name|createTypedLiteral
argument_list|(
name|sentPhrase
operator|.
name|getPositiveSentiment
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sentPhrase
operator|.
name|getNegativeSentiment
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|enh
argument_list|,
name|NEGATIVE_SENTIMENT_PROPERTY
argument_list|,
name|lf
operator|.
name|createTypedLiteral
argument_list|(
name|sentPhrase
operator|.
name|getNegativeSentiment
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|enh
argument_list|,
name|SENTIMENT_PROPERTY
argument_list|,
name|lf
operator|.
name|createTypedLiteral
argument_list|(
name|sentPhrase
operator|.
name|getSentiment
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|//add the Sentiment type as well as the type of the SSO Ontology
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|enh
argument_list|,
name|DC_TYPE
argument_list|,
name|SENTIMENT_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|UriRef
name|ssoType
init|=
name|NIFHelper
operator|.
name|SPAN_TYPE_TO_SSO_TYPE
operator|.
name|get
argument_list|(
name|SpanTypeEnum
operator|.
name|Chunk
argument_list|)
decl_stmt|;
if|if
condition|(
name|ssoType
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|enh
argument_list|,
name|DC_TYPE
argument_list|,
name|ssoType
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|writeSentencesSentimet
operator|&&
name|sentence
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|sentence
operator|.
name|equals
argument_list|(
name|currentSentence
argument_list|)
condition|)
block|{
name|sentencePhrases
operator|.
name|add
argument_list|(
name|sentPhrase
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writeSentiment
argument_list|(
name|ci
argument_list|,
name|currentSentence
argument_list|,
name|sentencePhrases
argument_list|)
expr_stmt|;
comment|//reset
name|currentSentence
operator|=
name|sentence
expr_stmt|;
name|sentencePhrases
operator|.
name|clear
argument_list|()
expr_stmt|;
name|sentencePhrases
operator|.
name|add
argument_list|(
name|sentPhrase
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|sentencePhrases
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|writeSentiment
argument_list|(
name|ci
argument_list|,
name|currentSentence
argument_list|,
name|sentencePhrases
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|writeDocumentSentiment
condition|)
block|{
name|writeSentiment
argument_list|(
name|ci
argument_list|,
name|at
argument_list|,
name|sentimentPhrases
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|writeSentiment
parameter_list|(
name|ContentItem
name|ci
parameter_list|,
name|Section
name|section
parameter_list|,
name|List
argument_list|<
name|SentimentPhrase
argument_list|>
name|sectionPhrases
parameter_list|)
block|{
if|if
condition|(
name|section
operator|==
literal|null
operator|||
name|sectionPhrases
operator|==
literal|null
operator|||
name|sectionPhrases
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
comment|//nothing to do
block|}
name|UriRef
name|enh
init|=
name|createTextEnhancement
argument_list|(
name|ci
argument_list|,
name|this
argument_list|)
decl_stmt|;
name|MGraph
name|metadata
init|=
name|ci
operator|.
name|getMetadata
argument_list|()
decl_stmt|;
if|if
condition|(
name|section
operator|.
name|getType
argument_list|()
operator|==
name|SpanTypeEnum
operator|.
name|Sentence
condition|)
block|{
comment|//TODO use the fise:TextAnnotation new model for
comment|//add start/end positions
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|enh
argument_list|,
name|ENHANCER_START
argument_list|,
name|lf
operator|.
name|createTypedLiteral
argument_list|(
name|section
operator|.
name|getStart
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|enh
argument_list|,
name|ENHANCER_END
argument_list|,
name|lf
operator|.
name|createTypedLiteral
argument_list|(
name|section
operator|.
name|getEnd
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//TODO: Summarize the sentiments of this section
comment|//add the sentiment information
name|double
name|positiveSent
init|=
literal|0.0
decl_stmt|;
name|int
name|positiveCount
init|=
literal|0
decl_stmt|;
name|double
name|negativeSent
init|=
literal|0.0
decl_stmt|;
name|int
name|negativeCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|SentimentPhrase
name|sentPhrase
range|:
name|sectionPhrases
control|)
block|{
if|if
condition|(
name|sentPhrase
operator|.
name|getNegativeSentiment
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|double
name|neg
init|=
name|sentPhrase
operator|.
name|getNegativeSentiment
argument_list|()
decl_stmt|;
name|negativeSent
operator|=
name|negativeSent
operator|+
operator|(
name|neg
operator|*
name|neg
operator|)
expr_stmt|;
name|negativeCount
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sentPhrase
operator|.
name|getPositiveSentiment
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|double
name|pos
init|=
name|sentPhrase
operator|.
name|getPositiveSentiment
argument_list|()
decl_stmt|;
name|positiveSent
operator|=
name|positiveSent
operator|+
operator|(
name|pos
operator|*
name|pos
operator|)
expr_stmt|;
name|positiveCount
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|positiveCount
operator|>
literal|0
condition|)
block|{
name|positiveSent
operator|=
name|Math
operator|.
name|sqrt
argument_list|(
name|positiveSent
operator|/
operator|(
name|double
operator|)
name|positiveCount
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|enh
argument_list|,
name|POSITIVE_SENTIMENT_PROPERTY
argument_list|,
name|lf
operator|.
name|createTypedLiteral
argument_list|(
name|Double
operator|.
name|valueOf
argument_list|(
name|positiveSent
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|negativeCount
operator|>
literal|0
condition|)
block|{
name|negativeSent
operator|=
name|Math
operator|.
name|sqrt
argument_list|(
name|negativeSent
operator|/
operator|(
name|double
operator|)
name|negativeCount
argument_list|)
operator|*
operator|-
literal|1
expr_stmt|;
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|enh
argument_list|,
name|NEGATIVE_SENTIMENT_PROPERTY
argument_list|,
name|lf
operator|.
name|createTypedLiteral
argument_list|(
name|Double
operator|.
name|valueOf
argument_list|(
name|negativeSent
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|enh
argument_list|,
name|SENTIMENT_PROPERTY
argument_list|,
name|lf
operator|.
name|createTypedLiteral
argument_list|(
name|Double
operator|.
name|valueOf
argument_list|(
name|negativeSent
operator|+
name|positiveSent
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|//add the Sentiment type as well as the type of the SSO Ontology
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|enh
argument_list|,
name|DC_TYPE
argument_list|,
name|SENTIMENT_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|UriRef
name|ssoType
init|=
name|NIFHelper
operator|.
name|SPAN_TYPE_TO_SSO_TYPE
operator|.
name|get
argument_list|(
name|section
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ssoType
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|enh
argument_list|,
name|DC_TYPE
argument_list|,
name|ssoType
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * The maximum size of the preix/suffix for the selection context      */
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_SELECTION_CONTEXT_PREFIX_SUFFIX_SIZE
init|=
literal|50
decl_stmt|;
comment|/**      * Extracts the selection context based on the content, selection and      * the start char offset of the selection      * @param content the content      * @param selection the selected text      * @param selectionStartPos the start char position of the selection      * @return the context      */
specifier|public
specifier|static
name|String
name|getSelectionContext
parameter_list|(
name|String
name|content
parameter_list|,
name|String
name|selection
parameter_list|,
name|int
name|selectionStartPos
parameter_list|)
block|{
comment|//extract the selection context
name|int
name|beginPos
decl_stmt|;
if|if
condition|(
name|selectionStartPos
operator|<=
name|DEFAULT_SELECTION_CONTEXT_PREFIX_SUFFIX_SIZE
condition|)
block|{
name|beginPos
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|int
name|start
init|=
name|selectionStartPos
operator|-
name|DEFAULT_SELECTION_CONTEXT_PREFIX_SUFFIX_SIZE
decl_stmt|;
name|beginPos
operator|=
name|content
operator|.
name|indexOf
argument_list|(
literal|' '
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|beginPos
operator|<
literal|0
operator|||
name|beginPos
operator|>=
name|selectionStartPos
condition|)
block|{
comment|//no words
name|beginPos
operator|=
name|start
expr_stmt|;
comment|//begin within a word
block|}
block|}
name|int
name|endPos
decl_stmt|;
if|if
condition|(
name|selectionStartPos
operator|+
name|selection
operator|.
name|length
argument_list|()
operator|+
name|DEFAULT_SELECTION_CONTEXT_PREFIX_SUFFIX_SIZE
operator|>=
name|content
operator|.
name|length
argument_list|()
condition|)
block|{
name|endPos
operator|=
name|content
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|int
name|start
init|=
name|selectionStartPos
operator|+
name|selection
operator|.
name|length
argument_list|()
operator|+
name|DEFAULT_SELECTION_CONTEXT_PREFIX_SUFFIX_SIZE
decl_stmt|;
name|endPos
operator|=
name|content
operator|.
name|lastIndexOf
argument_list|(
literal|' '
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|endPos
operator|<=
name|selectionStartPos
operator|+
name|selection
operator|.
name|length
argument_list|()
condition|)
block|{
name|endPos
operator|=
name|start
expr_stmt|;
comment|//end within a word;
block|}
block|}
return|return
name|content
operator|.
name|substring
argument_list|(
name|beginPos
argument_list|,
name|endPos
argument_list|)
return|;
block|}
block|}
end_class

end_unit

