begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|lucenefstlinking
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|NlpAnnotations
operator|.
name|NER_ANNOTATION
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|AccessController
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|collections
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|collections
operator|.
name|iterators
operator|.
name|FilterIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|CharTermAttribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|tokenattributes
operator|.
name|OffsetAttribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|model
operator|.
name|AnalysedText
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|model
operator|.
name|Chunk
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|model
operator|.
name|Span
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|model
operator|.
name|annotation
operator|.
name|Value
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|ner
operator|.
name|NerTag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|opensextant
operator|.
name|solrtexttagger
operator|.
name|TagClusterReducer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|opensextant
operator|.
name|solrtexttagger
operator|.
name|TagLL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|opensextant
operator|.
name|solrtexttagger
operator|.
name|TaggingAttribute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Class that ensures that only Tokens within a {@link Chunk} with a   * {@link NerTag} are processed.<p>  * This is ensured on two places:<ol>  *<li> Classifies Tokens in the Solr {@link TokenStream} with the {@link TaggingAttribute}  * based on {@link NerTag}s present in the {@link AnalysedText}.<p>  *<li> Implements {@link TagClusterReducer} to ensure that all {@link TagLL tags}  * that do not cover the whole Named Entity are removed from the Cluster.  *</ol>  *<b> Implementation Details</b><p>  * The {@link TokenStream} implementation of this class does set  *<code>{@link TaggingAttribute#isTaggable()} == ture</code> if the do overlap   * with a {@link Chunk} having an {@link NerTag}  *<p>  * The {@link TagClusterReducer} implementation keeps track of Chunks with   * {@link NerTag} while iterating over the {@link TokenStream} and adds them to   * the end of a List. When {@link TagClusterReducer#reduce(TagLL[])} is called   * tags of the cluster are checked if they do cover Chunks with a {@link NerTag}.  * If they do not they are removed from the cluster.  *<p>  * This implementation was derived from the {@link LinkableTokenFilter}  *   * @author Rupert Westenthaler  *  */
end_comment

begin_class
specifier|public
specifier|final
class|class
name|NamedEntityTokenFilter
extends|extends
name|TokenFilter
implements|implements
name|TagClusterReducer
block|{
specifier|private
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|NamedEntityTokenFilter
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * The NLP processing results      */
specifier|private
name|AnalysedText
name|at
decl_stmt|;
comment|/**      * The language of the text      */
comment|/**      * Iterator over all {@link Chunk}s in the {@link AnalysedText} that do       * have an {@link NerTag}      */
specifier|private
name|Iterator
argument_list|<
name|Chunk
argument_list|>
name|neChunks
decl_stmt|;
specifier|protected
specifier|final
name|CharTermAttribute
name|termAtt
decl_stmt|;
specifier|protected
specifier|final
name|OffsetAttribute
name|offset
decl_stmt|;
specifier|protected
specifier|final
name|TaggingAttribute
name|taggable
decl_stmt|;
specifier|private
name|int
name|lookupCount
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|incrementCount
init|=
literal|0
decl_stmt|;
comment|/**      * List with {@link Chunk}s having {@link NerTag}s. This is used by      * the {@link #reduce(TagLL[])} method to check if {@link TagLL tags}       * do cover Named Entities detected in the text.      */
specifier|private
name|List
argument_list|<
name|Chunk
argument_list|>
name|nePhrases
decl_stmt|;
specifier|private
specifier|final
name|NavigableMap
argument_list|<
name|int
index|[]
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|nePhrasesTypes
decl_stmt|;
specifier|private
name|Chunk
name|neChunk
decl_stmt|;
specifier|protected
specifier|final
name|boolean
name|wildcardType
decl_stmt|;
specifier|protected
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|neTypes
decl_stmt|;
comment|/**      * A Token Filter for Named Entities of the configured types. Also collects      * '<code>span -&gt type</code>' mappings for Named Entities.      * @param input the input token stream for the parsed text      * @param at the {@link AnalysedText} containing {@link NerTag} values      * @param lang the language of the text      * @param neTypes the string {@link NerTag#getType()} and {@link NerTag#getTag()}      * values of enabled Named Entities. If<code>null</code> or containing the      *<code>null</code> element all types will be accepted.      * @param nePhrasesTypes The {@link NavigableMap} used to store the spans of      * named entities as key and the set o their {@link NerTag#getTag()} and       * {@link NerTag#getType()} as values. Those information are collected while      * iterating over the text (by the {@link NamedEntityPredicate}) and are      * used later for filtering {@link Match}es based on the type of the Entities.      * Typically the {@link TaggingSession#entityMentionTypes} is parsed as this      * parameter.      */
specifier|protected
name|NamedEntityTokenFilter
parameter_list|(
name|TokenStream
name|input
parameter_list|,
name|AnalysedText
name|at
parameter_list|,
name|String
name|lang
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|neTypes
parameter_list|,
name|NavigableMap
argument_list|<
name|int
index|[]
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|nePhrasesTypes
parameter_list|)
block|{
name|super
argument_list|(
name|input
argument_list|)
expr_stmt|;
comment|//STANBOL-1177: add attributes in doPrivileged to avoid
comment|//AccessControlException: access denied ("java.lang.RuntimePermission" "getClassLoader")
name|termAtt
operator|=
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|PrivilegedAction
argument_list|<
name|CharTermAttribute
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|CharTermAttribute
name|run
parameter_list|()
block|{
return|return
name|addAttribute
argument_list|(
name|CharTermAttribute
operator|.
name|class
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|offset
operator|=
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|PrivilegedAction
argument_list|<
name|OffsetAttribute
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|OffsetAttribute
name|run
parameter_list|()
block|{
return|return
name|addAttribute
argument_list|(
name|OffsetAttribute
operator|.
name|class
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|taggable
operator|=
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|PrivilegedAction
argument_list|<
name|TaggingAttribute
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|TaggingAttribute
name|run
parameter_list|()
block|{
return|return
name|addAttribute
argument_list|(
name|TaggingAttribute
operator|.
name|class
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|this
operator|.
name|at
operator|=
name|at
expr_stmt|;
name|this
operator|.
name|wildcardType
operator|=
name|neTypes
operator|==
literal|null
operator|||
name|neTypes
operator|.
name|contains
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|this
operator|.
name|neTypes
operator|=
name|neTypes
expr_stmt|;
name|this
operator|.
name|nePhrasesTypes
operator|=
name|nePhrasesTypes
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
specifier|public
name|void
name|reset
parameter_list|()
throws|throws
name|IOException
block|{
name|super
operator|.
name|reset
argument_list|()
expr_stmt|;
name|nePhrases
operator|=
operator|new
name|LinkedList
argument_list|<
name|Chunk
argument_list|>
argument_list|()
expr_stmt|;
name|neChunks
operator|=
operator|new
name|FilterIterator
argument_list|(
name|at
operator|.
name|getChunks
argument_list|()
argument_list|,
operator|new
name|NamedEntityPredicate
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|incrementToken
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|input
operator|.
name|incrementToken
argument_list|()
condition|)
block|{
name|incrementCount
operator|++
expr_stmt|;
if|if
condition|(
name|log
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"> solr:[{},{}] {}"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|offset
operator|.
name|startOffset
argument_list|()
block|,
name|offset
operator|.
name|endOffset
argument_list|()
block|,
name|termAtt
block|}
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|neChunk
operator|==
literal|null
operator|||
name|neChunk
operator|.
name|getEnd
argument_list|()
operator|<
name|offset
operator|.
name|startOffset
argument_list|()
operator|)
operator|&&
name|neChunks
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|neChunk
operator|=
name|neChunks
operator|.
name|next
argument_list|()
expr_stmt|;
name|nePhrases
operator|.
name|add
argument_list|(
name|neChunk
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|neChunk
operator|==
literal|null
condition|)
block|{
name|taggable
operator|.
name|setTaggable
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|incrementCount
operator|++
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"lookup percentage: {}"
argument_list|,
name|lookupCount
operator|*
literal|100
operator|/
operator|(
name|float
operator|)
name|incrementCount
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|.
name|endOffset
argument_list|()
operator|>
name|neChunk
operator|.
name|getStart
argument_list|()
operator|||
name|offset
operator|.
name|startOffset
argument_list|()
operator|<
name|neChunk
operator|.
name|getEnd
argument_list|()
condition|)
block|{
comment|//set tagable to true if the tokens overlapps with the current chunk
name|taggable
operator|.
name|setTaggable
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|log
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"lookup: token [{},{}]: {} | named Entity [{},{}]:{}"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|offset
operator|.
name|startOffset
argument_list|()
block|,
name|offset
operator|.
name|endOffset
argument_list|()
block|,
name|termAtt
block|,
name|neChunk
operator|.
name|getStart
argument_list|()
block|,
name|neChunk
operator|.
name|getEnd
argument_list|()
block|,
name|neChunk
operator|.
name|getSpan
argument_list|()
block|}
argument_list|)
expr_stmt|;
block|}
name|lookupCount
operator|++
expr_stmt|;
block|}
else|else
block|{
name|taggable
operator|.
name|setTaggable
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|incrementCount
operator|++
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
comment|//no more tokens in the parent token stream
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|reduce
parameter_list|(
name|TagLL
index|[]
name|head
parameter_list|)
block|{
comment|//(1) reduce Tags based on named entity phrases.
for|for
control|(
name|TagLL
name|tag
init|=
name|head
index|[
literal|0
index|]
init|;
name|tag
operator|!=
literal|null
condition|;
name|tag
operator|=
name|tag
operator|.
name|getNextTag
argument_list|()
control|)
block|{
name|int
name|start
init|=
name|tag
operator|.
name|getStartOffset
argument_list|()
decl_stmt|;
name|int
name|end
init|=
name|tag
operator|.
name|getEndOffset
argument_list|()
decl_stmt|;
name|Chunk
name|nePhrase
init|=
name|nePhrases
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|nePhrases
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
name|nePhrase
operator|!=
literal|null
operator|&&
name|nePhrase
operator|.
name|getEnd
argument_list|()
operator|<=
name|start
condition|)
block|{
name|nePhrases
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|nePhrase
operator|=
name|nePhrases
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|nePhrases
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nePhrase
operator|==
literal|null
operator|||
operator|!
operator|(
name|start
operator|<=
name|nePhrase
operator|.
name|getStart
argument_list|()
operator|&&
name|end
operator|>=
name|nePhrase
operator|.
name|getEnd
argument_list|()
operator|)
condition|)
block|{
comment|//does not cover any named entity phrase
name|tag
operator|.
name|removeLL
argument_list|()
expr_stmt|;
comment|//remove the tag from the cluster
if|if
condition|(
name|log
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"> reduce tag {} - does not cover {}"
argument_list|,
name|tag
argument_list|,
name|nePhrase
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|log
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
comment|//the current Tag coveres a named entity phrase
name|log
operator|.
name|trace
argument_list|(
literal|"> keep tag {} for {}"
argument_list|,
name|tag
argument_list|,
name|nePhrase
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * {@link Predicate} used to select Named Entities based on matching       * {@link NerTag#getTag()} and {@link NerTag#getType()} values against the      * {@link NamedEntityTokenFilter#neTypes} configuration. As a side effect      * this also collects the {@link NamedEntityTokenFilter#nePhrasesTypes}      * information. This avoids a 2nd pass over the {@link AnalysedText} to      * collect those information      * @author Rupert Westenthaler      *      */
specifier|final
class|class
name|NamedEntityPredicate
implements|implements
name|Predicate
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|evaluate
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|Chunk
condition|)
block|{
name|Chunk
name|chunk
init|=
operator|(
name|Chunk
operator|)
name|o
decl_stmt|;
name|Value
argument_list|<
name|NerTag
argument_list|>
name|nerValue
init|=
name|chunk
operator|.
name|getAnnotation
argument_list|(
name|NER_ANNOTATION
argument_list|)
decl_stmt|;
if|if
condition|(
name|nerValue
operator|!=
literal|null
condition|)
block|{
name|NerTag
name|nerTag
init|=
name|nerValue
operator|.
name|value
argument_list|()
decl_stmt|;
name|String
name|nerType
init|=
name|nerTag
operator|.
name|getType
argument_list|()
operator|!=
literal|null
condition|?
name|nerTag
operator|.
name|getType
argument_list|()
operator|.
name|getUnicodeString
argument_list|()
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|wildcardType
operator|||
name|neTypes
operator|.
name|contains
argument_list|(
name|nerTag
operator|.
name|getTag
argument_list|()
argument_list|)
operator|||
operator|(
name|nerType
operator|!=
literal|null
operator|&&
name|neTypes
operator|.
name|contains
argument_list|(
name|nerType
argument_list|)
operator|)
condition|)
block|{
name|int
index|[]
name|span
init|=
operator|new
name|int
index|[]
block|{
name|chunk
operator|.
name|getStart
argument_list|()
block|,
name|chunk
operator|.
name|getEnd
argument_list|()
block|}
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|types
init|=
name|nePhrasesTypes
operator|.
name|get
argument_list|(
name|span
argument_list|)
decl_stmt|;
if|if
condition|(
name|types
operator|==
literal|null
condition|)
block|{
name|types
operator|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|nePhrasesTypes
operator|.
name|put
argument_list|(
name|span
argument_list|,
name|types
argument_list|)
expr_stmt|;
block|}
name|types
operator|.
name|add
argument_list|(
name|nerType
argument_list|)
expr_stmt|;
name|types
operator|.
name|add
argument_list|(
name|nerTag
operator|.
name|getTag
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
block|}
block|}
end_class

end_unit

