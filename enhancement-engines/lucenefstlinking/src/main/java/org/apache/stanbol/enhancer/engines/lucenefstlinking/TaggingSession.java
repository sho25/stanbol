begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|lucenefstlinking
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Language
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Literal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|UriRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|impl
operator|.
name|PlainLiteralImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Field
operator|.
name|Store
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|StringField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexableField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|queries
operator|.
name|function
operator|.
name|valuesource
operator|.
name|IfFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|schema
operator|.
name|SchemaField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|search
operator|.
name|SolrIndexSearcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|util
operator|.
name|RefCounted
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|lucenefstlinking
operator|.
name|Match
operator|.
name|FieldLoader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|lucenefstlinking
operator|.
name|Match
operator|.
name|FieldType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|lucenefstlinking
operator|.
name|cache
operator|.
name|EntityCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|lucenefstlinking
operator|.
name|impl
operator|.
name|ValueSourceAccessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|ContentItem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|EngineException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|EnhancementEngine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|opensextant
operator|.
name|solrtexttagger
operator|.
name|TaggerFstCorpus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Profile created based on the {@link IndexConfiguration} for processing a  * parsed ContentItem.<p>  *   * @author Rupert Westenthaler  *  */
end_comment

begin_class
specifier|public
class|class
name|TaggingSession
implements|implements
name|Closeable
block|{
specifier|private
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TaggingSession
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
name|String
name|language
decl_stmt|;
specifier|private
name|Corpus
name|langCorpus
decl_stmt|;
specifier|private
name|Corpus
name|defaultCorpus
decl_stmt|;
comment|/**      * The Solr document id field holding the URI of the Entity.      */
specifier|protected
specifier|final
name|String
name|idField
decl_stmt|;
comment|/**      * The Solr field holding the labels in the language of the current Document      */
specifier|protected
specifier|final
name|String
name|labelField
decl_stmt|;
specifier|protected
specifier|final
name|Language
name|labelLang
decl_stmt|;
comment|/**      * The Solr field holding the labels in the default matching language or      *<code>null</code> if the same as {@link #labelField}      */
specifier|protected
specifier|final
name|String
name|defaultLabelField
decl_stmt|;
specifier|protected
specifier|final
name|Language
name|defaultLabelLang
decl_stmt|;
specifier|protected
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|solrDocfields
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|IndexConfiguration
name|config
decl_stmt|;
specifier|protected
specifier|final
name|String
name|typeField
decl_stmt|;
specifier|protected
specifier|final
name|String
name|redirectField
decl_stmt|;
specifier|protected
specifier|final
name|String
name|rankingField
decl_stmt|;
specifier|private
specifier|final
name|RefCounted
argument_list|<
name|SolrIndexSearcher
argument_list|>
name|searcherRef
decl_stmt|;
comment|/*      * Document Cache and session statistics for the cache      */
specifier|private
name|RefCounted
argument_list|<
name|EntityCache
argument_list|>
name|documentCacheRef
decl_stmt|;
specifier|private
name|int
name|docLoaded
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|docCached
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|docAppended
init|=
literal|0
decl_stmt|;
comment|//private final ValueSourceAccessor uniqueKeyCache;
comment|//private final Map<Integer,Match> matchPool = new HashMap<Integer,Match>(2048);
specifier|private
specifier|final
name|FieldLoaderImpl
name|fieldLoader
decl_stmt|;
name|TaggingSession
parameter_list|(
name|String
name|language
parameter_list|,
name|IndexConfiguration
name|config
parameter_list|)
throws|throws
name|CorpusException
block|{
name|this
operator|.
name|language
operator|=
name|language
expr_stmt|;
name|this
operator|.
name|config
operator|=
name|config
expr_stmt|;
name|CorpusInfo
name|langCorpusInfo
init|=
name|config
operator|.
name|getCorpus
argument_list|(
name|language
argument_list|)
decl_stmt|;
name|CorpusInfo
name|defaultCorpusInfo
init|=
name|config
operator|.
name|getDefaultCorpus
argument_list|()
decl_stmt|;
comment|//obtain the Solr Document Id field
name|SchemaField
name|idSchemaField
init|=
name|config
operator|.
name|getIndex
argument_list|()
operator|.
name|getSchema
argument_list|()
operator|.
name|getUniqueKeyField
argument_list|()
decl_stmt|;
name|idField
operator|=
name|idSchemaField
operator|.
name|getName
argument_list|()
expr_stmt|;
name|solrDocfields
operator|.
name|add
argument_list|(
name|idField
argument_list|)
expr_stmt|;
comment|//obtain the language specific fields for the session
if|if
condition|(
name|langCorpusInfo
operator|==
literal|null
operator|&&
name|defaultCorpusInfo
operator|==
literal|null
condition|)
block|{
comment|//this should not happen, because the canEnhance method of the
comment|//engine should  already reject such calls
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"No FST Corpus configured for language '"
operator|+
name|language
operator|+
literal|"' and also no default FST Corpus is present.!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|langCorpusInfo
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|langCorpus
operator|=
operator|new
name|Corpus
argument_list|(
name|langCorpusInfo
argument_list|,
name|obtainFstCorpus
argument_list|(
name|langCorpusInfo
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|labelField
operator|=
name|langCorpusInfo
operator|.
name|storedField
expr_stmt|;
name|solrDocfields
operator|.
name|add
argument_list|(
name|labelField
argument_list|)
expr_stmt|;
name|this
operator|.
name|labelLang
operator|=
name|langCorpusInfo
operator|.
name|language
operator|==
literal|null
operator|||
name|StringUtils
operator|.
name|isBlank
argument_list|(
name|langCorpusInfo
operator|.
name|language
argument_list|)
condition|?
literal|null
else|:
operator|new
name|Language
argument_list|(
name|langCorpusInfo
operator|.
name|language
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|labelField
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|labelLang
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|defaultCorpusInfo
operator|!=
literal|null
operator|&&
operator|!
name|defaultCorpusInfo
operator|.
name|equals
argument_list|(
name|langCorpusInfo
argument_list|)
condition|)
block|{
name|this
operator|.
name|defaultCorpus
operator|=
operator|new
name|Corpus
argument_list|(
name|defaultCorpusInfo
argument_list|,
name|obtainFstCorpus
argument_list|(
name|defaultCorpusInfo
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|defaultLabelField
operator|=
name|defaultCorpusInfo
operator|.
name|storedField
expr_stmt|;
name|solrDocfields
operator|.
name|add
argument_list|(
name|defaultLabelField
argument_list|)
expr_stmt|;
name|this
operator|.
name|defaultLabelLang
operator|=
name|defaultCorpusInfo
operator|.
name|language
operator|==
literal|null
operator|||
name|StringUtils
operator|.
name|isBlank
argument_list|(
name|defaultCorpusInfo
operator|.
name|language
argument_list|)
condition|?
literal|null
else|:
operator|new
name|Language
argument_list|(
name|defaultCorpusInfo
operator|.
name|language
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|defaultCorpus
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|defaultLabelField
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|defaultLabelLang
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|defaultCorpus
operator|==
literal|null
operator|&&
name|this
operator|.
name|langCorpus
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|CorpusException
argument_list|(
literal|"Unable to initialise a FST corpus for language '"
operator|+
name|language
operator|+
literal|"'. Neigher the language specific Coprpus (field : "
operator|+
name|langCorpusInfo
operator|!=
literal|null
condition|?
name|langCorpusInfo
operator|.
name|indexedField
else|:
literal|"<undefined>"
operator|+
literal|") nor for the default language (field: "
operator|+
name|defaultCorpusInfo
operator|!=
literal|null
condition|?
name|defaultCorpusInfo
operator|.
name|indexedField
else|:
literal|"<undefined>"
operator|+
literal|") is currently available!"
argument_list|,
literal|null
argument_list|)
throw|;
block|}
if|if
condition|(
name|config
operator|.
name|getTypeField
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|typeField
operator|=
name|config
operator|.
name|getTypeField
argument_list|()
expr_stmt|;
name|solrDocfields
operator|.
name|add
argument_list|(
name|typeField
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|typeField
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|config
operator|.
name|getRedirectField
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|redirectField
operator|=
name|config
operator|.
name|getRedirectField
argument_list|()
expr_stmt|;
name|solrDocfields
operator|.
name|add
argument_list|(
name|redirectField
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|redirectField
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|config
operator|.
name|getRankingField
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|rankingField
operator|=
name|config
operator|.
name|getRankingField
argument_list|()
expr_stmt|;
name|solrDocfields
operator|.
name|add
argument_list|(
name|rankingField
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|rankingField
operator|=
literal|null
expr_stmt|;
block|}
name|searcherRef
operator|=
name|config
operator|.
name|getIndex
argument_list|()
operator|.
name|getSearcher
argument_list|()
expr_stmt|;
name|SolrIndexSearcher
name|searcher
init|=
name|searcherRef
operator|.
name|get
argument_list|()
decl_stmt|;
name|documentCacheRef
operator|=
name|config
operator|.
name|getEntityCacheManager
argument_list|()
operator|.
name|getCache
argument_list|(
name|searcher
argument_list|)
expr_stmt|;
comment|//        uniqueKeyCache = null; //no longer used.
comment|//        uniqueKeyCache = new ValueSourceAccessor(searcher, idSchemaField.getType()
comment|//            .getValueSource(idSchemaField, null));
name|fieldLoader
operator|=
operator|new
name|FieldLoaderImpl
argument_list|(
name|searcher
operator|.
name|getIndexReader
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Used to instantiate {@link Match}es       * @param docId the Lucene document Id as returned by the FST corpus      * @return the Match instance      */
specifier|public
name|Match
name|createMatch
parameter_list|(
name|int
name|docId
parameter_list|)
block|{
return|return
operator|new
name|Match
argument_list|(
name|docId
argument_list|,
name|fieldLoader
argument_list|)
return|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{
comment|//matchPool.clear(); //clean up the matchpool
name|searcherRef
operator|.
name|decref
argument_list|()
expr_stmt|;
comment|//clean up the Solr index searcher reference
name|documentCacheRef
operator|.
name|decref
argument_list|()
expr_stmt|;
comment|//clean up the DocumentCache reference
block|}
comment|/**      * The language of this Session. This is typically the language detected for      * the document.      * @return the language of this Session      */
specifier|public
name|String
name|getLanguage
parameter_list|()
block|{
return|return
name|language
return|;
block|}
comment|//    public String getTypeField() {
comment|//        return config.getTypeField();
comment|//    }
comment|//    public String getRedirectField() {
comment|//        return config.getRedirectField();
comment|//    }
comment|//    public String getDefaultLabelField() {
comment|//        return defaultLabelField;
comment|//    }
comment|//    public Language getDefaultLabelLanguage() {
comment|//        return defaultLabelLang;
comment|//    }
comment|//    public String getLabelField() {
comment|//        return labelField;
comment|//    }
comment|//    public Language getLabelLanguage() {
comment|//        return labelLang;
comment|//    }
comment|//    /**
comment|//     * @return the langCorpus
comment|//     */
comment|//    public final CorpusInfo getLangCorpus() {
comment|//        return langCorpusInfo;
comment|//    }
comment|//    /**
comment|//     * @return the defaultCorpus
comment|//     */
comment|//    public final CorpusInfo getDefaultCorpus() {
comment|//        return defaultCorpusInfo;
comment|//    }
specifier|public
name|Corpus
name|getDefaultCorpus
parameter_list|()
block|{
return|return
name|defaultCorpus
return|;
block|}
specifier|public
name|Corpus
name|getLanguageCorpus
parameter_list|()
block|{
return|return
name|langCorpus
return|;
block|}
specifier|public
name|SolrIndexSearcher
name|getSearcher
parameter_list|()
block|{
return|return
name|searcherRef
operator|.
name|get
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|TaggingSession
name|createSession
parameter_list|(
name|IndexConfiguration
name|indexConfig
parameter_list|,
name|String
name|language
parameter_list|)
throws|throws
name|CorpusException
block|{
name|TaggingSession
name|session
init|=
operator|new
name|TaggingSession
argument_list|(
name|language
argument_list|,
name|indexConfig
argument_list|)
decl_stmt|;
return|return
name|session
return|;
block|}
specifier|public
name|EntityCache
name|getDocumentCache
parameter_list|()
block|{
return|return
name|documentCacheRef
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**      * The number of Lucene Documents loaded form disc in this session so far      * @return      */
specifier|public
name|int
name|getSessionDocLoaded
parameter_list|()
block|{
return|return
name|docLoaded
return|;
block|}
comment|/**      * The number of Lucene Documents retrieved from the {@link #getDocumentCache()}      * in this session so far      * @return      */
specifier|public
name|int
name|getSessionDocCached
parameter_list|()
block|{
return|return
name|docCached
return|;
block|}
comment|/**      * The number of Lucene Documents retrived from the {@link #getDocumentCache()},      * but with missing fields from the Cache. For such documents the additional      * fields (typically labels of different languages) where readed from disc and      * added to the cached document.      * @return      */
specifier|public
name|int
name|getSessionDocAppended
parameter_list|()
block|{
return|return
name|docAppended
return|;
block|}
comment|/**      * Obtains the FST corpus for the parsed CorpusInfo. The other parameters      * are just used for error messages in case this is not successful.      * @param fstInfo the info about the corpus      * @param ci the contentIteem (just used for logging and error messages)      * @return      * @throws CorpusException      */
specifier|private
name|TaggerFstCorpus
name|obtainFstCorpus
parameter_list|(
name|CorpusInfo
name|fstInfo
parameter_list|)
throws|throws
name|CorpusException
block|{
name|TaggerFstCorpus
name|fstCorpus
decl_stmt|;
synchronized|synchronized
init|(
name|fstInfo
init|)
block|{
comment|// one at a time
name|fstCorpus
operator|=
name|fstInfo
operator|.
name|getCorpus
argument_list|()
expr_stmt|;
if|if
condition|(
name|fstCorpus
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|fstInfo
operator|.
name|isEnqueued
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|CorpusException
argument_list|(
literal|"The FST corpus for language '"
operator|+
name|fstInfo
operator|.
name|language
operator|+
literal|"' is enqueued for creation, but not yet "
operator|+
literal|"available. Try at a  later point in time"
argument_list|,
literal|null
argument_list|)
throw|;
block|}
if|if
condition|(
name|fstInfo
operator|.
name|isFstCreationError
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|CorpusException
argument_list|(
name|fstInfo
operator|.
name|getErrorMessage
argument_list|()
argument_list|,
literal|null
argument_list|)
throw|;
block|}
if|if
condition|(
name|fstInfo
operator|.
name|isFstFileError
argument_list|()
operator|&&
name|fstInfo
operator|.
name|allowCreation
condition|)
block|{
comment|//try to recreate the FST corpus
if|if
condition|(
name|config
operator|.
name|getExecutorService
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// TODO: this code should get moved to a CorpusManager class
name|config
operator|.
name|getExecutorService
argument_list|()
operator|.
name|execute
argument_list|(
operator|new
name|CorpusCreationTask
argument_list|(
name|config
argument_list|,
name|fstInfo
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|CorpusException
argument_list|(
literal|"The FST corpus for language '"
operator|+
name|fstInfo
operator|.
name|language
operator|+
literal|"' was invalid and is now "
operator|+
literal|"enqueued for re-creation. Retry at a  later "
operator|+
literal|"point in time."
argument_list|,
literal|null
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|CorpusException
argument_list|(
name|fstInfo
operator|.
name|getErrorMessage
argument_list|()
argument_list|,
literal|null
argument_list|)
throw|;
block|}
block|}
block|}
block|}
return|return
name|fstCorpus
return|;
block|}
comment|/**      * {@link FieldLoader} implementation used to create {@link Match} instances      */
specifier|private
class|class
name|FieldLoaderImpl
implements|implements
name|FieldLoader
block|{
specifier|private
specifier|static
specifier|final
name|String
name|LOADED_FIELDS_FIELD_NAME
init|=
literal|"__loadedFields__"
decl_stmt|;
specifier|private
name|List
argument_list|<
name|Field
argument_list|>
name|loadedFieldsFields
decl_stmt|;
specifier|private
specifier|final
name|IndexReader
name|reader
decl_stmt|;
comment|/**          * Cache similar to the {@link EntityCache}, but with a scope bound to          * life cycle of this FieldLoaderImpl instance (a single TaggingSession).          * This cache ensures the Lucene Documents are not loaded twice while          * processing the same document (even if no EntiyCache is configured or          * the size of the EntityCache is to small).          */
specifier|private
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Document
argument_list|>
name|sessionCache
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|Document
argument_list|>
argument_list|()
decl_stmt|;
comment|/**          * The EntityCache instance that caches entity data over multiple sessions          */
specifier|private
specifier|final
name|EntityCache
name|cache
decl_stmt|;
specifier|public
name|FieldLoaderImpl
parameter_list|(
name|IndexReader
name|reader
parameter_list|)
block|{
name|this
operator|.
name|reader
operator|=
name|reader
expr_stmt|;
name|loadedFieldsFields
operator|=
operator|new
name|ArrayList
argument_list|<
name|Field
argument_list|>
argument_list|(
name|solrDocfields
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|loadedFieldName
range|:
name|solrDocfields
control|)
block|{
name|loadedFieldsFields
operator|.
name|add
argument_list|(
operator|new
name|StringField
argument_list|(
name|LOADED_FIELDS_FIELD_NAME
argument_list|,
name|loadedFieldName
argument_list|,
name|Store
operator|.
name|NO
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|cache
operator|=
name|documentCacheRef
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|FieldType
argument_list|,
name|Object
argument_list|>
name|load
parameter_list|(
name|int
name|id
parameter_list|)
throws|throws
name|IOException
block|{
comment|//load the Lucene Document for the id
name|Integer
name|ID
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|Document
name|doc
init|=
name|sessionCache
operator|.
name|get
argument_list|(
name|ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
block|{
name|doc
operator|=
name|cache
operator|.
name|get
argument_list|(
name|ID
argument_list|)
expr_stmt|;
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
block|{
name|doc
operator|=
name|reader
operator|.
name|document
argument_list|(
name|id
argument_list|,
name|solrDocfields
argument_list|)
expr_stmt|;
comment|//if we read a doc from the index we need to add information about
comment|//the fields we loaded (especially the languages of labels loaded
comment|//NOTE that those information will never be stored in the index. They
comment|//are only kept in-memory when caching this document.
for|for
control|(
name|Field
name|loadedFieldsField
range|:
name|loadedFieldsFields
control|)
block|{
name|doc
operator|.
name|add
argument_list|(
name|loadedFieldsField
argument_list|)
expr_stmt|;
block|}
name|docLoaded
operator|++
expr_stmt|;
name|cache
operator|.
name|cache
argument_list|(
name|ID
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//we need to check if the fields of the cached doc are sufficient
comment|//for the requested Solr Document fields
name|Set
argument_list|<
name|String
argument_list|>
name|fields
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|solrDocfields
argument_list|)
decl_stmt|;
name|String
index|[]
name|loaded
init|=
name|doc
operator|.
name|getValues
argument_list|(
name|LOADED_FIELDS_FIELD_NAME
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|loaded
operator|.
name|length
operator|&&
operator|!
name|fields
operator|.
name|isEmpty
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|fields
operator|.
name|remove
argument_list|(
name|loaded
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fields
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//we are missing some fields
comment|//need to load it from the index
name|Document
name|tmp
init|=
name|reader
operator|.
name|document
argument_list|(
name|id
argument_list|,
name|fields
argument_list|)
decl_stmt|;
comment|//add the additional fields to the cached doc
for|for
control|(
name|IndexableField
name|field
range|:
name|tmp
operator|.
name|getFields
argument_list|()
control|)
block|{
name|doc
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
comment|//also update the loaded fields
for|for
control|(
name|String
name|loadedField
range|:
name|fields
control|)
block|{
name|doc
operator|.
name|add
argument_list|(
operator|new
name|StringField
argument_list|(
name|LOADED_FIELDS_FIELD_NAME
argument_list|,
name|loadedField
argument_list|,
name|Store
operator|.
name|NO
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//NOTE: no need to update the cache, as we have updated the
comment|//cached value.
comment|//cache.cache(ID, doc);
name|docAppended
operator|++
expr_stmt|;
block|}
else|else
block|{
name|docCached
operator|++
expr_stmt|;
block|}
comment|//and put the doc in the sessionCache
block|}
comment|//add this doc to the session cache
name|sessionCache
operator|.
name|put
argument_list|(
name|ID
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
comment|//else { //document is in the session cache ... just use it
comment|//NOTE: The session cache has a minor side effect on the
comment|// EntityCache. Because multiple occurrences of an Entity
comment|// within the Document are not requested on the EntityCache
comment|// LRU based implementations will get slightly different
comment|// statistics. Assuming that the maximum size of the EntityCache
comment|// is>> as the number of Documents matching for the current Text
comment|// this effect can be considered as negligible.
comment|//}
if|if
condition|(
name|doc
operator|!=
literal|null
condition|)
block|{
name|Map
argument_list|<
name|FieldType
argument_list|,
name|Object
argument_list|>
name|values
init|=
operator|new
name|EnumMap
argument_list|<
name|Match
operator|.
name|FieldType
argument_list|,
name|Object
argument_list|>
argument_list|(
name|FieldType
operator|.
name|class
argument_list|)
decl_stmt|;
comment|//load the ID
name|values
operator|.
name|put
argument_list|(
name|FieldType
operator|.
name|id
argument_list|,
name|doc
operator|.
name|get
argument_list|(
name|idField
argument_list|)
argument_list|)
expr_stmt|;
comment|//load the labels
name|Set
argument_list|<
name|Literal
argument_list|>
name|labels
init|=
operator|new
name|HashSet
argument_list|<
name|Literal
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|label
range|:
name|doc
operator|.
name|getValues
argument_list|(
name|labelField
argument_list|)
control|)
block|{
name|labels
operator|.
name|add
argument_list|(
operator|new
name|PlainLiteralImpl
argument_list|(
name|label
argument_list|,
name|labelLang
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|defaultLabelField
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|label
range|:
name|doc
operator|.
name|getValues
argument_list|(
name|defaultLabelField
argument_list|)
control|)
block|{
name|labels
operator|.
name|add
argument_list|(
operator|new
name|PlainLiteralImpl
argument_list|(
name|label
argument_list|,
name|defaultLabelLang
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|values
operator|.
name|put
argument_list|(
name|FieldType
operator|.
name|label
argument_list|,
name|labels
argument_list|)
expr_stmt|;
comment|//load the types
if|if
condition|(
name|typeField
operator|!=
literal|null
condition|)
block|{
name|Set
argument_list|<
name|UriRef
argument_list|>
name|types
init|=
operator|new
name|HashSet
argument_list|<
name|UriRef
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|type
range|:
name|doc
operator|.
name|getValues
argument_list|(
name|typeField
argument_list|)
control|)
block|{
name|types
operator|.
name|add
argument_list|(
operator|new
name|UriRef
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|values
operator|.
name|put
argument_list|(
name|FieldType
operator|.
name|type
argument_list|,
name|types
argument_list|)
expr_stmt|;
block|}
comment|//load the redirects
if|if
condition|(
name|redirectField
operator|!=
literal|null
condition|)
block|{
name|Set
argument_list|<
name|UriRef
argument_list|>
name|redirects
init|=
operator|new
name|HashSet
argument_list|<
name|UriRef
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|redirect
range|:
name|doc
operator|.
name|getValues
argument_list|(
name|redirectField
argument_list|)
control|)
block|{
name|redirects
operator|.
name|add
argument_list|(
operator|new
name|UriRef
argument_list|(
name|redirect
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|values
operator|.
name|put
argument_list|(
name|FieldType
operator|.
name|redirect
argument_list|,
name|redirects
argument_list|)
expr_stmt|;
block|}
comment|//load the rankings
if|if
condition|(
name|rankingField
operator|!=
literal|null
condition|)
block|{
name|Number
name|num
init|=
name|doc
operator|.
name|getField
argument_list|(
name|rankingField
argument_list|)
operator|.
name|numericValue
argument_list|()
decl_stmt|;
name|Double
name|ranking
decl_stmt|;
if|if
condition|(
name|num
operator|instanceof
name|Double
condition|)
block|{
name|ranking
operator|=
operator|(
name|Double
operator|)
name|num
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|num
operator|!=
literal|null
condition|)
block|{
name|ranking
operator|=
name|Double
operator|.
name|valueOf
argument_list|(
name|num
operator|.
name|doubleValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//num == null
name|String
name|value
init|=
name|doc
operator|.
name|get
argument_list|(
name|rankingField
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|ranking
operator|=
name|Double
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|ranking
operator|=
literal|null
expr_stmt|;
block|}
block|}
else|else
block|{
name|ranking
operator|=
literal|null
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ranking
operator|!=
literal|null
condition|)
block|{
name|values
operator|.
name|put
argument_list|(
name|FieldType
operator|.
name|ranking
argument_list|,
name|ranking
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|values
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No document found for Lucene doc id '"
operator|+
name|id
operator|+
literal|"'!"
argument_list|)
throw|;
block|}
block|}
block|}
specifier|public
class|class
name|Corpus
block|{
specifier|private
name|CorpusInfo
name|corpusInfo
decl_stmt|;
specifier|private
name|TaggerFstCorpus
name|fst
decl_stmt|;
name|Corpus
parameter_list|(
name|CorpusInfo
name|corpusInfo
parameter_list|,
name|TaggerFstCorpus
name|fst
parameter_list|)
block|{
name|this
operator|.
name|corpusInfo
operator|=
name|corpusInfo
expr_stmt|;
name|this
operator|.
name|fst
operator|=
name|fst
expr_stmt|;
block|}
specifier|public
name|String
name|getLanugage
parameter_list|()
block|{
return|return
name|corpusInfo
operator|.
name|language
return|;
block|}
specifier|public
name|Analyzer
name|getAnalyzer
parameter_list|()
block|{
return|return
name|corpusInfo
operator|.
name|analyzer
return|;
block|}
specifier|public
name|TaggerFstCorpus
name|getFst
parameter_list|()
block|{
return|return
name|fst
return|;
block|}
specifier|public
name|String
name|getIndexedField
parameter_list|()
block|{
return|return
name|corpusInfo
operator|.
name|indexedField
return|;
block|}
specifier|public
name|String
name|getStoredField
parameter_list|()
block|{
return|return
name|corpusInfo
operator|.
name|storedField
return|;
block|}
block|}
block|}
end_class

end_unit

