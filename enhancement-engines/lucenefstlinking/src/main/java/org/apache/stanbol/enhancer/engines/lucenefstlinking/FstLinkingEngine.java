begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|lucenefstlinking
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|utils
operator|.
name|NlpEngineHelper
operator|.
name|getAnalysedText
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|utils
operator|.
name|NlpEngineHelper
operator|.
name|getLanguage
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|EnhancementEngineHelper
operator|.
name|getSelectionContext
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|DC_CONTRIBUTOR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|ENHANCER_END
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|ENHANCER_ENTITY_REFERENCE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|ENHANCER_START
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|RDF_TYPE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|TechnicalClasses
operator|.
name|ENHANCER_TEXTANNOTATION
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Language
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Literal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|LiteralFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|MGraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Triple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|UriRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|impl
operator|.
name|PlainLiteralImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|impl
operator|.
name|TripleImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|input
operator|.
name|CharSequenceReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|TokenStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IntsRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|OpenBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|core
operator|.
name|SolrCore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|EntitySearcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|config
operator|.
name|EntityLinkerConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|config
operator|.
name|TextProcessingConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|engine
operator|.
name|EntityLinkingEngine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|impl
operator|.
name|LinkedEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|impl
operator|.
name|Suggestion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|lucenefstlinking
operator|.
name|TaggingSession
operator|.
name|Corpus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|model
operator|.
name|AnalysedText
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|ContentItem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|EngineException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|EnhancementEngine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|ServiceProperties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|EnhancementEngineHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|NamespaceEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|opensextant
operator|.
name|solrtexttagger
operator|.
name|TagClusterReducer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|opensextant
operator|.
name|solrtexttagger
operator|.
name|Tagger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_class
specifier|public
class|class
name|FstLinkingEngine
implements|implements
name|EnhancementEngine
implements|,
name|ServiceProperties
block|{
specifier|private
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|FstLinkingEngine
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * Use the same {@link ServiceProperties#ENHANCEMENT_ENGINE_ORDERING} as the      * {@link EntityLinkingEngine#DEFAULT_ORDER}      */
specifier|public
specifier|static
specifier|final
name|Integer
name|ENGINE_ORDERING
init|=
name|EntityLinkingEngine
operator|.
name|DEFAULT_ORDER
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|SERVICE_PROPERTIES
init|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|Collections
operator|.
name|singletonMap
argument_list|(
name|ServiceProperties
operator|.
name|ENHANCEMENT_ENGINE_ORDERING
argument_list|,
operator|(
name|Object
operator|)
name|ENGINE_ORDERING
argument_list|)
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|UriRef
name|ENHANCER_ENTITY_RANKING
init|=
operator|new
name|UriRef
argument_list|(
name|NamespaceEnum
operator|.
name|fise
operator|+
literal|"entity-ranking"
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|LiteralFactory
name|literalFactory
init|=
name|LiteralFactory
operator|.
name|getInstance
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|String
name|name
decl_stmt|;
specifier|protected
specifier|final
name|TextProcessingConfig
name|tpConfig
decl_stmt|;
specifier|protected
specifier|final
name|EntityLinkerConfig
name|elConfig
decl_stmt|;
specifier|private
name|IndexConfiguration
name|indexConfig
decl_stmt|;
specifier|public
name|FstLinkingEngine
parameter_list|(
name|String
name|name
parameter_list|,
name|IndexConfiguration
name|indexConfig
parameter_list|,
name|TextProcessingConfig
name|tpConfig
parameter_list|,
name|EntityLinkerConfig
name|elConfig
parameter_list|)
block|{
if|if
condition|(
name|StringUtils
operator|.
name|isBlank
argument_list|(
name|name
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed name MUST NOT be NULL nor blank!"
argument_list|)
throw|;
block|}
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|indexConfig
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed IndexConfiguration MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|this
operator|.
name|indexConfig
operator|=
name|indexConfig
expr_stmt|;
if|if
condition|(
name|tpConfig
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Text Processing configuration MUST NOT be NULL"
argument_list|)
throw|;
block|}
name|this
operator|.
name|tpConfig
operator|=
name|tpConfig
expr_stmt|;
if|if
condition|(
name|elConfig
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Entity Linking configuration MUST NOT be NULL"
argument_list|)
throw|;
block|}
name|this
operator|.
name|elConfig
operator|=
name|elConfig
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|getServiceProperties
parameter_list|()
block|{
return|return
name|SERVICE_PROPERTIES
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|canEnhance
parameter_list|(
name|ContentItem
name|ci
parameter_list|)
throws|throws
name|EngineException
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"canEnhancer {}"
argument_list|,
name|ci
operator|.
name|getUri
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|language
init|=
name|getLanguage
argument_list|(
name|this
argument_list|,
name|ci
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|//(1) check if the language is enabled by the config
if|if
condition|(
name|language
operator|==
literal|null
operator|||
operator|!
name|indexConfig
operator|.
name|getFstConfig
argument_list|()
operator|.
name|isLanguage
argument_list|(
name|language
argument_list|)
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Engine {} ignores ContentItem {} becuase language {} is not condigured."
argument_list|,
operator|new
name|Object
index|[]
block|{
name|getName
argument_list|()
block|,
name|ci
operator|.
name|getUri
argument_list|()
block|,
name|language
block|}
argument_list|)
expr_stmt|;
return|return
name|CANNOT_ENHANCE
return|;
block|}
comment|//(2) check if we have a FST model for the language
if|if
condition|(
name|indexConfig
operator|.
name|getCorpus
argument_list|(
name|language
argument_list|)
operator|==
literal|null
operator|&&
comment|//for the language
name|indexConfig
operator|.
name|getDefaultCorpus
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|//a default model
name|log
operator|.
name|debug
argument_list|(
literal|"Engine {} ignores ContentItem {} becuase no FST modles for language {} "
operator|+
literal|"are available"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|getName
argument_list|()
block|,
name|ci
operator|.
name|getUri
argument_list|()
block|,
name|language
block|}
argument_list|)
expr_stmt|;
return|return
name|CANNOT_ENHANCE
return|;
block|}
comment|// we need a detected language, the AnalyzedText contentPart with
comment|// Tokens.
name|AnalysedText
name|at
init|=
name|getAnalysedText
argument_list|(
name|this
argument_list|,
name|ci
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|at
operator|!=
literal|null
operator|&&
name|at
operator|.
name|getTokens
argument_list|()
operator|.
name|hasNext
argument_list|()
condition|?
name|ENHANCE_ASYNC
else|:
name|CANNOT_ENHANCE
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|computeEnhancements
parameter_list|(
name|ContentItem
name|ci
parameter_list|)
throws|throws
name|EngineException
block|{
name|AnalysedText
name|at
init|=
name|getAnalysedText
argument_list|(
name|this
argument_list|,
name|ci
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"> AnalysedText {}"
argument_list|,
name|at
argument_list|)
expr_stmt|;
name|String
name|language
init|=
name|getLanguage
argument_list|(
name|this
argument_list|,
name|ci
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"> Language {}"
argument_list|,
name|language
argument_list|)
expr_stmt|;
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"computeEnhancements for ContentItem {} language {} text={}"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|ci
operator|.
name|getUri
argument_list|()
operator|.
name|getUnicodeString
argument_list|()
block|,
name|language
block|,
name|StringUtils
operator|.
name|abbreviate
argument_list|(
name|at
operator|.
name|getSpan
argument_list|()
argument_list|,
literal|100
argument_list|)
block|}
argument_list|)
expr_stmt|;
block|}
comment|// TODO: we need to do the same for the the default matching language
name|TaggingSession
name|session
decl_stmt|;
try|try
block|{
name|session
operator|=
name|TaggingSession
operator|.
name|createSession
argument_list|(
name|indexConfig
argument_list|,
name|language
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CorpusException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|EngineException
argument_list|(
name|this
argument_list|,
name|ci
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|long
name|taggingStart
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
specifier|final
name|NavigableMap
argument_list|<
name|int
index|[]
argument_list|,
name|Tag
argument_list|>
name|tags
init|=
operator|new
name|TreeMap
argument_list|<
name|int
index|[]
argument_list|,
name|Tag
argument_list|>
argument_list|(
name|Tag
operator|.
name|SPAN_COMPARATOR
argument_list|)
decl_stmt|;
try|try
block|{
comment|//process the language of the document
name|Corpus
name|corpus
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|session
operator|.
name|getLanguageCorpus
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|corpus
operator|=
name|session
operator|.
name|getLanguageCorpus
argument_list|()
expr_stmt|;
name|long
name|t
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|int
name|d
init|=
name|tag
argument_list|(
name|at
argument_list|,
name|session
argument_list|,
name|corpus
argument_list|,
name|tags
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|" - {}: fst: {}ms (callback: {}ms)"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|corpus
operator|.
name|getIndexedField
argument_list|()
block|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|t
block|,
name|d
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|session
operator|.
name|getDefaultCorpus
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|corpus
operator|==
literal|null
condition|)
block|{
name|corpus
operator|=
name|session
operator|.
name|getDefaultCorpus
argument_list|()
expr_stmt|;
block|}
name|long
name|t
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|int
name|d
init|=
name|tag
argument_list|(
name|at
argument_list|,
name|session
argument_list|,
name|session
operator|.
name|getDefaultCorpus
argument_list|()
argument_list|,
name|tags
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|" - {}: fst: {}ms (callback: {}ms)"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|session
operator|.
name|getDefaultCorpus
argument_list|()
operator|.
name|getIndexedField
argument_list|()
block|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|t
block|,
name|d
block|}
argument_list|)
expr_stmt|;
block|}
name|long
name|taggingEnd
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|corpus
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|EngineException
argument_list|(
name|this
argument_list|,
name|ci
argument_list|,
literal|"No FST corpus found to process contentItem "
operator|+
literal|"language '"
operator|+
name|session
operator|.
name|getLanguage
argument_list|()
operator|+
literal|"'!"
argument_list|,
literal|null
argument_list|)
throw|;
block|}
else|else
block|{
if|if
condition|(
name|session
operator|.
name|getLanguageCorpus
argument_list|()
operator|!=
literal|null
operator|&&
name|session
operator|.
name|getDefaultCorpus
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|" - sum fst: {} ms"
argument_list|,
name|taggingEnd
operator|-
name|taggingStart
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|matches
init|=
name|match
argument_list|(
name|at
argument_list|,
name|tags
operator|.
name|values
argument_list|()
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|" - loaded {} ({} loaded, {} cached, {} appended) Matches in {} ms"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|matches
block|,
name|session
operator|.
name|getSessionDocLoaded
argument_list|()
block|,
name|session
operator|.
name|getSessionDocCached
argument_list|()
block|,
name|session
operator|.
name|getSessionDocAppended
argument_list|()
block|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|taggingEnd
block|}
argument_list|)
expr_stmt|;
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
name|session
operator|.
name|getDocumentCache
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"EntityCache Statistics: {}"
argument_list|,
name|session
operator|.
name|getDocumentCache
argument_list|()
operator|.
name|printStatistics
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|EngineException
argument_list|(
name|this
argument_list|,
name|ci
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|session
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|log
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"Tagged Entities:"
argument_list|)
expr_stmt|;
for|for
control|(
name|Tag
name|tag
range|:
name|tags
operator|.
name|values
argument_list|()
control|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"[{},{}]: {}"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|tag
operator|.
name|getStart
argument_list|()
block|,
name|tag
operator|.
name|getEnd
argument_list|()
block|,
name|tag
operator|.
name|getMatches
argument_list|()
block|}
argument_list|)
expr_stmt|;
block|}
block|}
name|ci
operator|.
name|getLock
argument_list|()
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|writeEnhancements
argument_list|(
name|ci
argument_list|,
name|at
operator|.
name|getSpan
argument_list|()
argument_list|,
name|tags
operator|.
name|values
argument_list|()
argument_list|,
name|language
argument_list|,
name|elConfig
operator|.
name|isWriteEntityRankings
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|ci
operator|.
name|getLock
argument_list|()
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|tags
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|//help the GC
block|}
specifier|private
name|int
name|match
parameter_list|(
name|AnalysedText
name|at
parameter_list|,
name|Collection
argument_list|<
name|Tag
argument_list|>
name|tags
parameter_list|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"  ... process matches for {} extracted Tags:"
argument_list|,
name|tags
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|matchCount
init|=
literal|0
decl_stmt|;
name|String
name|text
init|=
name|at
operator|.
name|getSpan
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Tag
argument_list|>
name|tagIt
init|=
name|tags
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|tagIt
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Tag
name|tag
init|=
name|tagIt
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|anchor
init|=
name|text
operator|.
name|substring
argument_list|(
name|tag
operator|.
name|getStart
argument_list|()
argument_list|,
name|tag
operator|.
name|getEnd
argument_list|()
argument_list|)
decl_stmt|;
name|log
operator|.
name|trace
argument_list|(
literal|" {}: '{}'"
argument_list|,
name|tag
argument_list|,
name|anchor
argument_list|)
expr_stmt|;
name|tag
operator|.
name|setAnchor
argument_list|(
name|anchor
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elConfig
operator|.
name|isCaseSensitiveMatching
argument_list|()
condition|)
block|{
name|anchor
operator|=
name|anchor
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
expr_stmt|;
block|}
name|int
name|alength
init|=
name|anchor
operator|.
name|length
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Match
argument_list|>
name|suggestions
init|=
operator|new
name|ArrayList
argument_list|<
name|Match
argument_list|>
argument_list|(
name|tag
operator|.
name|getMatches
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
comment|//only for trace level debugging
for|for
control|(
name|Match
name|match
range|:
name|tag
operator|.
name|getMatches
argument_list|()
control|)
block|{
if|if
condition|(
name|log
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|" {}. {}"
argument_list|,
name|i
operator|++
argument_list|,
name|match
operator|.
name|getUri
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|matchCount
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|filterEntityByType
argument_list|(
name|match
operator|.
name|getTypes
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|)
condition|)
block|{
name|int
name|distance
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
name|Literal
name|matchLabel
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|Literal
argument_list|>
name|it
init|=
name|match
operator|.
name|getLabels
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
operator|&&
name|distance
operator|>
literal|0
condition|;
control|)
block|{
name|Literal
name|literal
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|label
init|=
name|literal
operator|.
name|getLexicalForm
argument_list|()
decl_stmt|;
name|int
name|d
decl_stmt|;
if|if
condition|(
operator|!
name|elConfig
operator|.
name|isCaseSensitiveMatching
argument_list|()
condition|)
block|{
name|label
operator|=
name|label
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
expr_stmt|;
block|}
name|d
operator|=
name|StringUtils
operator|.
name|getLevenshteinDistance
argument_list|(
name|anchor
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|<
name|distance
condition|)
block|{
name|distance
operator|=
name|d
expr_stmt|;
name|matchLabel
operator|=
name|literal
expr_stmt|;
block|}
block|}
if|if
condition|(
name|distance
operator|==
literal|0
condition|)
block|{
name|match
operator|.
name|setMatch
argument_list|(
literal|1.0
argument_list|,
name|matchLabel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|double
name|length
init|=
name|Math
operator|.
name|max
argument_list|(
name|alength
argument_list|,
name|matchLabel
operator|.
name|getLexicalForm
argument_list|()
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|match
operator|.
name|setMatch
argument_list|(
literal|1d
operator|-
operator|(
operator|(
name|double
operator|)
name|distance
operator|/
name|length
operator|)
argument_list|,
name|matchLabel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|match
operator|.
name|getScore
argument_list|()
operator|>=
name|elConfig
operator|.
name|getMinMatchScore
argument_list|()
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|" ... add suggestion: label: '{}'; conf: {}"
argument_list|,
name|matchLabel
argument_list|,
name|match
operator|.
name|getScore
argument_list|()
argument_list|)
expr_stmt|;
name|suggestions
operator|.
name|add
argument_list|(
name|match
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|trace
argument_list|(
literal|" ... filtered because match score< {}"
argument_list|,
name|elConfig
operator|.
name|getMinMatchScore
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//the type of the current Entity is blacklisted
name|log
operator|.
name|trace
argument_list|(
literal|"  ... filtered because of entity types"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|suggestions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|tagIt
operator|.
name|remove
argument_list|()
expr_stmt|;
comment|// remove this tag as no match is left
block|}
elseif|else
if|if
condition|(
name|suggestions
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|//if we have multiple suggestions
comment|//sort based on score
name|Collections
operator|.
name|sort
argument_list|(
name|suggestions
argument_list|,
name|Match
operator|.
name|SCORE_COMPARATOR
argument_list|)
expr_stmt|;
name|int
name|maxSuggestions
init|=
name|elConfig
operator|.
name|getMaxSuggestions
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|suggestions
operator|.
name|size
argument_list|()
operator|>
name|maxSuggestions
operator|+
literal|1
operator|)
operator|&&
name|elConfig
operator|.
name|isIncludeSuggestionsWithSimilarScore
argument_list|()
condition|)
block|{
comment|//include suggestions with similar score
name|double
name|minIncludeScore
init|=
name|suggestions
operator|.
name|get
argument_list|(
name|maxSuggestions
argument_list|)
operator|.
name|getScore
argument_list|()
decl_stmt|;
name|int
name|numInclude
init|=
name|maxSuggestions
operator|+
literal|1
decl_stmt|;
comment|//the next element
name|double
name|actScore
decl_stmt|;
do|do
block|{
name|actScore
operator|=
name|suggestions
operator|.
name|get
argument_list|(
name|numInclude
argument_list|)
operator|.
name|getScore
argument_list|()
expr_stmt|;
name|numInclude
operator|++
expr_stmt|;
comment|//increase for the next iteration
block|}
do|while
condition|(
name|numInclude
operator|<
name|suggestions
operator|.
name|size
argument_list|()
operator|&&
name|actScore
operator|>=
name|minIncludeScore
condition|)
do|;
name|maxSuggestions
operator|=
name|numInclude
operator|-
literal|1
expr_stmt|;
block|}
comment|//adapt score based on entity ranking
if|if
condition|(
name|elConfig
operator|.
name|isRankEqualScoresBasedOnEntityRankings
argument_list|()
condition|)
block|{
name|adaptScoresForEntityRankings
argument_list|(
name|suggestions
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|log
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
comment|//log the suggestion information
name|log
operator|.
name|trace
argument_list|(
literal|"Suggestions:"
argument_list|)
expr_stmt|;
name|int
name|si
init|=
literal|1
decl_stmt|;
for|for
control|(
name|Match
name|m
range|:
name|suggestions
control|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|" {}. {} - {} ({})"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|si
operator|<=
name|maxSuggestions
condition|?
name|si
else|:
literal|"--"
block|,
name|m
operator|.
name|getScore
argument_list|()
block|,
name|m
operator|.
name|getMatchLabel
argument_list|()
block|,
name|m
operator|.
name|getUri
argument_list|()
block|}
argument_list|)
expr_stmt|;
name|si
operator|++
expr_stmt|;
block|}
block|}
comment|//remove all suggestions> maxSuggestions
if|if
condition|(
name|suggestions
operator|.
name|size
argument_list|()
operator|>
name|maxSuggestions
condition|)
block|{
name|suggestions
operator|.
name|subList
argument_list|(
name|maxSuggestions
argument_list|,
name|suggestions
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
name|tag
operator|.
name|setSuggestions
argument_list|(
name|suggestions
argument_list|)
expr_stmt|;
block|}
return|return
name|matchCount
return|;
block|}
comment|/**      * Applies the configured entity type based filters      * @param entityTypes      * @return      */
specifier|private
name|boolean
name|filterEntityByType
parameter_list|(
name|Iterator
argument_list|<
name|UriRef
argument_list|>
name|entityTypes
parameter_list|)
block|{
name|Map
argument_list|<
name|UriRef
argument_list|,
name|Integer
argument_list|>
name|whiteList
init|=
name|elConfig
operator|.
name|getWhitelistedTypes
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|UriRef
argument_list|,
name|Integer
argument_list|>
name|blackList
init|=
name|elConfig
operator|.
name|getBlacklistedTypes
argument_list|()
decl_stmt|;
name|Integer
name|w
init|=
literal|null
decl_stmt|;
name|Integer
name|b
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|entityTypes
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|UriRef
name|type
init|=
name|entityTypes
operator|.
name|next
argument_list|()
decl_stmt|;
name|Integer
name|act
init|=
name|whiteList
operator|.
name|get
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|act
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|w
operator|==
literal|null
operator|||
name|act
operator|.
name|compareTo
argument_list|(
name|w
argument_list|)
operator|<
literal|0
condition|)
block|{
name|w
operator|=
name|act
expr_stmt|;
block|}
if|if
condition|(
name|act
operator|.
name|intValue
argument_list|()
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
name|act
operator|=
name|blackList
operator|.
name|get
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|act
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|b
operator|==
literal|null
operator|||
name|act
operator|.
name|compareTo
argument_list|(
name|b
argument_list|)
operator|<
literal|0
condition|)
block|{
name|b
operator|=
name|act
expr_stmt|;
block|}
if|if
condition|(
name|act
operator|.
name|intValue
argument_list|()
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
block|}
if|if
condition|(
name|w
operator|==
literal|null
operator|&&
name|b
operator|==
literal|null
condition|)
block|{
return|return
operator|!
name|elConfig
operator|.
name|isDefaultWhitelistTypes
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|w
operator|!=
literal|null
condition|)
block|{
return|return
name|b
operator|==
literal|null
operator|||
name|w
operator|.
name|compareTo
argument_list|(
name|b
argument_list|)
operator|<
literal|0
condition|?
literal|false
else|:
literal|true
return|;
block|}
else|else
block|{
comment|//w == null&& b != null
return|return
literal|true
return|;
comment|//filter
block|}
block|}
comment|/**      * Uses the {@link Corpus} to tag the the {@link AnalysedText} and adds       * tagging results to the parsed tag map.      * @param at the AnalyzedText      * @param session the tagging session of the text      * @param corpus the corpus o the session to tag the content with      * @param tags the Tags map used to store the tagging results      * @return the time in milliseconds spent in the tag callback.      * @throws IOException on any error while accessing the {@link SolrCore}      */
specifier|private
name|int
name|tag
parameter_list|(
specifier|final
name|AnalysedText
name|at
parameter_list|,
specifier|final
name|TaggingSession
name|session
parameter_list|,
specifier|final
name|Corpus
name|corpus
parameter_list|,
specifier|final
name|Map
argument_list|<
name|int
index|[]
argument_list|,
name|Tag
argument_list|>
name|tags
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|OpenBitSet
name|matchDocIdsBS
init|=
operator|new
name|OpenBitSet
argument_list|(
name|session
operator|.
name|getSearcher
argument_list|()
operator|.
name|maxDoc
argument_list|()
argument_list|)
decl_stmt|;
name|TokenStream
name|baseTokenStream
init|=
name|corpus
operator|.
name|getTaggingAnalyzer
argument_list|()
operator|.
name|tokenStream
argument_list|(
literal|""
argument_list|,
operator|new
name|CharSequenceReader
argument_list|(
name|at
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|LinkableTokenFilter
name|linkableTokenFilter
init|=
operator|new
name|LinkableTokenFilter
argument_list|(
name|baseTokenStream
argument_list|,
name|at
argument_list|,
name|session
operator|.
name|getLanguage
argument_list|()
argument_list|,
name|tpConfig
operator|.
name|getConfiguration
argument_list|(
name|session
operator|.
name|getLanguage
argument_list|()
argument_list|)
argument_list|,
name|elConfig
operator|.
name|getMinChunkMatchScore
argument_list|()
argument_list|,
name|elConfig
operator|.
name|getMinFoundTokens
argument_list|()
argument_list|)
decl_stmt|;
comment|//we use two TagClusterReducer implementations.
comment|// (1) the linkableTokenFilter filters all tags that do not overlap any
comment|//     linkable Token
comment|// (2) the LONGEST_DOMINANT_RIGHT reducer (TODO: make configurable)
name|TagClusterReducer
name|reducer
init|=
operator|new
name|ChainedTagClusterReducer
argument_list|(
name|linkableTokenFilter
argument_list|,
name|TagClusterReducer
operator|.
name|ALL
argument_list|)
decl_stmt|;
specifier|final
name|long
index|[]
name|time
init|=
operator|new
name|long
index|[]
block|{
literal|0
block|}
decl_stmt|;
operator|new
name|Tagger
argument_list|(
name|corpus
operator|.
name|getFst
argument_list|()
argument_list|,
name|linkableTokenFilter
argument_list|,
name|reducer
argument_list|,
name|session
operator|.
name|isSkipAltTokens
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|tagCallback
parameter_list|(
name|int
name|startOffset
parameter_list|,
name|int
name|endOffset
parameter_list|,
name|long
name|docIdsKey
parameter_list|)
block|{
name|long
name|start
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|log
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"> tagCallback for {}"
argument_list|,
name|at
operator|.
name|getText
argument_list|()
operator|.
name|subSequence
argument_list|(
name|startOffset
argument_list|,
name|endOffset
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|int
index|[]
name|span
init|=
operator|new
name|int
index|[]
block|{
name|startOffset
block|,
name|endOffset
block|}
decl_stmt|;
name|Tag
name|tag
init|=
name|tags
operator|.
name|get
argument_list|(
name|span
argument_list|)
decl_stmt|;
if|if
condition|(
name|tag
operator|==
literal|null
condition|)
block|{
name|tag
operator|=
operator|new
name|Tag
argument_list|(
name|span
argument_list|)
expr_stmt|;
name|tags
operator|.
name|put
argument_list|(
name|span
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
comment|// below caches, and also flags matchDocIdsBS
name|Set
argument_list|<
name|Match
argument_list|>
name|matches
init|=
name|createMatches
argument_list|(
name|docIdsKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|log
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"  - {} matches"
argument_list|,
name|matches
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|tag
operator|.
name|addIds
argument_list|(
name|matches
argument_list|)
expr_stmt|;
name|long
name|dif
init|=
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|start
decl_stmt|;
name|time
index|[
literal|0
index|]
operator|=
name|time
index|[
literal|0
index|]
operator|+
name|dif
expr_stmt|;
block|}
comment|//NOTE: We can not use a cache, because we need to create different
comment|//      Match instances even for the same 'docIdsKey'. This is because
comment|//      the same result list might get generated for different
comment|//      surface forms in the text (e.g. if the SolrIndex is case
comment|//      insensitive, but the linking does consider the case when
comment|//      calculating the score). If we would use this cache Match
comment|//      instances would be used for several occurrences in the text
comment|//      and Match#getScore() values would get overridden when
comment|//      processing those multiple occurrences.
comment|//Map<Long,Set<Match>> docIdsListCache = new HashMap<Long,Set<Match>>(1024);
specifier|private
name|Set
argument_list|<
name|Match
argument_list|>
name|createMatches
parameter_list|(
name|long
name|docIdsKey
parameter_list|)
block|{
name|IntsRef
name|docIds
init|=
name|lookupDocIds
argument_list|(
name|docIdsKey
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|Match
argument_list|>
name|matches
init|=
operator|new
name|HashSet
argument_list|<
name|Match
argument_list|>
argument_list|(
name|docIds
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|docIds
operator|.
name|offset
init|;
name|i
operator|<
name|docIds
operator|.
name|offset
operator|+
name|docIds
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|docId
init|=
name|docIds
operator|.
name|ints
index|[
name|i
index|]
decl_stmt|;
name|matchDocIdsBS
operator|.
name|set
argument_list|(
name|docId
argument_list|)
expr_stmt|;
comment|// also, flip docid in bitset
name|matches
operator|.
name|add
argument_list|(
name|session
operator|.
name|createMatch
argument_list|(
name|docId
argument_list|)
argument_list|)
expr_stmt|;
comment|// translates here
block|}
return|return
name|matches
return|;
block|}
block|}
operator|.
name|process
argument_list|()
expr_stmt|;
return|return
call|(
name|int
call|)
argument_list|(
name|time
index|[
literal|0
index|]
operator|/
literal|1000000
argument_list|)
return|;
block|}
comment|/**      * Adapts the scores of Matches with the same {@link Match#getScore() score}      * but different {@link Match#getRanking() entity rankings} in a way that      * suggestions with a higher ranking do have a slightly better score. The      * score difference is never higher as<code>0.1</code>.      * @param matches the matches      */
specifier|private
name|void
name|adaptScoresForEntityRankings
parameter_list|(
name|List
argument_list|<
name|Match
argument_list|>
name|matches
parameter_list|)
block|{
name|List
argument_list|<
name|Match
argument_list|>
name|equalScoreList
init|=
operator|new
name|ArrayList
argument_list|<
name|Match
argument_list|>
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|double
name|score
init|=
literal|2f
decl_stmt|;
for|for
control|(
name|Match
name|match
range|:
name|matches
control|)
block|{
name|double
name|actScore
init|=
name|match
operator|.
name|getScore
argument_list|()
decl_stmt|;
if|if
condition|(
name|score
operator|==
name|actScore
condition|)
block|{
name|equalScoreList
operator|.
name|add
argument_list|(
name|match
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|equalScoreList
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|adaptScoreForEntityRankings
argument_list|(
name|equalScoreList
argument_list|,
name|actScore
argument_list|)
expr_stmt|;
block|}
name|score
operator|=
name|actScore
expr_stmt|;
name|equalScoreList
operator|.
name|clear
argument_list|()
expr_stmt|;
name|equalScoreList
operator|.
name|add
argument_list|(
name|match
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|equalScoreList
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|adaptScoreForEntityRankings
argument_list|(
name|equalScoreList
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|//resort by score
name|Collections
operator|.
name|sort
argument_list|(
name|matches
argument_list|,
name|Match
operator|.
name|SCORE_COMPARATOR
argument_list|)
expr_stmt|;
block|}
comment|/**      * This method slightly adapts scores of Suggestions based on the Entity ranking.      * It is used for Suggestions that would have the exact same score (e.g. 1.0) to      * ensure ordering of the suggestions based on the rankings of the Entities      * within the knowledge base linked against      * @param equalScoreList Entities with the same {@link Suggestion#getScore()}      * values. If this is not the case this method will change scores in unintended      * ways      * @param nextScore the score of the {@link Suggestion} with a lower score as the      * list of suggestions parsed in the first parameter      */
specifier|private
name|void
name|adaptScoreForEntityRankings
parameter_list|(
name|List
argument_list|<
name|Match
argument_list|>
name|equalScoreList
parameter_list|,
name|double
name|nextScore
parameter_list|)
block|{
name|double
name|score
init|=
name|equalScoreList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getScore
argument_list|()
decl_stmt|;
name|log
operator|.
name|trace
argument_list|(
literal|"> Adapt Score of multiple Suggestions "
operator|+
literal|"with '{}' based on EntityRanking"
argument_list|,
name|score
argument_list|)
expr_stmt|;
comment|//Adapt the score to reflect the entity ranking
comment|//but do not change order with entities of different
comment|//score. Also do not change the score more that 0.1
comment|//TODO: make the max change (0.1) configurable
name|double
name|dif
init|=
operator|(
name|Math
operator|.
name|min
argument_list|(
literal|0.1
argument_list|,
name|score
operator|-
name|nextScore
argument_list|)
operator|)
operator|/
name|equalScoreList
operator|.
name|size
argument_list|()
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|equalScoreList
argument_list|,
name|Match
operator|.
name|ENTITY_RANK_COMPARATOR
argument_list|)
expr_stmt|;
name|log
operator|.
name|trace
argument_list|(
literal|"    - keep socre of {} at {}"
argument_list|,
name|equalScoreList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getUri
argument_list|()
argument_list|,
name|score
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|equalScoreList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|score
operator|=
name|score
operator|-
name|dif
expr_stmt|;
if|if
condition|(
name|Match
operator|.
name|ENTITY_RANK_COMPARATOR
operator|.
name|compare
argument_list|(
name|equalScoreList
operator|.
name|get
argument_list|(
name|i
operator|-
literal|1
argument_list|)
argument_list|,
name|equalScoreList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|equalScoreList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|updateScore
argument_list|(
name|score
argument_list|)
expr_stmt|;
name|log
operator|.
name|trace
argument_list|(
literal|"    - set score of {} to {}"
argument_list|,
name|equalScoreList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getUri
argument_list|()
argument_list|,
name|score
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|double
name|lastScore
init|=
name|equalScoreList
operator|.
name|get
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|.
name|getScore
argument_list|()
decl_stmt|;
name|equalScoreList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|updateScore
argument_list|(
name|lastScore
argument_list|)
expr_stmt|;
name|log
operator|.
name|trace
argument_list|(
literal|"    - set score of {} to {}"
argument_list|,
name|equalScoreList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getUri
argument_list|()
argument_list|,
name|lastScore
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Writes the Enhancements for the {@link LinkedEntity LinkedEntities}      * extracted from the parsed ContentItem      * @param ci      * @param tags      * @param language      */
specifier|private
name|void
name|writeEnhancements
parameter_list|(
name|ContentItem
name|ci
parameter_list|,
name|String
name|text
parameter_list|,
name|Collection
argument_list|<
name|Tag
argument_list|>
name|tags
parameter_list|,
name|String
name|language
parameter_list|,
name|boolean
name|writeRankings
parameter_list|)
block|{
name|Language
name|languageObject
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|language
operator|!=
literal|null
operator|&&
operator|!
name|language
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|languageObject
operator|=
operator|new
name|Language
argument_list|(
name|language
argument_list|)
expr_stmt|;
block|}
name|MGraph
name|metadata
init|=
name|ci
operator|.
name|getMetadata
argument_list|()
decl_stmt|;
for|for
control|(
name|Tag
name|tag
range|:
name|tags
control|)
block|{
name|Collection
argument_list|<
name|UriRef
argument_list|>
name|textAnnotations
init|=
operator|new
name|ArrayList
argument_list|<
name|UriRef
argument_list|>
argument_list|(
name|tags
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|//first create the TextAnnotations for the Occurrences
name|Literal
name|startLiteral
init|=
name|literalFactory
operator|.
name|createTypedLiteral
argument_list|(
name|tag
operator|.
name|getStart
argument_list|()
argument_list|)
decl_stmt|;
name|Literal
name|endLiteral
init|=
name|literalFactory
operator|.
name|createTypedLiteral
argument_list|(
name|tag
operator|.
name|getEnd
argument_list|()
argument_list|)
decl_stmt|;
comment|//search for existing text annotation
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|it
init|=
name|metadata
operator|.
name|filter
argument_list|(
literal|null
argument_list|,
name|ENHANCER_START
argument_list|,
name|startLiteral
argument_list|)
decl_stmt|;
name|UriRef
name|textAnnotation
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Triple
name|t
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|metadata
operator|.
name|filter
argument_list|(
name|t
operator|.
name|getSubject
argument_list|()
argument_list|,
name|ENHANCER_END
argument_list|,
name|endLiteral
argument_list|)
operator|.
name|hasNext
argument_list|()
operator|&&
name|metadata
operator|.
name|filter
argument_list|(
name|t
operator|.
name|getSubject
argument_list|()
argument_list|,
name|RDF_TYPE
argument_list|,
name|ENHANCER_TEXTANNOTATION
argument_list|)
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|textAnnotation
operator|=
operator|(
name|UriRef
operator|)
name|t
operator|.
name|getSubject
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|textAnnotation
operator|==
literal|null
condition|)
block|{
comment|//not found ... create a new one
name|textAnnotation
operator|=
name|EnhancementEngineHelper
operator|.
name|createTextEnhancement
argument_list|(
name|ci
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|textAnnotation
argument_list|,
name|Properties
operator|.
name|ENHANCER_START
argument_list|,
name|startLiteral
argument_list|)
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|textAnnotation
argument_list|,
name|Properties
operator|.
name|ENHANCER_END
argument_list|,
name|endLiteral
argument_list|)
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|textAnnotation
argument_list|,
name|Properties
operator|.
name|ENHANCER_SELECTION_CONTEXT
argument_list|,
operator|new
name|PlainLiteralImpl
argument_list|(
name|getSelectionContext
argument_list|(
name|text
argument_list|,
name|tag
operator|.
name|getAnchor
argument_list|()
argument_list|,
name|tag
operator|.
name|getStart
argument_list|()
argument_list|)
argument_list|,
name|languageObject
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|textAnnotation
argument_list|,
name|Properties
operator|.
name|ENHANCER_SELECTED_TEXT
argument_list|,
operator|new
name|PlainLiteralImpl
argument_list|(
name|tag
operator|.
name|getAnchor
argument_list|()
argument_list|,
name|languageObject
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|textAnnotation
argument_list|,
name|Properties
operator|.
name|ENHANCER_CONFIDENCE
argument_list|,
name|literalFactory
operator|.
name|createTypedLiteral
argument_list|(
name|tag
operator|.
name|getScore
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//if existing add this engine as contributor
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|textAnnotation
argument_list|,
name|DC_CONTRIBUTOR
argument_list|,
operator|new
name|PlainLiteralImpl
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//add dc:types (even to existing)
for|for
control|(
name|UriRef
name|dcType
range|:
name|getDcTypes
argument_list|(
name|tag
operator|.
name|getSuggestions
argument_list|()
argument_list|)
control|)
block|{
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|textAnnotation
argument_list|,
name|Properties
operator|.
name|DC_TYPE
argument_list|,
name|dcType
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|textAnnotations
operator|.
name|add
argument_list|(
name|textAnnotation
argument_list|)
expr_stmt|;
comment|//now the EntityAnnotations for the Suggestions
for|for
control|(
name|Match
name|match
range|:
name|tag
operator|.
name|getSuggestions
argument_list|()
control|)
block|{
name|UriRef
name|entityAnnotation
init|=
name|EnhancementEngineHelper
operator|.
name|createEntityEnhancement
argument_list|(
name|ci
argument_list|,
name|this
argument_list|)
decl_stmt|;
comment|//should we use the label used for the match, or search the
comment|//representation for the best label ... currently its the matched one
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|entityAnnotation
argument_list|,
name|Properties
operator|.
name|ENHANCER_ENTITY_LABEL
argument_list|,
name|match
operator|.
name|getMatchLabel
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|entityAnnotation
argument_list|,
name|ENHANCER_ENTITY_REFERENCE
argument_list|,
operator|new
name|UriRef
argument_list|(
name|match
operator|.
name|getUri
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|UriRef
name|type
range|:
name|match
operator|.
name|getTypes
argument_list|()
control|)
block|{
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|entityAnnotation
argument_list|,
name|Properties
operator|.
name|ENHANCER_ENTITY_TYPE
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|entityAnnotation
argument_list|,
name|Properties
operator|.
name|ENHANCER_CONFIDENCE
argument_list|,
name|literalFactory
operator|.
name|createTypedLiteral
argument_list|(
name|match
operator|.
name|getScore
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|//add the relation to the fise:TextAnnotation (the tag)
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|entityAnnotation
argument_list|,
name|Properties
operator|.
name|DC_RELATION
argument_list|,
name|textAnnotation
argument_list|)
argument_list|)
expr_stmt|;
comment|//TODO: add origin information of the EntiySearcher
comment|//                for(Entry<UriRef,Collection<Resource>> originInfo : entitySearcher.getOriginInformation().entrySet()){
comment|//                    for(Resource value : originInfo.getValue()){
comment|//                        metadata.add(new TripleImpl(entityAnnotation,
comment|//                            originInfo.getKey(),value));
comment|//                    }
comment|//                }
if|if
condition|(
name|writeRankings
condition|)
block|{
name|Double
name|ranking
init|=
name|match
operator|.
name|getRanking
argument_list|()
decl_stmt|;
if|if
condition|(
name|ranking
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|entityAnnotation
argument_list|,
name|ENHANCER_ENTITY_RANKING
argument_list|,
name|literalFactory
operator|.
name|createTypedLiteral
argument_list|(
name|ranking
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|//TODO: dereferencing
comment|//                if(linkerConfig.isDereferenceEntitiesEnabled()&&
comment|//                        dereferencedEntitis.add(entity.getUri())){ //not yet dereferenced
comment|//                    //add all outgoing triples for this entity
comment|//                    //NOTE: do not add all triples as there might be other data in the graph
comment|//                    for(Iterator<Triple> triples = entity.getData().filter(entity.getUri(), null, null);
comment|//                            triples.hasNext();metadata.add(triples.next()));
comment|//                }
block|}
block|}
block|}
comment|/**      * Retrieves all {@link EntitySearcher#getEncodedTypeField()} values of the parsed      * {@link Suggestion}s and than lookup the {@link NamespaceEnum#dcTerms dc}:type      * values for the {@link LinkedEntity#getTypes()} by using the configured      * {@link EntityLinkerConfig#getTypeMappings() types mappings} (and if      * no mapping is found the {@link EntityLinkerConfig#getDefaultDcType()       * default} type.      * @param conceptTypes The list of suggestions      * @return the types values for the {@link LinkedEntity}      */
specifier|private
name|Set
argument_list|<
name|UriRef
argument_list|>
name|getDcTypes
parameter_list|(
name|List
argument_list|<
name|Match
argument_list|>
name|matches
parameter_list|)
block|{
if|if
condition|(
name|matches
operator|==
literal|null
operator|||
name|matches
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|Collections
operator|.
name|emptySet
argument_list|()
return|;
block|}
name|Collection
argument_list|<
name|UriRef
argument_list|>
name|conceptTypes
init|=
operator|new
name|HashSet
argument_list|<
name|UriRef
argument_list|>
argument_list|()
decl_stmt|;
name|double
name|score
init|=
operator|-
literal|1
decl_stmt|;
comment|//only consider types of the best ranked Entities
for|for
control|(
name|Match
name|match
range|:
name|matches
control|)
block|{
name|double
name|actScore
init|=
name|match
operator|.
name|getScore
argument_list|()
decl_stmt|;
if|if
condition|(
name|actScore
operator|<
name|score
condition|)
block|{
break|break;
block|}
name|score
operator|=
name|actScore
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|UriRef
argument_list|>
name|types
init|=
name|match
operator|.
name|getTypes
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|types
operator|.
name|hasNext
argument_list|()
condition|;
name|conceptTypes
operator|.
name|add
argument_list|(
name|types
operator|.
name|next
argument_list|()
argument_list|)
control|)
empty_stmt|;
block|}
name|Map
argument_list|<
name|UriRef
argument_list|,
name|UriRef
argument_list|>
name|typeMappings
init|=
name|elConfig
operator|.
name|getTypeMappings
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|UriRef
argument_list|>
name|dcTypes
init|=
operator|new
name|HashSet
argument_list|<
name|UriRef
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|UriRef
name|conceptType
range|:
name|conceptTypes
control|)
block|{
name|UriRef
name|dcType
init|=
name|typeMappings
operator|.
name|get
argument_list|(
name|conceptType
argument_list|)
decl_stmt|;
if|if
condition|(
name|dcType
operator|!=
literal|null
condition|)
block|{
name|dcTypes
operator|.
name|add
argument_list|(
name|dcType
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dcTypes
operator|.
name|isEmpty
argument_list|()
operator|&&
name|elConfig
operator|.
name|getDefaultDcType
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|dcTypes
operator|.
name|add
argument_list|(
name|elConfig
operator|.
name|getDefaultDcType
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|dcTypes
return|;
block|}
block|}
end_class

end_unit

