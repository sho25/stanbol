begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2012, FORMCEPT [http://www.formcept.com]  *  *  Licensed under the Apache License, Version 2.0 (the "License");  *  you may not use this file except in compliance with the License.  *  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engine
operator|.
name|disambiguation
operator|.
name|mlt
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|DC_RELATION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|ENHANCER_CONFIDENCE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|RDFS_LABEL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Dictionary
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|LiteralFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|commons
operator|.
name|rdf
operator|.
name|Graph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|commons
operator|.
name|rdf
operator|.
name|Triple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|commons
operator|.
name|rdf
operator|.
name|IRI
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|commons
operator|.
name|rdf
operator|.
name|impl
operator|.
name|utils
operator|.
name|TripleImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Activate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Component
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Deactivate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Property
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Reference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Service
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|Blob
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|ContentItem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|EngineException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|EnhancementEngine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|InvalidContentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|ServiceProperties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|ContentItemHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|EnhancementEngineHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|impl
operator|.
name|AbstractEnhancementEngine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|NamespaceEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|defaults
operator|.
name|SpecialFieldEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Entity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Representation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|rdf
operator|.
name|RdfResourceEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|Constraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|FieldQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|QueryResultList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|SimilarityConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|TextConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|site
operator|.
name|Site
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|site
operator|.
name|SiteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|site
operator|.
name|SiteManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|service
operator|.
name|cm
operator|.
name|ConfigurationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|service
operator|.
name|component
operator|.
name|ComponentContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Disambiguation Engine using Entityhub {@link SimilarityConstraint}s to disambiguate between existing  * fise:EntityAnnotations for fise:TextAnnotations.  *<p>  *<b>TODOs</b>:  *<ul>  *<li>Configurations: currently all configurations is set to the defaults  *<li>Context: test and improve different ways to determine the context used for disambiguation.  *<li>URI based similarity: currently only full text similarity is used. However it would also be possible to  * use the {@link SpecialFieldEnum#references} field to disambiguate based on URIs of already suggested  * Entities.  *</ul>  *   * @author Kritarth Anand  * @author Rupert Westenthaler  */
end_comment

begin_class
annotation|@
name|Component
argument_list|(
name|immediate
operator|=
literal|true
argument_list|,
name|metatype
operator|=
literal|true
argument_list|)
annotation|@
name|Service
annotation|@
name|Properties
argument_list|(
name|value
operator|=
block|{
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|EnhancementEngine
operator|.
name|PROPERTY_NAME
argument_list|,
name|value
operator|=
literal|"disambiguation-mlt"
argument_list|)
block|}
argument_list|)
specifier|public
class|class
name|DisambiguatorEngine
extends|extends
name|AbstractEnhancementEngine
argument_list|<
name|IOException
argument_list|,
name|RuntimeException
argument_list|>
implements|implements
name|EnhancementEngine
implements|,
name|ServiceProperties
block|{
specifier|private
specifier|static
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|DisambiguatorEngine
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * Service URL      */
specifier|private
name|String
name|serviceURL
decl_stmt|;
comment|/**      * The default value for the execution of this Engine. Currently set to      * {@link ServiceProperties#ORDERING_POST_PROCESSING} + 90.      *<p>      * This should ensure that this engines runs as one of the first engines of the post-processing phase      */
specifier|public
specifier|static
specifier|final
name|Integer
name|defaultOrder
init|=
name|ServiceProperties
operator|.
name|ORDERING_POST_PROCESSING
operator|-
literal|90
decl_stmt|;
comment|/**      * The plain text might be required for determining the extraction context      */
specifier|public
specifier|static
specifier|final
name|String
name|PLAIN_TEXT_MIMETYPE
init|=
literal|"text/plain"
decl_stmt|;
comment|/**      * Contains the only supported mime type {@link #PLAIN_TEXT_MIMETYPE}      */
specifier|public
specifier|static
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|SUPPORTED_MIMETYPES
init|=
name|Collections
operator|.
name|singleton
argument_list|(
name|PLAIN_TEXT_MIMETYPE
argument_list|)
decl_stmt|;
comment|/**      * Used to lookup the Entityhub {@link Site} used to perform the disambiguation.      */
annotation|@
name|Reference
specifier|protected
name|SiteManager
name|siteManager
decl_stmt|;
comment|/*      * The following parameters describe the ratio of the original fise:confidence values and the      * disambiguation scores contributing to the final disambiguated fise:confidence      *       * TODO: make configurable      */
comment|/**      * Default ratio for Disambiguation (2.0)      */
specifier|public
specifier|static
specifier|final
name|double
name|DEFAULT_DISAMBIGUATION_RATIO
init|=
literal|2.0
decl_stmt|;
comment|/**      * Default ratio for the original fise:confidence of suggested entities      */
specifier|public
specifier|static
specifier|final
name|double
name|DEFAULT_CONFIDNECE_RATIO
init|=
literal|1.0
decl_stmt|;
comment|/**      * The weight for disambiguation scores<code>:= disRatio/(disRatio+confRatio)</code>      */
specifier|private
name|double
name|disambiguationWeight
init|=
name|DEFAULT_DISAMBIGUATION_RATIO
operator|/
operator|(
name|DEFAULT_DISAMBIGUATION_RATIO
operator|+
name|DEFAULT_CONFIDNECE_RATIO
operator|)
decl_stmt|;
comment|/**      * The weight for the original confidence scores<code>:= confRatio/(disRatio+confRatio)</code>      */
specifier|private
name|double
name|confidenceWeight
init|=
name|DEFAULT_CONFIDNECE_RATIO
operator|/
operator|(
name|DEFAULT_DISAMBIGUATION_RATIO
operator|+
name|DEFAULT_CONFIDNECE_RATIO
operator|)
decl_stmt|;
comment|/**      * The {@link LiteralFactory} used to create typed RDF literals      */
specifier|private
specifier|final
name|LiteralFactory
name|literalFactory
init|=
name|LiteralFactory
operator|.
name|getInstance
argument_list|()
decl_stmt|;
comment|/**      * Returns the properties containing the {@link ServiceProperties#ENHANCEMENT_ENGINE_ORDERING}      */
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|getServiceProperties
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|Collections
operator|.
name|singletonMap
argument_list|(
name|ENHANCEMENT_ENGINE_ORDERING
argument_list|,
operator|(
name|Object
operator|)
name|defaultOrder
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|canEnhance
parameter_list|(
name|ContentItem
name|ci
parameter_list|)
throws|throws
name|EngineException
block|{
comment|// check if content is present
try|try
block|{
if|if
condition|(
operator|(
name|ContentItemHelper
operator|.
name|getText
argument_list|(
name|ci
operator|.
name|getBlob
argument_list|()
argument_list|)
operator|==
literal|null
operator|)
operator|||
operator|(
name|ContentItemHelper
operator|.
name|getText
argument_list|(
name|ci
operator|.
name|getBlob
argument_list|()
argument_list|)
operator|.
name|trim
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
return|return
name|CANNOT_ENHANCE
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Failed to get the text for "
operator|+
literal|"enhancement of content: "
operator|+
name|ci
operator|.
name|getUri
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|InvalidContentException
argument_list|(
name|this
argument_list|,
name|ci
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// default enhancement is synchronous enhancement
return|return
name|ENHANCE_SYNCHRONOUS
return|;
block|}
comment|/*      * This function first evaluates all the possible ambiguations of each text annotation detected. the text      * of all entities detected is used for making a Dbpedia query with all string for MLT that contain all      * the other entities. The results obtained are used to calcualte new confidence values which are updated      * in the metadata.      */
annotation|@
name|Override
specifier|public
name|void
name|computeEnhancements
parameter_list|(
name|ContentItem
name|ci
parameter_list|)
throws|throws
name|EngineException
block|{
name|String
name|textContent
decl_stmt|;
name|Entry
argument_list|<
name|IRI
argument_list|,
name|Blob
argument_list|>
name|textBlob
init|=
name|ContentItemHelper
operator|.
name|getBlob
argument_list|(
name|ci
argument_list|,
name|SUPPORTED_MIMETYPES
argument_list|)
decl_stmt|;
if|if
condition|(
name|textBlob
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|textContent
operator|=
name|ContentItemHelper
operator|.
name|getText
argument_list|(
name|textBlob
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to retieve plain text content for ContentItem "
operator|+
name|ci
operator|.
name|getUri
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|textContent
operator|=
literal|null
expr_stmt|;
block|}
block|}
else|else
block|{
name|textContent
operator|=
literal|null
expr_stmt|;
block|}
name|Graph
name|graph
init|=
name|ci
operator|.
name|getMetadata
argument_list|()
decl_stmt|;
comment|// (1) read the data from the content item
name|String
name|contentLangauge
decl_stmt|;
name|DisambiguationData
name|disData
decl_stmt|;
name|ci
operator|.
name|getLock
argument_list|()
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|contentLangauge
operator|=
name|EnhancementEngineHelper
operator|.
name|getLanguage
argument_list|(
name|ci
argument_list|)
expr_stmt|;
comment|// NOTE (rwesten): moved the parsing of the information from the
comment|// contentItem to static method of the Class holding those information
comment|// (similar as it already was for SavedEntity)
comment|// readEntities(loseConfidence, allEntities, textAnnotations, graph);
name|disData
operator|=
name|DisambiguationData
operator|.
name|createFromContentItem
argument_list|(
name|ci
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|ci
operator|.
name|getLock
argument_list|()
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|// (2) Disambiguate the SavedEntities
for|for
control|(
name|SavedEntity
name|savedEntity
range|:
name|disData
operator|.
name|textAnnotations
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|savedEntity
operator|.
name|getSuggestions
argument_list|()
operator|.
name|size
argument_list|()
operator|<=
literal|1
condition|)
block|{
comment|// we need not to disambiguate if only one suggestion is present
continue|continue;
block|}
comment|// NOTE: the site is determined from the
comment|// fise:TextAnnotation<-- dc:relation --
comment|// fise:EntityAnnotation -- entityhub:ste --> "{siteName}"^^xsd:string
comment|// data.
comment|// TODO: add configuration to include/exclude Sites by name
name|Site
name|site
init|=
name|siteManager
operator|.
name|getSite
argument_list|(
name|savedEntity
operator|.
name|getSite
argument_list|()
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|String
argument_list|>
name|types
init|=
literal|null
decl_stmt|;
comment|// potential types of entities
name|boolean
name|casesensitive
init|=
literal|false
decl_stmt|;
comment|// TODO: make configurable
name|String
name|savedEntityLabel
init|=
name|casesensitive
condition|?
name|savedEntity
operator|.
name|getName
argument_list|()
else|:
name|savedEntity
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
comment|// Determine the context used for disambiguation
comment|// TODO: make this configurable options
name|String
name|disambiguationContext
decl_stmt|;
comment|// (0.a) The easiest way is to just use the selection context
comment|// disambiguationContext = savedEntity.getContext();
comment|// (0.b) Calculate a context based on a moving window
name|String
name|window
init|=
name|getDisambiguationContext
argument_list|(
name|textContent
argument_list|,
name|savedEntity
operator|.
name|getName
argument_list|()
argument_list|,
name|savedEntity
operator|.
name|getStart
argument_list|()
argument_list|,
literal|100
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Use Window: '{}' for '{}'"
argument_list|,
name|window
argument_list|,
name|savedEntity
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
comment|// (1) The contextSelections:
comment|// All other selected text within the selection context
name|List
argument_list|<
name|String
argument_list|>
name|contextSelections
init|=
name|getSelectionsInContext
argument_list|(
name|savedEntity
operator|.
name|getName
argument_list|()
argument_list|,
name|disData
operator|.
name|allSelectedTexts
argument_list|,
name|window
argument_list|)
decl_stmt|;
comment|// savedEntity.getContext());
name|disambiguationContext
operator|=
name|unionString
argument_list|(
literal|false
argument_list|,
name|contextSelections
argument_list|)
expr_stmt|;
comment|// (2) I do not understand this variant (see comment for the
comment|// EntitiesInRange(..) method
comment|// List<String> L = EntitiesInRange(disData.directoryTextAnotation,
comment|// (savedEntity.getStart() + savedEntity.getEnd()) / 2);
comment|// disambiguationContext = unionString(false,contextSelections);
comment|// (3) one can build a combination of the above
comment|// disambiguationContext = unionString(true, //unique adds
comment|// Collections.singleton(savedEntity.getName()), //the selected text
comment|// Collections.singleton(context), //the context
comment|// contextSelections); //other selected parsed in the context
comment|// or just the name of the entity AND the context
comment|// disambiguationContext = unionString(false,
comment|// Collections.singleton(savedEntity.getName()),
comment|// contextSelections);
comment|// (4) TODO: I would also like to have the possibility to disambiguate
comment|// using URIs of Entities suggested for other TextAnnotations
comment|// within the context.
comment|// make the similarity query on the Entityhub using the collected
comment|// information
name|QueryResultList
argument_list|<
name|Entity
argument_list|>
name|results
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|" - Query '{}' for {}@{} with context '{}'"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|site
operator|.
name|getId
argument_list|()
block|,
name|savedEntityLabel
block|,
name|contentLangauge
block|,
name|disambiguationContext
block|}
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|StringUtils
operator|.
name|isBlank
argument_list|(
name|disambiguationContext
argument_list|)
condition|)
block|{
try|try
block|{
name|results
operator|=
name|query
argument_list|(
name|site
argument_list|,
name|savedEntityLabel
argument_list|,
name|contentLangauge
argument_list|,
name|disambiguationContext
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SiteException
name|e
parameter_list|)
block|{
comment|// TODO we could also try to catch those errors ...
throw|throw
operator|new
name|EngineException
argument_list|(
literal|"Unable to disambiguate Mention of '"
operator|+
name|savedEntity
operator|.
name|getName
argument_list|()
operator|+
literal|"' on Entityhub Site '"
operator|+
name|site
operator|.
name|getId
argument_list|()
operator|+
literal|"!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|log
operator|.
name|debug
argument_list|(
literal|" - {} results returned by query {}"
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|,
name|results
operator|.
name|getQuery
argument_list|()
argument_list|)
expr_stmt|;
comment|// match the results with the suggestions
name|disambiguateSuggestions
argument_list|(
name|results
argument_list|,
name|savedEntity
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|" - not disambiguated because of empty context!"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// (3) Write back the Results of the Disambiguation process
comment|// NOTE (rwesten): In the original version of Kritarth this was done as
comment|// part of (2) - disambiguation. This is now changed as in (2) the
comment|// disambiguation results are stored in the Suggestions and only
comment|// applied to the EnhancementStructure in (3). This allows to reduce the
comment|// coverage of the wirte lock needed to be applied to the ContentItem.
name|ci
operator|.
name|getLock
argument_list|()
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|applyDisambiguationResults
argument_list|(
name|graph
argument_list|,
name|disData
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|ci
operator|.
name|getLock
argument_list|()
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*      * Is used to query the Dbpedia with a entity as main constraint and then add string of all other entities      * detected as similarity constraints      */
specifier|protected
name|QueryResultList
argument_list|<
name|Entity
argument_list|>
name|query
parameter_list|(
name|Site
name|dbpediaSite
parameter_list|,
name|String
name|savedEntityLabel
parameter_list|,
name|String
name|language
parameter_list|,
name|String
name|extractionContext
parameter_list|)
throws|throws
name|SiteException
block|{
name|FieldQuery
name|query
init|=
name|dbpediaSite
operator|.
name|getQueryFactory
argument_list|()
operator|.
name|createFieldQuery
argument_list|()
decl_stmt|;
if|if
condition|(
name|savedEntityLabel
operator|!=
literal|null
operator|&&
operator|!
name|savedEntityLabel
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Constraint
name|labelConstraint
decl_stmt|;
if|if
condition|(
name|language
operator|!=
literal|null
condition|)
block|{
name|labelConstraint
operator|=
operator|new
name|TextConstraint
argument_list|(
name|savedEntityLabel
argument_list|,
literal|false
argument_list|,
name|language
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|labelConstraint
operator|=
operator|new
name|TextConstraint
argument_list|(
name|savedEntityLabel
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// TODO: what happens if a recommendation was not based on rdfs:label?
name|query
operator|.
name|setConstraint
argument_list|(
name|RDFS_LABEL
operator|.
name|getUnicodeString
argument_list|()
argument_list|,
name|labelConstraint
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"parsed label {} was empty or NULL. Will use Similarity constraint only!"
argument_list|,
name|savedEntityLabel
argument_list|)
expr_stmt|;
block|}
name|query
operator|.
name|setConstraint
argument_list|(
name|SpecialFieldEnum
operator|.
name|fullText
operator|.
name|getUri
argument_list|()
argument_list|,
operator|new
name|SimilarityConstraint
argument_list|(
name|extractionContext
argument_list|)
argument_list|)
expr_stmt|;
name|query
operator|.
name|setLimit
argument_list|(
literal|25
argument_list|)
expr_stmt|;
return|return
name|dbpediaSite
operator|.
name|findEntities
argument_list|(
name|query
argument_list|)
return|;
block|}
comment|/*      * If for an entity the Dbpedia query results in suggestion none of which match the already present      * ambiguations, we go with the ambiguations found earlier that is the ones we have with.      */
comment|// NOTE (rwesten): The disambiguateSuggestions now reduces confidence
comment|// values of Suggestions that are not within the disambiguation result
comment|// by the #confidenceWeight. So if not a single suggestion do match with
comment|// the disambiguation result the ambiguation is kept but the overall
comment|// fise:confidence values are reduced by #confidenceWeight (ensured to be
comment|// less than 1)
comment|// protected List<Triple> unchangedConfidences(List<IRI> subsumed,
comment|// Graph graph,
comment|// List<Triple> loseConfidence) {
comment|// for (int i = 0; i< subsumed.size(); i++) {
comment|// IRI uri = subsumed.get(i);
comment|// Iterator<Triple> confidenceTriple = graph.filter(uri, ENHANCER_CONFIDENCE, null);
comment|// while (confidenceTriple.hasNext()) {
comment|// loseConfidence.remove(confidenceTriple.next());
comment|// }
comment|// }
comment|// return loseConfidence;
comment|// }
comment|/**      * Applies the disambiguation results to the suggestions of the {@link SavedEntity}.      *<p>      * This method modifies the state of the {@link SavedEntity#getSuggestions()}      *       * @param results      *            the results of the disambiguation request      * @param savedEntity      *            the saved entity to be disambiguated      **/
specifier|protected
name|void
name|disambiguateSuggestions
parameter_list|(
name|QueryResultList
argument_list|<
name|Entity
argument_list|>
name|results
parameter_list|,
name|SavedEntity
name|savedEntity
parameter_list|)
block|{
comment|// NOTE (rwesten) We should not score disambiguation results based on
comment|// how well the labels match.
comment|// Either use directly the scores of the disambiguation results OR
comment|// do combine the confidence of the original suggestion with the
comment|// scores of the disambiguation
comment|/*          * Algorithm: Combine original confidence with Disambiguation results          *           * Parameter(s):          *           * * ratio configured as '{dr}:{cr}' where 'dr' stands for the ratio for the disambiguation score and          * 'cr' stand for the ratio for the original fise:confidence of a suggestion (default 1:1) *          * disambiguation weight (dw) := dr/(dr+cr) ... already calculated based on the configured ratio in          * #disambiguationWeight * confidence weight (cw) := cw/(dr+cr) ... already calculated based on the          * configured ratio in #confidenceWeight          *           * Input(s):          *           * * confidence (c): the original confidence of a suggestion (range [0..1]) * score (s): the score of          * the disambiguation * maximum score (ms): the maximum disambiguation score          *           * Output          *           * * disambiguated confidence (dc): the confidence after disambiguation          *           * Algorithm:          *           * * normalized score (ns) := s/ms ... ensures range [0..1] for disambiguation scores * disambiguated          * confidence = c*cw+ns*dw ... guaranteed to be [0..1]          */
name|List
argument_list|<
name|Suggestion
argument_list|>
name|matches
init|=
operator|new
name|ArrayList
argument_list|<
name|Suggestion
argument_list|>
argument_list|(
name|results
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|Float
name|maxScore
init|=
literal|null
decl_stmt|;
name|Float
name|maxSuggestedScore
init|=
literal|null
decl_stmt|;
name|Iterator
argument_list|<
name|Entity
argument_list|>
name|guesses
init|=
name|results
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"disambiguate {}: "
argument_list|,
name|savedEntity
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
name|guesses
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entity
name|guess
init|=
name|guesses
operator|.
name|next
argument_list|()
decl_stmt|;
name|Float
name|score
init|=
name|guess
operator|.
name|getRepresentation
argument_list|()
operator|.
name|getFirst
argument_list|(
name|RdfResourceEnum
operator|.
name|resultScore
operator|.
name|getUri
argument_list|()
argument_list|,
name|Float
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|score
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Missing Score for Entityhub Query Result {}!"
argument_list|,
name|guess
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|maxScore
operator|==
literal|null
condition|)
block|{
name|maxScore
operator|=
name|score
expr_stmt|;
block|}
name|IRI
name|uri
init|=
operator|new
name|IRI
argument_list|(
name|guess
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
name|Suggestion
name|suggestion
init|=
name|savedEntity
operator|.
name|getSuggestion
argument_list|(
name|uri
argument_list|)
decl_stmt|;
if|if
condition|(
name|suggestion
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|" - not found {}"
argument_list|,
name|guess
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|maxSuggestedScore
operator|==
literal|null
condition|)
block|{
name|maxSuggestedScore
operator|=
name|score
expr_stmt|;
block|}
name|double
name|c
init|=
name|suggestion
operator|.
name|getOriginalConfidnece
argument_list|()
operator|==
literal|null
condition|?
literal|0
else|:
name|suggestion
operator|.
name|getOriginalConfidnece
argument_list|()
decl_stmt|;
comment|// TODO (rwesten) we need to find out if we should normalize based on the
comment|// maximum score or the maximum score of an suggested one
name|double
name|ns
init|=
name|score
operator|/
name|maxSuggestedScore
decl_stmt|;
name|suggestion
operator|.
name|setNormalizedDisambiguationScore
argument_list|(
name|ns
argument_list|)
expr_stmt|;
name|double
name|dc
init|=
name|c
operator|*
name|confidenceWeight
operator|+
name|ns
operator|*
name|disambiguationWeight
decl_stmt|;
name|suggestion
operator|.
name|setDisambiguatedConfidence
argument_list|(
name|dc
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"  - found {}, origConf:{}, disScore:{}, disConf:{}"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|suggestion
operator|.
name|getEntityUri
argument_list|()
block|,
name|c
block|,
name|ns
block|,
name|dc
block|}
argument_list|)
expr_stmt|;
block|}
comment|// if at least one suggestion was also in the disambiguation result
if|if
condition|(
name|maxSuggestedScore
operator|!=
literal|null
condition|)
block|{
comment|// adapt the confidence of suggestions that where not part of the
comment|// disambiguation result
for|for
control|(
name|Suggestion
name|suggestion
range|:
name|savedEntity
operator|.
name|getSuggestions
argument_list|()
control|)
block|{
if|if
condition|(
name|suggestion
operator|.
name|getDisambiguatedConfidence
argument_list|()
operator|==
literal|null
condition|)
block|{
name|double
name|c
init|=
name|suggestion
operator|.
name|getOriginalConfidnece
argument_list|()
operator|==
literal|null
condition|?
literal|0
else|:
name|suggestion
operator|.
name|getOriginalConfidnece
argument_list|()
decl_stmt|;
name|suggestion
operator|.
name|setDisambiguatedConfidence
argument_list|(
name|c
operator|*
name|confidenceWeight
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// else keep the original results
name|log
operator|.
name|info
argument_list|(
literal|"  - none found"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Checks if there is any common elements amongst the ambiguations amongst latest dbpedia query and intial      * ambiguations      */
comment|// NOTE (rwesten): now done as part of the disambiguateSuggestions(..)
comment|// method.
comment|// protected boolean intersectionCheck(List<Suggestion> matches,
comment|// List<IRI> subsumed,
comment|// Graph graph,
comment|// String contentLangauge) {
comment|// for (int i = 0; i< subsumed.size(); i++) {
comment|// IRI uri = subsumed.get(i);
comment|//
comment|// IRI uri1 = EnhancementEngineHelper.getReference(graph, uri, new IRI(NamespaceEnum.fise
comment|// + "entity-reference"));
comment|//
comment|// String selectedText = EnhancementEngineHelper.getString(graph, uri, ENHANCER_ENTITY_LABEL);
comment|//
comment|// if (selectedText == null) {
comment|// continue;
comment|// }
comment|//
comment|// for (int j = 0; j< matches.size(); j++) {
comment|// Suggestion suggestion = matches.get(j);
comment|// String suggestName = suggestion.getURI();
comment|// if (suggestName.compareToIgnoreCase(uri1.getUnicodeString()) == 0) return true;
comment|// }
comment|// }
comment|// return false;
comment|// }
comment|// NOTE (rwesten): one MUST NOT store information of processed ContentItems
comment|// as member variables, as one EnhancementEngine instance is
comment|// concurrently used to process multiple ContentItems. Because
comment|// of that member variables will have data of different
comment|// ContentItems!
comment|// All those data need to be hold in information that are local
comment|// to the processing of a single ContentItem (similar to
comment|// SavedEntity).
comment|// NOTE moved the DisambiguationData#directoryTextAnotation
comment|// public Map<Integer,String> directoryTextAnotation = new HashMap<Integer,String>();
comment|// TODO: make configureable
name|int
name|radii
init|=
literal|23
decl_stmt|;
comment|// Value to be configured
specifier|public
name|boolean
name|toInclude
parameter_list|(
name|int
name|k
parameter_list|,
name|int
name|s
parameter_list|)
block|{
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|k
operator|-
name|s
argument_list|)
operator|<
name|radii
operator|&&
name|Math
operator|.
name|abs
argument_list|(
name|k
operator|-
name|s
argument_list|)
operator|>
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/*      * TODO: rwesten I do not understand what is the intension of this Adding the fise:selection-context of      * all entities within a range of #radii characters seams not to be a great way to build a context (or do      * i miss something?      */
annotation|@
name|Deprecated
comment|// for now until someone can answer the anove question
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|EntitiesInRange
parameter_list|(
name|NavigableMap
argument_list|<
name|Integer
argument_list|,
name|SavedEntity
argument_list|>
name|map
parameter_list|,
name|int
name|radius
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|temp
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// TODO: reimplement using subMap of the parsed NavigableMap map
for|for
control|(
name|Entry
argument_list|<
name|Integer
argument_list|,
name|SavedEntity
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Integer
name|s
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|String
name|subs
init|=
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|getContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|toInclude
argument_list|(
name|s
argument_list|,
name|radius
argument_list|)
condition|)
block|{
name|temp
operator|.
name|add
argument_list|(
name|subs
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|temp
return|;
comment|// if(Cal(f,k))
block|}
comment|/**      * Returns a list of all fise:selected-text values occurring in the parsed context (excluding the parsed      * label if not null      *       * @param label      *            The label of the current Entity. parse<code>null</code> if the current label should not be      *            ignored (and included in the context)      * @param allEntities      *            The collections with all the fise:selection-text values of all fise:TextAnnotations      * @param context      * @return      */
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|getSelectionsInContext
parameter_list|(
name|String
name|label
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|allEntities
parameter_list|,
name|String
name|context
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|allEntityString
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|selectedText
range|:
name|allEntities
control|)
block|{
if|if
condition|(
name|context
operator|.
name|contains
argument_list|(
name|selectedText
argument_list|)
operator|&&
name|selectedText
operator|.
name|compareToIgnoreCase
argument_list|(
name|label
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|allEntityString
operator|.
name|add
argument_list|(
name|selectedText
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|allEntityString
return|;
block|}
specifier|public
name|String
name|unionString
parameter_list|(
name|boolean
name|unique
parameter_list|,
name|Collection
argument_list|<
name|?
argument_list|>
modifier|...
name|lists
parameter_list|)
block|{
name|StringBuilder
name|union
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|HashSet
argument_list|<
name|String
argument_list|>
name|added
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Collection
argument_list|<
name|?
argument_list|>
name|list
range|:
name|lists
control|)
block|{
for|for
control|(
name|Object
name|entry
range|:
name|list
control|)
block|{
if|if
condition|(
operator|!
name|unique
operator|||
name|added
operator|.
name|add
argument_list|(
name|entry
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
name|union
operator|.
name|append
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|union
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|union
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/*      * Finds values the lie in intersection of both the set of disambiguations( the one intially suggested and      * the one from dpedia). Update the confidence values of those and make the confidence values of others as      * 0 in gainconfidence list      */
comment|// NOTE (rwesten): intersection is calculated as part of the disambiguateSuggestions(..)
comment|// method. Results are stored in the Suggestions (member of SavedEntiy) and
comment|// than written back to the EnhancementStructure in a separate step
comment|// protected List<Triple> intersection(List<Suggestion> matches,
comment|// List<IRI> subsumed,
comment|// Graph graph,
comment|// List<Triple> gainConfidence,
comment|// String contentLangauge) {
comment|//
comment|// for (int i = 0; i< subsumed.size(); i++) {
comment|// boolean matchFound = false;
comment|// IRI uri = subsumed.get(i);
comment|//
comment|// IRI uri1 = EnhancementEngineHelper.getReference(graph, uri, new IRI(NamespaceEnum.fise
comment|// + "entity-reference"));
comment|//
comment|// for (int j = 0; j< matches.size(); j++) {
comment|// Suggestion suggestion = matches.get(j);
comment|// String suggestName = suggestion.getURI();
comment|//
comment|// if (suggestName != null&& uri1 != null
comment|//&& suggestName.compareToIgnoreCase(uri1.getUnicodeString()) == 0) {
comment|// Triple confidenceTriple = new TripleImpl(uri, ENHANCER_CONFIDENCE, LiteralFactory
comment|// .getInstance().createTypedLiteral(suggestion.getScore()));
comment|// Triple contributorTriple = new TripleImpl((IRI) confidenceTriple.getSubject(),
comment|// new IRI(NamespaceEnum.dc + "contributor"), LiteralFactory.getInstance()
comment|// .createTypedLiteral(this.getClass().getName()));
comment|// gainConfidence.add(confidenceTriple);
comment|// gainConfidence.add(contributorTriple);
comment|// matchFound = true;
comment|// }
comment|// }
comment|//
comment|// if (!matchFound) {
comment|// Triple confidenceTriple = new TripleImpl(uri, ENHANCER_CONFIDENCE, LiteralFactory
comment|// .getInstance().createTypedLiteral(0.0));
comment|// Triple contributorTriple = new TripleImpl((IRI) confidenceTriple.getSubject(), new IRI(
comment|// NamespaceEnum.dc + "contributor"), LiteralFactory.getInstance().createTypedLiteral(
comment|// this.getClass().getName()));
comment|// gainConfidence.add(confidenceTriple);
comment|// gainConfidence.add(contributorTriple);
comment|// }
comment|// }
comment|//
comment|// return gainConfidence;
comment|// }
comment|/* Removes the value in lose confidence from the graph */
specifier|protected
name|void
name|removeOldConfidenceFromGraph
parameter_list|(
name|Graph
name|graph
parameter_list|,
name|List
argument_list|<
name|Triple
argument_list|>
name|loseConfidence
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|loseConfidence
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Triple
name|elementToRemove
init|=
name|loseConfidence
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|graph
operator|.
name|remove
argument_list|(
name|elementToRemove
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Adds the disambiguation results to the enhancement structure      *       * @param graph      *            the metadata of the {@link ContentItem}      * @param disData      *            the disambiguation data      */
specifier|protected
name|void
name|applyDisambiguationResults
parameter_list|(
name|Graph
name|graph
parameter_list|,
name|DisambiguationData
name|disData
parameter_list|)
block|{
for|for
control|(
name|SavedEntity
name|savedEntity
range|:
name|disData
operator|.
name|textAnnotations
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|Suggestion
name|s
range|:
name|savedEntity
operator|.
name|getSuggestions
argument_list|()
control|)
block|{
if|if
condition|(
name|s
operator|.
name|getDisambiguatedConfidence
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|disData
operator|.
name|suggestionMap
operator|.
name|get
argument_list|(
name|s
operator|.
name|getEntityAnnotation
argument_list|()
argument_list|)
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|// already encountered AND disambiguated -> we need to clone!!
name|log
operator|.
name|info
argument_list|(
literal|"clone {} suggesting {} for {}[{},{}]({})"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|s
operator|.
name|getEntityAnnotation
argument_list|()
block|,
name|s
operator|.
name|getEntityUri
argument_list|()
block|,
name|savedEntity
operator|.
name|getName
argument_list|()
block|,
name|savedEntity
operator|.
name|getStart
argument_list|()
block|,
name|savedEntity
operator|.
name|getEnd
argument_list|()
block|,
name|savedEntity
operator|.
name|getUri
argument_list|()
block|}
argument_list|)
expr_stmt|;
name|s
operator|.
name|setEntityAnnotation
argument_list|(
name|cloneTextAnnotation
argument_list|(
name|graph
argument_list|,
name|s
operator|.
name|getEntityAnnotation
argument_list|()
argument_list|,
name|savedEntity
operator|.
name|getUri
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"  - cloned {}"
argument_list|,
name|s
operator|.
name|getEntityAnnotation
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// change the confidence
name|EnhancementEngineHelper
operator|.
name|set
argument_list|(
name|graph
argument_list|,
name|s
operator|.
name|getEntityAnnotation
argument_list|()
argument_list|,
name|ENHANCER_CONFIDENCE
argument_list|,
name|s
operator|.
name|getDisambiguatedConfidence
argument_list|()
argument_list|,
name|literalFactory
argument_list|)
expr_stmt|;
name|EnhancementEngineHelper
operator|.
name|addContributingEngine
argument_list|(
name|graph
argument_list|,
name|s
operator|.
name|getEntityAnnotation
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * This creates a 'clone' of the fise:EntityAnnotation where the original does no longer have a      * dc:relation to the parsed fise:TextAnnotation and the created clone does only have a dc:relation to the      * parsed fise:TextAnnotation.      *<p>      * This is required by disambiguation because other engines typically only create a single      * fise:EntityAnnotation instance if several fise:TextAnnotation do have the same fise:selected-text      * values. So for a text that multiple times mentions the same Entity (e.g. "Paris") there will be      * multiple fise:TextAnnotations selecting the different mentions of that Entity, but there will be only a      * single set of suggestions - fise:EntityAnnotations (e.g. "Paris, France" and "Paris, Texas"). Now lets      * assume a text like      *       *<pre>      *     Paris is the capital of France and it is worth a visit for sure. But      *     one can also visit Paris without leaving the United States as there      *     is also a city with the same name in Texas.      *</pre>      *       * Entity Disambiguation need to be able to have different fise:confidence values for the first and second      * mention of Paris and this is only possible of the fise:TextAnnotations of those mentions do NOT refer      * to the same set of fise:EntityAnnotations.      *<p>      * This methods accomplished exactly that as it      *<ul>      *<li>creates a clone of a fise:EntityAnnotation      *<li>removes the dc:relation link to the 2nd mention of Paris from the original      *<li>only adds the dc:relation of the end mention to the clone      *</ul>      * So in the end you will have two fise:EntityAnnotation      *<ul>      *<li>the original fise:EntityAnnotation with dc:relation to all fise:TextAnnotations other than the 2nd      * mention (the one this method was called for)      *<li>the cloned fise:EntityAnnnotation with a dc:relation to the 2nd mention.      *</ul>      *       * @param graph      * @param entityAnnotation      * @param textAnnotation      * @return      */
specifier|public
specifier|static
name|IRI
name|cloneTextAnnotation
parameter_list|(
name|Graph
name|graph
parameter_list|,
name|IRI
name|entityAnnotation
parameter_list|,
name|IRI
name|textAnnotation
parameter_list|)
block|{
name|IRI
name|copy
init|=
operator|new
name|IRI
argument_list|(
literal|"urn:enhancement-"
operator|+
name|EnhancementEngineHelper
operator|.
name|randomUUID
argument_list|()
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|it
init|=
name|graph
operator|.
name|filter
argument_list|(
name|entityAnnotation
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// we can not add triples to the graph while iterating. So store them
comment|// in a list and add later
name|List
argument_list|<
name|Triple
argument_list|>
name|added
init|=
operator|new
name|ArrayList
argument_list|<
name|Triple
argument_list|>
argument_list|(
literal|32
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Triple
name|triple
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|DC_RELATION
operator|.
name|equals
argument_list|(
name|triple
operator|.
name|getPredicate
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|triple
operator|.
name|getObject
argument_list|()
operator|.
name|equals
argument_list|(
name|textAnnotation
argument_list|)
condition|)
block|{
comment|// remove the dc relation to the currently processed
comment|// textAnnotation from the original
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
comment|// and add it to the copy
name|added
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|copy
argument_list|,
comment|// use the copy as subject!
name|triple
operator|.
name|getPredicate
argument_list|()
argument_list|,
name|triple
operator|.
name|getObject
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// else it is not the currently processed TextAnnotation
comment|// so we need to keep in in the original and NOT add
comment|// it to the copy
block|}
else|else
block|{
comment|// we can copy all other information 1:1
name|added
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|copy
argument_list|,
comment|// use the copy as subject!
name|triple
operator|.
name|getPredicate
argument_list|()
argument_list|,
name|triple
operator|.
name|getObject
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|graph
operator|.
name|addAll
argument_list|(
name|added
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
block|}
comment|/* Returns a string on appended text annotations seperated by spaces */
specifier|protected
name|String
name|getEntitiesfromContext
parameter_list|(
name|String
name|label
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|allEntities
parameter_list|,
name|String
name|context
parameter_list|)
block|{
name|String
name|allEntityString
init|=
literal|""
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|allEntities
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|label
operator|.
name|compareToIgnoreCase
argument_list|(
name|allEntities
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|context
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|context
operator|.
name|contains
argument_list|(
name|allEntities
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|allEntityString
operator|=
name|allEntityString
operator|+
literal|"  "
operator|+
name|allEntities
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|allEntityString
return|;
block|}
specifier|protected
name|String
name|deriveSentence
parameter_list|(
name|String
name|Context
parameter_list|,
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
name|String
name|allEntityString
init|=
literal|""
decl_stmt|;
name|String
name|start
init|=
name|Context
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|a
argument_list|)
decl_stmt|;
name|String
name|end
init|=
name|Context
operator|.
name|substring
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|int
name|s
init|=
name|start
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
name|int
name|e
init|=
name|end
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|e
operator|<
literal|0
condition|)
return|return
name|Context
return|;
else|else
return|return
name|Context
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|b
operator|+
name|e
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|e
operator|<
literal|0
condition|)
return|return
name|Context
operator|.
name|substring
argument_list|(
name|s
argument_list|)
return|;
else|else
return|return
name|Context
operator|.
name|substring
argument_list|(
name|s
operator|+
literal|1
argument_list|,
name|b
operator|+
name|e
argument_list|)
return|;
block|}
block|}
comment|/**      * Extracts the selection context based on the content, selection and the start char offset of the      * selection      *       * @param content      *            the content      * @param selection      *            the selected text      * @param selectionStartPos      *            the start char position of the selection      * @param contextSize      *            the size of the context in characters      * @return the context      */
specifier|public
specifier|static
name|String
name|getDisambiguationContext
parameter_list|(
name|String
name|content
parameter_list|,
name|String
name|selection
parameter_list|,
name|int
name|selectionStartPos
parameter_list|,
name|int
name|contextSize
parameter_list|)
block|{
comment|// extract the selection context
name|int
name|beginPos
decl_stmt|;
if|if
condition|(
name|selectionStartPos
operator|<=
name|contextSize
condition|)
block|{
name|beginPos
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|int
name|start
init|=
name|selectionStartPos
operator|-
name|contextSize
decl_stmt|;
name|beginPos
operator|=
name|start
expr_stmt|;
name|int
name|c
decl_stmt|;
do|do
block|{
name|c
operator|=
name|content
operator|.
name|codePointAt
argument_list|(
name|beginPos
argument_list|)
expr_stmt|;
name|beginPos
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|beginPos
operator|<=
name|selectionStartPos
operator|||
name|Character
operator|.
name|isWhitespace
argument_list|(
name|c
argument_list|)
operator|||
name|Character
operator|.
name|getType
argument_list|(
name|c
argument_list|)
operator|==
name|Character
operator|.
name|SPACE_SEPARATOR
condition|)
do|;
if|if
condition|(
name|beginPos
operator|<
literal|0
operator|||
name|beginPos
operator|>=
name|selectionStartPos
condition|)
block|{
comment|// no words
name|beginPos
operator|=
name|start
expr_stmt|;
comment|// begin within a word
block|}
block|}
name|int
name|endPos
decl_stmt|;
if|if
condition|(
name|selectionStartPos
operator|+
name|selection
operator|.
name|length
argument_list|()
operator|+
name|contextSize
operator|>=
name|content
operator|.
name|length
argument_list|()
condition|)
block|{
name|endPos
operator|=
name|content
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|int
name|selectionEndPos
init|=
name|selectionStartPos
operator|+
name|selection
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|end
init|=
name|selectionEndPos
operator|+
name|contextSize
decl_stmt|;
name|endPos
operator|=
name|end
expr_stmt|;
name|int
name|c
decl_stmt|;
do|do
block|{
name|c
operator|=
name|content
operator|.
name|codePointAt
argument_list|(
name|endPos
argument_list|)
expr_stmt|;
name|endPos
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|endPos
operator|>
name|selectionEndPos
operator|||
name|Character
operator|.
name|isWhitespace
argument_list|(
name|c
argument_list|)
operator|||
name|Character
operator|.
name|getType
argument_list|(
name|c
argument_list|)
operator|==
name|Character
operator|.
name|SPACE_SEPARATOR
condition|)
do|;
if|if
condition|(
name|endPos
operator|<=
name|selectionStartPos
operator|+
name|selection
operator|.
name|length
argument_list|()
condition|)
block|{
name|endPos
operator|=
name|end
expr_stmt|;
comment|// end within a word;
block|}
block|}
return|return
name|content
operator|.
name|substring
argument_list|(
name|beginPos
argument_list|,
name|endPos
argument_list|)
return|;
block|}
comment|/**      * Activate and read the properties      *       * @param ce      *            the {@link ComponentContext}      */
annotation|@
name|Activate
specifier|protected
name|void
name|activate
parameter_list|(
name|ComponentContext
name|ce
parameter_list|)
throws|throws
name|ConfigurationException
block|{
try|try
block|{
name|super
operator|.
name|activate
argument_list|(
name|ce
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// log
name|log
operator|.
name|error
argument_list|(
literal|"Failed to update the configuration"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Dictionary
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|properties
init|=
name|ce
operator|.
name|getProperties
argument_list|()
decl_stmt|;
comment|// update the service URL if it is defined
comment|// if (properties.get(FORMCEPT_SERVICE_URL) != null) {
comment|// this.serviceURL = (String) properties.get(FORMCEPT_SERVICE_URL);
comment|// }
block|}
comment|/**      * Deactivate      *       * @param ce      *            the {@link ComponentContext}      */
annotation|@
name|Deactivate
specifier|protected
name|void
name|deactivate
parameter_list|(
name|ComponentContext
name|ce
parameter_list|)
block|{
name|super
operator|.
name|deactivate
argument_list|(
name|ce
argument_list|)
expr_stmt|;
block|}
comment|/**      * Gets the Service URL      *       * @return      */
specifier|public
name|String
name|getServiceURL
parameter_list|()
block|{
return|return
name|serviceURL
return|;
block|}
comment|// private static double levenshtein(String s1, String s2) {
comment|// if (s1 == null || s2 == null) {
comment|// throw new IllegalArgumentException("NONE of the parsed String MUST BE NULL!");
comment|// }
comment|// s1 = StringUtils.trim(s1);
comment|// s2 = StringUtils.trim(s2);
comment|// return s1.isEmpty() || s2.isEmpty() ? 0
comment|// : 1.0 - (((double) getLevenshteinDistance(s1, s2)) / ((double) (Math.max(s1.length(),
comment|// s2.length()))));
comment|// }
block|}
end_class

end_unit

