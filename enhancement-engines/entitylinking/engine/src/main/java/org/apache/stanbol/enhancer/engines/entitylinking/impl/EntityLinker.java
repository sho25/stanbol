begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|impl
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|NlpAnnotations
operator|.
name|POS_ANNOTATION
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|MGraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|PlainLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Triple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|UriRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|impl
operator|.
name|TripleImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|Entity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|EntitySearcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|EntitySearcherException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|LabelTokenizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|config
operator|.
name|EntityLinkerConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|config
operator|.
name|EntityLinkerConfig
operator|.
name|RedirectProcessingMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|config
operator|.
name|LanguageProcessingConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|impl
operator|.
name|ProcessingState
operator|.
name|TokenData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|impl
operator|.
name|Suggestion
operator|.
name|MATCH
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|model
operator|.
name|AnalysedText
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|model
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|NamespaceEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_class
specifier|public
class|class
name|EntityLinker
block|{
specifier|private
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|EntityLinker
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|EntityLinkerConfig
name|linkerConfig
decl_stmt|;
specifier|private
specifier|final
name|LanguageProcessingConfig
name|textProcessingConfig
decl_stmt|;
comment|//private final AnalysedText analysedText;
specifier|private
specifier|final
name|EntitySearcher
name|entitySearcher
decl_stmt|;
comment|/**      * The state of the current processing      */
specifier|private
specifier|final
name|ProcessingState
name|state
decl_stmt|;
comment|/**      * The map holding the results of the linking process      */
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|LinkedEntity
argument_list|>
name|linkedEntities
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|LinkedEntity
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|Integer
name|lookupLimit
decl_stmt|;
specifier|private
name|LabelTokenizer
name|labelTokenizer
decl_stmt|;
specifier|public
name|EntityLinker
parameter_list|(
name|AnalysedText
name|analysedText
parameter_list|,
name|String
name|language
parameter_list|,
name|LanguageProcessingConfig
name|textProcessingConfig
parameter_list|,
name|EntitySearcher
name|entitySearcher
parameter_list|,
name|EntityLinkerConfig
name|linkerConfig
parameter_list|,
name|LabelTokenizer
name|labelTokenizer
parameter_list|)
block|{
comment|//this.analysedText = analysedText;
name|this
operator|.
name|entitySearcher
operator|=
name|entitySearcher
expr_stmt|;
name|this
operator|.
name|linkerConfig
operator|=
name|linkerConfig
expr_stmt|;
name|this
operator|.
name|textProcessingConfig
operator|=
name|textProcessingConfig
expr_stmt|;
name|this
operator|.
name|labelTokenizer
operator|=
name|labelTokenizer
expr_stmt|;
name|this
operator|.
name|state
operator|=
operator|new
name|ProcessingState
argument_list|(
name|analysedText
argument_list|,
name|language
argument_list|,
name|textProcessingConfig
argument_list|,
name|linkerConfig
argument_list|)
expr_stmt|;
name|this
operator|.
name|lookupLimit
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|10
argument_list|,
name|linkerConfig
operator|.
name|getMaxSuggestions
argument_list|()
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/**      * Steps over the sentences, chunks, tokens of the {@link #sentences}      */
specifier|public
name|void
name|process
parameter_list|()
throws|throws
name|EntitySearcherException
block|{
comment|//int debugedIndex = 0;
while|while
condition|(
name|state
operator|.
name|next
argument_list|()
condition|)
block|{
name|TokenData
name|token
init|=
name|state
operator|.
name|getToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"--- preocess Token {}: {} (lemma: {} | pos:{}) chunk: {}"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|token
operator|.
name|index
block|,
name|token
operator|.
name|token
operator|.
name|getSpan
argument_list|()
block|,
name|token
operator|.
name|morpho
operator|!=
literal|null
condition|?
name|token
operator|.
name|morpho
operator|.
name|getLemma
argument_list|()
else|:
literal|"none"
block|,
name|token
operator|.
name|token
operator|.
name|getAnnotations
argument_list|(
name|POS_ANNOTATION
argument_list|)
block|,
name|token
operator|.
name|inChunk
operator|!=
literal|null
condition|?
operator|(
name|token
operator|.
name|inChunk
operator|.
name|chunk
operator|+
literal|" "
operator|+
name|token
operator|.
name|inChunk
operator|.
name|chunk
operator|.
name|getSpan
argument_list|()
operator|)
else|:
literal|"none"
block|}
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|searchStrings
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|linkerConfig
operator|.
name|getMaxSearchTokens
argument_list|()
argument_list|)
decl_stmt|;
name|searchStrings
operator|.
name|add
argument_list|(
name|token
operator|.
name|getTokenText
argument_list|()
argument_list|)
expr_stmt|;
comment|//Determine the range we are allowed to search for tokens
specifier|final
name|int
name|minIncludeIndex
decl_stmt|;
specifier|final
name|int
name|maxIndcludeIndex
decl_stmt|;
comment|//NOTE: testing has shown that using Chunks to restrict search for
comment|//      additional matchable tokens does have an negative impact on
comment|//      recall. Because of that this restriction is for now deactivated
name|boolean
name|restrirctContextByChunks
init|=
literal|false
decl_stmt|;
comment|//TODO: maybe make configurable
if|if
condition|(
name|token
operator|.
name|inChunk
operator|!=
literal|null
operator|&&
operator|!
name|textProcessingConfig
operator|.
name|isIgnoreChunks
argument_list|()
operator|&&
name|restrirctContextByChunks
condition|)
block|{
name|minIncludeIndex
operator|=
name|Math
operator|.
name|max
argument_list|(
name|state
operator|.
name|getConsumedIndex
argument_list|()
operator|+
literal|1
argument_list|,
name|token
operator|.
name|inChunk
operator|.
name|startToken
argument_list|)
expr_stmt|;
name|maxIndcludeIndex
operator|=
name|token
operator|.
name|inChunk
operator|.
name|endToken
expr_stmt|;
block|}
else|else
block|{
name|maxIndcludeIndex
operator|=
name|state
operator|.
name|getTokens
argument_list|()
operator|.
name|size
argument_list|()
operator|-
literal|1
expr_stmt|;
name|minIncludeIndex
operator|=
name|state
operator|.
name|getConsumedIndex
argument_list|()
operator|+
literal|1
expr_stmt|;
block|}
name|int
name|prevIndex
decl_stmt|,
name|pastIndex
decl_stmt|;
comment|//search away from the currently active token
name|int
name|distance
init|=
literal|0
decl_stmt|;
do|do
block|{
name|distance
operator|++
expr_stmt|;
name|prevIndex
operator|=
name|token
operator|.
name|index
operator|-
name|distance
expr_stmt|;
name|pastIndex
operator|=
name|token
operator|.
name|index
operator|+
name|distance
expr_stmt|;
if|if
condition|(
name|minIncludeIndex
operator|<=
name|prevIndex
condition|)
block|{
name|TokenData
name|prevToken
init|=
name|state
operator|.
name|getTokens
argument_list|()
operator|.
name|get
argument_list|(
name|prevIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"    {} {}:'{}' (lemma: {} | pos:{})"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|prevToken
operator|.
name|isMatchable
condition|?
literal|'+'
else|:
literal|'-'
block|,
name|prevToken
operator|.
name|index
block|,
name|prevToken
operator|.
name|token
operator|.
name|getSpan
argument_list|()
block|,
name|prevToken
operator|.
name|morpho
operator|!=
literal|null
condition|?
name|prevToken
operator|.
name|morpho
operator|.
name|getLemma
argument_list|()
else|:
literal|"none"
block|,
name|prevToken
operator|.
name|token
operator|.
name|getAnnotations
argument_list|(
name|POS_ANNOTATION
argument_list|)
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prevToken
operator|.
name|isMatchable
condition|)
block|{
name|searchStrings
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|prevToken
operator|.
name|getTokenText
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|maxIndcludeIndex
operator|>=
name|pastIndex
condition|)
block|{
name|TokenData
name|pastToken
init|=
name|state
operator|.
name|getTokens
argument_list|()
operator|.
name|get
argument_list|(
name|pastIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"    {} {}:'{}' (lemma: {} | pos:{})"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|pastToken
operator|.
name|isMatchable
condition|?
literal|'+'
else|:
literal|'-'
block|,
name|pastToken
operator|.
name|index
block|,
name|pastToken
operator|.
name|token
operator|.
name|getSpan
argument_list|()
block|,
name|pastToken
operator|.
name|morpho
operator|!=
literal|null
condition|?
name|pastToken
operator|.
name|morpho
operator|.
name|getLemma
argument_list|()
else|:
literal|"none"
block|,
name|pastToken
operator|.
name|token
operator|.
name|getAnnotations
argument_list|(
name|POS_ANNOTATION
argument_list|)
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pastToken
operator|.
name|isMatchable
condition|)
block|{
name|searchStrings
operator|.
name|add
argument_list|(
name|pastToken
operator|.
name|getTokenText
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|searchStrings
operator|.
name|size
argument_list|()
operator|<
name|linkerConfig
operator|.
name|getMaxSearchTokens
argument_list|()
operator|&&
name|distance
operator|<
name|linkerConfig
operator|.
name|getMaxSearchDistance
argument_list|()
operator|&&
operator|(
name|prevIndex
operator|>
name|minIncludeIndex
operator|||
name|pastIndex
operator|<
name|maxIndcludeIndex
operator|)
condition|)
do|;
comment|//we might have an additional element in the list
if|if
condition|(
name|searchStrings
operator|.
name|size
argument_list|()
operator|>
name|linkerConfig
operator|.
name|getMaxSearchTokens
argument_list|()
condition|)
block|{
name|searchStrings
operator|=
name|searchStrings
operator|.
name|subList
argument_list|(
comment|//the last part of the list
name|searchStrings
operator|.
name|size
argument_list|()
operator|-
name|linkerConfig
operator|.
name|getMaxSearchTokens
argument_list|()
argument_list|,
name|searchStrings
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|debug
argument_list|(
literal|">> searchStrings {}"
argument_list|,
name|searchStrings
argument_list|)
expr_stmt|;
comment|//search for Entities
name|List
argument_list|<
name|Suggestion
argument_list|>
name|suggestions
init|=
name|lookupEntities
argument_list|(
name|searchStrings
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|suggestions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//update the suggestions based on the best match
name|int
name|bestMatchCount
init|=
name|suggestions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getLabelMatch
argument_list|()
operator|.
name|getMatchCount
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Suggestion
argument_list|>
name|it
init|=
name|suggestions
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Suggestion
name|suggestion
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
comment|//suggestions that match less tokens as the best match
comment|//need to be updated to PARTIAL
name|int
name|matchCount
init|=
name|suggestion
operator|.
name|getLabelMatch
argument_list|()
operator|.
name|getMatchCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|matchCount
operator|<
name|bestMatchCount
condition|)
block|{
name|suggestion
operator|.
name|setMatch
argument_list|(
name|MATCH
operator|.
name|PARTIAL
argument_list|)
expr_stmt|;
block|}
comment|//Filter matches with less than config.getMinFoundTokens()
comment|//if matchcount is less than of the best match
if|if
condition|(
name|matchCount
operator|<
name|bestMatchCount
operator|&&
name|matchCount
operator|<
name|linkerConfig
operator|.
name|getMinFoundTokens
argument_list|()
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|//calculate the score
comment|//how good is the current match in relation to the best one
name|double
name|spanScore
init|=
name|matchCount
operator|/
name|bestMatchCount
decl_stmt|;
name|suggestion
operator|.
name|setScore
argument_list|(
name|spanScore
operator|*
name|spanScore
operator|*
name|suggestion
operator|.
name|getLabelMatch
argument_list|()
operator|.
name|getMatchScore
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|Suggestion
name|oldBestRanked
init|=
name|suggestions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|//for debugging
comment|//resort by score
name|Collections
operator|.
name|sort
argument_list|(
name|suggestions
argument_list|,
name|Suggestion
operator|.
name|SCORE_COMPARATOR
argument_list|)
expr_stmt|;
comment|//this should never happen ... but the
comment|//matchcount of the best match MUST NOT change
comment|//after the sort by score!
if|if
condition|(
name|bestMatchCount
operator|!=
name|suggestions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getLabelMatch
argument_list|()
operator|.
name|getMatchCount
argument_list|()
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"The match count for the top Ranked Suggestion for {} "
operator|+
literal|"changed after resorting based on Scores!"
argument_list|,
name|state
operator|.
name|getTokenText
argument_list|(
name|suggestions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getLabelMatch
argument_list|()
operator|.
name|getStart
argument_list|()
argument_list|,
name|bestMatchCount
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|warn
argument_list|(
literal|"  originalbest   : {}"
argument_list|,
name|oldBestRanked
argument_list|)
expr_stmt|;
name|log
operator|.
name|warn
argument_list|(
literal|" currnet ranking : {}"
argument_list|,
name|suggestions
argument_list|)
expr_stmt|;
name|log
operator|.
name|warn
argument_list|(
literal|"  ... this will result in worng confidence values relative to the best match"
argument_list|)
expr_stmt|;
block|}
comment|//remove all suggestions> config.maxSuggestions
if|if
condition|(
name|suggestions
operator|.
name|size
argument_list|()
operator|>
name|linkerConfig
operator|.
name|getMaxSuggestions
argument_list|()
condition|)
block|{
name|suggestions
operator|.
name|subList
argument_list|(
name|linkerConfig
operator|.
name|getMaxSuggestions
argument_list|()
argument_list|,
name|suggestions
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|">> Suggestions:"
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Suggestion
name|s
range|:
name|suggestions
control|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"   - {}: {}"
argument_list|,
name|i
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
comment|//process redirects
if|if
condition|(
name|linkerConfig
operator|.
name|getRedirectProcessingMode
argument_list|()
operator|!=
name|RedirectProcessingMode
operator|.
name|IGNORE
condition|)
block|{
for|for
control|(
name|Suggestion
name|suggestion
range|:
name|suggestions
control|)
block|{
name|processRedirects
argument_list|(
name|suggestion
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|start
init|=
name|suggestions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getLabelMatch
argument_list|()
operator|.
name|getStart
argument_list|()
decl_stmt|;
name|int
name|span
init|=
name|suggestions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getLabelMatch
argument_list|()
operator|.
name|getSpan
argument_list|()
decl_stmt|;
comment|//Store the linking results
name|String
name|selectedText
init|=
name|state
operator|.
name|getTokenText
argument_list|(
name|start
argument_list|,
name|span
argument_list|)
decl_stmt|;
comment|//float score;
name|LinkedEntity
name|linkedEntity
init|=
name|linkedEntities
operator|.
name|get
argument_list|(
name|selectedText
argument_list|)
decl_stmt|;
if|if
condition|(
name|linkedEntity
operator|==
literal|null
condition|)
block|{
name|linkedEntity
operator|=
operator|new
name|LinkedEntity
argument_list|(
name|selectedText
argument_list|,
name|suggestions
argument_list|,
name|getLinkedEntityTypes
argument_list|(
name|suggestions
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|linkedEntities
operator|.
name|put
argument_list|(
name|selectedText
argument_list|,
name|linkedEntity
argument_list|)
expr_stmt|;
block|}
name|linkedEntity
operator|.
name|addOccurrence
argument_list|(
name|state
operator|.
name|getSentence
argument_list|()
argument_list|,
comment|//NOTE: The end Token is "start+span-1"
name|state
operator|.
name|getTokens
argument_list|()
operator|.
name|get
argument_list|(
name|start
argument_list|)
operator|.
name|token
argument_list|,
name|state
operator|.
name|getTokens
argument_list|()
operator|.
name|get
argument_list|(
name|start
operator|+
name|span
operator|-
literal|1
argument_list|)
operator|.
name|token
argument_list|)
expr_stmt|;
comment|//set the next token to process to the next word after the
comment|//currently found suggestion
name|state
operator|.
name|setConsumed
argument_list|(
name|start
operator|+
name|span
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * After {@link #process()}ing this returns the entities linked for the      * parsed {@link AnalysedContent}.      * @return the linked entities      */
specifier|public
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|LinkedEntity
argument_list|>
name|getLinkedEntities
parameter_list|()
block|{
return|return
name|linkedEntities
return|;
block|}
comment|/**      * Retrieves all {@link EntitySearcher#getTypeField()} values of the parsed      * {@link Suggestion}s and than lookup the {@link NamespaceEnum#dcTerms dc}:type      * values for the {@link LinkedEntity#getTypes()} by using the configured      * {@link EntityLinkerConfig#getTypeMappings() types mappings} (and if      * no mapping is found the {@link EntityLinkerConfig#getDefaultDcType()       * default} type.      * @param conceptTypes The list of suggestions      * @return the types values for the {@link LinkedEntity}      */
specifier|private
name|Set
argument_list|<
name|UriRef
argument_list|>
name|getLinkedEntityTypes
parameter_list|(
name|Collection
argument_list|<
name|Suggestion
argument_list|>
name|suggestions
parameter_list|)
block|{
name|Collection
argument_list|<
name|UriRef
argument_list|>
name|conceptTypes
init|=
operator|new
name|HashSet
argument_list|<
name|UriRef
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Suggestion
name|suggestion
range|:
name|suggestions
control|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|UriRef
argument_list|>
name|types
init|=
name|suggestion
operator|.
name|getEntity
argument_list|()
operator|.
name|getReferences
argument_list|(
name|linkerConfig
operator|.
name|getTypeField
argument_list|()
argument_list|)
init|;
name|types
operator|.
name|hasNext
argument_list|()
condition|;
name|conceptTypes
operator|.
name|add
argument_list|(
name|types
operator|.
name|next
argument_list|()
argument_list|)
control|)
empty_stmt|;
block|}
name|Map
argument_list|<
name|UriRef
argument_list|,
name|UriRef
argument_list|>
name|typeMappings
init|=
name|linkerConfig
operator|.
name|getTypeMappings
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|UriRef
argument_list|>
name|dcTypes
init|=
operator|new
name|HashSet
argument_list|<
name|UriRef
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|UriRef
name|conceptType
range|:
name|conceptTypes
control|)
block|{
name|UriRef
name|dcType
init|=
name|typeMappings
operator|.
name|get
argument_list|(
name|conceptType
argument_list|)
decl_stmt|;
if|if
condition|(
name|dcType
operator|!=
literal|null
condition|)
block|{
name|dcTypes
operator|.
name|add
argument_list|(
name|dcType
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dcTypes
operator|.
name|isEmpty
argument_list|()
operator|&&
name|linkerConfig
operator|.
name|getDefaultDcType
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|dcTypes
operator|.
name|add
argument_list|(
name|linkerConfig
operator|.
name|getDefaultDcType
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|dcTypes
return|;
block|}
comment|/**      * Processes {@link EntitySearcher#getRedirectField() redirect field} values for      * the parsed suggestions based on the {@link RedirectProcessingMode}      * as configured in the {@link #config}.<p>      * The results of this method are stored within the parsed {@link Suggestion}s      * @param suggestion The suggestion to process.      * @throws EntitySearcherException       */
specifier|private
name|void
name|processRedirects
parameter_list|(
name|Suggestion
name|suggestion
parameter_list|)
throws|throws
name|EntitySearcherException
block|{
comment|//if mode is IGNORE -> nothing to do
if|if
condition|(
name|linkerConfig
operator|.
name|getRedirectProcessingMode
argument_list|()
operator|==
name|RedirectProcessingMode
operator|.
name|IGNORE
condition|)
block|{
return|return;
block|}
comment|//in case results for queries are locally cached it might be the case
comment|//that some/all of the results do already redirects processed.
comment|//therefore there is a small internal state that stores this information
if|if
condition|(
name|suggestion
operator|.
name|isRedirectedProcessed
argument_list|()
condition|)
block|{
return|return;
comment|//Redirects for ResultMatch are already processed ... ignore
block|}
name|Entity
name|result
init|=
name|suggestion
operator|.
name|getResult
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|UriRef
argument_list|>
name|redirects
init|=
name|result
operator|.
name|getReferences
argument_list|(
name|linkerConfig
operator|.
name|getRedirectField
argument_list|()
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|linkerConfig
operator|.
name|getRedirectProcessingMode
argument_list|()
condition|)
block|{
case|case
name|ADD_VALUES
case|:
name|MGraph
name|entityData
init|=
name|result
operator|.
name|getData
argument_list|()
decl_stmt|;
name|UriRef
name|entityUri
init|=
name|result
operator|.
name|getUri
argument_list|()
decl_stmt|;
while|while
condition|(
name|redirects
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|UriRef
name|redirect
init|=
name|redirects
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|redirect
operator|!=
literal|null
condition|)
block|{
name|Entity
name|redirectedEntity
init|=
name|entitySearcher
operator|.
name|get
argument_list|(
name|redirect
argument_list|,
name|linkerConfig
operator|.
name|getSelectedFields
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|redirectedEntity
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|data
init|=
name|redirectedEntity
operator|.
name|getData
argument_list|()
operator|.
name|filter
argument_list|(
name|redirectedEntity
operator|.
name|getUri
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
init|;
name|data
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Triple
name|t
init|=
name|data
operator|.
name|next
argument_list|()
decl_stmt|;
name|entityData
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|entityUri
argument_list|,
name|t
operator|.
name|getPredicate
argument_list|()
argument_list|,
name|t
operator|.
name|getObject
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|//set that the redirects where searched for this result
name|suggestion
operator|.
name|setRedirectProcessed
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
case|case
name|FOLLOW
case|:
while|while
condition|(
name|redirects
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|UriRef
name|redirect
init|=
name|redirects
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|redirect
operator|!=
literal|null
condition|)
block|{
name|Entity
name|redirectedEntity
init|=
name|entitySearcher
operator|.
name|get
argument_list|(
name|redirect
argument_list|,
name|linkerConfig
operator|.
name|getSelectedFields
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|redirectedEntity
operator|!=
literal|null
condition|)
block|{
name|suggestion
operator|.
name|setRedirect
argument_list|(
name|redirectedEntity
argument_list|)
expr_stmt|;
block|}
block|}
block|}
default|default:
comment|//nothing to do
block|}
block|}
comment|/**      * Searches for Entities in the {@link #entitySearcher} corresponding to the      * {@link Token#getText() words} of the current {@link #state position} in      * the text.      * @param searchStrings the list of {@link Token#getText() words} to search      * entities for.      * @return The sorted list with the suggestions.      * If there are no suggestions an empty list will be returned.      * @throws EntitySearcherException       */
specifier|private
name|List
argument_list|<
name|Suggestion
argument_list|>
name|lookupEntities
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|searchStrings
parameter_list|)
throws|throws
name|EntitySearcherException
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|languages
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|languages
operator|.
name|add
argument_list|(
name|linkerConfig
operator|.
name|getDefaultLanguage
argument_list|()
argument_list|)
expr_stmt|;
name|languages
operator|.
name|add
argument_list|(
name|state
operator|.
name|getLanguage
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|countryCodeIndex
init|=
name|state
operator|.
name|getLanguage
argument_list|()
operator|==
literal|null
condition|?
operator|-
literal|1
else|:
name|state
operator|.
name|getLanguage
argument_list|()
operator|.
name|indexOf
argument_list|(
literal|'-'
argument_list|)
decl_stmt|;
if|if
condition|(
name|countryCodeIndex
operator|>=
literal|2
condition|)
block|{
name|languages
operator|.
name|add
argument_list|(
name|state
operator|.
name|getLanguage
argument_list|()
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|countryCodeIndex
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Collection
argument_list|<
name|?
extends|extends
name|Entity
argument_list|>
name|results
decl_stmt|;
name|results
operator|=
name|entitySearcher
operator|.
name|lookup
argument_list|(
name|linkerConfig
operator|.
name|getNameField
argument_list|()
argument_list|,
name|linkerConfig
operator|.
name|getSelectedFields
argument_list|()
argument_list|,
name|searchStrings
argument_list|,
name|languages
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|languages
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|,
name|lookupLimit
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"   - found {} entities ..."
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Suggestion
argument_list|>
name|suggestions
init|=
operator|new
name|ArrayList
argument_list|<
name|Suggestion
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Entity
name|result
range|:
name|results
control|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"> {}"
argument_list|,
name|result
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|Suggestion
name|suggestion
init|=
name|matchLabels
argument_list|(
name|result
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"< {}"
argument_list|,
name|suggestion
argument_list|)
expr_stmt|;
if|if
condition|(
name|suggestion
operator|.
name|getMatch
argument_list|()
operator|!=
name|MATCH
operator|.
name|NONE
condition|)
block|{
name|suggestions
operator|.
name|add
argument_list|(
name|suggestion
argument_list|)
expr_stmt|;
block|}
block|}
comment|//sort the suggestions
if|if
condition|(
name|suggestions
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|suggestions
argument_list|,
name|Suggestion
operator|.
name|MATCH_TYPE_SUGGESTION_COMPARATOR
argument_list|)
expr_stmt|;
block|}
comment|//TODO: Work in Progress feature ... allowing to refine search if no
comment|//      suggestion is found but results where present
comment|//      However this would need full limit/offset support for the
comment|//      EntitySearcher. (rwesten 2012-05-21)
comment|//        Integer maxResults = entitySearcher.getLimit();
comment|//        if(maxResults == null){
comment|//            maxResults = 1; //fall back to 1 if limit is not known
comment|//        }
comment|//        if(suggestions.isEmpty()&& //if no suggestions where found
comment|//                results.size()>= maxResults&& //but the query had max results
comment|//                //than the actual entity might not be within the first LIMIT results
comment|//                searchStrings.size()> 1){ //if multiple words where used for the search
comment|//            //try again with only a single word
comment|//            suggestions = lookupEntities(Collections.singletonList(searchStrings.get(0)));
comment|//
comment|//        }
comment|//remove all elements> config.getMaxSuggestions()
return|return
name|suggestions
return|;
block|}
comment|/**      * Matches the labels of the parsed {@link Representation} with the Tokens of      * the texts (beginning with the currently active       * {@link ProcessingState#getToken() token}).<p>      * The field used to get the labels is retrieved from       * {@link EntitySearcher#getNameField()}. Only labels with no language or the      * language of the current sentence are considered. If less than       * {@link EntityLinkerConfig#getMinFoundTokens()} tokens match with an      * label the Concept is only considered to match if the label is      * {@link String#equalsIgnoreCase(String)} to the text covered by the      * matched token(s). Otherwise also {@link MATCH#FULL} and {@link MATCH#PARTIAL}      * results are allowed.      * @param entity The entity including at least the data for the      * {@link EntitySearcher#getNameField()} property.      * @return The result of the matching.      */
specifier|private
name|Suggestion
name|matchLabels
parameter_list|(
name|Entity
name|entity
parameter_list|)
block|{
name|String
name|curLang
init|=
name|state
operator|.
name|getLanguage
argument_list|()
decl_stmt|;
comment|//language of the current sentence
name|String
name|defLang
init|=
name|linkerConfig
operator|.
name|getDefaultLanguage
argument_list|()
decl_stmt|;
comment|//configured default language
name|String
name|mainLang
decl_stmt|;
name|int
name|countryCodeIndex
init|=
name|state
operator|.
name|getLanguage
argument_list|()
operator|==
literal|null
condition|?
operator|-
literal|1
else|:
name|state
operator|.
name|getLanguage
argument_list|()
operator|.
name|indexOf
argument_list|(
literal|'-'
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|PlainLiteral
argument_list|>
name|mainLangLabels
decl_stmt|;
if|if
condition|(
name|countryCodeIndex
operator|>=
literal|2
condition|)
block|{
name|mainLang
operator|=
name|state
operator|.
name|getLanguage
argument_list|()
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|countryCodeIndex
argument_list|)
expr_stmt|;
name|mainLangLabels
operator|=
operator|new
name|ArrayList
argument_list|<
name|PlainLiteral
argument_list|>
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|mainLang
operator|=
name|curLang
expr_stmt|;
name|mainLangLabels
operator|=
name|Collections
operator|.
name|emptyList
argument_list|()
expr_stmt|;
block|}
name|Iterator
argument_list|<
name|PlainLiteral
argument_list|>
name|labels
init|=
name|entity
operator|.
name|getText
argument_list|(
name|linkerConfig
operator|.
name|getNameField
argument_list|()
argument_list|)
decl_stmt|;
name|Suggestion
name|match
init|=
operator|new
name|Suggestion
argument_list|(
name|entity
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|PlainLiteral
argument_list|>
name|defaultLabels
init|=
operator|new
name|ArrayList
argument_list|<
name|PlainLiteral
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|matchedLangLabel
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|labels
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|PlainLiteral
name|label
init|=
name|labels
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|lang
init|=
name|label
operator|.
name|getLanguage
argument_list|()
operator|!=
literal|null
condition|?
name|label
operator|.
name|getLanguage
argument_list|()
operator|.
name|toString
argument_list|()
else|:
literal|null
decl_stmt|;
if|if
condition|(
operator|(
name|lang
operator|==
literal|null
operator|&&
name|curLang
operator|==
literal|null
operator|)
operator|||
operator|(
name|lang
operator|!=
literal|null
operator|&&
name|curLang
operator|!=
literal|null
operator|&&
name|lang
operator|.
name|equalsIgnoreCase
argument_list|(
name|curLang
argument_list|)
operator|)
condition|)
block|{
name|matchLabel
argument_list|(
name|match
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|matchedLangLabel
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|lang
operator|==
literal|null
operator|&&
name|mainLang
operator|==
literal|null
operator|)
operator|||
operator|(
name|lang
operator|!=
literal|null
operator|&&
name|mainLang
operator|!=
literal|null
operator|&&
name|lang
operator|.
name|equalsIgnoreCase
argument_list|(
name|mainLang
argument_list|)
operator|)
condition|)
block|{
name|mainLangLabels
operator|.
name|add
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|lang
operator|==
literal|null
operator|&&
name|defLang
operator|==
literal|null
operator|)
operator|||
operator|(
name|lang
operator|!=
literal|null
operator|&&
name|defLang
operator|!=
literal|null
operator|&&
name|lang
operator|.
name|startsWith
argument_list|(
name|defLang
argument_list|)
operator|)
condition|)
block|{
name|defaultLabels
operator|.
name|add
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
block|}
comment|//try to match main language labels
if|if
condition|(
operator|!
name|matchedLangLabel
operator|||
name|match
operator|.
name|getMatch
argument_list|()
operator|==
name|MATCH
operator|.
name|NONE
condition|)
block|{
for|for
control|(
name|PlainLiteral
name|mainLangLabel
range|:
name|mainLangLabels
control|)
block|{
name|matchLabel
argument_list|(
name|match
argument_list|,
name|mainLangLabel
argument_list|)
expr_stmt|;
name|matchedLangLabel
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|//use only labels in the default language if there is
comment|// * no label in the current language or
comment|// * no MATCH was found in the current language
if|if
condition|(
operator|!
name|matchedLangLabel
operator|||
name|match
operator|.
name|getMatch
argument_list|()
operator|==
name|MATCH
operator|.
name|NONE
condition|)
block|{
for|for
control|(
name|PlainLiteral
name|defaultLangLabel
range|:
name|defaultLabels
control|)
block|{
name|matchLabel
argument_list|(
name|match
argument_list|,
name|defaultLangLabel
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|match
return|;
block|}
comment|/**      * @param suggestion      * @param label      */
specifier|private
name|void
name|matchLabel
parameter_list|(
name|Suggestion
name|suggestion
parameter_list|,
name|PlainLiteral
name|label
parameter_list|)
block|{
name|String
name|text
init|=
name|label
operator|.
name|getLexicalForm
argument_list|()
decl_stmt|;
name|String
name|lang
init|=
name|label
operator|.
name|getLanguage
argument_list|()
operator|==
literal|null
condition|?
literal|null
else|:
name|label
operator|.
name|getLanguage
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|linkerConfig
operator|.
name|isCaseSensitiveMatching
argument_list|()
condition|)
block|{
name|text
operator|=
name|text
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
comment|//TODO use language of label for Locale
block|}
comment|//Tokenize the label and remove remove tokens without alpha numerical chars
name|String
index|[]
name|unprocessedLabelTokens
init|=
name|labelTokenizer
operator|.
name|tokenize
argument_list|(
name|text
argument_list|,
name|lang
argument_list|)
decl_stmt|;
if|if
condition|(
name|unprocessedLabelTokens
operator|==
literal|null
condition|)
block|{
comment|//no tokenizer available
name|log
operator|.
name|info
argument_list|(
literal|"Unable to tokenize {} language texts. Will process untokenized label {}"
argument_list|,
name|state
operator|.
name|getLanguage
argument_list|()
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|unprocessedLabelTokens
operator|=
operator|new
name|String
index|[]
block|{
name|text
block|}
expr_stmt|;
comment|//there is already a warning
block|}
name|int
name|offset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|unprocessedLabelTokens
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|boolean
name|hasAlphaNumericChar
init|=
name|Utils
operator|.
name|hasAlphaNumericChar
argument_list|(
name|unprocessedLabelTokens
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|hasAlphaNumericChar
condition|)
block|{
name|offset
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|>
literal|0
condition|)
block|{
name|unprocessedLabelTokens
index|[
name|i
operator|-
name|offset
index|]
operator|=
name|unprocessedLabelTokens
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|String
index|[]
name|labelTokens
decl_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
name|labelTokens
operator|=
name|unprocessedLabelTokens
expr_stmt|;
block|}
else|else
block|{
name|labelTokens
operator|=
operator|new
name|String
index|[
name|unprocessedLabelTokens
operator|.
name|length
operator|-
name|offset
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|unprocessedLabelTokens
argument_list|,
literal|0
argument_list|,
name|labelTokens
argument_list|,
literal|0
argument_list|,
name|labelTokens
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|labelTokenSet
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|labelTokens
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|foundProcessableTokens
init|=
literal|0
decl_stmt|;
name|int
name|foundTokens
init|=
literal|0
decl_stmt|;
name|float
name|foundTokenMatch
init|=
literal|0
decl_stmt|;
comment|//ensure the correct order of the tokens in the suggested entity
name|boolean
name|search
init|=
literal|true
decl_stmt|;
name|int
name|firstFoundIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|firstProcessableFoundIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|lastFoundIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|lastProcessableFoundIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|firstFoundLabelIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|lastfoundLabelIndex
init|=
operator|-
literal|1
decl_stmt|;
name|TokenData
name|currentToken
decl_stmt|;
name|String
name|currentTokenText
decl_stmt|;
name|int
name|currentTokenLength
decl_stmt|;
name|int
name|notFound
init|=
literal|0
decl_stmt|;
name|int
name|matchedTokensNotWithinProcessableTokenSpan
init|=
literal|0
decl_stmt|;
name|int
name|foundTokensWithinCoveredProcessableTokens
init|=
literal|0
decl_stmt|;
name|float
name|minTokenMatchFactor
init|=
name|linkerConfig
operator|.
name|getMinTokenMatchFactor
argument_list|()
decl_stmt|;
comment|//search for matches within the correct order
for|for
control|(
name|int
name|currentIndex
init|=
name|state
operator|.
name|getToken
argument_list|()
operator|.
name|index
init|;
name|currentIndex
operator|<
name|state
operator|.
name|getTokens
argument_list|()
operator|.
name|size
argument_list|()
operator|&&
name|search
condition|;
name|currentIndex
operator|++
control|)
block|{
name|currentToken
operator|=
name|state
operator|.
name|getTokens
argument_list|()
operator|.
name|get
argument_list|(
name|currentIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentToken
operator|.
name|hasAlphaNumeric
condition|)
block|{
name|currentTokenText
operator|=
name|currentToken
operator|.
name|getTokenText
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|linkerConfig
operator|.
name|isCaseSensitiveMatching
argument_list|()
condition|)
block|{
name|currentTokenText
operator|=
name|currentTokenText
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
block|}
name|currentTokenLength
operator|=
name|currentTokenText
operator|.
name|length
argument_list|()
expr_stmt|;
name|boolean
name|found
init|=
literal|false
decl_stmt|;
name|float
name|matchFactor
init|=
literal|0f
decl_stmt|;
comment|//iteration starts at the next token after the last matched one
comment|//so it is OK to skip tokens in the label, but not within the text
for|for
control|(
name|int
name|i
init|=
name|lastfoundLabelIndex
operator|+
literal|1
init|;
operator|!
name|found
operator|&&
name|i
operator|<
name|labelTokens
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|labelTokenText
init|=
name|labelTokens
index|[
name|i
index|]
decl_stmt|;
name|int
name|labelTokenLength
init|=
name|labelTokenText
operator|.
name|length
argument_list|()
decl_stmt|;
name|float
name|maxLength
init|=
name|currentTokenLength
operator|>
name|labelTokenLength
condition|?
name|currentTokenLength
else|:
name|labelTokenLength
decl_stmt|;
name|float
name|lengthDif
init|=
name|Math
operator|.
name|abs
argument_list|(
name|currentTokenLength
operator|-
name|labelTokenLength
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|lengthDif
operator|/
name|maxLength
operator|)
operator|<=
operator|(
literal|1
operator|-
name|minTokenMatchFactor
operator|)
condition|)
block|{
comment|//this prevents unnecessary string comparison
name|int
name|matchCount
init|=
name|compareTokens
argument_list|(
name|currentTokenText
argument_list|,
name|labelTokenText
argument_list|)
decl_stmt|;
if|if
condition|(
name|matchCount
operator|/
name|maxLength
operator|>=
name|minTokenMatchFactor
condition|)
block|{
name|lastfoundLabelIndex
operator|=
name|i
expr_stmt|;
comment|//set the last found index to the current position
name|found
operator|=
literal|true
expr_stmt|;
comment|//set found to true -> stops iteration
name|matchFactor
operator|=
name|matchCount
operator|/
name|maxLength
expr_stmt|;
comment|//how good is the match
comment|//remove matched labels from the set to disable them for
comment|//a later random oder search
name|labelTokenSet
operator|.
name|remove
argument_list|(
name|labelTokenText
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
comment|//search for a match in the wrong order
comment|//currently only exact matches (for testing)
if|if
condition|(
name|found
operator|=
name|labelTokenSet
operator|.
name|remove
argument_list|(
name|currentTokenText
argument_list|)
condition|)
block|{
name|matchFactor
operator|=
literal|0.7f
expr_stmt|;
block|}
block|}
comment|//int found = text.indexOf(currentToken.getText().toLowerCase());
if|if
condition|(
name|found
condition|)
block|{
comment|//found
if|if
condition|(
name|currentToken
operator|.
name|isMatchable
condition|)
block|{
name|foundProcessableTokens
operator|++
expr_stmt|;
comment|//only count processable Tokens
if|if
condition|(
name|firstProcessableFoundIndex
operator|<
literal|0
condition|)
block|{
name|firstProcessableFoundIndex
operator|=
name|currentIndex
expr_stmt|;
block|}
name|lastProcessableFoundIndex
operator|=
name|currentIndex
expr_stmt|;
name|foundTokensWithinCoveredProcessableTokens
operator|++
expr_stmt|;
if|if
condition|(
name|matchedTokensNotWithinProcessableTokenSpan
operator|>
literal|0
condition|)
block|{
name|foundTokensWithinCoveredProcessableTokens
operator|=
name|foundTokensWithinCoveredProcessableTokens
operator|+
name|matchedTokensNotWithinProcessableTokenSpan
expr_stmt|;
name|matchedTokensNotWithinProcessableTokenSpan
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|matchedTokensNotWithinProcessableTokenSpan
operator|++
expr_stmt|;
block|}
name|foundTokens
operator|++
expr_stmt|;
name|foundTokenMatch
operator|=
name|foundTokenMatch
operator|+
name|matchFactor
expr_stmt|;
comment|//sum up the matches
if|if
condition|(
name|firstFoundIndex
operator|<
literal|0
condition|)
block|{
name|firstFoundIndex
operator|=
name|currentIndex
expr_stmt|;
name|firstFoundLabelIndex
operator|=
name|lastfoundLabelIndex
expr_stmt|;
block|}
name|lastFoundIndex
operator|=
name|currentIndex
expr_stmt|;
block|}
else|else
block|{
comment|//not found
name|notFound
operator|++
expr_stmt|;
if|if
condition|(
name|currentToken
operator|.
name|isMatchable
operator|||
name|notFound
operator|>
name|linkerConfig
operator|.
name|getMaxNotFound
argument_list|()
condition|)
block|{
comment|//stop as soon as a token that needs to be processed is
comment|//not found in the label or the maximum number of tokens
comment|//that are not processable are not found
name|search
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
comment|// else token without alpha or numeric characters are not processed
block|}
comment|//search backwards for label tokens until firstFoundLabelIndex if there
comment|//are unconsumed Tokens in the sentence before state.getTokenIndex
name|int
name|currentIndex
init|=
name|state
operator|.
name|getToken
argument_list|()
operator|.
name|index
operator|-
literal|1
decl_stmt|;
name|int
name|labelIndex
init|=
name|firstFoundLabelIndex
operator|-
literal|1
decl_stmt|;
name|notFound
operator|=
literal|0
expr_stmt|;
name|matchedTokensNotWithinProcessableTokenSpan
operator|=
literal|0
expr_stmt|;
name|search
operator|=
literal|true
expr_stmt|;
while|while
condition|(
name|search
operator|&&
name|labelIndex
operator|>=
literal|0
operator|&&
name|currentIndex
operator|>
name|state
operator|.
name|getConsumedIndex
argument_list|()
condition|)
block|{
name|String
name|labelTokenText
init|=
name|labelTokens
index|[
name|labelIndex
index|]
decl_stmt|;
if|if
condition|(
name|labelTokenSet
operator|.
name|contains
argument_list|(
name|labelTokenText
argument_list|)
condition|)
block|{
comment|//still not matched
name|currentToken
operator|=
name|state
operator|.
name|getTokens
argument_list|()
operator|.
name|get
argument_list|(
name|currentIndex
argument_list|)
expr_stmt|;
name|currentTokenText
operator|=
name|currentToken
operator|.
name|getTokenText
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|linkerConfig
operator|.
name|isCaseSensitiveMatching
argument_list|()
condition|)
block|{
name|currentTokenText
operator|=
name|currentTokenText
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
block|}
name|currentTokenLength
operator|=
name|currentTokenText
operator|.
name|length
argument_list|()
expr_stmt|;
name|boolean
name|found
init|=
literal|false
decl_stmt|;
name|float
name|matchFactor
init|=
literal|0f
decl_stmt|;
name|int
name|labelTokenLength
init|=
name|labelTokenText
operator|.
name|length
argument_list|()
decl_stmt|;
name|float
name|maxLength
init|=
name|currentTokenLength
operator|>
name|labelTokenLength
condition|?
name|currentTokenLength
else|:
name|labelTokenLength
decl_stmt|;
name|float
name|lengthDif
init|=
name|Math
operator|.
name|abs
argument_list|(
name|currentTokenLength
operator|-
name|labelTokenLength
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|lengthDif
operator|/
name|maxLength
operator|)
operator|<=
operator|(
literal|1
operator|-
name|minTokenMatchFactor
operator|)
condition|)
block|{
comment|//this prevents unnecessary string comparison
name|int
name|matchCount
init|=
name|compareTokens
argument_list|(
name|currentTokenText
argument_list|,
name|labelTokenText
argument_list|)
decl_stmt|;
if|if
condition|(
name|matchCount
operator|/
name|maxLength
operator|>=
name|minTokenMatchFactor
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
comment|//set found to true -> stops iteration
name|matchFactor
operator|=
name|matchCount
operator|/
name|maxLength
expr_stmt|;
comment|//how good is the match
block|}
block|}
if|if
condition|(
name|found
condition|)
block|{
comment|//found
if|if
condition|(
name|currentToken
operator|.
name|isMatchable
condition|)
block|{
name|foundProcessableTokens
operator|++
expr_stmt|;
comment|//only count processable Tokens
if|if
condition|(
name|lastProcessableFoundIndex
operator|<
literal|0
condition|)
block|{
comment|//if last is not yet set
name|lastProcessableFoundIndex
operator|=
name|currentIndex
expr_stmt|;
block|}
name|firstProcessableFoundIndex
operator|=
name|currentIndex
expr_stmt|;
name|foundTokensWithinCoveredProcessableTokens
operator|++
expr_stmt|;
if|if
condition|(
name|matchedTokensNotWithinProcessableTokenSpan
operator|>
literal|0
condition|)
block|{
name|foundTokensWithinCoveredProcessableTokens
operator|=
name|foundTokensWithinCoveredProcessableTokens
operator|+
name|matchedTokensNotWithinProcessableTokenSpan
expr_stmt|;
name|matchedTokensNotWithinProcessableTokenSpan
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|matchedTokensNotWithinProcessableTokenSpan
operator|++
expr_stmt|;
block|}
name|foundTokens
operator|++
expr_stmt|;
name|foundTokenMatch
operator|=
name|foundTokenMatch
operator|+
name|matchFactor
expr_stmt|;
comment|//sum up the matches
name|firstFoundIndex
operator|=
name|currentIndex
expr_stmt|;
name|labelIndex
operator|--
expr_stmt|;
name|labelTokenSet
operator|.
name|remove
argument_list|(
name|labelTokenText
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|notFound
operator|++
expr_stmt|;
if|if
condition|(
name|currentToken
operator|.
name|isMatchable
operator|||
name|notFound
operator|>
name|linkerConfig
operator|.
name|getMaxNotFound
argument_list|()
condition|)
block|{
comment|//stop as soon as a token that needs to be processed is
comment|//not found in the label or the maximum number of tokens
comment|//that are not processable are not found
name|search
operator|=
literal|false
expr_stmt|;
block|}
block|}
name|currentIndex
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|//this token is already matched ...
name|labelIndex
operator|--
expr_stmt|;
comment|//try the next one
block|}
block|}
if|if
condition|(
name|foundProcessableTokens
operator|>
literal|0
condition|)
block|{
comment|//if any Token has matched
comment|//Now we make a second round to search tokens that match in the wrong order
comment|//e.g. if given and family name of persons are switched
specifier|final
name|LabelMatch
name|labelMatch
decl_stmt|;
name|int
name|coveredTokens
init|=
name|lastFoundIndex
operator|-
name|firstFoundIndex
operator|+
literal|1
decl_stmt|;
name|int
name|coveredProcessableTokens
init|=
name|lastProcessableFoundIndex
operator|-
name|firstProcessableFoundIndex
operator|+
literal|1
decl_stmt|;
comment|//matched tokens only within the span of the first/last processable token
comment|//Matching rules
comment|// - if less than config#minTokenFound() than accept only EXACT
comment|// - override PARTIAL matches with FULL/EXACT matches only if
comment|//   foundTokens of the PARTIAL match is> than of the FULL/EXACT
comment|//   match (this will be very rare
name|String
name|currentText
init|=
name|state
operator|.
name|getTokenText
argument_list|(
name|firstFoundIndex
argument_list|,
name|coveredTokens
argument_list|)
decl_stmt|;
if|if
condition|(
name|linkerConfig
operator|.
name|isCaseSensitiveMatching
argument_list|()
condition|?
name|currentText
operator|.
name|equals
argument_list|(
name|text
argument_list|)
else|:
name|currentText
operator|.
name|equalsIgnoreCase
argument_list|(
name|text
argument_list|)
condition|)
block|{
name|labelMatch
operator|=
operator|new
name|LabelMatch
argument_list|(
name|firstFoundIndex
argument_list|,
name|coveredTokens
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|foundTokens
operator|==
name|labelTokens
operator|.
name|length
operator|&&
name|foundTokens
operator|==
name|coveredTokens
condition|)
block|{
comment|//if all token matched set found to covered: May be lower because only
comment|//processable tokens are counted, but FULL also checks
comment|//of non-processable!
name|foundTokens
operator|=
name|coveredTokens
expr_stmt|;
name|foundProcessableTokens
operator|=
name|coveredProcessableTokens
expr_stmt|;
block|}
name|labelMatch
operator|=
operator|new
name|LabelMatch
argument_list|(
name|firstProcessableFoundIndex
argument_list|,
name|coveredProcessableTokens
argument_list|,
name|foundProcessableTokens
argument_list|,
name|foundTokensWithinCoveredProcessableTokens
argument_list|,
name|foundTokenMatch
operator|/
name|foundTokens
argument_list|,
name|label
argument_list|,
name|labelTokens
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|labelMatch
operator|.
name|getLabelScore
argument_list|()
operator|>=
name|linkerConfig
operator|.
name|getMinLabelScore
argument_list|()
operator|&&
name|labelMatch
operator|.
name|getTextScore
argument_list|()
operator|>=
name|linkerConfig
operator|.
name|getMinTextScore
argument_list|()
operator|&&
name|labelMatch
operator|.
name|getMatchScore
argument_list|()
operator|>=
name|linkerConfig
operator|.
name|getMinMatchScore
argument_list|()
condition|)
block|{
name|suggestion
operator|.
name|addLabelMatch
argument_list|(
name|labelMatch
argument_list|)
expr_stmt|;
block|}
block|}
comment|//else NO tokens found -> nothing to do
block|}
comment|/**      * Compares to token with each other and returns the longest match. The       * tokens are compared from the beginning and from the end.      * @param token1 the first token      * @param token2 the second token      * @return the number of matching chars      */
specifier|private
name|int
name|compareTokens
parameter_list|(
name|String
name|token1
parameter_list|,
name|String
name|token2
parameter_list|)
block|{
name|int
name|l1
init|=
name|token1
operator|.
name|length
argument_list|()
decl_stmt|;
comment|//length of the first token
name|int
name|l2
init|=
name|token2
operator|.
name|length
argument_list|()
decl_stmt|;
comment|//length of the second token
comment|//in case of same length check for equals first
if|if
condition|(
name|l1
operator|==
name|l2
operator|&&
name|token1
operator|.
name|equals
argument_list|(
name|token2
argument_list|)
condition|)
block|{
return|return
name|l1
return|;
block|}
name|int
name|ml
init|=
name|l1
operator|>
name|l2
condition|?
name|l2
else|:
name|l1
decl_stmt|;
comment|//minimum length of a token
if|if
condition|(
name|ml
operator|==
literal|0
condition|)
block|{
return|return
name|ml
return|;
block|}
name|int
name|f
init|=
literal|0
decl_stmt|;
comment|//forward match count + 1
name|int
name|b
init|=
literal|0
decl_stmt|;
comment|//backward match count + 1
name|boolean
name|match
init|=
literal|true
decl_stmt|;
comment|//still matches
while|while
condition|(
name|match
operator|&&
name|f
operator|<
name|ml
condition|)
block|{
name|match
operator|=
name|token1
operator|.
name|charAt
argument_list|(
name|f
argument_list|)
operator|==
name|token2
operator|.
name|charAt
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|f
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|match
condition|)
block|{
name|f
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|<
name|ml
condition|)
block|{
name|match
operator|=
literal|true
expr_stmt|;
while|while
condition|(
name|match
operator|&&
name|b
operator|<
name|ml
condition|)
block|{
name|b
operator|++
expr_stmt|;
name|match
operator|=
name|token1
operator|.
name|charAt
argument_list|(
name|l1
operator|-
name|b
argument_list|)
operator|==
name|token2
operator|.
name|charAt
argument_list|(
name|l2
operator|-
name|b
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|match
condition|)
block|{
name|b
operator|--
expr_stmt|;
block|}
block|}
return|return
name|f
operator|>
name|b
condition|?
name|f
else|:
name|b
return|;
block|}
block|}
end_class

end_unit

