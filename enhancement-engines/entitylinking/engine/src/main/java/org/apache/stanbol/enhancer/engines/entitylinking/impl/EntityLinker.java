begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|impl
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|impl
operator|.
name|Suggestion
operator|.
name|ENTITY_RANK_COMPARATOR
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|PlainLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Triple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|TripleCollection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|UriRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|impl
operator|.
name|TripleImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|Entity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|EntitySearcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|EntitySearcherException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|LabelTokenizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|config
operator|.
name|EntityLinkerConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|config
operator|.
name|EntityLinkerConfig
operator|.
name|RedirectProcessingMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|config
operator|.
name|LanguageProcessingConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|impl
operator|.
name|Suggestion
operator|.
name|MATCH
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|model
operator|.
name|AnalysedText
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|model
operator|.
name|Section
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|model
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|NamespaceEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_class
specifier|public
class|class
name|EntityLinker
block|{
specifier|private
specifier|static
specifier|final
name|int
name|MIN_SEARCH_LIMIT
init|=
literal|10
decl_stmt|;
specifier|private
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|EntityLinker
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|EntityLinkerConfig
name|linkerConfig
decl_stmt|;
specifier|private
specifier|final
name|LanguageProcessingConfig
name|textProcessingConfig
decl_stmt|;
comment|//private final AnalysedText analysedText;
specifier|private
specifier|final
name|EntitySearcher
name|entitySearcher
decl_stmt|;
comment|/**      * The state of the current processing      */
specifier|private
specifier|final
name|ProcessingState
name|state
decl_stmt|;
comment|/**      * The map holding the results of the linking process      */
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|LinkedEntity
argument_list|>
name|linkedEntities
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|LinkedEntity
argument_list|>
argument_list|()
decl_stmt|;
comment|//private Integer lookupLimit;
specifier|private
name|LabelTokenizer
name|labelTokenizer
decl_stmt|;
specifier|private
name|LinkingStateAware
name|linkingStateAware
decl_stmt|;
specifier|final
name|int
name|minSearchResults
decl_stmt|;
comment|//Language configuration
specifier|final
name|String
name|documentLang
decl_stmt|;
specifier|final
name|String
name|defaultLang
decl_stmt|;
specifier|final
name|String
name|documentMainLang
decl_stmt|;
specifier|private
name|Statistic
name|textProcessingStats
init|=
operator|new
name|Statistic
argument_list|(
literal|"Text Processing"
argument_list|)
decl_stmt|;
specifier|private
name|Statistic
name|lookupStats
init|=
operator|new
name|Statistic
argument_list|(
literal|"Vocabulary Lookup"
argument_list|)
decl_stmt|;
specifier|private
name|int
name|cacheHits
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|numQueryResults
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|numFilteredResults
init|=
literal|0
decl_stmt|;
specifier|private
name|Statistic
name|matchingStats
init|=
operator|new
name|Statistic
argument_list|(
literal|"Label Matching"
argument_list|)
decl_stmt|;
specifier|private
name|Statistic
name|rankingStats
init|=
operator|new
name|Statistic
argument_list|(
literal|"Suggestion Ranking"
argument_list|)
decl_stmt|;
comment|//    private Statistic test = new Statistic("test1");
comment|//    private Statistic test2_ = new Statistic("test2");
comment|//    private int numLabels = 0;
specifier|private
name|long
name|processingTime
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|HashMap
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|,
name|List
argument_list|<
name|Entity
argument_list|>
argument_list|>
name|lookupCache
decl_stmt|;
specifier|public
name|EntityLinker
parameter_list|(
name|AnalysedText
name|analysedText
parameter_list|,
name|String
name|language
parameter_list|,
name|LanguageProcessingConfig
name|textProcessingConfig
parameter_list|,
name|EntitySearcher
name|entitySearcher
parameter_list|,
name|EntityLinkerConfig
name|linkerConfig
parameter_list|,
name|LabelTokenizer
name|labelTokenizer
parameter_list|)
block|{
name|this
argument_list|(
name|analysedText
argument_list|,
name|language
argument_list|,
name|textProcessingConfig
argument_list|,
name|entitySearcher
argument_list|,
name|linkerConfig
argument_list|,
name|labelTokenizer
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|EntityLinker
parameter_list|(
name|AnalysedText
name|analysedText
parameter_list|,
name|String
name|language
parameter_list|,
name|LanguageProcessingConfig
name|textProcessingConfig
parameter_list|,
name|EntitySearcher
name|entitySearcher
parameter_list|,
name|EntityLinkerConfig
name|linkerConfig
parameter_list|,
name|LabelTokenizer
name|labelTokenizer
parameter_list|,
name|LinkingStateAware
name|linkingStateAware
parameter_list|)
block|{
comment|//this.analysedText = analysedText;
name|this
operator|.
name|lookupCache
operator|=
operator|new
name|HashMap
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|,
name|List
argument_list|<
name|Entity
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|entitySearcher
operator|=
name|entitySearcher
expr_stmt|;
name|this
operator|.
name|linkerConfig
operator|=
name|linkerConfig
expr_stmt|;
name|this
operator|.
name|textProcessingConfig
operator|=
name|textProcessingConfig
expr_stmt|;
name|this
operator|.
name|labelTokenizer
operator|=
name|labelTokenizer
expr_stmt|;
name|this
operator|.
name|state
operator|=
operator|new
name|ProcessingState
argument_list|(
name|analysedText
argument_list|,
name|language
argument_list|,
name|textProcessingConfig
argument_list|)
expr_stmt|;
name|minSearchResults
operator|=
name|entitySearcher
operator|.
name|getLimit
argument_list|()
operator|==
literal|null
condition|?
name|MIN_SEARCH_LIMIT
else|:
name|Math
operator|.
name|max
argument_list|(
name|MIN_SEARCH_LIMIT
argument_list|,
name|entitySearcher
operator|.
name|getLimit
argument_list|()
argument_list|)
expr_stmt|;
comment|//this.lookupLimit  = Math.max(minResults,linkerConfig.getMaxSuggestions()*3);
name|this
operator|.
name|linkingStateAware
operator|=
name|linkingStateAware
expr_stmt|;
comment|//init the language settings
name|this
operator|.
name|documentLang
operator|=
name|state
operator|.
name|getLanguage
argument_list|()
expr_stmt|;
name|this
operator|.
name|defaultLang
operator|=
name|linkerConfig
operator|.
name|getDefaultLanguage
argument_list|()
expr_stmt|;
name|int
name|countryCodeIndex
init|=
name|documentLang
operator|==
literal|null
condition|?
operator|-
literal|1
else|:
name|documentLang
operator|.
name|indexOf
argument_list|(
literal|'-'
argument_list|)
decl_stmt|;
if|if
condition|(
name|countryCodeIndex
operator|>=
literal|2
condition|)
block|{
name|documentMainLang
operator|=
name|documentLang
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|countryCodeIndex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|documentMainLang
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**      * Steps over the sentences, chunks, tokens of the {@link #sentences}      */
specifier|public
name|void
name|process
parameter_list|()
throws|throws
name|EntitySearcherException
block|{
name|long
name|startTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
comment|//int debugedIndex = 0;
name|Section
name|sentence
init|=
literal|null
decl_stmt|;
name|textProcessingStats
operator|.
name|begin
argument_list|()
expr_stmt|;
while|while
condition|(
name|state
operator|.
name|next
argument_list|()
condition|)
block|{
comment|//STANBOL-1070: added linkingStateAware callbacks for components that
comment|//   need to react on the state of the Linking process
if|if
condition|(
name|linkingStateAware
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|state
operator|.
name|getSentence
argument_list|()
operator|.
name|equals
argument_list|(
name|sentence
argument_list|)
condition|)
block|{
if|if
condition|(
name|sentence
operator|!=
literal|null
condition|)
block|{
name|linkingStateAware
operator|.
name|endSection
argument_list|(
name|sentence
argument_list|)
expr_stmt|;
block|}
name|sentence
operator|=
name|state
operator|.
name|getSentence
argument_list|()
expr_stmt|;
comment|//set the next sentence
name|linkingStateAware
operator|.
name|startSection
argument_list|(
name|sentence
argument_list|)
expr_stmt|;
comment|//notify its start
block|}
name|linkingStateAware
operator|.
name|startToken
argument_list|(
name|state
operator|.
name|getToken
argument_list|()
operator|.
name|token
argument_list|)
expr_stmt|;
comment|//notify the current token
block|}
name|TokenData
name|token
init|=
name|state
operator|.
name|getToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"--- preocess Token {}: {} (lemma: {}) linkable={}, matchable={} | chunk: {}"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|token
operator|.
name|index
block|,
name|token
operator|.
name|getTokenText
argument_list|()
block|,
name|token
operator|.
name|getTokenLemma
argument_list|()
block|,
name|token
operator|.
name|isLinkable
block|,
name|token
operator|.
name|isMatchable
block|,
name|token
operator|.
name|inChunk
operator|!=
literal|null
condition|?
operator|(
name|token
operator|.
name|inChunk
operator|.
name|chunk
operator|+
literal|" "
operator|+
name|token
operator|.
name|inChunk
operator|.
name|chunk
operator|.
name|getSpan
argument_list|()
operator|)
else|:
literal|"none"
block|}
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|TokenData
argument_list|>
name|searchStrings
init|=
operator|new
name|ArrayList
argument_list|<
name|TokenData
argument_list|>
argument_list|(
name|linkerConfig
operator|.
name|getMaxSearchTokens
argument_list|()
argument_list|)
decl_stmt|;
name|getSearchString
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|searchStrings
operator|.
name|add
argument_list|(
name|token
argument_list|)
expr_stmt|;
comment|//Determine the range we are allowed to search for tokens
specifier|final
name|int
name|minIncludeIndex
decl_stmt|;
specifier|final
name|int
name|maxIndcludeIndex
decl_stmt|;
name|int
name|consumedIndex
init|=
name|state
operator|.
name|getConsumedIndex
argument_list|()
decl_stmt|;
comment|//NOTE: testing has shown that using Chunks to restrict search for
comment|//      additional matchable tokens does have an negative impact on
comment|//      recall. Because of that this restriction is for now deactivated
comment|//            if(token.inChunk != null&& !textProcessingConfig.isIgnoreChunks()){
comment|//                minIncludeIndex = token.inChunk.getStartTokenIndex();
comment|//                maxIndcludeIndex = token.inChunk.getEndTokenIndex();
comment|//                log.debug("  - restrict context to chunk[{}, {}]",
comment|//                    minIncludeIndex, maxIndcludeIndex);
comment|//            } else {
name|maxIndcludeIndex
operator|=
name|state
operator|.
name|getTokens
argument_list|()
operator|.
name|size
argument_list|()
operator|-
literal|1
expr_stmt|;
name|minIncludeIndex
operator|=
literal|0
expr_stmt|;
comment|//            }
name|int
name|prevIndex
init|=
name|token
operator|.
name|index
decl_stmt|;
name|int
name|pastIndex
init|=
name|token
operator|.
name|index
decl_stmt|;
name|int
name|pastNonMatchable
init|=
literal|0
decl_stmt|;
name|int
name|prevNonMatchable
init|=
literal|0
decl_stmt|;
name|int
name|distance
init|=
literal|0
decl_stmt|;
do|do
block|{
name|distance
operator|++
expr_stmt|;
comment|//keep track of the distance
comment|//get the past token at the given distance (However ignore
comment|//non AlphaNumeric tokens when calculating the distance)
name|pastIndex
operator|++
expr_stmt|;
name|TokenData
name|pastToken
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|pastToken
operator|==
literal|null
operator|&&
name|maxIndcludeIndex
operator|>=
name|pastIndex
operator|&&
name|pastNonMatchable
operator|<=
literal|1
condition|)
block|{
name|TokenData
name|td
init|=
name|state
operator|.
name|getTokens
argument_list|()
operator|.
name|get
argument_list|(
name|pastIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|td
operator|.
name|hasAlphaNumeric
condition|)
block|{
name|pastToken
operator|=
name|td
expr_stmt|;
block|}
else|else
block|{
name|pastIndex
operator|++
expr_stmt|;
block|}
block|}
comment|//get the previous token at the given distance (However ignore
comment|//non AlphaNumeric tokens when calculating the distance)
name|prevIndex
operator|--
expr_stmt|;
name|TokenData
name|prevToken
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|prevToken
operator|==
literal|null
operator|&&
name|minIncludeIndex
operator|<=
name|prevIndex
operator|&&
comment|//allow one nonMatchable token if prevIndex> the last
comment|//consumed one and zero nonMatchable if prevIndex is<=
comment|//the last consumed one
operator|(
operator|(
name|prevIndex
operator|>
name|consumedIndex
operator|&&
name|prevNonMatchable
operator|<=
literal|1
operator|)
operator|||
name|prevIndex
operator|<=
name|consumedIndex
operator|&&
name|prevNonMatchable
operator|<
literal|1
operator|)
condition|)
block|{
name|TokenData
name|td
init|=
name|state
operator|.
name|getTokens
argument_list|()
operator|.
name|get
argument_list|(
name|prevIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|td
operator|.
name|hasAlphaNumeric
condition|)
block|{
name|prevToken
operator|=
name|td
expr_stmt|;
block|}
else|else
block|{
name|prevIndex
operator|--
expr_stmt|;
block|}
block|}
comment|//now that we know the tokens at this distance check if they are matchable
comment|//Fist the past token
if|if
condition|(
name|pastToken
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"    {} {}:'{}' (lemma: {}) linkable={}, matchable={}"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|pastToken
operator|.
name|isMatchable
condition|?
literal|'+'
else|:
literal|'-'
block|,
name|pastToken
operator|.
name|index
block|,
name|pastToken
operator|.
name|getTokenText
argument_list|()
block|,
name|pastToken
operator|.
name|getTokenLemma
argument_list|()
block|,
name|pastToken
operator|.
name|isLinkable
block|,
name|pastToken
operator|.
name|isMatchable
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pastToken
operator|.
name|isMatchable
condition|)
block|{
name|searchStrings
operator|.
name|add
argument_list|(
name|pastToken
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pastNonMatchable
operator|++
expr_stmt|;
block|}
block|}
comment|//Second in the previous token
if|if
condition|(
name|prevToken
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"    {} {}:'{}' (lemma: {}) linkable={}, matchable={}"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|prevToken
operator|.
name|isMatchable
condition|?
literal|'+'
else|:
literal|'-'
block|,
name|prevToken
operator|.
name|index
block|,
name|prevToken
operator|.
name|getTokenText
argument_list|()
block|,
name|prevToken
operator|.
name|getTokenLemma
argument_list|()
block|,
name|prevToken
operator|.
name|isLinkable
block|,
name|prevToken
operator|.
name|isMatchable
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prevToken
operator|.
name|isMatchable
condition|)
block|{
name|getSearchString
argument_list|(
name|prevToken
argument_list|)
expr_stmt|;
name|searchStrings
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|prevToken
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prevNonMatchable
operator|++
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|searchStrings
operator|.
name|size
argument_list|()
operator|<
name|linkerConfig
operator|.
name|getMaxSearchTokens
argument_list|()
operator|&&
name|distance
operator|<
name|linkerConfig
operator|.
name|getMaxSearchDistance
argument_list|()
operator|&&
operator|(
name|prevIndex
operator|>
name|minIncludeIndex
operator|||
name|pastIndex
operator|<
name|maxIndcludeIndex
operator|)
operator|&&
operator|(
name|prevNonMatchable
operator|<=
literal|1
operator|||
name|pastNonMatchable
operator|<=
literal|1
operator|)
condition|)
do|;
comment|//we might have an additional element in the list
if|if
condition|(
name|searchStrings
operator|.
name|size
argument_list|()
operator|>
name|linkerConfig
operator|.
name|getMaxSearchTokens
argument_list|()
condition|)
block|{
name|searchStrings
operator|=
name|searchStrings
operator|.
name|subList
argument_list|(
comment|//the last part of the list
name|searchStrings
operator|.
name|size
argument_list|()
operator|-
name|linkerConfig
operator|.
name|getMaxSearchTokens
argument_list|()
argument_list|,
name|searchStrings
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|searchStrings
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|TokenData
name|dt
range|:
name|searchStrings
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|dt
operator|.
name|token
operator|.
name|getSpan
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|debug
argument_list|(
literal|">> searchStrings {}"
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
name|textProcessingStats
operator|.
name|complete
argument_list|()
expr_stmt|;
comment|//search for Entities
name|List
argument_list|<
name|Suggestion
argument_list|>
name|suggestions
init|=
name|lookupEntities
argument_list|(
name|searchStrings
argument_list|)
decl_stmt|;
comment|//Treat partial matches that do match more as the best FULL match
comment|//differently
name|List
argument_list|<
name|Suggestion
argument_list|>
name|partialMatches
init|=
operator|new
name|ArrayList
argument_list|<
name|Suggestion
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|suggestions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|rankingStats
operator|.
name|begin
argument_list|()
expr_stmt|;
comment|//update the suggestions based on the best match
name|int
name|bestMatchCount
init|=
name|suggestions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getLabelMatch
argument_list|()
operator|.
name|getMatchCount
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Suggestion
argument_list|>
name|it
init|=
name|suggestions
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Suggestion
name|suggestion
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
comment|//suggestions that match less tokens as the best match
comment|//need to be updated to PARTIAL
name|int
name|matchCount
init|=
name|suggestion
operator|.
name|getLabelMatch
argument_list|()
operator|.
name|getMatchCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|matchCount
operator|<
name|bestMatchCount
condition|)
block|{
name|suggestion
operator|.
name|setMatch
argument_list|(
name|MATCH
operator|.
name|PARTIAL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|matchCount
operator|>
name|bestMatchCount
condition|)
block|{
comment|//selects more tokens
name|partialMatches
operator|.
name|add
argument_list|(
name|suggestion
argument_list|)
expr_stmt|;
comment|//but only a PARTIAL MATCH
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
comment|//remove from the main suggestion list
block|}
comment|//Filter matches with less than config.getMinFoundTokens()
comment|//if matchcount is less than of the best match
if|if
condition|(
name|matchCount
operator|<
name|bestMatchCount
operator|&&
name|matchCount
operator|<
name|linkerConfig
operator|.
name|getMinFoundTokens
argument_list|()
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|//calculate the score
comment|//how good is the current match in relation to the best one
name|double
name|spanScore
init|=
name|matchCount
operator|>=
name|bestMatchCount
condition|?
literal|1.0d
else|:
name|matchCount
operator|/
operator|(
name|double
operator|)
name|bestMatchCount
decl_stmt|;
name|suggestion
operator|.
name|setScore
argument_list|(
name|spanScore
operator|*
name|spanScore
operator|*
name|suggestion
operator|.
name|getLabelMatch
argument_list|()
operator|.
name|getMatchScore
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|Suggestion
name|oldBestRanked
init|=
name|suggestions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|//for debugging
comment|//resort by score
name|Collections
operator|.
name|sort
argument_list|(
name|suggestions
argument_list|,
name|Suggestion
operator|.
name|SCORE_COMPARATOR
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|partialMatches
argument_list|,
name|Suggestion
operator|.
name|SCORE_COMPARATOR
argument_list|)
expr_stmt|;
comment|//this should never happen ... but the
comment|//matchcount of the best match MUST NOT change
comment|//after the sort by score!
if|if
condition|(
name|bestMatchCount
operator|!=
name|suggestions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getLabelMatch
argument_list|()
operator|.
name|getMatchCount
argument_list|()
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"The match count for the top Ranked Suggestion for {} "
operator|+
literal|"changed after resorting based on Scores!"
argument_list|,
name|state
operator|.
name|getTokenText
argument_list|(
name|suggestions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getLabelMatch
argument_list|()
operator|.
name|getStart
argument_list|()
argument_list|,
name|bestMatchCount
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|warn
argument_list|(
literal|"  originalbest   : {}"
argument_list|,
name|oldBestRanked
argument_list|)
expr_stmt|;
name|log
operator|.
name|warn
argument_list|(
literal|" currnet ranking : {}"
argument_list|,
name|suggestions
argument_list|)
expr_stmt|;
name|log
operator|.
name|warn
argument_list|(
literal|"  ... this will result in worng confidence values relative to the best match"
argument_list|)
expr_stmt|;
block|}
comment|//adapt equals rankings based on the entity rank
if|if
condition|(
name|linkerConfig
operator|.
name|isRankEqualScoresBasedOnEntityRankings
argument_list|()
condition|)
block|{
name|adaptScoresForEntityRankings
argument_list|(
name|suggestions
argument_list|)
expr_stmt|;
name|adaptScoresForEntityRankings
argument_list|(
name|partialMatches
argument_list|)
expr_stmt|;
block|}
comment|//remove all suggestions> config.maxSuggestions
if|if
condition|(
name|suggestions
operator|.
name|size
argument_list|()
operator|>
name|linkerConfig
operator|.
name|getMaxSuggestions
argument_list|()
condition|)
block|{
name|suggestions
operator|.
name|subList
argument_list|(
name|linkerConfig
operator|.
name|getMaxSuggestions
argument_list|()
argument_list|,
name|suggestions
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|">> Suggestions:"
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Suggestion
name|s
range|:
name|suggestions
control|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"   - {}: {}"
argument_list|,
name|i
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
comment|//process redirects
if|if
condition|(
name|linkerConfig
operator|.
name|getRedirectProcessingMode
argument_list|()
operator|!=
name|RedirectProcessingMode
operator|.
name|IGNORE
condition|)
block|{
for|for
control|(
name|Suggestion
name|suggestion
range|:
name|suggestions
control|)
block|{
name|processRedirects
argument_list|(
name|suggestion
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Suggestion
name|suggestion
range|:
name|partialMatches
control|)
block|{
name|processRedirects
argument_list|(
name|suggestion
argument_list|)
expr_stmt|;
block|}
block|}
comment|//create LinkedEntities for the main suggestions
name|int
name|start
init|=
name|suggestions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getLabelMatch
argument_list|()
operator|.
name|getStart
argument_list|()
decl_stmt|;
name|int
name|span
init|=
name|suggestions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getLabelMatch
argument_list|()
operator|.
name|getSpan
argument_list|()
decl_stmt|;
comment|//Store the linking results
name|String
name|selectedText
init|=
name|state
operator|.
name|getTokenText
argument_list|(
name|start
argument_list|,
name|span
argument_list|)
decl_stmt|;
comment|//float score;
name|LinkedEntity
name|linkedEntity
init|=
name|linkedEntities
operator|.
name|get
argument_list|(
name|selectedText
argument_list|)
decl_stmt|;
if|if
condition|(
name|linkedEntity
operator|==
literal|null
condition|)
block|{
name|linkedEntity
operator|=
operator|new
name|LinkedEntity
argument_list|(
name|selectedText
argument_list|,
name|suggestions
argument_list|,
name|getLinkedEntityTypes
argument_list|(
name|suggestions
argument_list|)
argument_list|)
expr_stmt|;
name|linkedEntities
operator|.
name|put
argument_list|(
name|selectedText
argument_list|,
name|linkedEntity
argument_list|)
expr_stmt|;
block|}
comment|// else Assumption: The list of suggestions is the SAME
name|linkedEntity
operator|.
name|addOccurrence
argument_list|(
name|state
operator|.
name|getSentence
argument_list|()
argument_list|,
comment|//NOTE: The end Token is "start+span-1"
name|state
operator|.
name|getTokens
argument_list|()
operator|.
name|get
argument_list|(
name|start
argument_list|)
operator|.
name|token
argument_list|,
name|state
operator|.
name|getTokens
argument_list|()
operator|.
name|get
argument_list|(
name|start
operator|+
name|span
operator|-
literal|1
argument_list|)
operator|.
name|token
argument_list|)
expr_stmt|;
comment|//In case of a FULL or EXACT MATCH we can set the next token to process to the next
comment|//word after the currently found suggestion
if|if
condition|(
name|suggestions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getMatch
argument_list|()
operator|.
name|ordinal
argument_list|()
operator|>=
name|MATCH
operator|.
name|FULL
operator|.
name|ordinal
argument_list|()
condition|)
block|{
name|state
operator|.
name|setConsumed
argument_list|(
name|start
operator|+
name|span
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|//create LinkedEntities for partial matches
comment|//TODO: maybe we need to group partial matches based on their
comment|//      selected Tokens and only group those suggestions that do
comment|//      select the same span in the Text. Currently all are grouped
comment|//      based on those that does select the most tokens.
if|if
condition|(
operator|!
name|partialMatches
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|start
operator|=
name|partialMatches
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getLabelMatch
argument_list|()
operator|.
name|getStart
argument_list|()
expr_stmt|;
name|span
operator|=
name|partialMatches
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getLabelMatch
argument_list|()
operator|.
name|getSpan
argument_list|()
expr_stmt|;
name|selectedText
operator|=
name|state
operator|.
name|getTokenText
argument_list|(
name|start
argument_list|,
name|span
argument_list|)
expr_stmt|;
name|linkedEntity
operator|=
name|linkedEntities
operator|.
name|get
argument_list|(
name|selectedText
argument_list|)
expr_stmt|;
if|if
condition|(
name|linkedEntity
operator|==
literal|null
condition|)
block|{
name|linkedEntity
operator|=
operator|new
name|LinkedEntity
argument_list|(
name|selectedText
argument_list|,
name|partialMatches
argument_list|,
name|getLinkedEntityTypes
argument_list|(
name|suggestions
argument_list|)
argument_list|)
expr_stmt|;
name|linkedEntities
operator|.
name|put
argument_list|(
name|selectedText
argument_list|,
name|linkedEntity
argument_list|)
expr_stmt|;
block|}
comment|// else Assumption: The list of suggestions is the SAME
name|linkedEntity
operator|.
name|addOccurrence
argument_list|(
name|state
operator|.
name|getSentence
argument_list|()
argument_list|,
comment|//NOTE: The end Token is "start+span-1"
name|state
operator|.
name|getTokens
argument_list|()
operator|.
name|get
argument_list|(
name|start
argument_list|)
operator|.
name|token
argument_list|,
name|state
operator|.
name|getTokens
argument_list|()
operator|.
name|get
argument_list|(
name|start
operator|+
name|span
operator|-
literal|1
argument_list|)
operator|.
name|token
argument_list|)
expr_stmt|;
block|}
name|rankingStats
operator|.
name|complete
argument_list|()
expr_stmt|;
block|}
comment|// else suggestions are empty
if|if
condition|(
name|linkingStateAware
operator|!=
literal|null
condition|)
block|{
name|linkingStateAware
operator|.
name|endToken
argument_list|(
name|state
operator|.
name|getToken
argument_list|()
operator|.
name|token
argument_list|)
expr_stmt|;
block|}
name|textProcessingStats
operator|.
name|begin
argument_list|()
expr_stmt|;
block|}
name|textProcessingStats
operator|.
name|cancel
argument_list|()
expr_stmt|;
comment|//do not count the last call
if|if
condition|(
name|linkingStateAware
operator|!=
literal|null
operator|&&
name|sentence
operator|!=
literal|null
condition|)
block|{
name|linkingStateAware
operator|.
name|endSection
argument_list|(
name|sentence
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|processingTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startTime
expr_stmt|;
block|}
comment|/**      * @param suggestions      */
specifier|private
name|void
name|adaptScoresForEntityRankings
parameter_list|(
name|List
argument_list|<
name|Suggestion
argument_list|>
name|suggestions
parameter_list|)
block|{
name|List
argument_list|<
name|Suggestion
argument_list|>
name|equalScoreList
init|=
operator|new
name|ArrayList
argument_list|<
name|Suggestion
argument_list|>
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|double
name|score
init|=
literal|2f
decl_stmt|;
for|for
control|(
name|Suggestion
name|s
range|:
name|suggestions
control|)
block|{
name|double
name|actScore
init|=
name|s
operator|.
name|getScore
argument_list|()
decl_stmt|;
if|if
condition|(
name|score
operator|==
name|actScore
condition|)
block|{
name|equalScoreList
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|equalScoreList
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|adaptScoreForEntityRankings
argument_list|(
name|equalScoreList
argument_list|,
name|actScore
argument_list|)
expr_stmt|;
block|}
name|score
operator|=
name|actScore
expr_stmt|;
name|equalScoreList
operator|.
name|clear
argument_list|()
expr_stmt|;
name|equalScoreList
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|equalScoreList
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|adaptScoreForEntityRankings
argument_list|(
name|equalScoreList
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|//resort by score
name|Collections
operator|.
name|sort
argument_list|(
name|suggestions
argument_list|,
name|Suggestion
operator|.
name|SCORE_COMPARATOR
argument_list|)
expr_stmt|;
block|}
comment|/**      * Helper that extracts the       * @param token      */
specifier|private
name|String
name|getSearchString
parameter_list|(
name|TokenData
name|token
parameter_list|)
block|{
name|String
name|searchString
init|=
name|linkerConfig
operator|.
name|isLemmaMatching
argument_list|()
condition|?
name|token
operator|.
name|getTokenLemma
argument_list|()
else|:
name|token
operator|.
name|getTokenText
argument_list|()
decl_stmt|;
if|if
condition|(
name|searchString
operator|==
literal|null
condition|)
block|{
name|searchString
operator|=
name|token
operator|.
name|getTokenText
argument_list|()
expr_stmt|;
block|}
return|return
name|searchString
return|;
block|}
comment|/**      * This method slightly adapts scores of Suggestions based on the Entity ranking.      * It is used for Suggestions that would have the exact same score (e.g. 1.0) to      * ensure ordering of the suggestions based on the rankings of the Entities      * within the knowledge base linked against      * @param equalScoreList Entities with the same {@link Suggestion#getScore()}      * values. If this is not the case this method will change scores in unintended      * ways      * @param nextScore the score of the {@link Suggestion} with a lower score as the      * list of suggestions parsed in the first parameter      */
specifier|private
name|void
name|adaptScoreForEntityRankings
parameter_list|(
name|List
argument_list|<
name|Suggestion
argument_list|>
name|equalScoreList
parameter_list|,
name|double
name|nextScore
parameter_list|)
block|{
name|double
name|score
init|=
name|equalScoreList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getScore
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"> Adapt Score of multiple Suggestions "
operator|+
literal|"with '{}' based on EntityRanking"
argument_list|,
name|score
argument_list|)
expr_stmt|;
comment|//Adapt the score to reflect the entity ranking
comment|//but do not change order with entities of different
comment|//score. Also do not change the score more that 0.1
comment|//TODO: make the max change (0.1) configurable
name|double
name|dif
init|=
operator|(
name|Math
operator|.
name|min
argument_list|(
literal|0.1
argument_list|,
name|score
operator|-
name|nextScore
argument_list|)
operator|)
operator|/
name|equalScoreList
operator|.
name|size
argument_list|()
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|equalScoreList
argument_list|,
name|ENTITY_RANK_COMPARATOR
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"    - keep socre of {} at {}"
argument_list|,
name|equalScoreList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getEntity
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|,
name|score
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|equalScoreList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|score
operator|=
name|score
operator|-
name|dif
expr_stmt|;
if|if
condition|(
name|ENTITY_RANK_COMPARATOR
operator|.
name|compare
argument_list|(
name|equalScoreList
operator|.
name|get
argument_list|(
name|i
operator|-
literal|1
argument_list|)
argument_list|,
name|equalScoreList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|equalScoreList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|setScore
argument_list|(
name|score
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"    - set score of {} at {}"
argument_list|,
name|equalScoreList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getEntity
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|,
name|score
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|double
name|lastScore
init|=
name|equalScoreList
operator|.
name|get
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|.
name|getScore
argument_list|()
decl_stmt|;
name|equalScoreList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|setScore
argument_list|(
name|lastScore
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"    - set score of {} at {}"
argument_list|,
name|equalScoreList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getEntity
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|,
name|lastScore
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * After {@link #process()}ing this returns the entities linked for the      * parsed {@link AnalysedContent}.      * @return the linked entities      */
specifier|public
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|LinkedEntity
argument_list|>
name|getLinkedEntities
parameter_list|()
block|{
return|return
name|linkedEntities
return|;
block|}
comment|/**      * Retrieves all {@link EntitySearcher#getTypeField()} values of the parsed      * {@link Suggestion}s and than lookup the {@link NamespaceEnum#dcTerms dc}:type      * values for the {@link LinkedEntity#getTypes()} by using the configured      * {@link EntityLinkerConfig#getTypeMappings() types mappings} (and if      * no mapping is found the {@link EntityLinkerConfig#getDefaultDcType()       * default} type.      * @param conceptTypes The list of suggestions      * @return the types values for the {@link LinkedEntity}      */
specifier|private
name|Set
argument_list|<
name|UriRef
argument_list|>
name|getLinkedEntityTypes
parameter_list|(
name|Collection
argument_list|<
name|Suggestion
argument_list|>
name|suggestions
parameter_list|)
block|{
name|Collection
argument_list|<
name|UriRef
argument_list|>
name|conceptTypes
init|=
operator|new
name|HashSet
argument_list|<
name|UriRef
argument_list|>
argument_list|()
decl_stmt|;
name|double
name|score
init|=
operator|-
literal|1
decl_stmt|;
comment|//only consider types of the best ranked Entities
for|for
control|(
name|Suggestion
name|suggestion
range|:
name|suggestions
control|)
block|{
name|double
name|actScore
init|=
name|suggestion
operator|.
name|getScore
argument_list|()
decl_stmt|;
if|if
condition|(
name|actScore
operator|<
name|score
condition|)
block|{
break|break;
block|}
for|for
control|(
name|Iterator
argument_list|<
name|UriRef
argument_list|>
name|types
init|=
name|suggestion
operator|.
name|getEntity
argument_list|()
operator|.
name|getReferences
argument_list|(
name|linkerConfig
operator|.
name|getTypeField
argument_list|()
argument_list|)
init|;
name|types
operator|.
name|hasNext
argument_list|()
condition|;
name|conceptTypes
operator|.
name|add
argument_list|(
name|types
operator|.
name|next
argument_list|()
argument_list|)
control|)
empty_stmt|;
block|}
name|Map
argument_list|<
name|UriRef
argument_list|,
name|UriRef
argument_list|>
name|typeMappings
init|=
name|linkerConfig
operator|.
name|getTypeMappings
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|UriRef
argument_list|>
name|dcTypes
init|=
operator|new
name|HashSet
argument_list|<
name|UriRef
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|UriRef
name|conceptType
range|:
name|conceptTypes
control|)
block|{
name|UriRef
name|dcType
init|=
name|typeMappings
operator|.
name|get
argument_list|(
name|conceptType
argument_list|)
decl_stmt|;
if|if
condition|(
name|dcType
operator|!=
literal|null
condition|)
block|{
name|dcTypes
operator|.
name|add
argument_list|(
name|dcType
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dcTypes
operator|.
name|isEmpty
argument_list|()
operator|&&
name|linkerConfig
operator|.
name|getDefaultDcType
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|dcTypes
operator|.
name|add
argument_list|(
name|linkerConfig
operator|.
name|getDefaultDcType
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|dcTypes
return|;
block|}
comment|/**      * Processes {@link EntitySearcher#getRedirectField() redirect field} values for      * the parsed suggestions based on the {@link RedirectProcessingMode}      * as configured in the {@link #config}.<p>      * The results of this method are stored within the parsed {@link Suggestion}s      * @param suggestion The suggestion to process.      * @throws EntitySearcherException       */
specifier|private
name|void
name|processRedirects
parameter_list|(
name|Suggestion
name|suggestion
parameter_list|)
throws|throws
name|EntitySearcherException
block|{
comment|//if mode is IGNORE -> nothing to do
if|if
condition|(
name|linkerConfig
operator|.
name|getRedirectProcessingMode
argument_list|()
operator|==
name|RedirectProcessingMode
operator|.
name|IGNORE
condition|)
block|{
return|return;
block|}
comment|//in case results for queries are locally cached it might be the case
comment|//that some/all of the results do already redirects processed.
comment|//therefore there is a small internal state that stores this information
if|if
condition|(
name|suggestion
operator|.
name|isRedirectedProcessed
argument_list|()
condition|)
block|{
return|return;
comment|//Redirects for ResultMatch are already processed ... ignore
block|}
name|Entity
name|result
init|=
name|suggestion
operator|.
name|getResult
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|UriRef
argument_list|>
name|redirects
init|=
name|result
operator|.
name|getReferences
argument_list|(
name|linkerConfig
operator|.
name|getRedirectField
argument_list|()
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|linkerConfig
operator|.
name|getRedirectProcessingMode
argument_list|()
condition|)
block|{
case|case
name|ADD_VALUES
case|:
name|TripleCollection
name|entityData
init|=
name|result
operator|.
name|getData
argument_list|()
decl_stmt|;
name|UriRef
name|entityUri
init|=
name|result
operator|.
name|getUri
argument_list|()
decl_stmt|;
while|while
condition|(
name|redirects
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|UriRef
name|redirect
init|=
name|redirects
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|redirect
operator|!=
literal|null
condition|)
block|{
name|Entity
name|redirectedEntity
init|=
name|entitySearcher
operator|.
name|get
argument_list|(
name|redirect
argument_list|,
name|linkerConfig
operator|.
name|getSelectedFields
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|redirectedEntity
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|data
init|=
name|redirectedEntity
operator|.
name|getData
argument_list|()
operator|.
name|filter
argument_list|(
name|redirectedEntity
operator|.
name|getUri
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
init|;
name|data
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Triple
name|t
init|=
name|data
operator|.
name|next
argument_list|()
decl_stmt|;
name|entityData
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|entityUri
argument_list|,
name|t
operator|.
name|getPredicate
argument_list|()
argument_list|,
name|t
operator|.
name|getObject
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|//set that the redirects where searched for this result
name|suggestion
operator|.
name|setRedirectProcessed
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
case|case
name|FOLLOW
case|:
while|while
condition|(
name|redirects
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|UriRef
name|redirect
init|=
name|redirects
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|redirect
operator|!=
literal|null
condition|)
block|{
name|Entity
name|redirectedEntity
init|=
name|entitySearcher
operator|.
name|get
argument_list|(
name|redirect
argument_list|,
name|linkerConfig
operator|.
name|getSelectedFields
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|redirectedEntity
operator|!=
literal|null
condition|)
block|{
name|suggestion
operator|.
name|setRedirect
argument_list|(
name|redirectedEntity
argument_list|)
expr_stmt|;
block|}
block|}
block|}
default|default:
comment|//nothing to do
block|}
block|}
comment|/**      * Searches for Entities in the {@link #entitySearcher} corresponding to the      * {@link Token#getText() words} of the current {@link #state position} in      * the text.      * @param searchTokens the list of {@link Token#getText() words} to search      * entities for.      * @return The sorted list with the suggestions.      * If there are no suggestions an empty list will be returned.      * @throws EntitySearcherException       */
specifier|private
name|List
argument_list|<
name|Suggestion
argument_list|>
name|lookupEntities
parameter_list|(
name|List
argument_list|<
name|TokenData
argument_list|>
name|searchTokens
parameter_list|)
throws|throws
name|EntitySearcherException
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|languages
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|languages
operator|.
name|add
argument_list|(
name|linkerConfig
operator|.
name|getDefaultLanguage
argument_list|()
argument_list|)
expr_stmt|;
name|languages
operator|.
name|add
argument_list|(
name|state
operator|.
name|getLanguage
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|countryCodeIndex
init|=
name|state
operator|.
name|getLanguage
argument_list|()
operator|==
literal|null
condition|?
operator|-
literal|1
else|:
name|state
operator|.
name|getLanguage
argument_list|()
operator|.
name|indexOf
argument_list|(
literal|'-'
argument_list|)
decl_stmt|;
if|if
condition|(
name|countryCodeIndex
operator|>=
literal|2
condition|)
block|{
name|languages
operator|.
name|add
argument_list|(
name|state
operator|.
name|getLanguage
argument_list|()
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|countryCodeIndex
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|searchStrings
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|searchTokens
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|TokenData
argument_list|>
name|it
init|=
name|searchTokens
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|searchStrings
operator|.
name|add
argument_list|(
name|getSearchString
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|String
index|[]
name|languageArray
init|=
name|languages
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|languages
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Suggestion
argument_list|>
name|suggestions
init|=
operator|new
name|ArrayList
argument_list|<
name|Suggestion
argument_list|>
argument_list|()
decl_stmt|;
comment|//check if we have the search strings in the cache
name|List
argument_list|<
name|Entity
argument_list|>
name|results
init|=
name|lookupCache
operator|.
name|get
argument_list|(
name|searchStrings
argument_list|)
decl_stmt|;
if|if
condition|(
name|results
operator|!=
literal|null
condition|)
block|{
comment|//query is cached
name|cacheHits
operator|++
expr_stmt|;
comment|//match the cached results
for|for
control|(
name|Entity
name|result
range|:
name|results
control|)
block|{
name|processLookupResult
argument_list|(
name|searchTokens
argument_list|,
name|result
argument_list|,
name|suggestions
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// we need to perform a new query
name|results
operator|=
operator|new
name|ArrayList
argument_list|<
name|Entity
argument_list|>
argument_list|()
expr_stmt|;
comment|//perform the lookup with the parsed parameter
name|int
name|numResults
init|=
name|performLookup
argument_list|(
name|searchStrings
argument_list|,
name|languageArray
argument_list|,
name|suggestions
argument_list|,
name|searchTokens
argument_list|,
name|results
argument_list|)
decl_stmt|;
comment|//cache the results
name|lookupCache
operator|.
name|put
argument_list|(
name|searchStrings
argument_list|,
name|results
argument_list|)
expr_stmt|;
comment|//if no match where found in the result .. fallback to a search for the
comment|//current token
if|if
condition|(
name|suggestions
operator|.
name|isEmpty
argument_list|()
operator|&&
name|numResults
operator|>
literal|0
operator|&&
name|searchStrings
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|//there where results, but no one matched ...
comment|//   ... it is most likely a case where the used search terms are
comment|//       not releated. So try to query for the active token only
name|log
operator|.
name|debug
argument_list|(
literal|"> No match for '{}' searchStrings ... "
argument_list|,
name|searchStrings
argument_list|)
expr_stmt|;
name|searchStrings
operator|=
name|Collections
operator|.
name|singletonList
argument_list|(
name|getSearchString
argument_list|(
name|state
operator|.
name|getToken
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|searchTokens
operator|=
name|Collections
operator|.
name|singletonList
argument_list|(
name|state
operator|.
name|getToken
argument_list|()
argument_list|)
expr_stmt|;
name|results
operator|=
name|lookupCache
operator|.
name|get
argument_list|(
name|searchStrings
argument_list|)
expr_stmt|;
if|if
condition|(
name|results
operator|!=
literal|null
condition|)
block|{
comment|//query is cached
name|cacheHits
operator|++
expr_stmt|;
comment|//match the cached results
for|for
control|(
name|Entity
name|result
range|:
name|results
control|)
block|{
name|processLookupResult
argument_list|(
name|searchTokens
argument_list|,
name|result
argument_list|,
name|suggestions
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|results
operator|=
operator|new
name|ArrayList
argument_list|<
name|Entity
argument_list|>
argument_list|()
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"     ... fallback to search for active token '{}' ..."
argument_list|,
name|searchStrings
argument_list|)
expr_stmt|;
name|performLookup
argument_list|(
name|searchStrings
argument_list|,
name|languageArray
argument_list|,
name|suggestions
argument_list|,
name|searchTokens
argument_list|,
name|results
argument_list|)
expr_stmt|;
comment|//cache the results of the fall-back query
name|lookupCache
operator|.
name|put
argument_list|(
name|searchStrings
argument_list|,
name|results
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//sort the suggestions
if|if
condition|(
name|suggestions
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|suggestions
argument_list|,
name|Suggestion
operator|.
name|MATCH_TYPE_SUGGESTION_COMPARATOR
argument_list|)
expr_stmt|;
block|}
return|return
name|suggestions
return|;
block|}
comment|/**      * @param searchStrings      * @param languageArray      * @param suggestions      * @param searchTokens      * @param queryResults the unprocessed results of the query for the parsed      * parameters. This is used to cache results of queries. This avoid issuing      * the same query twice for a analysed document.      * string.      * @return      * @throws EntitySearcherException      */
specifier|private
name|int
name|performLookup
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|searchStrings
parameter_list|,
name|String
index|[]
name|languageArray
parameter_list|,
name|List
argument_list|<
name|Suggestion
argument_list|>
name|suggestions
parameter_list|,
name|List
argument_list|<
name|TokenData
argument_list|>
name|searchTokens
parameter_list|,
name|List
argument_list|<
name|Entity
argument_list|>
name|queryResults
parameter_list|)
throws|throws
name|EntitySearcherException
block|{
name|int
name|minProcessedResults
init|=
name|linkerConfig
operator|.
name|getMaxSuggestions
argument_list|()
operator|*
literal|3
decl_stmt|;
name|int
name|lookupLimit
init|=
name|Math
operator|.
name|max
argument_list|(
name|MIN_SEARCH_LIMIT
argument_list|,
name|linkerConfig
operator|.
name|getMaxSuggestions
argument_list|()
operator|*
literal|2
operator|*
name|searchTokens
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|maxResults
init|=
name|lookupLimit
operator|*
literal|2
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|numFiltered
init|=
literal|0
decl_stmt|;
name|boolean
name|moreResultsAvailable
init|=
literal|true
decl_stmt|;
name|int
name|numResults
init|=
literal|0
decl_stmt|;
comment|//search for entities until
comment|// (1) we have more as MAX_SUGGESTION results
comment|// (2) no more results are available
comment|// (3) the number of processed Entities is smaller as two times the
comment|//     suggestions
comment|// (4) the number of requested Entities is smaller as two times the
comment|//     lookup limit.
comment|//NOTE: making multiple requests can decrease the performance a lot.
comment|//      Because of that those limits assure that no more than two
comment|//      requests are made for the same lookup.
while|while
condition|(
name|suggestions
operator|.
name|size
argument_list|()
operator|<
name|linkerConfig
operator|.
name|getMaxSuggestions
argument_list|()
operator|&&
name|moreResultsAvailable
operator|&&
operator|(
name|numResults
operator|-
name|numFiltered
operator|)
operator|<
operator|(
name|minProcessedResults
operator|)
operator|&&
name|numResults
operator|<
name|maxResults
condition|)
block|{
name|Collection
argument_list|<
name|?
extends|extends
name|Entity
argument_list|>
name|results
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"> request entities [{}-{}] entities ..."
argument_list|,
name|offset
argument_list|,
operator|(
name|offset
operator|+
name|lookupLimit
operator|)
argument_list|)
expr_stmt|;
name|lookupStats
operator|.
name|begin
argument_list|()
expr_stmt|;
comment|//keep statistics
name|results
operator|=
name|entitySearcher
operator|.
name|lookup
argument_list|(
name|linkerConfig
operator|.
name|getNameField
argument_list|()
argument_list|,
name|linkerConfig
operator|.
name|getSelectedFields
argument_list|()
argument_list|,
name|searchStrings
argument_list|,
name|languageArray
argument_list|,
name|lookupLimit
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|lookupStats
operator|.
name|complete
argument_list|()
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"< found {} entities ..."
argument_list|,
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|//queries might return more as the requested results
name|moreResultsAvailable
operator|=
name|results
operator|.
name|size
argument_list|()
operator|>=
name|lookupLimit
expr_stmt|;
name|numResults
operator|=
name|numResults
operator|+
name|results
operator|.
name|size
argument_list|()
expr_stmt|;
name|offset
operator|=
name|numResults
expr_stmt|;
name|matchingStats
operator|.
name|begin
argument_list|()
expr_stmt|;
for|for
control|(
name|Entity
name|result
range|:
name|results
control|)
block|{
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"> {} (ranking: {})"
argument_list|,
name|result
operator|.
name|getId
argument_list|()
argument_list|,
name|result
operator|.
name|getEntityRanking
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|numQueryResults
operator|++
expr_stmt|;
comment|//white/black list based entity type filtering (STANBOL-1111)
if|if
condition|(
operator|!
name|linkerConfig
operator|.
name|isEntityTypeFilteringActive
argument_list|()
operator|||
operator|!
name|filterEntity
argument_list|(
name|result
operator|.
name|getReferences
argument_list|(
name|linkerConfig
operator|.
name|getTypeField
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
comment|//a valid query result
name|queryResults
operator|.
name|add
argument_list|(
name|result
argument_list|)
expr_stmt|;
comment|//now match the result against the current position in the text
name|processLookupResult
argument_list|(
name|searchTokens
argument_list|,
name|result
argument_list|,
name|suggestions
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//do not process Entities with a filtered type
name|numFilteredResults
operator|++
expr_stmt|;
comment|//global statistics
name|numFiltered
operator|++
expr_stmt|;
block|}
block|}
name|matchingStats
operator|.
name|complete
argument_list|()
expr_stmt|;
comment|//sort the suggestions
block|}
return|return
name|numResults
return|;
block|}
comment|/**      * Processes the parsed entity lookup results and adds suggestions to the      * parsed suggestion list      * @param result the result to process      * @param suggestions the suggestions      * @return the number of filtered results      */
specifier|private
name|void
name|processLookupResult
parameter_list|(
name|List
argument_list|<
name|TokenData
argument_list|>
name|searchTokens
parameter_list|,
name|Entity
name|result
parameter_list|,
name|List
argument_list|<
name|Suggestion
argument_list|>
name|suggestions
parameter_list|)
block|{
name|Suggestion
name|suggestion
init|=
name|matchLabels
argument_list|(
name|searchTokens
argument_list|,
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
name|suggestion
operator|.
name|getMatch
argument_list|()
operator|!=
name|MATCH
operator|.
name|NONE
condition|)
block|{
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"      + {}"
argument_list|,
name|suggestion
argument_list|)
expr_stmt|;
block|}
name|suggestions
operator|.
name|add
argument_list|(
name|suggestion
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"      - no match"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|boolean
name|filterEntity
parameter_list|(
name|Iterator
argument_list|<
name|UriRef
argument_list|>
name|entityTypes
parameter_list|)
block|{
name|Map
argument_list|<
name|UriRef
argument_list|,
name|Integer
argument_list|>
name|whiteList
init|=
name|linkerConfig
operator|.
name|getWhitelistedTypes
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|UriRef
argument_list|,
name|Integer
argument_list|>
name|blackList
init|=
name|linkerConfig
operator|.
name|getBlacklistedTypes
argument_list|()
decl_stmt|;
name|Integer
name|w
init|=
literal|null
decl_stmt|;
name|Integer
name|b
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|entityTypes
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|UriRef
name|type
init|=
name|entityTypes
operator|.
name|next
argument_list|()
decl_stmt|;
name|Integer
name|act
init|=
name|whiteList
operator|.
name|get
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|act
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|w
operator|==
literal|null
operator|||
name|act
operator|.
name|compareTo
argument_list|(
name|w
argument_list|)
operator|<
literal|0
condition|)
block|{
name|w
operator|=
name|act
expr_stmt|;
block|}
if|if
condition|(
name|act
operator|.
name|intValue
argument_list|()
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
name|act
operator|=
name|blackList
operator|.
name|get
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|act
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|b
operator|==
literal|null
operator|||
name|act
operator|.
name|compareTo
argument_list|(
name|b
argument_list|)
operator|<
literal|0
condition|)
block|{
name|b
operator|=
name|act
expr_stmt|;
block|}
if|if
condition|(
name|act
operator|.
name|intValue
argument_list|()
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
block|}
if|if
condition|(
name|w
operator|==
literal|null
operator|&&
name|b
operator|==
literal|null
condition|)
block|{
return|return
operator|!
name|linkerConfig
operator|.
name|isDefaultWhitelistTypes
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|w
operator|!=
literal|null
condition|)
block|{
return|return
name|b
operator|==
literal|null
operator|||
name|w
operator|.
name|compareTo
argument_list|(
name|b
argument_list|)
operator|<
literal|0
condition|?
literal|false
else|:
literal|true
return|;
block|}
else|else
block|{
comment|//w == null&& b != null
return|return
literal|true
return|;
comment|//filter
block|}
block|}
comment|/**      * Matches the labels of the parsed {@link Representation} with the Tokens of      * the texts (beginning with the currently active       * {@link ProcessingState#getToken() token}).<p>      * The field used to get the labels is retrieved from       * {@link EntitySearcher#getNameField()}. Only labels with no language or the      * language of the current sentence are considered. If less than       * {@link EntityLinkerConfig#getMinFoundTokens()} tokens match with an      * label the Concept is only considered to match if the label is      * {@link String#equalsIgnoreCase(String)} to the text covered by the      * matched token(s). Otherwise also {@link MATCH#FULL} and {@link MATCH#PARTIAL}      * results are allowed.      * @param entity The entity including at least the data for the      * {@link EntitySearcher#getNameField()} property.      * @return The result of the matching.      */
specifier|private
name|Suggestion
name|matchLabels
parameter_list|(
name|List
argument_list|<
name|TokenData
argument_list|>
name|searchTokens
parameter_list|,
name|Entity
name|entity
parameter_list|)
block|{
name|String
name|curLang
init|=
name|documentLang
decl_stmt|;
comment|//language of the current sentence
name|String
name|defLang
init|=
name|defaultLang
decl_stmt|;
comment|//configured default language
name|String
name|mainLang
init|=
name|documentMainLang
decl_stmt|;
name|Collection
argument_list|<
name|PlainLiteral
argument_list|>
name|mainLangLabels
decl_stmt|;
if|if
condition|(
name|documentMainLang
operator|!=
literal|null
condition|)
block|{
name|mainLang
operator|=
name|documentMainLang
expr_stmt|;
name|mainLangLabels
operator|=
operator|new
name|ArrayList
argument_list|<
name|PlainLiteral
argument_list|>
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|mainLang
operator|=
name|documentLang
expr_stmt|;
name|mainLangLabels
operator|=
name|Collections
operator|.
name|emptyList
argument_list|()
expr_stmt|;
block|}
name|Iterator
argument_list|<
name|PlainLiteral
argument_list|>
name|labels
init|=
name|entity
operator|.
name|getText
argument_list|(
name|linkerConfig
operator|.
name|getNameField
argument_list|()
argument_list|)
decl_stmt|;
name|Suggestion
name|match
init|=
operator|new
name|Suggestion
argument_list|(
name|entity
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|PlainLiteral
argument_list|>
name|defaultLabels
init|=
operator|new
name|ArrayList
argument_list|<
name|PlainLiteral
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|matchedLangLabel
init|=
literal|false
decl_stmt|;
comment|//avoid matching multiple labels with the exact same lexical.
name|Set
argument_list|<
name|String
argument_list|>
name|matchedLabels
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|labels
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|PlainLiteral
name|label
init|=
name|labels
operator|.
name|next
argument_list|()
decl_stmt|;
comment|//numLabels++;
name|String
name|lang
init|=
name|label
operator|.
name|getLanguage
argument_list|()
operator|!=
literal|null
condition|?
name|label
operator|.
name|getLanguage
argument_list|()
operator|.
name|toString
argument_list|()
else|:
literal|null
decl_stmt|;
name|String
name|text
init|=
name|label
operator|.
name|getLexicalForm
argument_list|()
decl_stmt|;
comment|//if case-insensitive matching ... compare lower case versions
if|if
condition|(
operator|!
name|linkerConfig
operator|.
name|isCaseSensitiveMatching
argument_list|()
condition|)
block|{
name|text
operator|=
name|text
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|lang
operator|==
literal|null
operator|&&
name|curLang
operator|==
literal|null
operator|)
operator|||
operator|(
name|lang
operator|!=
literal|null
operator|&&
name|curLang
operator|!=
literal|null
operator|&&
name|lang
operator|.
name|equalsIgnoreCase
argument_list|(
name|curLang
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|matchedLabels
operator|.
name|contains
argument_list|(
name|text
argument_list|)
condition|)
block|{
name|matchLabel
argument_list|(
name|searchTokens
argument_list|,
name|match
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|matchedLabels
operator|.
name|add
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|matchedLangLabel
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|matchedLangLabel
condition|)
block|{
name|matchedLangLabel
operator|=
literal|true
expr_stmt|;
comment|//found a equivalent label in the matchlang
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|lang
operator|==
literal|null
operator|&&
name|mainLang
operator|==
literal|null
operator|)
operator|||
operator|(
name|lang
operator|!=
literal|null
operator|&&
name|mainLang
operator|!=
literal|null
operator|&&
name|lang
operator|.
name|equalsIgnoreCase
argument_list|(
name|mainLang
argument_list|)
operator|)
condition|)
block|{
name|mainLangLabels
operator|.
name|add
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|lang
operator|==
literal|null
operator|&&
name|defLang
operator|==
literal|null
operator|)
operator|||
operator|(
name|lang
operator|!=
literal|null
operator|&&
name|defLang
operator|!=
literal|null
operator|&&
name|lang
operator|.
name|startsWith
argument_list|(
name|defLang
argument_list|)
operator|)
condition|)
block|{
name|defaultLabels
operator|.
name|add
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
block|}
comment|//try to match main language labels
if|if
condition|(
operator|!
name|matchedLangLabel
operator|||
name|match
operator|.
name|getMatch
argument_list|()
operator|==
name|MATCH
operator|.
name|NONE
condition|)
block|{
for|for
control|(
name|PlainLiteral
name|mainLangLabel
range|:
name|mainLangLabels
control|)
block|{
if|if
condition|(
operator|!
name|matchedLabels
operator|.
name|contains
argument_list|(
name|mainLangLabel
operator|.
name|getLexicalForm
argument_list|()
argument_list|)
condition|)
block|{
name|matchLabel
argument_list|(
name|searchTokens
argument_list|,
name|match
argument_list|,
name|mainLangLabel
argument_list|)
expr_stmt|;
name|matchedLabels
operator|.
name|add
argument_list|(
name|mainLangLabel
operator|.
name|getLexicalForm
argument_list|()
argument_list|)
expr_stmt|;
name|matchedLangLabel
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
comment|//use only labels in the default language if there is
comment|// * no label in the current language or
comment|// * no MATCH was found in the current language
if|if
condition|(
operator|!
name|matchedLangLabel
operator|||
name|match
operator|.
name|getMatch
argument_list|()
operator|==
name|MATCH
operator|.
name|NONE
condition|)
block|{
for|for
control|(
name|PlainLiteral
name|defaultLangLabel
range|:
name|defaultLabels
control|)
block|{
if|if
condition|(
operator|!
name|matchedLabels
operator|.
name|contains
argument_list|(
name|defaultLangLabel
operator|.
name|getLexicalForm
argument_list|()
argument_list|)
condition|)
block|{
name|matchLabel
argument_list|(
name|searchTokens
argument_list|,
name|match
argument_list|,
name|defaultLangLabel
argument_list|)
expr_stmt|;
name|matchedLabels
operator|.
name|add
argument_list|(
name|defaultLangLabel
operator|.
name|getLexicalForm
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|match
return|;
block|}
comment|/**      * @param suggestion      * @param label      */
specifier|private
name|void
name|matchLabel
parameter_list|(
name|List
argument_list|<
name|TokenData
argument_list|>
name|searchTokens
parameter_list|,
name|Suggestion
name|suggestion
parameter_list|,
name|PlainLiteral
name|label
parameter_list|)
block|{
comment|//        test.begin();
name|String
name|text
init|=
name|label
operator|.
name|getLexicalForm
argument_list|()
decl_stmt|;
name|String
name|lang
init|=
name|label
operator|.
name|getLanguage
argument_list|()
operator|==
literal|null
condition|?
literal|null
else|:
name|label
operator|.
name|getLanguage
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|linkerConfig
operator|.
name|isCaseSensitiveMatching
argument_list|()
condition|)
block|{
name|text
operator|=
name|text
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
comment|//TODO use language of label for Locale
block|}
comment|//Tokenize the label and remove remove tokens without alpha numerical chars
name|String
index|[]
name|unprocessedLabelTokens
init|=
name|labelTokenizer
operator|!=
literal|null
condition|?
name|labelTokenizer
operator|.
name|tokenize
argument_list|(
name|text
argument_list|,
name|lang
argument_list|)
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|unprocessedLabelTokens
operator|==
literal|null
condition|)
block|{
comment|//no tokenizer available
name|log
operator|.
name|info
argument_list|(
literal|"Unable to tokenize {} language texts. Will process untokenized label {}"
argument_list|,
name|state
operator|.
name|getLanguage
argument_list|()
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|unprocessedLabelTokens
operator|=
operator|new
name|String
index|[]
block|{
name|text
block|}
expr_stmt|;
comment|//there is already a warning
block|}
name|int
name|offset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|unprocessedLabelTokens
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|boolean
name|hasAlphaNumericChar
init|=
name|Utils
operator|.
name|hasAlphaNumericChar
argument_list|(
name|unprocessedLabelTokens
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|hasAlphaNumericChar
condition|)
block|{
name|offset
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|>
literal|0
condition|)
block|{
name|String
name|token
init|=
name|unprocessedLabelTokens
index|[
name|i
index|]
decl_stmt|;
name|token
operator|=
name|StringUtils
operator|.
name|replaceChars
argument_list|(
name|token
argument_list|,
literal|"."
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|unprocessedLabelTokens
index|[
name|i
operator|-
name|offset
index|]
operator|=
name|token
expr_stmt|;
block|}
block|}
name|String
index|[]
name|labelTokens
decl_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
name|labelTokens
operator|=
name|unprocessedLabelTokens
expr_stmt|;
block|}
else|else
block|{
name|labelTokens
operator|=
operator|new
name|String
index|[
name|unprocessedLabelTokens
operator|.
name|length
operator|-
name|offset
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|unprocessedLabelTokens
argument_list|,
literal|0
argument_list|,
name|labelTokens
argument_list|,
literal|0
argument_list|,
name|labelTokens
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|//holds the tokens and their position within the label. NOTE that the same
comment|//token may appear multiple times in the label (e.g. "Da Da Bing"
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|labelTokenMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|labelTokens
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|tokenIndexes
init|=
name|labelTokenMap
operator|.
name|get
argument_list|(
name|labelTokens
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|tokenIndexes
operator|==
literal|null
condition|)
block|{
name|tokenIndexes
operator|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|labelTokenMap
operator|.
name|put
argument_list|(
name|labelTokens
index|[
name|i
index|]
argument_list|,
name|tokenIndexes
argument_list|)
expr_stmt|;
block|}
name|tokenIndexes
operator|.
name|add
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|NavigableMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|matchedLabelTokens
init|=
operator|new
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|foundProcessableTokens
init|=
literal|0
decl_stmt|;
name|int
name|foundTokens
init|=
literal|0
decl_stmt|;
name|float
name|foundTokenMatch
init|=
literal|0
decl_stmt|;
comment|//ensure the correct order of the tokens in the suggested entity
name|boolean
name|search
init|=
literal|true
decl_stmt|;
name|boolean
name|activeTokenNotMatched
init|=
literal|true
decl_stmt|;
name|int
name|firstFoundIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|firstProcessableFoundIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|lastFoundIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|lastProcessableFoundIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|firstFoundLabelIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|lastfoundLabelIndex
init|=
operator|-
literal|1
decl_stmt|;
name|TokenData
name|currentToken
decl_stmt|;
name|String
name|currentTokenText
decl_stmt|;
name|int
name|currentTokenLength
decl_stmt|;
name|int
name|notFound
init|=
literal|0
decl_stmt|;
name|int
name|matchedTokensNotWithinProcessableTokenSpan
init|=
literal|0
decl_stmt|;
name|int
name|foundTokensWithinCoveredProcessableTokens
init|=
literal|0
decl_stmt|;
name|float
name|minTokenMatchFactor
init|=
name|linkerConfig
operator|.
name|getMinTokenMatchFactor
argument_list|()
decl_stmt|;
comment|//search for matches within the correct order
for|for
control|(
name|int
name|currentIndex
init|=
name|state
operator|.
name|getToken
argument_list|()
operator|.
name|index
init|;
name|currentIndex
operator|<
name|state
operator|.
name|getTokens
argument_list|()
operator|.
name|size
argument_list|()
operator|&&
name|search
condition|;
name|currentIndex
operator|++
control|)
block|{
name|currentToken
operator|=
name|state
operator|.
name|getTokens
argument_list|()
operator|.
name|get
argument_list|(
name|currentIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentToken
operator|.
name|hasAlphaNumeric
condition|)
block|{
name|currentTokenText
operator|=
name|linkerConfig
operator|.
name|isLemmaMatching
argument_list|()
condition|?
name|currentToken
operator|.
name|getTokenLemma
argument_list|()
else|:
name|currentToken
operator|.
name|getTokenText
argument_list|()
expr_stmt|;
if|if
condition|(
name|currentTokenText
operator|==
literal|null
condition|)
block|{
comment|//no lemma available
name|currentTokenText
operator|=
name|currentToken
operator|.
name|getTokenText
argument_list|()
expr_stmt|;
comment|//fallback to text
block|}
comment|//ignore '.' in tokens to ensure that 'D.C.' matches 'DC' ...
name|currentTokenText
operator|=
name|StringUtils
operator|.
name|replaceChars
argument_list|(
name|currentTokenText
argument_list|,
literal|"."
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|linkerConfig
operator|.
name|isCaseSensitiveMatching
argument_list|()
condition|)
block|{
name|currentTokenText
operator|=
name|currentTokenText
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
block|}
name|currentTokenLength
operator|=
name|currentTokenText
operator|.
name|length
argument_list|()
expr_stmt|;
name|boolean
name|found
init|=
literal|false
decl_stmt|;
name|float
name|matchFactor
init|=
literal|0f
decl_stmt|;
comment|//iteration starts at the next token after the last matched one
comment|//so it is OK to skip tokens in the label, but not within the text
for|for
control|(
name|int
name|i
init|=
name|lastfoundLabelIndex
operator|+
literal|1
init|;
operator|!
name|found
operator|&&
name|i
operator|<
name|labelTokens
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|labelTokenText
init|=
name|labelTokens
index|[
name|i
index|]
decl_stmt|;
name|int
name|labelTokenLength
init|=
name|labelTokenText
operator|.
name|length
argument_list|()
decl_stmt|;
name|float
name|maxLength
init|=
name|currentTokenLength
operator|>
name|labelTokenLength
condition|?
name|currentTokenLength
else|:
name|labelTokenLength
decl_stmt|;
name|float
name|lengthDif
init|=
name|Math
operator|.
name|abs
argument_list|(
name|currentTokenLength
operator|-
name|labelTokenLength
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|lengthDif
operator|/
name|maxLength
operator|)
operator|<=
operator|(
literal|1
operator|-
name|minTokenMatchFactor
operator|)
condition|)
block|{
comment|//this prevents unnecessary string comparison
name|int
name|matchCount
init|=
name|compareTokens
argument_list|(
name|currentTokenText
argument_list|,
name|labelTokenText
argument_list|)
decl_stmt|;
if|if
condition|(
name|matchCount
operator|/
name|maxLength
operator|>=
name|minTokenMatchFactor
condition|)
block|{
name|lastfoundLabelIndex
operator|=
name|i
expr_stmt|;
comment|//set the last found index to the current position
name|found
operator|=
literal|true
expr_stmt|;
comment|//set found to true -> stops iteration
name|matchFactor
operator|=
name|matchCount
operator|/
name|maxLength
expr_stmt|;
comment|//how good is the match
comment|//remove matched labels from the set to disable them for
comment|//a later random oder search
name|Integer
name|labelTokenIndex
init|=
name|getLabelTokenIndex
argument_list|(
name|labelTokenText
argument_list|,
name|i
argument_list|,
name|labelTokenMap
argument_list|)
decl_stmt|;
name|matchedLabelTokens
operator|.
name|put
argument_list|(
name|labelTokenIndex
argument_list|,
name|labelTokenText
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
comment|//search for a match in the wrong order
comment|//currently only exact matches (for testing)
name|Integer
name|index
init|=
name|getLabelTokenIndex
argument_list|(
name|currentTokenText
argument_list|,
name|lastfoundLabelIndex
operator|+
literal|1
argument_list|,
name|labelTokenMap
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|!=
literal|null
condition|)
block|{
name|matchedLabelTokens
operator|.
name|put
argument_list|(
name|index
argument_list|,
name|currentTokenText
argument_list|)
expr_stmt|;
name|found
operator|=
literal|true
expr_stmt|;
name|matchFactor
operator|=
literal|0.7f
expr_stmt|;
block|}
block|}
comment|//int found = text.indexOf(currentToken.getText().toLowerCase());
if|if
condition|(
name|found
condition|)
block|{
comment|//found
if|if
condition|(
name|currentToken
operator|.
name|isMatchable
condition|)
block|{
name|foundProcessableTokens
operator|++
expr_stmt|;
comment|//only count processable Tokens
if|if
condition|(
name|firstProcessableFoundIndex
operator|<
literal|0
condition|)
block|{
name|firstProcessableFoundIndex
operator|=
name|currentIndex
expr_stmt|;
block|}
name|lastProcessableFoundIndex
operator|=
name|currentIndex
expr_stmt|;
name|foundTokensWithinCoveredProcessableTokens
operator|++
expr_stmt|;
if|if
condition|(
name|matchedTokensNotWithinProcessableTokenSpan
operator|>
literal|0
condition|)
block|{
name|foundTokensWithinCoveredProcessableTokens
operator|=
name|foundTokensWithinCoveredProcessableTokens
operator|+
name|matchedTokensNotWithinProcessableTokenSpan
expr_stmt|;
name|matchedTokensNotWithinProcessableTokenSpan
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|matchedTokensNotWithinProcessableTokenSpan
operator|++
expr_stmt|;
block|}
name|foundTokens
operator|++
expr_stmt|;
name|foundTokenMatch
operator|=
name|foundTokenMatch
operator|+
name|matchFactor
expr_stmt|;
comment|//sum up the matches
if|if
condition|(
name|firstFoundIndex
operator|<
literal|0
condition|)
block|{
name|firstFoundIndex
operator|=
name|currentIndex
expr_stmt|;
name|firstFoundLabelIndex
operator|=
name|lastfoundLabelIndex
expr_stmt|;
block|}
name|lastFoundIndex
operator|=
name|currentIndex
expr_stmt|;
block|}
else|else
block|{
comment|//not found
if|if
condition|(
name|state
operator|.
name|getToken
argument_list|()
operator|.
name|index
operator|==
name|currentToken
operator|.
name|index
condition|)
block|{
comment|//the currently active Token MUST BE matched
name|search
operator|=
literal|false
expr_stmt|;
name|activeTokenNotMatched
operator|=
literal|true
expr_stmt|;
block|}
name|notFound
operator|++
expr_stmt|;
comment|//stop forward search if
comment|//                    if(currentToken.isMatchable || notFound> linkerConfig.getMaxNotFound()){
if|if
condition|(
operator|!
name|searchTokens
operator|.
name|contains
argument_list|(
name|currentToken
argument_list|)
condition|)
block|{
comment|//stop as soon as a token that needs to be processed is
comment|//not found in the label or the maximum number of tokens
comment|//that are not processable are not found
name|search
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
comment|// else token without alpha or numeric characters are not processed
block|}
comment|//search backwards for label tokens until firstFoundLabelIndex if there
comment|//are unconsumed Tokens in the sentence before state.getTokenIndex
name|int
name|currentIndex
init|=
name|state
operator|.
name|getToken
argument_list|()
operator|.
name|index
operator|-
literal|1
decl_stmt|;
name|int
name|labelIndex
init|=
name|firstFoundLabelIndex
operator|-
literal|1
decl_stmt|;
name|notFound
operator|=
literal|0
expr_stmt|;
name|matchedTokensNotWithinProcessableTokenSpan
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|activeTokenNotMatched
condition|)
block|{
comment|//do not search backwards if the active token
comment|//was not found
name|search
operator|=
literal|true
expr_stmt|;
block|}
while|while
condition|(
name|search
operator|&&
name|labelIndex
operator|>=
literal|0
operator|&&
name|currentIndex
operator|>=
literal|0
condition|)
block|{
comment|//&& currentIndex> state.getConsumedIndex()){
name|String
name|labelTokenText
init|=
name|labelTokens
index|[
name|labelIndex
index|]
decl_stmt|;
if|if
condition|(
name|labelTokenMap
operator|.
name|containsKey
argument_list|(
name|labelTokenText
argument_list|)
condition|)
block|{
comment|//still not matched
name|currentToken
operator|=
name|state
operator|.
name|getTokens
argument_list|()
operator|.
name|get
argument_list|(
name|currentIndex
argument_list|)
expr_stmt|;
name|currentTokenText
operator|=
name|linkerConfig
operator|.
name|isLemmaMatching
argument_list|()
condition|?
name|currentToken
operator|.
name|getTokenLemma
argument_list|()
else|:
name|currentToken
operator|.
name|getTokenText
argument_list|()
expr_stmt|;
if|if
condition|(
name|currentTokenText
operator|==
literal|null
condition|)
block|{
comment|//no lemma available
name|currentTokenText
operator|=
name|currentToken
operator|.
name|getTokenText
argument_list|()
expr_stmt|;
comment|//fallback to text
block|}
if|if
condition|(
operator|!
name|linkerConfig
operator|.
name|isCaseSensitiveMatching
argument_list|()
condition|)
block|{
name|currentTokenText
operator|=
name|currentTokenText
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
block|}
name|currentTokenText
operator|=
name|StringUtils
operator|.
name|replaceChars
argument_list|(
name|currentTokenText
argument_list|,
literal|"."
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|currentTokenLength
operator|=
name|currentTokenText
operator|.
name|length
argument_list|()
expr_stmt|;
name|boolean
name|found
init|=
literal|false
decl_stmt|;
name|float
name|matchFactor
init|=
literal|0f
decl_stmt|;
name|int
name|labelTokenLength
init|=
name|labelTokenText
operator|.
name|length
argument_list|()
decl_stmt|;
name|float
name|maxLength
init|=
name|currentTokenLength
operator|>
name|labelTokenLength
condition|?
name|currentTokenLength
else|:
name|labelTokenLength
decl_stmt|;
name|float
name|lengthDif
init|=
name|Math
operator|.
name|abs
argument_list|(
name|currentTokenLength
operator|-
name|labelTokenLength
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|lengthDif
operator|/
name|maxLength
operator|)
operator|<=
operator|(
literal|1
operator|-
name|minTokenMatchFactor
operator|)
condition|)
block|{
comment|//this prevents unnecessary string comparison
name|int
name|matchCount
init|=
name|compareTokens
argument_list|(
name|currentTokenText
argument_list|,
name|labelTokenText
argument_list|)
decl_stmt|;
if|if
condition|(
name|matchCount
operator|/
name|maxLength
operator|>=
name|minTokenMatchFactor
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
comment|//set found to true -> stops iteration
name|matchFactor
operator|=
name|matchCount
operator|/
name|maxLength
expr_stmt|;
comment|//how good is the match
block|}
block|}
if|if
condition|(
name|found
condition|)
block|{
comment|//found
if|if
condition|(
name|currentToken
operator|.
name|isMatchable
condition|)
block|{
name|foundProcessableTokens
operator|++
expr_stmt|;
comment|//only count processable Tokens
if|if
condition|(
name|lastProcessableFoundIndex
operator|<
literal|0
condition|)
block|{
comment|//if last is not yet set
name|lastProcessableFoundIndex
operator|=
name|currentIndex
expr_stmt|;
block|}
name|firstProcessableFoundIndex
operator|=
name|currentIndex
expr_stmt|;
name|foundTokensWithinCoveredProcessableTokens
operator|++
expr_stmt|;
if|if
condition|(
name|matchedTokensNotWithinProcessableTokenSpan
operator|>
literal|0
condition|)
block|{
name|foundTokensWithinCoveredProcessableTokens
operator|=
name|foundTokensWithinCoveredProcessableTokens
operator|+
name|matchedTokensNotWithinProcessableTokenSpan
expr_stmt|;
name|matchedTokensNotWithinProcessableTokenSpan
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|matchedTokensNotWithinProcessableTokenSpan
operator|++
expr_stmt|;
block|}
name|foundTokens
operator|++
expr_stmt|;
name|foundTokenMatch
operator|=
name|foundTokenMatch
operator|+
name|matchFactor
expr_stmt|;
comment|//sum up the matches
name|firstFoundIndex
operator|=
name|currentIndex
expr_stmt|;
name|labelIndex
operator|--
expr_stmt|;
name|Integer
name|foundIndex
init|=
name|getLabelTokenIndex
argument_list|(
name|labelTokenText
argument_list|,
name|currentIndex
argument_list|,
name|labelTokenMap
argument_list|)
decl_stmt|;
name|matchedLabelTokens
operator|.
name|put
argument_list|(
name|foundIndex
argument_list|,
name|labelTokenText
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|notFound
operator|++
expr_stmt|;
if|if
condition|(
name|currentToken
operator|.
name|isMatchable
operator|||
name|notFound
operator|>
name|linkerConfig
operator|.
name|getMaxNotFound
argument_list|()
condition|)
block|{
comment|//stop as soon as a token that needs to be processed is
comment|//not found in the label or the maximum number of tokens
comment|//that are not processable are not found
name|search
operator|=
literal|false
expr_stmt|;
block|}
block|}
name|currentIndex
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|//this token is already matched ...
name|labelIndex
operator|--
expr_stmt|;
comment|//try the next one
block|}
block|}
if|if
condition|(
name|foundProcessableTokens
operator|>
literal|0
condition|)
block|{
comment|//if any Token has matched
comment|//Now we make a second round to search tokens that match in the wrong order
comment|//e.g. if given and family name of persons are switched
specifier|final
name|LabelMatch
name|labelMatch
decl_stmt|;
name|int
name|coveredTokens
init|=
name|lastFoundIndex
operator|-
name|firstFoundIndex
operator|+
literal|1
decl_stmt|;
name|int
name|coveredProcessableTokens
init|=
name|lastProcessableFoundIndex
operator|-
name|firstProcessableFoundIndex
operator|+
literal|1
decl_stmt|;
comment|//check if we lookup Entities within a processable chunk
specifier|final
name|float
name|chunkMatchScore
decl_stmt|;
if|if
condition|(
operator|!
name|textProcessingConfig
operator|.
name|isIgnoreChunks
argument_list|()
operator|&&
name|state
operator|.
name|getToken
argument_list|()
operator|.
name|inChunk
operator|!=
literal|null
operator|&&
comment|//there is a chunk
name|state
operator|.
name|getToken
argument_list|()
operator|.
name|inChunk
operator|.
name|isProcessable
condition|)
block|{
comment|//the chunk is processable
name|ChunkData
name|cd
init|=
name|state
operator|.
name|getToken
argument_list|()
operator|.
name|inChunk
decl_stmt|;
name|List
argument_list|<
name|TokenData
argument_list|>
name|tokens
init|=
name|state
operator|.
name|getTokens
argument_list|()
decl_stmt|;
if|if
condition|(
name|log
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|"  ... checking match with chunk {}: {}"
argument_list|,
name|cd
operator|.
name|chunk
argument_list|,
name|cd
operator|.
name|chunk
operator|.
name|getSpan
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|int
name|cstart
init|=
name|cd
operator|.
name|getMatchableStart
argument_list|()
operator|>=
literal|0
condition|?
name|cd
operator|.
name|getMatchableStart
argument_list|()
else|:
name|firstProcessableFoundIndex
decl_stmt|;
name|int
name|cend
init|=
name|cd
operator|.
name|getMatchableEndChar
argument_list|()
decl_stmt|;
comment|//if the match does not cover the whole chunk
if|if
condition|(
name|cstart
argument_list|<
name|firstProcessableFoundIndex
operator|||
name|cend
argument_list|>
name|lastProcessableFoundIndex
condition|)
block|{
name|int
name|foundInChunk
init|=
literal|0
decl_stmt|;
name|int
name|numInChunk
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|cd
operator|.
name|matchableStart
init|;
name|i
operator|<=
name|cd
operator|.
name|matchableEnd
condition|;
name|i
operator|++
control|)
block|{
name|TokenData
name|td
init|=
name|tokens
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|td
operator|.
name|isMatchable
condition|)
block|{
name|numInChunk
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|firstProcessableFoundIndex
operator|&&
name|i
operator|<=
name|lastProcessableFoundIndex
condition|)
block|{
name|foundInChunk
operator|++
expr_stmt|;
block|}
block|}
block|}
name|chunkMatchScore
operator|=
operator|(
name|float
operator|)
name|foundInChunk
operator|/
operator|(
name|float
operator|)
name|numInChunk
expr_stmt|;
name|log
operator|.
name|trace
argument_list|(
literal|"  ... label matches {} of {} matchable token in Chunk"
argument_list|,
name|foundInChunk
argument_list|,
name|numInChunk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//matches the whole chunk
name|chunkMatchScore
operator|=
literal|1f
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//no chunk (or ignoreChuncks == true) .. set chunkMatchScore to 1f
name|chunkMatchScore
operator|=
literal|1f
expr_stmt|;
block|}
comment|//matched tokens only within the span of the first/last processable token
comment|//Matching rules
comment|// - if less than config#minTokenFound() than accept only EXACT
comment|// - override PARTIAL matches with FULL/EXACT matches only if
comment|//   foundTokens of the PARTIAL match is> than of the FULL/EXACT
comment|//   match (this will be very rare
name|String
name|currentText
init|=
name|state
operator|.
name|getTokenText
argument_list|(
name|firstFoundIndex
argument_list|,
name|coveredTokens
argument_list|)
decl_stmt|;
if|if
condition|(
name|chunkMatchScore
operator|==
literal|1f
operator|&&
comment|//the whole chunk matches
operator|(
name|linkerConfig
operator|.
name|isCaseSensitiveMatching
argument_list|()
condition|?
name|currentText
operator|.
name|equals
argument_list|(
name|text
argument_list|)
else|:
name|currentText
operator|.
name|equalsIgnoreCase
argument_list|(
name|text
argument_list|)
operator|)
condition|)
block|{
name|labelMatch
operator|=
operator|new
name|LabelMatch
argument_list|(
name|firstFoundIndex
argument_list|,
name|coveredTokens
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chunkMatchScore
operator|>=
name|linkerConfig
operator|.
name|getMinChunkMatchScore
argument_list|()
condition|)
block|{
name|int
name|coveredLabelTokens
init|=
name|matchedLabelTokens
operator|.
name|lastKey
argument_list|()
operator|.
name|intValue
argument_list|()
operator|-
name|matchedLabelTokens
operator|.
name|firstKey
argument_list|()
operator|.
name|intValue
argument_list|()
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|foundTokens
operator|==
name|labelTokens
operator|.
name|length
operator|&&
name|foundTokens
operator|==
name|coveredTokens
condition|)
block|{
comment|//if all token matched set found to covered: May be lower because only
comment|//processable tokens are counted, but FULL also checks
comment|//of non-processable!
name|foundTokens
operator|=
name|coveredTokens
expr_stmt|;
name|foundProcessableTokens
operator|=
name|coveredProcessableTokens
expr_stmt|;
block|}
name|labelMatch
operator|=
operator|new
name|LabelMatch
argument_list|(
name|firstProcessableFoundIndex
argument_list|,
name|coveredProcessableTokens
argument_list|,
name|foundProcessableTokens
argument_list|,
name|foundTokensWithinCoveredProcessableTokens
argument_list|,
name|foundTokenMatch
operator|/
operator|(
name|float
operator|)
name|foundTokens
argument_list|,
name|label
argument_list|,
name|labelTokens
operator|.
name|length
argument_list|,
name|coveredLabelTokens
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|log
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
comment|//trace level logging for STANBOL-1211
name|List
argument_list|<
name|TokenData
argument_list|>
name|tokens
init|=
name|state
operator|.
name|getTokens
argument_list|()
decl_stmt|;
name|int
name|start
init|=
name|tokens
operator|.
name|get
argument_list|(
name|firstProcessableFoundIndex
argument_list|)
operator|.
name|token
operator|.
name|getStart
argument_list|()
decl_stmt|;
name|int
name|end
init|=
name|tokens
operator|.
name|get
argument_list|(
name|lastProcessableFoundIndex
argument_list|)
operator|.
name|token
operator|.
name|getEnd
argument_list|()
decl_stmt|;
name|CharSequence
name|content
init|=
name|state
operator|.
name|getToken
argument_list|()
operator|.
name|token
operator|.
name|getContext
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
name|CharSequence
name|match
init|=
name|content
operator|.
name|subSequence
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
decl_stmt|;
name|ChunkData
name|cd
init|=
name|state
operator|.
name|getToken
argument_list|()
operator|.
name|inChunk
decl_stmt|;
name|int
name|cStart
init|=
name|tokens
operator|.
name|get
argument_list|(
name|cd
operator|.
name|matchableStart
argument_list|)
operator|.
name|token
operator|.
name|getStart
argument_list|()
decl_stmt|;
name|int
name|cEnd
init|=
name|tokens
operator|.
name|get
argument_list|(
name|cd
operator|.
name|matchableEnd
argument_list|)
operator|.
name|token
operator|.
name|getEnd
argument_list|()
decl_stmt|;
name|CharSequence
name|context
init|=
name|content
operator|.
name|subSequence
argument_list|(
name|cStart
argument_list|,
name|cEnd
argument_list|)
decl_stmt|;
name|log
operator|.
name|trace
argument_list|(
literal|" - filter match '{}'@[{},{}] because it does only match "
operator|+
literal|"{}% (min: {}%) of the matchable Tokens in Chunk '{}'@[{},{}]"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|match
block|,
name|start
block|,
name|end
block|,
name|Math
operator|.
name|round
argument_list|(
name|chunkMatchScore
operator|*
literal|100
argument_list|)
block|,
name|Math
operator|.
name|round
argument_list|(
name|linkerConfig
operator|.
name|getMinChunkMatchScore
argument_list|()
operator|*
literal|100
argument_list|)
block|,
name|context
block|,
name|cStart
block|,
name|cEnd
block|}
argument_list|)
expr_stmt|;
block|}
name|labelMatch
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|labelMatch
operator|!=
literal|null
operator|&&
name|labelMatch
operator|.
name|getLabelScore
argument_list|()
operator|>=
name|linkerConfig
operator|.
name|getMinLabelScore
argument_list|()
operator|&&
name|labelMatch
operator|.
name|getTextScore
argument_list|()
operator|>=
name|linkerConfig
operator|.
name|getMinTextScore
argument_list|()
operator|&&
name|labelMatch
operator|.
name|getMatchScore
argument_list|()
operator|>=
name|linkerConfig
operator|.
name|getMinMatchScore
argument_list|()
condition|)
block|{
name|log
operator|.
name|trace
argument_list|(
literal|" + add suggestion {}"
argument_list|,
name|labelMatch
argument_list|)
expr_stmt|;
name|suggestion
operator|.
name|addLabelMatch
argument_list|(
name|labelMatch
argument_list|)
expr_stmt|;
block|}
block|}
comment|//else NO tokens found -> nothing to do
comment|//        test.complete();
block|}
comment|/**      * Utility Method that searches for the Index of the parsed label token text      * within the labelTokenMap. Matched tokens are removed from the parsed      * LabelTokenMap<p>      * NOTE: This is necessary, because in cases where Labels do contain the same      * token twice, it might not be always clear which token is the matching one.      * Especially if the order of the Tokens in the Text does not exactly match      * the order within the Label. This Method tries always to find the matching      * token closest to the parsed currentIndex.      * It iterates backwards to prefer Tokens that occur later as the current index      * in the tokenized label.      * @param labelTokenText the text of the current labelToken      * @param currentIndex the current index of the processing (or if not known      * the last matched index of an token within the label      * @param labelTokenMap the Map holding tokens as key and a list of occurrences      * as values or<code>null</code> if no Token with the parsed labelTokenText      * was present as key in the parsed labelTokenMap      * @return the index of the selected label token      */
specifier|private
name|Integer
name|getLabelTokenIndex
parameter_list|(
name|String
name|labelTokenText
parameter_list|,
name|int
name|currentIndex
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|labelTokenMap
parameter_list|)
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|tokenIndexes
init|=
name|labelTokenMap
operator|.
name|get
argument_list|(
name|labelTokenText
argument_list|)
decl_stmt|;
if|if
condition|(
name|tokenIndexes
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|//try to remove the closest index in the map
name|Integer
name|labelTokenIndex
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|currentIndex
argument_list|)
decl_stmt|;
comment|//search the closest position
name|int
name|closest
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
name|int
name|closestIndex
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|p
init|=
name|tokenIndexes
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|p
operator|>=
literal|0
condition|;
name|p
operator|--
control|)
block|{
name|Integer
name|index
init|=
name|tokenIndexes
operator|.
name|get
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|int
name|dif
init|=
name|Math
operator|.
name|abs
argument_list|(
name|index
operator|.
name|intValue
argument_list|()
operator|-
name|currentIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|index
operator|.
name|intValue
argument_list|()
operator|-
name|currentIndex
argument_list|)
operator|<
name|closest
condition|)
block|{
name|closest
operator|=
name|dif
expr_stmt|;
name|closestIndex
operator|=
name|p
expr_stmt|;
name|labelTokenIndex
operator|=
name|index
expr_stmt|;
if|if
condition|(
name|closest
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
block|}
name|tokenIndexes
operator|.
name|remove
argument_list|(
name|closestIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|tokenIndexes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|labelTokenMap
operator|.
name|remove
argument_list|(
name|labelTokenText
argument_list|)
expr_stmt|;
block|}
return|return
name|labelTokenIndex
return|;
block|}
comment|/**      * Compares to token with each other and returns the longest match. The       * tokens are compared from the beginning and from the end.      * @param token1 the first token      * @param token2 the second token      * @return the number of matching chars      */
specifier|private
name|int
name|compareTokens
parameter_list|(
name|String
name|token1
parameter_list|,
name|String
name|token2
parameter_list|)
block|{
name|int
name|l1
init|=
name|token1
operator|.
name|length
argument_list|()
decl_stmt|;
comment|//length of the first token
name|int
name|l2
init|=
name|token2
operator|.
name|length
argument_list|()
decl_stmt|;
comment|//length of the second token
comment|//in case of same length check for equals first
if|if
condition|(
name|l1
operator|==
name|l2
operator|&&
name|token1
operator|.
name|equals
argument_list|(
name|token2
argument_list|)
condition|)
block|{
return|return
name|l1
return|;
block|}
name|int
name|ml
init|=
name|l1
operator|>
name|l2
condition|?
name|l2
else|:
name|l1
decl_stmt|;
comment|//minimum length of a token
if|if
condition|(
name|ml
operator|==
literal|0
condition|)
block|{
return|return
name|ml
return|;
block|}
name|int
name|f
init|=
literal|0
decl_stmt|;
comment|//forward match count + 1
name|int
name|b
init|=
literal|0
decl_stmt|;
comment|//backward match count + 1
name|boolean
name|match
init|=
literal|true
decl_stmt|;
comment|//still matches
while|while
condition|(
name|match
operator|&&
name|f
operator|<
name|ml
condition|)
block|{
name|match
operator|=
name|token1
operator|.
name|charAt
argument_list|(
name|f
argument_list|)
operator|==
name|token2
operator|.
name|charAt
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|f
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|match
condition|)
block|{
name|f
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|<
name|ml
condition|)
block|{
name|match
operator|=
literal|true
expr_stmt|;
while|while
condition|(
name|match
operator|&&
name|b
operator|<
name|ml
condition|)
block|{
name|b
operator|++
expr_stmt|;
name|match
operator|=
name|token1
operator|.
name|charAt
argument_list|(
name|l1
operator|-
name|b
argument_list|)
operator|==
name|token2
operator|.
name|charAt
argument_list|(
name|l2
operator|-
name|b
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|match
condition|)
block|{
name|b
operator|--
expr_stmt|;
block|}
block|}
return|return
name|f
operator|>
name|b
condition|?
name|f
else|:
name|b
return|;
block|}
comment|/**      * This logs the statistics about the processing process      * @param log the logger used to log the statistics      */
specifier|public
name|void
name|logStatistics
parameter_list|(
name|Logger
name|log
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"EntityLinking Statistics:"
argument_list|)
expr_stmt|;
name|double
name|textProcessingDuration
init|=
name|textProcessingStats
operator|.
name|getDuration
argument_list|()
decl_stmt|;
name|double
name|lookupDuration
init|=
name|lookupStats
operator|.
name|getDuration
argument_list|()
decl_stmt|;
name|double
name|matchingDuration
init|=
name|matchingStats
operator|.
name|getDuration
argument_list|()
decl_stmt|;
name|double
name|rankingDuration
init|=
name|rankingStats
operator|.
name|getDuration
argument_list|()
decl_stmt|;
name|double
name|other
init|=
name|processingTime
operator|-
name|textProcessingDuration
operator|-
name|lookupDuration
operator|-
name|matchingDuration
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"    - overal: {}ms (text processing: {}%, lookup: {}%, matching {}%, ranking {}%, other {}%)"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|processingTime
block|,
name|Math
operator|.
name|round
argument_list|(
name|textProcessingDuration
operator|*
literal|100
operator|/
operator|(
name|double
operator|)
name|processingTime
argument_list|)
block|,
name|Math
operator|.
name|round
argument_list|(
name|lookupDuration
operator|*
literal|100
operator|/
operator|(
name|double
operator|)
name|processingTime
argument_list|)
block|,
name|Math
operator|.
name|round
argument_list|(
name|matchingDuration
operator|*
literal|100
operator|/
operator|(
name|double
operator|)
name|processingTime
argument_list|)
block|,
name|Math
operator|.
name|round
argument_list|(
name|rankingDuration
operator|*
literal|100
operator|/
operator|(
name|double
operator|)
name|processingTime
argument_list|)
block|,
name|Math
operator|.
name|round
argument_list|(
name|other
operator|*
literal|100
operator|/
operator|(
name|double
operator|)
name|processingTime
argument_list|)
block|,         }
argument_list|)
expr_stmt|;
name|textProcessingStats
operator|.
name|printStatistics
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|lookupStats
operator|.
name|printStatistics
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|float
name|cacheHitPercentage
init|=
name|lookupStats
operator|.
name|count
operator|>
literal|0
condition|?
comment|//avoid division by zero
name|cacheHits
operator|*
literal|100f
operator|/
operator|(
name|float
operator|)
name|lookupStats
operator|.
name|count
else|:
name|Float
operator|.
name|NaN
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"    - cache hits: {} ({}%)"
argument_list|,
name|cacheHits
argument_list|,
name|cacheHitPercentage
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"      - {} query results ({} filtered - {}%)"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|numQueryResults
block|,
name|numFilteredResults
block|,
name|numFilteredResults
operator|*
literal|100f
operator|/
operator|(
name|float
operator|)
name|numQueryResults
block|}
argument_list|)
expr_stmt|;
name|matchingStats
operator|.
name|printStatistics
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|rankingStats
operator|.
name|printStatistics
argument_list|(
name|log
argument_list|)
expr_stmt|;
comment|//        test.printStatistics(log);
comment|//        test2.printStatistics(log);
block|}
block|}
end_class

end_unit

