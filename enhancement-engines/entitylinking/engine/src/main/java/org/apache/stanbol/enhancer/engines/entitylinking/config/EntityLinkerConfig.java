begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|config
package|;
end_package

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Dictionary
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|UriRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|namespaceprefix
operator|.
name|NamespaceMappingUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|namespaceprefix
operator|.
name|NamespacePrefixService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|EntitySearcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|impl
operator|.
name|EntityLinker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|impl
operator|.
name|Suggestion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|impl
operator|.
name|Suggestion
operator|.
name|MATCH
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|NlpAnnotations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|model
operator|.
name|Chunk
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|model
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|morpho
operator|.
name|MorphoFeatures
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|pos
operator|.
name|Pos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|pos
operator|.
name|PosTag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|OntologicalClasses
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|service
operator|.
name|cm
operator|.
name|ConfigurationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * The configuration for the {@link EntityLinker}. Typically this  * configuration does not change often. Therefore it will be used for  * several {@link EntityLinker} instances processing different   * contents.  * @author Rupert Westenthaler  *  */
end_comment

begin_class
specifier|public
class|class
name|EntityLinkerConfig
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|EntityLinkerConfig
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * The field used to search for labels in the vocabulary linked against      */
specifier|public
specifier|static
specifier|final
name|String
name|NAME_FIELD
init|=
literal|"enhancer.engines.linking.labelField"
decl_stmt|;
comment|/**      * The field used as types for entities. While the type does not influence the      * suggestions it is used for the<code>fise:entity-type</code> value of       *<code>fise:EntityAnnotation</code>s and also to determine the      *<code>dc:type</code> value of<code>fise:TextAnnotation</code>s via the      * configured {@link #TYPE_MAPPINGS}.      */
specifier|public
specifier|static
specifier|final
name|String
name|TYPE_FIELD
init|=
literal|"enhancer.engines.linking.typeField"
decl_stmt|;
comment|/**      * Allows to configure a list of entity types that are white/black listed.      */
specifier|public
specifier|static
specifier|final
name|String
name|ENTITY_TYPES
init|=
literal|"enhancer.engines.linking.entityTypes"
decl_stmt|;
comment|/**      * Allows to enable/disable case sensitive matching      */
specifier|public
specifier|static
specifier|final
name|String
name|CASE_SENSITIVE
init|=
literal|"enhancer.engines.linking.caseSensitive"
decl_stmt|;
comment|/**      * The field used to lookup redirects      */
specifier|public
specifier|static
specifier|final
name|String
name|REDIRECT_FIELD
init|=
literal|"enhancer.engines.linking.redirectField"
decl_stmt|;
comment|/**      * If/how redirects (provided by the {@link #REDIRECT_FIELD}) are processed.      */
specifier|public
specifier|static
specifier|final
name|String
name|REDIRECT_MODE
init|=
literal|"enhancer.engines.linking.redirectMode"
decl_stmt|;
comment|/**      * The maximum number of fise:EntityAnnotations created as suggestion for a fise:TextAnnotation      */
specifier|public
specifier|static
specifier|final
name|String
name|SUGGESTIONS
init|=
literal|"enhancer.engines.linking.suggestions"
decl_stmt|;
comment|/**      * If enabled {@link MorphoFeatures#getLemma()} values are used instead of the {@link Token#getSpan()} to      * search/match Entities within the Vocabulary linked against.      * @see EntityLinkerConfig#isLemmaMatching()      * @see EntityLinkerConfig#DEFAULT_LEMMA_MATCHING_STATE      */
specifier|public
specifier|static
specifier|final
name|String
name|LEMMA_MATCHING_STATE
init|=
literal|"enhancer.engines.linking.lemmaMatching"
decl_stmt|;
comment|/**      * Can be used to that the "default language" from<code>null</code>      * (labels without language tag) to an other value (e.g. "en").<p>      * The "default language" is used in addition to the language of the      * processed text to search for labels.      */
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_MATCHING_LANGUAGE
init|=
literal|"enhancer.engines.linking.defaultMatchingLanguage"
decl_stmt|;
comment|/**      * Allows to configure entity type -> dc:type mappings as used for created      * fise:TextAnnotations      */
specifier|public
specifier|static
specifier|final
name|String
name|TYPE_MAPPINGS
init|=
literal|"enhancer.engines.linking.typeMappings"
decl_stmt|;
comment|/**      * How well single tokens of the Label needs to match a token of the Text so that they      * are considered to match. Matching does only allow differences at the end of the      * token (e.g. "London" -> "Londons major")      */
specifier|public
specifier|static
specifier|final
name|String
name|MIN_TOKEN_SCORE
init|=
literal|"enhancer.engines.linking.minTokenScore"
decl_stmt|;
comment|/**      * The minimum number of matching tokens. Only "matchable" tokens are counted.      * For full matches (where all tokens of the Label do match tokens in the text)      * this parameter is ignored.<p>      * This parameter is strongly related with the {@link #MIN_LABEL_SCORE}.      * Typical setting are<ul>      *<li><code>{@link #MIN_FOUND_TOKENS}=1</code> and<code>{@link #MIN_LABEL_SCORE}> 0.5</code> (e.g. 0.75)      *<li><code>{@link #MIN_FOUND_TOKENS}=2</code> and<code>{@link #MIN_LABEL_SCORE}<= 0.5</code> (e.g. 0.5)      *</ul>      * as both settings will ensures that Labels with two tokens where only a single one      * does match with the text are not suggested.<p>      * If used in combination with an disambiguation Engine one might want to consider      * Entities where their labels do match only a single token is such cases a      *<code>{@link #MIN_FOUND_TOKENS}=1</code> and<code>{@link #MIN_LABEL_SCORE}<= 0.5</code>      * might be also a meaningful configuration. In such cases users will also want to set the      *<code>{@link #SUGGESTIONS}> 10</code>.      */
specifier|public
specifier|static
specifier|final
name|String
name|MIN_FOUND_TOKENS
init|=
literal|"enhancer.engines.linking.minFoundTokens"
decl_stmt|;
comment|/**      * The "Label Score" [0..1] represents how much of the      * Label of an Entity matches with the Text. It compares the number      * of Tokens of the Label with the number of Tokens matched to the      * Text. Not exact matches for Tokens, or if the Tokens within the       * label do appear in an other order than in the text do also       * reduce this score.<p>      * The default is {@link EntityLinkerConfig#DEFAULT_MIN_LABEL_SCORE}      * (value: {@value EntityLinkerConfig#DEFAULT_MIN_LABEL_SCORE})      */
specifier|public
specifier|static
specifier|final
name|String
name|MIN_LABEL_SCORE
init|=
literal|"enhancer.engines.linking.minLabelScore"
decl_stmt|;
comment|/**      * The "Text Score" [0..1] represents how well the      * Label of an Entity matches to the selected Span in the Text.      * It compares the number of matched {@link Token} from      * the label with the number of Tokens enclosed by the Span      * in the Text an Entity is suggested for. Not exact matches       * for Tokens, or if the Tokens within the label do appear in      * an other order than in the text do also reduce this score.<p>      * The default is {@link EntityLinkerConfig#DEFAULT_MIN_TEXT_SCORE}      * (value: {@value EntityLinkerConfig#DEFAULT_MIN_TEXT_SCORE})      */
specifier|public
specifier|static
specifier|final
name|String
name|MIN_TEXT_SCORE
init|=
literal|"enhancer.engines.linking.minTextScore"
decl_stmt|;
comment|/**      * Defined as the product of the "Text Score" with the      * "Label Score" - meaning that this value represents      * both how well the label matches the text and how much of the      * label is matched with the text.<p>      * The default is {@link EntityLinkerConfig#DEFAULT_MIN_MATCH_SCORE}      * (value: {@value EntityLinkerConfig#DEFAULT_MIN_MATCH_SCORE})      * @see #MIN_TEXT_SCORE      * @see #MIN_LABEL_SCORE      */
specifier|public
specifier|static
specifier|final
name|String
name|MIN_MATCH_FACTOR
init|=
literal|"enhancer.engines.linking.minMatchScore"
decl_stmt|;
comment|/**      * The minimum score an Entity must match matchable {@link Token}s within a processable      * {@link Chunk}. By {@link #DEFAULT_MIN_CHUNK_MATCH_SCORE default} this is      * set to<code>51%</code> to filter Entities that do only match a single token      * within a NounPhrase of two words. This feature was introduced with      *<a href="https://issues.apache.org/jira/browse/STANBOL-1211">STANBOL-1211</a>      */
specifier|public
specifier|static
specifier|final
name|String
name|MIN_CHUNK_MATCH_SCORE
init|=
literal|"enhancer.engines.linking.minChunkMatchScore"
decl_stmt|;
comment|/**      * The maximum number of {@link Token} used as search terms with the       * {@link EntitySearcher#lookup(String, Set, java.util.List, String[], Integer)}      * method      */
specifier|public
specifier|static
specifier|final
name|String
name|MAX_SEARCH_TOKENS
init|=
literal|"enhancer.engines.linking.maxSearchTokens"
decl_stmt|;
comment|/**      * The maximum number of {@link Token} searched around a linkable Token for      * additional search tokens.<p>      * As an Example in the text section "at the University of Munich a new procedure to"      * only "Munich" would be classified as {@link Pos#ProperNoun} and considered as      * linkable. However for searching it makes sence to use additional Tokens to      * reduce (or correctly rank) the expected high number of results for "Munich".      * Because of that "matchable" words surrounding the linkable are considered as      * included for searches.<p>      * This parameter allows to configure the maximum distance surounding the current      * linkable Token other linkable tokens can be included in searches.      */
specifier|public
specifier|static
specifier|final
name|String
name|MAX_SEARCH_TOKEN_DISTANCE
init|=
literal|"enhancer.engines.linking.maxSearchTokenDistance"
decl_stmt|;
comment|/**      * Adds the dereference feature (STANBOL-333) also to this engine.      * This will be replaced by STANBOL-336.       */
specifier|public
specifier|static
specifier|final
name|String
name|DEREFERENCE_ENTITIES
init|=
literal|"enhancer.engines.linking.dereference"
decl_stmt|;
comment|/**      * Allows to add a list of fields that are included when dereferencing Entities      */
specifier|public
specifier|static
specifier|final
name|String
name|DEREFERENCE_ENTITIES_FIELDS
init|=
literal|"enhancer.engines.linking.dereferenceFields"
decl_stmt|;
comment|/**      * Allows to enable/disable sorting of suggestion that have the same score      * based on the entity ranking (popularity of the entity within the knowledge base)      */
specifier|public
specifier|static
specifier|final
name|String
name|RANK_EQUAL_SCORES_BASED_ON_ENTITY_RANKINGS
init|=
literal|"enhancer.engines.linking.useEntityRankings"
decl_stmt|;
comment|/**      * The default number for the maximum number of terms suggested for a word      */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_SUGGESTIONS
init|=
literal|3
decl_stmt|;
comment|/**      * Default value for the number of tokens that must be contained in      * suggested terms. The default is<code>1</code>      */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MIN_FOUND_TOKENS
init|=
literal|1
decl_stmt|;
comment|/**      * Multiple Tokens can be sent to the {@link EntitySearcher} service. The      * service uses this as optional parameters for the search. Therefore      * returned Concepts MUST contain at least a single of the parsed       * tokens.<p>      * The default value of<code>2</code> should be enough for nearly all      * Taxonomies to sufficiently reduce the number of results.<p>      * NOTE that the labels (nameField) of the results are compared as a      * whole. So even if only 2 Tokens are used for the search there may be      * more mapped to the actual label of an result.      */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MAX_SEARCH_TOKENS
init|=
literal|2
decl_stmt|;
comment|/**      * Default value for the maximum distance tokens are      * considered to be used (in addition to the currently processed on)      * for searches of Entities.<p>      * The default is set to<code>3</code>       */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MAX_SEARCH_DISTANCE
init|=
literal|3
decl_stmt|;
comment|/**      * Default value for {@link #getNameField()} (rdfs:label)      */
specifier|public
specifier|static
specifier|final
name|UriRef
name|DEFAULT_NAME_FIELD
init|=
operator|new
name|UriRef
argument_list|(
literal|"http://www.w3.org/2000/01/rdf-schema#label"
argument_list|)
decl_stmt|;
comment|/**      * Default value for {@link #getTypeField()} (rdf:type)      */
specifier|public
specifier|static
specifier|final
name|UriRef
name|DEFAULT_TYPE_FIELD
init|=
operator|new
name|UriRef
argument_list|(
literal|"http://www.w3.org/1999/02/22-rdf-syntax-ns#type"
argument_list|)
decl_stmt|;
comment|/**      * Default value for {@link #getRedirectField()} (rdf:seeAlso)      */
specifier|public
specifier|static
specifier|final
name|UriRef
name|DEFAULT_REDIRECT_FIELD
init|=
operator|new
name|UriRef
argument_list|(
literal|"http://www.w3.org/2000/01/rdf-schema#seeAlso"
argument_list|)
decl_stmt|;
comment|/**      * The default language used to search for labels regardless of the language      * of the text. The default value is<code>null</code> causing to include      * labels that do not have a language assigned.      */
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_LANGUAGE
init|=
literal|null
decl_stmt|;
comment|/**      * The default for case sensitive matching is set to<code>false</code>      */
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_CASE_SENSITIVE_MATCHING_STATE
init|=
literal|false
decl_stmt|;
comment|/**      * By default Lemma based matching is deactivated.      */
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_LEMMA_MATCHING_STATE
init|=
literal|false
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|double
name|DEFAULT_MIN_LABEL_SCORE
init|=
literal|0.75
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|double
name|DEFAULT_MIN_TEXT_SCORE
init|=
literal|0.4
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|double
name|DEFAULT_MIN_MATCH_SCORE
init|=
literal|0.3
decl_stmt|;
comment|/**      * By default more as 50% of the matchable tokens of a processable chunk      * need to match so that a Entity is considered to be mentioned in the text      * (STANBOL-1211)      */
specifier|public
specifier|static
specifier|final
name|double
name|DEFAULT_MIN_CHUNK_MATCH_SCORE
init|=
literal|0.51
decl_stmt|;
comment|/**      * Default mapping for Concept types to dc:type values added for      * TextAnnotations.      */
specifier|public
specifier|static
specifier|final
name|Map
argument_list|<
name|UriRef
argument_list|,
name|UriRef
argument_list|>
name|DEFAULT_ENTITY_TYPE_MAPPINGS
decl_stmt|;
static|static
block|{
comment|//the default mappings for the three types used by the Stanbol Enhancement Structure
name|Map
argument_list|<
name|UriRef
argument_list|,
name|UriRef
argument_list|>
name|mappings
init|=
operator|new
name|HashMap
argument_list|<
name|UriRef
argument_list|,
name|UriRef
argument_list|>
argument_list|()
decl_stmt|;
name|mappings
operator|.
name|put
argument_list|(
name|OntologicalClasses
operator|.
name|DBPEDIA_ORGANISATION
argument_list|,
name|OntologicalClasses
operator|.
name|DBPEDIA_ORGANISATION
argument_list|)
expr_stmt|;
name|mappings
operator|.
name|put
argument_list|(
operator|new
name|UriRef
argument_list|(
literal|"http://dbpedia.org/ontology/Newspaper"
argument_list|)
argument_list|,
name|OntologicalClasses
operator|.
name|DBPEDIA_ORGANISATION
argument_list|)
expr_stmt|;
name|mappings
operator|.
name|put
argument_list|(
operator|new
name|UriRef
argument_list|(
literal|"http://schema.org/Organization"
argument_list|)
argument_list|,
name|OntologicalClasses
operator|.
name|DBPEDIA_ORGANISATION
argument_list|)
expr_stmt|;
comment|//        mappings.put(NamespaceEnum.dailymed+"organization",OntologicalClasses.DBPEDIA_ORGANISATION);
name|mappings
operator|.
name|put
argument_list|(
name|OntologicalClasses
operator|.
name|DBPEDIA_PERSON
argument_list|,
name|OntologicalClasses
operator|.
name|DBPEDIA_PERSON
argument_list|)
expr_stmt|;
name|mappings
operator|.
name|put
argument_list|(
operator|new
name|UriRef
argument_list|(
literal|"http://xmlns.com/foaf/0.1/Person"
argument_list|)
argument_list|,
name|OntologicalClasses
operator|.
name|DBPEDIA_PERSON
argument_list|)
expr_stmt|;
name|mappings
operator|.
name|put
argument_list|(
operator|new
name|UriRef
argument_list|(
literal|"http://schema.org/Person"
argument_list|)
argument_list|,
name|OntologicalClasses
operator|.
name|DBPEDIA_PERSON
argument_list|)
expr_stmt|;
name|mappings
operator|.
name|put
argument_list|(
name|OntologicalClasses
operator|.
name|DBPEDIA_PLACE
argument_list|,
name|OntologicalClasses
operator|.
name|DBPEDIA_PLACE
argument_list|)
expr_stmt|;
name|mappings
operator|.
name|put
argument_list|(
operator|new
name|UriRef
argument_list|(
literal|"http://schema.org/Place"
argument_list|)
argument_list|,
name|OntologicalClasses
operator|.
name|DBPEDIA_PLACE
argument_list|)
expr_stmt|;
name|mappings
operator|.
name|put
argument_list|(
operator|new
name|UriRef
argument_list|(
literal|"http://www.opengis.net/gml/_Feature"
argument_list|)
argument_list|,
name|OntologicalClasses
operator|.
name|DBPEDIA_PLACE
argument_list|)
expr_stmt|;
name|mappings
operator|.
name|put
argument_list|(
name|OntologicalClasses
operator|.
name|SKOS_CONCEPT
argument_list|,
name|OntologicalClasses
operator|.
name|SKOS_CONCEPT
argument_list|)
expr_stmt|;
comment|//        UriRef DRUG = new UriRef(NamespaceEnum.drugbank+"drugs");
comment|//        mappings.put(DRUG.getUnicodeString(), DRUG);
comment|//        mappings.put(NamespaceEnum.dbpediaOnt+"Drug", DRUG);
comment|//        mappings.put(NamespaceEnum.dailymed+"drugs", DRUG);
comment|//        mappings.put(NamespaceEnum.sider+"drugs", DRUG);
comment|//        mappings.put(NamespaceEnum.tcm+"Medicine", DRUG);
comment|//
comment|//        UriRef DISEASE = new UriRef(NamespaceEnum.diseasome+"diseases");
comment|//        mappings.put(DISEASE.getUnicodeString(), DISEASE);
comment|//        mappings.put(NamespaceEnum.linkedct+"condition", DISEASE);
comment|//        mappings.put(NamespaceEnum.tcm+"Disease", DISEASE);
comment|//
comment|//        UriRef SIDE_EFFECT = new UriRef(NamespaceEnum.sider+"side_effects");
comment|//        mappings.put(SIDE_EFFECT.getUnicodeString(), SIDE_EFFECT);
comment|//
comment|//        UriRef INGREDIENT = new UriRef(NamespaceEnum.dailymed+"ingredients");
comment|//        mappings.put(INGREDIENT.getUnicodeString(), INGREDIENT);
name|DEFAULT_ENTITY_TYPE_MAPPINGS
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|mappings
argument_list|)
expr_stmt|;
block|}
comment|/**      * Enumeration over the different possibilities on how to deal with      * redirects (similar to Browsers following HTTP status 303 and RDF defining      * the "rdf:seeAlso" relation.       * @author Rupert Westenthaler      */
specifier|public
specifier|static
enum|enum
name|RedirectProcessingMode
block|{
comment|/**          * Ignore redirects          */
name|IGNORE
block|,
comment|/**          * Follow redirects, but only add the values (e.g. labels, types) such          * entities to the original one.          */
name|ADD_VALUES
block|,
comment|/**          * Follow the redirect.          */
name|FOLLOW
block|}
comment|/**      * The default value for how to process redirect is set to      * {@link RedirectProcessingMode#IGNORE}      */
specifier|public
specifier|static
name|RedirectProcessingMode
name|DEFAULT_REDIRECT_PROCESSING_MODE
init|=
name|RedirectProcessingMode
operator|.
name|IGNORE
decl_stmt|;
comment|/**      * The dereferenceEntitiesState as set in {@link #activateEntityDereference(Dictionary)}      */
specifier|private
name|boolean
name|dereferenceEntitiesState
decl_stmt|;
comment|/**      * The the maximum number of terms suggested for a word      */
specifier|private
name|int
name|maxSuggestions
init|=
name|DEFAULT_SUGGESTIONS
decl_stmt|;
comment|/**      * The minimum number of Tokens in the text that must match with       * a label of the Entity so that also non-exact matches are      * used for suggestions      */
specifier|private
name|int
name|minFoundTokens
init|=
name|DEFAULT_MIN_FOUND_TOKENS
decl_stmt|;
comment|/**      * The maximum numbers of Tokens sent to the {@link EntitySearcher} to search      * for concepts.<p>      * NOTE that the labels (nameField) of the results are compared as a      * whole. So even if only e.g. 2 tokens are used for the search there may be      * more mapped to the actual label of an result.      */
specifier|private
name|int
name|maxSearchTokens
init|=
name|DEFAULT_MAX_SEARCH_TOKENS
decl_stmt|;
comment|/**      * Defines the maximum distance tokens are      * considered to be used (in addition to the currently processed on)      * for searches of Entities.<p>      */
specifier|private
name|int
name|maxSearchDistance
init|=
name|DEFAULT_MAX_SEARCH_DISTANCE
decl_stmt|;
specifier|private
name|boolean
name|caseSensitiveMatchingState
init|=
name|DEFAULT_CASE_SENSITIVE_MATCHING_STATE
decl_stmt|;
comment|/**      * Holds the mappings of rdf:type used by concepts to dc:type values used      * by TextAnnotations.       */
specifier|private
name|Map
argument_list|<
name|UriRef
argument_list|,
name|UriRef
argument_list|>
name|typeMappings
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|UriRef
argument_list|,
name|UriRef
argument_list|>
name|unmodTypeMappings
decl_stmt|;
comment|/**      * The mode on how to process redirect for Entities.       */
specifier|private
name|RedirectProcessingMode
name|redirectProcessingMode
decl_stmt|;
comment|/**      * the default DC Type      */
specifier|private
name|UriRef
name|defaultDcType
decl_stmt|;
specifier|private
name|UriRef
name|nameField
decl_stmt|;
specifier|private
name|UriRef
name|redirectField
decl_stmt|;
specifier|private
name|UriRef
name|typeField
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|UriRef
argument_list|,
name|Integer
argument_list|>
name|blacklistedTypes
init|=
operator|new
name|HashMap
argument_list|<
name|UriRef
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|UriRef
argument_list|,
name|Integer
argument_list|>
name|whitelistedTypes
init|=
operator|new
name|HashMap
argument_list|<
name|UriRef
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|Boolean
name|defaultWhitelistTypes
init|=
literal|null
decl_stmt|;
specifier|private
name|Set
argument_list|<
name|UriRef
argument_list|>
name|dereferencedFields
init|=
operator|new
name|HashSet
argument_list|<
name|UriRef
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|Set
argument_list|<
name|UriRef
argument_list|>
name|__selectedFields
decl_stmt|;
comment|/**      * The language always included in searches (regardless of the language      * detected for the text.      */
specifier|private
name|String
name|defaultLanguage
init|=
name|DEFAULT_LANGUAGE
decl_stmt|;
comment|/**      * Default for the maximum number of non-processable tokens that are       * allowed to not match before no further tokens are matched against a label       * of an Entity.<p>      * This allows e.g. to match "Dr. Richard Dogles" with "Dr Richard Dogles"      * as '.' is a non-processable token in the text that is missing in the      * label.<p>      * The default is set to<code>1</code>      */
specifier|public
specifier|final
specifier|static
name|int
name|DEFAULT_MAX_NOT_FOUND
init|=
literal|1
decl_stmt|;
comment|/**      * Value of the maximum number of non-processable tokens that are       * allowed to not match before no further tokens are matched against a label       * of an Entity.<p>      * This allows e.g. to match "Dr. Richard Dogles" with "Dr Richard Dogles"      * as '.' is a non-processable token in the text that is missing in the      * label.     */
specifier|private
name|int
name|maxNotFound
decl_stmt|;
comment|/**      * Default value for the minimum token match factor.      * If Tokens match is determined by comparing them using some algorithm.      * Results need to be in the range [0..1]. This factor defines the minimum      * similarity value so that a match is assumed. Not that this factor only      * is used for filtering out non-matching tokens. The similarity value will      * still used for calculating the confidence.<p>      * The default is set to<code>0.7</code>.      */
specifier|public
specifier|final
specifier|static
name|float
name|DEFAULT_MIN_TOKEN_SCORE
init|=
literal|0.7f
decl_stmt|;
comment|/**      * By default Entities are dereferenced      */
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_DEREFERENCE_ENTITIES_STATE
init|=
literal|true
decl_stmt|;
comment|/**      * The default value for the state if entities that would have the same score      * should get their score slightly changed to ensure that entities with an      * higher ranking (popularity) do have an higher score.      */
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_RANK_EQUAL_SCORES_BASED_ON_ENTITY_RANKINGS
init|=
literal|true
decl_stmt|;
comment|/**      * If Tokens match is determined by comparing them using some algorithm.      * Results need to be in the range [0..1]. This factor defines the minimum      * similarity value so that a match is assumed. Not that this factor only      * is used for filtering out non-matching tokens. The similarity value will      * still used for calculating the confidence      */
specifier|private
name|float
name|minTokenMatchFactor
decl_stmt|;
comment|/**      * If lemmas are used instead of the Tokens as present in the text to search      * and match Entities within the linked vocabulary      */
specifier|private
name|boolean
name|lemmaMatchingState
init|=
name|DEFAULT_LEMMA_MATCHING_STATE
decl_stmt|;
specifier|private
name|double
name|minLabelScore
init|=
name|DEFAULT_MIN_LABEL_SCORE
decl_stmt|;
specifier|private
name|double
name|minTextScore
init|=
name|DEFAULT_MIN_TEXT_SCORE
decl_stmt|;
specifier|private
name|double
name|minMatchScore
init|=
name|DEFAULT_MIN_MATCH_SCORE
decl_stmt|;
comment|/**      * The minimum score an entity needs to match matchable tokens within a      * chunk so that is is considered as a mentions (STANBOL-1211)      */
specifier|private
name|double
name|minChunkMatchScore
init|=
name|DEFAULT_MIN_CHUNK_MATCH_SCORE
decl_stmt|;
specifier|private
name|boolean
name|rankEqualScoresBasedOnEntityRankings
init|=
name|DEFAULT_RANK_EQUAL_SCORES_BASED_ON_ENTITY_RANKINGS
decl_stmt|;
comment|/**      * Default constructor the initializes the configuration with the       * default values      */
specifier|public
name|EntityLinkerConfig
parameter_list|()
block|{
name|setMaxSuggestions
argument_list|(
name|DEFAULT_SUGGESTIONS
argument_list|)
expr_stmt|;
name|setMaxSearchTokens
argument_list|(
name|DEFAULT_MAX_SEARCH_TOKENS
argument_list|)
expr_stmt|;
name|setRedirectProcessingMode
argument_list|(
name|DEFAULT_REDIRECT_PROCESSING_MODE
argument_list|)
expr_stmt|;
name|typeMappings
operator|=
operator|new
name|HashMap
argument_list|<
name|UriRef
argument_list|,
name|UriRef
argument_list|>
argument_list|(
name|DEFAULT_ENTITY_TYPE_MAPPINGS
argument_list|)
expr_stmt|;
name|unmodTypeMappings
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|typeMappings
argument_list|)
expr_stmt|;
name|setDefaultDcType
argument_list|(
name|typeMappings
operator|.
name|remove
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|setNameField
argument_list|(
name|DEFAULT_NAME_FIELD
argument_list|)
expr_stmt|;
name|setRedirectField
argument_list|(
name|DEFAULT_REDIRECT_FIELD
argument_list|)
expr_stmt|;
name|setTypeField
argument_list|(
name|DEFAULT_TYPE_FIELD
argument_list|)
expr_stmt|;
name|setMaxNotFound
argument_list|(
name|DEFAULT_MAX_NOT_FOUND
argument_list|)
expr_stmt|;
name|setMinTokenMatchFactor
argument_list|(
name|DEFAULT_MIN_TOKEN_SCORE
argument_list|)
expr_stmt|;
name|setDereferenceEntitiesState
argument_list|(
name|DEFAULT_DEREFERENCE_ENTITIES_STATE
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a new {@link EntityLinkerConfig} based on the properties      * in the parsed {@link Dictionary}      * @param configuration the configuration      * @param prefixService Optionally a namespace prefix service used to      * convert '{prefix}:{localname}' parameters in the configuration to URIs.      * If<code>null</code> is parsed this feature is not supported and parameters      * are not changed.      * @return the configured {@link EntityLinkerConfig}      * @throws ConfigurationException if the parsed configuration is not valid      */
specifier|public
specifier|static
name|EntityLinkerConfig
name|createInstance
parameter_list|(
name|Dictionary
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|configuration
parameter_list|,
name|NamespacePrefixService
name|prefixService
parameter_list|)
throws|throws
name|ConfigurationException
block|{
name|EntityLinkerConfig
name|elc
init|=
operator|new
name|EntityLinkerConfig
argument_list|()
decl_stmt|;
name|setConfiguration
argument_list|(
name|elc
argument_list|,
name|configuration
argument_list|,
name|prefixService
argument_list|)
expr_stmt|;
return|return
name|elc
return|;
block|}
comment|/**      * Sets the configuration as parsed by the {@link Dictionary} to the      * parsed {@link EntityLinkerConfig}.      * @param linkerConfig the instance to apply the configuration to      * @param configuration the configuration      * @param prefixService Optionally a namespace prefix service used to      * convert '{prefix}:{localname}' parameters in the configuration to URIs.      * If<code>null</code> is parsed this feature is not supported and parameters      * are not changed.      * @throws ConfigurationException in case the configuration is invalid      */
specifier|public
specifier|static
name|void
name|setConfiguration
parameter_list|(
name|EntityLinkerConfig
name|linkerConfig
parameter_list|,
name|Dictionary
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|configuration
parameter_list|,
name|NamespacePrefixService
name|prefixService
parameter_list|)
throws|throws
name|ConfigurationException
block|{
name|Object
name|value
decl_stmt|;
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|NAME_FIELD
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|value
operator|.
name|toString
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|NAME_FIELD
argument_list|,
literal|"The configured name field MUST NOT be empty"
argument_list|)
throw|;
block|}
name|linkerConfig
operator|.
name|setNameField
argument_list|(
operator|new
name|UriRef
argument_list|(
name|getFullName
argument_list|(
name|prefixService
argument_list|,
name|NAME_FIELD
argument_list|,
name|value
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//init case sensitivity
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|CASE_SENSITIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Boolean
condition|)
block|{
name|linkerConfig
operator|.
name|setCaseSensitiveMatchingState
argument_list|(
operator|(
name|Boolean
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
operator|!
name|value
operator|.
name|toString
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|linkerConfig
operator|.
name|setCaseSensitiveMatchingState
argument_list|(
name|Boolean
operator|.
name|valueOf
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//if NULL or empty use default
comment|//init TYPE_FIELD
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|TYPE_FIELD
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|value
operator|.
name|toString
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|TYPE_FIELD
argument_list|,
literal|"The configured name field MUST NOT be empty"
argument_list|)
throw|;
block|}
name|linkerConfig
operator|.
name|setTypeField
argument_list|(
operator|new
name|UriRef
argument_list|(
name|getFullName
argument_list|(
name|prefixService
argument_list|,
name|TYPE_FIELD
argument_list|,
name|value
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//init REDIRECT_FIELD
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|REDIRECT_FIELD
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|value
operator|.
name|toString
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|NAME_FIELD
argument_list|,
literal|"The configured name field MUST NOT be empty"
argument_list|)
throw|;
block|}
name|linkerConfig
operator|.
name|setRedirectField
argument_list|(
operator|new
name|UriRef
argument_list|(
name|getFullName
argument_list|(
name|prefixService
argument_list|,
name|REDIRECT_FIELD
argument_list|,
name|value
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//init MAX_SUGGESTIONS
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|SUGGESTIONS
argument_list|)
expr_stmt|;
name|Integer
name|maxSuggestions
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Integer
condition|)
block|{
name|maxSuggestions
operator|=
operator|(
name|Integer
operator|)
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|maxSuggestions
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|SUGGESTIONS
argument_list|,
literal|"Values MUST be valid Integer values> 0"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|maxSuggestions
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|maxSuggestions
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|maxSuggestions
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|SUGGESTIONS
argument_list|,
literal|"Values MUST be valid Integer values> 0"
argument_list|)
throw|;
block|}
name|linkerConfig
operator|.
name|setMaxSuggestions
argument_list|(
name|maxSuggestions
argument_list|)
expr_stmt|;
block|}
comment|//init MIN_FOUND_TOKENS
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|MIN_FOUND_TOKENS
argument_list|)
expr_stmt|;
name|Integer
name|minFoundTokens
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Integer
condition|)
block|{
name|minFoundTokens
operator|=
operator|(
name|Integer
operator|)
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|minFoundTokens
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|MIN_FOUND_TOKENS
argument_list|,
literal|"Values MUST be valid Integer values> 0"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|minFoundTokens
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|minFoundTokens
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|minFoundTokens
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|MIN_FOUND_TOKENS
argument_list|,
literal|"Values MUST be valid Integer values> 0"
argument_list|)
throw|;
block|}
name|linkerConfig
operator|.
name|setMinFoundTokens
argument_list|(
name|minFoundTokens
argument_list|)
expr_stmt|;
block|}
comment|//init Label Score parameters
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|MIN_LABEL_SCORE
argument_list|)
expr_stmt|;
name|Double
name|minLabelMatchFactor
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Number
condition|)
block|{
name|minLabelMatchFactor
operator|=
name|Double
operator|.
name|valueOf
argument_list|(
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|doubleValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|minLabelMatchFactor
operator|=
name|Double
operator|.
name|valueOf
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|MIN_LABEL_SCORE
argument_list|,
literal|"Parsed value '"
operator|+
name|value
operator|+
literal|"' is not an valid double!"
argument_list|)
throw|;
block|}
block|}
try|try
block|{
name|linkerConfig
operator|.
name|setMinLabelScore
argument_list|(
name|minLabelMatchFactor
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|MIN_LABEL_SCORE
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|MIN_TEXT_SCORE
argument_list|)
expr_stmt|;
name|Double
name|minTextMatchFactor
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Number
condition|)
block|{
name|minTextMatchFactor
operator|=
name|Double
operator|.
name|valueOf
argument_list|(
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|doubleValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|minTextMatchFactor
operator|=
name|Double
operator|.
name|valueOf
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|MIN_TEXT_SCORE
argument_list|,
literal|"Parsed value '"
operator|+
name|value
operator|+
literal|"' is not an valid double!"
argument_list|)
throw|;
block|}
block|}
try|try
block|{
name|linkerConfig
operator|.
name|setMinTextScore
argument_list|(
name|minTextMatchFactor
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|MIN_TEXT_SCORE
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|MIN_MATCH_FACTOR
argument_list|)
expr_stmt|;
name|Double
name|minMatchFactor
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Number
condition|)
block|{
name|minMatchFactor
operator|=
name|Double
operator|.
name|valueOf
argument_list|(
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|doubleValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|minMatchFactor
operator|=
name|Double
operator|.
name|valueOf
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|MIN_MATCH_FACTOR
argument_list|,
literal|"Parsed value '"
operator|+
name|value
operator|+
literal|"' is not an valid double!"
argument_list|)
throw|;
block|}
block|}
try|try
block|{
name|linkerConfig
operator|.
name|setMinMatchScore
argument_list|(
name|minMatchFactor
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|MIN_MATCH_FACTOR
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|MIN_CHUNK_MATCH_SCORE
argument_list|)
expr_stmt|;
name|Double
name|minChunkMatchScore
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Number
condition|)
block|{
name|minChunkMatchScore
operator|=
name|Double
operator|.
name|valueOf
argument_list|(
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|doubleValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|minChunkMatchScore
operator|=
name|Double
operator|.
name|valueOf
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|MIN_CHUNK_MATCH_SCORE
argument_list|,
literal|"Parsed value '"
operator|+
name|value
operator|+
literal|"' is not an valid double!"
argument_list|)
throw|;
block|}
block|}
try|try
block|{
name|linkerConfig
operator|.
name|setMinChunkMatchScore
argument_list|(
name|minChunkMatchScore
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|MIN_CHUNK_MATCH_SCORE
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
comment|//init LEMMA_MATCHING_STATE
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|LEMMA_MATCHING_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Boolean
condition|)
block|{
name|linkerConfig
operator|.
name|setLemmaMatchingState
argument_list|(
operator|(
name|Boolean
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|linkerConfig
operator|.
name|setLemmaMatchingState
argument_list|(
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//init MAX_SEARCH_TOKENS
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|MAX_SEARCH_TOKENS
argument_list|)
expr_stmt|;
name|Integer
name|maxSearchTokens
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Integer
condition|)
block|{
name|maxSearchTokens
operator|=
operator|(
name|Integer
operator|)
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|maxSearchTokens
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|MAX_SEARCH_TOKENS
argument_list|,
literal|"Values MUST be valid Integer values> 0"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|maxSearchTokens
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|maxSearchTokens
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|maxSearchTokens
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|MAX_SEARCH_TOKENS
argument_list|,
literal|"Values MUST be valid Integer values> 0"
argument_list|)
throw|;
block|}
name|linkerConfig
operator|.
name|setMaxSearchTokens
argument_list|(
name|maxSearchTokens
argument_list|)
expr_stmt|;
block|}
comment|//init the MAX_SEARCH_TOKEN_DISTANCE
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|MAX_SEARCH_TOKEN_DISTANCE
argument_list|)
expr_stmt|;
name|Integer
name|maxSearchDistance
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Integer
condition|)
block|{
name|maxSearchDistance
operator|=
operator|(
name|Integer
operator|)
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|maxSearchDistance
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|MAX_SEARCH_TOKEN_DISTANCE
argument_list|,
literal|"Values MUST be valid Integer values> 0"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|maxSearchDistance
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|maxSearchDistance
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|maxSearchDistance
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|MAX_SEARCH_TOKEN_DISTANCE
argument_list|,
literal|"Values MUST be valid Integer values> 0"
argument_list|)
throw|;
block|}
name|linkerConfig
operator|.
name|setMaxSearchDistance
argument_list|(
name|maxSearchDistance
argument_list|)
expr_stmt|;
block|}
comment|//init the REDIRECT_PROCESSING_MODE
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|REDIRECT_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|linkerConfig
operator|.
name|setRedirectProcessingMode
argument_list|(
name|RedirectProcessingMode
operator|.
name|valueOf
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|REDIRECT_MODE
argument_list|,
literal|"Values MUST be one of "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|RedirectProcessingMode
operator|.
name|values
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|//init the DEFAULT_LANGUAGE
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|DEFAULT_MATCHING_LANGUAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|String
name|defaultLang
init|=
name|value
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
name|defaultLang
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|linkerConfig
operator|.
name|setDefaultLanguage
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|defaultLang
operator|.
name|length
argument_list|()
operator|==
literal|1
condition|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|DEFAULT_MATCHING_LANGUAGE
argument_list|,
literal|"Illegal language code '"
operator|+
name|defaultLang
operator|+
literal|"'! Language Codes MUST BE at least 2 chars long."
argument_list|)
throw|;
block|}
else|else
block|{
name|linkerConfig
operator|.
name|setDefaultLanguage
argument_list|(
name|defaultLang
argument_list|)
expr_stmt|;
block|}
block|}
comment|// init MIN_TOKEN_MATCH_FACTOR
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|MIN_TOKEN_SCORE
argument_list|)
expr_stmt|;
name|float
name|minTokenMatchFactor
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Number
condition|)
block|{
name|minTokenMatchFactor
operator|=
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|floatValue
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|minTokenMatchFactor
operator|=
name|Float
operator|.
name|valueOf
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|MIN_TOKEN_SCORE
argument_list|,
literal|"Unable to parse the minimum token match factor from the parsed value "
operator|+
name|value
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|minTokenMatchFactor
operator|<
literal|0
condition|)
block|{
name|minTokenMatchFactor
operator|=
name|EntityLinkerConfig
operator|.
name|DEFAULT_MIN_TOKEN_SCORE
expr_stmt|;
block|}
block|}
else|else
block|{
name|minTokenMatchFactor
operator|=
name|EntityLinkerConfig
operator|.
name|DEFAULT_MIN_TOKEN_SCORE
expr_stmt|;
block|}
if|if
condition|(
name|minTokenMatchFactor
operator|==
literal|0
operator|||
name|minTokenMatchFactor
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|MIN_TOKEN_SCORE
argument_list|,
literal|"The minimum token match factor MUST be> 0 and<= 1 (negative values for the default)"
argument_list|)
throw|;
block|}
name|linkerConfig
operator|.
name|setMinTokenMatchFactor
argument_list|(
name|minTokenMatchFactor
argument_list|)
expr_stmt|;
comment|//init type mappings
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|TYPE_MAPPINGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|String
index|[]
condition|)
block|{
comment|//support array
name|value
operator|=
name|Arrays
operator|.
name|asList
argument_list|(
operator|(
name|String
index|[]
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|String
condition|)
block|{
comment|//single value
name|value
operator|=
name|Collections
operator|.
name|singleton
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|instanceof
name|Collection
argument_list|<
name|?
argument_list|>
condition|)
block|{
comment|//and collection
name|log
operator|.
name|info
argument_list|(
literal|"Init Type Mappings"
argument_list|)
expr_stmt|;
name|configs
label|:
for|for
control|(
name|Object
name|o
operator|:
operator|(
name|Iterable
argument_list|<
name|?
argument_list|>
operator|)
name|value
control|)
block|{
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
name|StringBuilder
name|usage
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"useages: "
argument_list|)
decl_stmt|;
name|usage
operator|.
name|append
argument_list|(
literal|"a: '{uri}' short for {uri}> {uri} | "
argument_list|)
expr_stmt|;
name|usage
operator|.
name|append
argument_list|(
literal|"b: '{source1};{source2};..;{sourceN}> {target}'"
argument_list|)
expr_stmt|;
name|String
index|[]
name|config
init|=
name|o
operator|.
name|toString
argument_list|()
operator|.
name|split
argument_list|(
literal|">"
argument_list|)
decl_stmt|;
if|if
condition|(
name|config
index|[
literal|0
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Invalid Type Mapping Config '{}': Missing Source Type ({}) -> ignore this config"
argument_list|,
name|o
argument_list|,
name|usage
argument_list|)
expr_stmt|;
continue|continue
name|configs
continue|;
block|}
name|String
index|[]
name|sourceTypes
init|=
name|config
index|[
literal|0
index|]
operator|.
name|split
argument_list|(
literal|";"
argument_list|)
decl_stmt|;
if|if
condition|(
name|sourceTypes
operator|.
name|length
operator|>
literal|1
operator|&&
operator|(
name|config
operator|.
name|length
operator|<
literal|2
operator|||
name|config
index|[
literal|1
index|]
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Invalid Type Mapping Config '{}': Missing Target Type '{}' ({}) -> ignore this config"
argument_list|,
name|o
argument_list|,
name|usage
argument_list|)
expr_stmt|;
continue|continue
name|configs
continue|;
block|}
name|String
name|targetType
init|=
name|config
operator|.
name|length
operator|<
literal|2
condition|?
name|sourceTypes
index|[
literal|0
index|]
else|:
name|config
index|[
literal|1
index|]
decl_stmt|;
name|targetType
operator|=
name|getFullName
argument_list|(
name|prefixService
argument_list|,
name|TYPE_MAPPINGS
argument_list|,
name|targetType
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
comment|//support for ns:localName
try|try
block|{
comment|//validate
operator|new
name|URI
argument_list|(
name|targetType
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Invalid URI '{}' in Type Mapping Config '{}' -> ignore this config"
argument_list|,
name|sourceTypes
index|[
literal|0
index|]
argument_list|,
name|o
argument_list|)
expr_stmt|;
continue|continue
name|configs
continue|;
block|}
name|UriRef
name|targetUri
init|=
operator|new
name|UriRef
argument_list|(
name|targetType
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|sourceType
range|:
name|sourceTypes
control|)
block|{
if|if
condition|(
operator|!
name|sourceType
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|sourceType
operator|=
name|getFullName
argument_list|(
name|prefixService
argument_list|,
name|TYPE_MAPPINGS
argument_list|,
name|sourceType
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
comment|//support for ns:localName
try|try
block|{
comment|//validate
operator|new
name|URI
argument_list|(
name|sourceType
argument_list|)
expr_stmt|;
name|UriRef
name|old
init|=
name|linkerConfig
operator|.
name|setTypeMapping
argument_list|(
name|sourceType
argument_list|,
name|targetUri
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"> add type mapping {}> {}"
argument_list|,
name|sourceType
argument_list|,
name|targetType
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"> set type mapping {}> {} (old: {})"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|sourceType
block|,
name|targetType
block|,
name|old
operator|.
name|getUnicodeString
argument_list|()
block|}
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Invalid URI '{}' in Type Mapping Config '{}' -> ignore this source type"
argument_list|,
name|sourceTypes
index|[
literal|0
index|]
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"No Type mappings configured"
argument_list|)
expr_stmt|;
block|}
comment|//dereference entities
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|DEREFERENCE_ENTITIES
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Boolean
condition|)
block|{
name|linkerConfig
operator|.
name|setDereferenceEntitiesState
argument_list|(
operator|(
operator|(
name|Boolean
operator|)
name|value
operator|)
operator|.
name|booleanValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
operator|!
name|value
operator|.
name|toString
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|linkerConfig
operator|.
name|setDereferenceEntitiesState
argument_list|(
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|linkerConfig
operator|.
name|isDereferenceEntitiesEnabled
argument_list|()
condition|)
block|{
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|DEREFERENCE_ENTITIES_FIELDS
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|String
index|[]
condition|)
block|{
for|for
control|(
name|String
name|field
range|:
operator|(
name|String
index|[]
operator|)
name|value
control|)
block|{
if|if
condition|(
name|field
operator|!=
literal|null
operator|&&
operator|!
name|field
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|linkerConfig
operator|.
name|getDereferencedFields
argument_list|()
operator|.
name|add
argument_list|(
operator|new
name|UriRef
argument_list|(
name|getFullName
argument_list|(
name|prefixService
argument_list|,
name|DEREFERENCE_ENTITIES_FIELDS
argument_list|,
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Collection
argument_list|<
name|?
argument_list|>
condition|)
block|{
for|for
control|(
name|Object
name|field
else|:
operator|(
name|Collection
argument_list|<
name|?
argument_list|>
operator|)
name|value
block|)
block|{
if|if
condition|(
name|field
operator|!=
literal|null
operator|&&
operator|!
name|field
operator|.
name|toString
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|linkerConfig
operator|.
name|getDereferencedFields
argument_list|()
operator|.
name|add
argument_list|(
operator|new
name|UriRef
argument_list|(
name|getFullName
argument_list|(
name|prefixService
argument_list|,
name|DEREFERENCE_ENTITIES_FIELDS
argument_list|,
name|field
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_class

begin_if
unit|} else
if|if
condition|(
name|value
operator|instanceof
name|String
condition|)
block|{
if|if
condition|(
operator|!
name|value
operator|.
name|toString
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|linkerConfig
operator|.
name|getDereferencedFields
argument_list|()
operator|.
name|add
argument_list|(
operator|new
name|UriRef
argument_list|(
name|getFullName
argument_list|(
name|prefixService
argument_list|,
name|DEREFERENCE_ENTITIES_FIELDS
argument_list|,
name|value
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|DEREFERENCE_ENTITIES_FIELDS
argument_list|,
literal|"Dereference Entities_Fields MUST BE parsed as String[], Collection<String> or "
operator|+
literal|"String (single value). The actual value '"
operator|+
name|value
operator|+
literal|"'(type: '"
operator|+
name|value
operator|.
name|getClass
argument_list|()
operator|+
literal|"') is NOT supported"
argument_list|)
throw|;
block|}
else|else
block|{
comment|//value == null
name|log
operator|.
name|debug
argument_list|(
literal|"No deference fields for entity configured"
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
unit|}
comment|//init USE ENTITY RANKINGS (STANBOL-1030)
end_comment

begin_expr_stmt
unit|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|RANK_EQUAL_SCORES_BASED_ON_ENTITY_RANKINGS
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|value
operator|instanceof
name|Boolean
condition|)
block|{
name|linkerConfig
operator|.
name|setRankEqualScoresBasedOnEntityRankings
argument_list|(
operator|(
operator|(
name|Boolean
operator|)
name|value
operator|)
operator|.
name|booleanValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|linkerConfig
operator|.
name|setRankEqualScoresBasedOnEntityRankings
argument_list|(
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|linkerConfig
operator|.
name|setRankEqualScoresBasedOnEntityRankings
argument_list|(
name|DEFAULT_RANK_EQUAL_SCORES_BASED_ON_ENTITY_RANKINGS
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|//init the list of whitelisted/blacklisted types
end_comment

begin_expr_stmt
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|ENTITY_TYPES
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|List
argument_list|<
name|String
argument_list|>
name|entityTypesConfig
decl_stmt|;
end_decl_stmt

begin_comment
comment|//first collect and cleanup the config
end_comment

begin_if
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|entityTypesConfig
operator|=
name|Collections
operator|.
name|emptyList
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|String
index|[]
condition|)
block|{
name|entityTypesConfig
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|String
name|type
range|:
operator|(
name|String
index|[]
operator|)
name|value
control|)
block|{
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
block|{
name|type
operator|=
name|type
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|type
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|entityTypesConfig
operator|.
name|add
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Collection
argument_list|<
name|?
argument_list|>
condition|)
block|{
name|entityTypesConfig
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|Object
name|o
operator|:
operator|(
name|Collection
argument_list|<
name|Object
argument_list|>
operator|)
name|value
control|)
block|{
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
name|String
name|type
init|=
name|o
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|type
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|entityTypesConfig
operator|.
name|add
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_if

begin_if
unit|} else
if|if
condition|(
name|value
operator|instanceof
name|String
condition|)
block|{
comment|//support parsing single values as string
name|String
name|type
init|=
name|value
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|entityTypesConfig
operator|=
name|Collections
operator|.
name|emptyList
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|entityTypesConfig
operator|=
name|Collections
operator|.
name|singletonList
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|ENTITY_TYPES
argument_list|,
literal|"The list of ignored types (if present) "
operator|+
literal|"MUST BE a collection or a string array (present: "
operator|+
name|value
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|")!"
argument_list|)
throw|;
block|}
end_if

begin_comment
comment|//apply the config
end_comment

begin_for
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|entityTypesConfig
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|type
init|=
name|entityTypesConfig
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
literal|"*"
operator|.
name|equals
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|linkerConfig
operator|.
name|setDefaultWhitelistTypes
argument_list|(
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|boolean
name|blacklisted
init|=
name|type
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'!'
decl_stmt|;
if|if
condition|(
name|blacklisted
operator|&&
name|type
operator|.
name|length
argument_list|()
operator|<
literal|2
condition|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|ENTITY_TYPES
argument_list|,
literal|"The list of whitelisted/blacklisted "
operator|+
literal|"MUST NOT contain '!' (configured: "
operator|+
name|entityTypesConfig
operator|+
literal|")!"
argument_list|)
throw|;
block|}
name|UriRef
name|uri
init|=
operator|new
name|UriRef
argument_list|(
name|getFullName
argument_list|(
name|prefixService
argument_list|,
name|ENTITY_TYPES
argument_list|,
name|blacklisted
condition|?
name|type
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
else|:
name|type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|blacklisted
condition|)
block|{
name|linkerConfig
operator|.
name|addBlacklistType
argument_list|(
name|uri
argument_list|,
name|Integer
operator|.
name|valueOf
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|linkerConfig
operator|.
name|addWhitelistType
argument_list|(
name|uri
argument_list|,
name|Integer
operator|.
name|valueOf
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_for

begin_comment
unit|}
comment|/**      * Gets the full URI for the parsed value by using the parsed {@link NamespacePrefixService}      * @param prefixService the {@link NamespacePrefixService} used to lookup the full URI      * @param property the config property (just used to create a {@link ConfigurationException}      * in case the used namespace prefix is unknown by the namespace prefix service)      * @param value the configured value (might be both a short or a full URI)      * @return the full URI      * @throws ConfigurationException      */
end_comment

begin_function
unit|private
specifier|static
name|String
name|getFullName
parameter_list|(
name|NamespacePrefixService
name|prefixService
parameter_list|,
name|String
name|property
parameter_list|,
name|String
name|value
parameter_list|)
throws|throws
name|ConfigurationException
block|{
name|String
name|prefix
init|=
name|NamespaceMappingUtils
operator|.
name|getPrefix
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|prefixService
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|prefix
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|property
argument_list|,
literal|"'{prefix}:{localname}' tpye configurations "
operator|+
literal|"are not supported if no "
operator|+
name|NamespacePrefixService
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"is present (configured value='"
operator|+
name|value
operator|+
literal|"')!"
argument_list|)
throw|;
block|}
else|else
block|{
return|return
name|value
return|;
block|}
block|}
else|else
block|{
name|String
name|uri
init|=
name|prefixService
operator|.
name|getFullName
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|uri
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|property
argument_list|,
literal|"The prefix '"
operator|+
name|prefix
operator|+
literal|"' as used by the configured value '"
operator|+
name|value
operator|+
literal|"' is unknow to the"
operator|+
name|NamespacePrefixService
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
argument_list|)
throw|;
block|}
name|log
operator|.
name|debug
argument_list|(
literal|"mapped '{}' -> '{}'"
argument_list|,
name|value
argument_list|,
name|uri
argument_list|)
expr_stmt|;
return|return
name|uri
return|;
block|}
block|}
end_function

begin_comment
comment|/**      * Getter for the uri of the field used for the names in the taxonomy      * (e.g. rdfs:label, skos:prefLabel). Needs to return the full URI      * @return the field used for the names of in the Taxonomy.      */
end_comment

begin_function
specifier|public
specifier|final
name|UriRef
name|getNameField
parameter_list|()
block|{
return|return
name|nameField
return|;
block|}
end_function

begin_comment
comment|/**      * Setter for the uri of the field used for the names in the taxonomy      * (e.g. rdfs:label, skos:prefLabel).      * @param nameField the nameField to set      */
end_comment

begin_function
specifier|public
specifier|final
name|void
name|setNameField
parameter_list|(
name|UriRef
name|nameField
parameter_list|)
block|{
name|this
operator|.
name|nameField
operator|=
name|nameField
expr_stmt|;
name|__selectedFields
operator|=
literal|null
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * Getter for the dereferencedFields. This is a read- and write-able      * set that allows to configure the fields that should be dereferenced      * @return      */
end_comment

begin_function
specifier|public
specifier|final
name|Set
argument_list|<
name|UriRef
argument_list|>
name|getDereferencedFields
parameter_list|()
block|{
return|return
name|dereferencedFields
return|;
block|}
end_function

begin_comment
comment|/**      * The field used to follow redirects (typically rdf:seeAlso)      * @return the redirect field      */
end_comment

begin_function
specifier|public
specifier|final
name|UriRef
name|getRedirectField
parameter_list|()
block|{
return|return
name|redirectField
return|;
block|}
end_function

begin_comment
comment|/**      * The field used to follow redirects (typically rdf:seeAlso)      * @param redirectField the redirectField to set      */
end_comment

begin_function
specifier|public
specifier|final
name|void
name|setRedirectField
parameter_list|(
name|UriRef
name|redirectField
parameter_list|)
block|{
name|this
operator|.
name|redirectField
operator|=
name|redirectField
expr_stmt|;
name|__selectedFields
operator|=
literal|null
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * The field used to lookup the types (typically rdf:type)      * @return the field name used to lookup types      */
end_comment

begin_function
specifier|public
specifier|final
name|UriRef
name|getTypeField
parameter_list|()
block|{
return|return
name|typeField
return|;
block|}
end_function

begin_comment
comment|/**      * The field used to lookup the types (typically rdf:type)      * @param typeField the typeField to set      */
end_comment

begin_function
specifier|public
specifier|final
name|void
name|setTypeField
parameter_list|(
name|UriRef
name|typeField
parameter_list|)
block|{
name|this
operator|.
name|typeField
operator|=
name|typeField
expr_stmt|;
name|__selectedFields
operator|=
literal|null
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * Setter for the maximum number of suggestion returned.       * @param maxSuggestions the maxSuggestions to set      */
end_comment

begin_function
specifier|public
name|void
name|setMaxSuggestions
parameter_list|(
name|int
name|maxSuggestions
parameter_list|)
block|{
name|this
operator|.
name|maxSuggestions
operator|=
name|maxSuggestions
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * Getter for the maximum number of suggestion returned.       * @return the maxSuggestions      */
end_comment

begin_function
specifier|public
name|int
name|getMaxSuggestions
parameter_list|()
block|{
return|return
name|maxSuggestions
return|;
block|}
end_function

begin_comment
comment|/**      * Setter for the minimum number of Tokens (of the content) that MUST match      * with a {@link EntitySearcher#getNameField() label} of a       * {@link EntitySearcher#lookup(java.util.List, String...) concept of the taxonomy}      * so that it is {@link Suggestion suggested} even if the match is only      * {@link MATCH#PARTIAL}. Entities that match less than that are only included      * if a label is an {@link MATCH#EXACT EXACT} match with the current position      * in the text.       * @param minFoundTokens the minFoundTokens to set      */
end_comment

begin_function
specifier|public
name|void
name|setMinFoundTokens
parameter_list|(
name|int
name|minFoundTokens
parameter_list|)
block|{
name|this
operator|.
name|minFoundTokens
operator|=
name|minFoundTokens
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * Getter for the minimum number of Tokens (of the content) that MUST match      * with a {@link EntitySearcher#getNameField() label} of a       * {@link EntitySearcher#lookup(java.util.List, String...) concept of the taxonomy}      * so that it is {@link Suggestion suggested} even if the match is only      * {@link MATCH#PARTIAL}. Entities that match less than that are only included      * if a label is an {@link MATCH#EXACT EXACT} match with the current position      * in the text.       * @return the minFoundTokens      */
end_comment

begin_function
specifier|public
name|int
name|getMinFoundTokens
parameter_list|()
block|{
return|return
name|minFoundTokens
return|;
block|}
end_function

begin_comment
comment|/**      * Getter for the  maximum number of tokens parsed to       * {@link EntitySearcher#lookup(java.util.List, String...)}      * @return the maxSearchTokens      */
end_comment

begin_function
specifier|public
specifier|final
name|int
name|getMaxSearchTokens
parameter_list|()
block|{
return|return
name|maxSearchTokens
return|;
block|}
end_function

begin_comment
comment|/**      * The maximum number of tokens parsed to       * {@link EntitySearcher#lookup(java.util.List, String...)}. This is NOT the      * maximum number of Tokens mapped for Entities returned by such queries.<p>      * In case {@link Chunk}s are available in the parsed {@link AnalysedText}      * searches can be scoped by such chunks. However if no chunks are available,      * than this value is used to collect this number of words in the text.<p>      * The {@link #DEFAULT_MAX_SEARCH_TOKENS default value} of<code>2</code>      * should be ok in most cases.        * @param maxSearchTokens the maxSearchTokens to set      */
end_comment

begin_function
specifier|public
specifier|final
name|void
name|setMaxSearchTokens
parameter_list|(
name|int
name|maxSearchTokens
parameter_list|)
block|{
if|if
condition|(
name|maxSearchTokens
operator|==
literal|0
condition|)
block|{
name|this
operator|.
name|maxSearchTokens
operator|=
name|DEFAULT_MAX_SEARCH_TOKENS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|maxSearchTokens
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The maxSearchToken value MUST BE>= 0 (0 for setting the default)"
argument_list|)
throw|;
block|}
else|else
block|{
name|this
operator|.
name|maxSearchTokens
operator|=
name|maxSearchTokens
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**      * Getter for the case sensitive matching state      * @return the state      */
end_comment

begin_function
specifier|public
name|boolean
name|isCaseSensitiveMatching
parameter_list|()
block|{
return|return
name|caseSensitiveMatchingState
return|;
block|}
end_function

begin_comment
comment|/**      * Setter for the case sensitive matching state      * @param caseSensitiveMatchingState the state      */
end_comment

begin_function
specifier|public
name|void
name|setCaseSensitiveMatchingState
parameter_list|(
name|boolean
name|state
parameter_list|)
block|{
name|this
operator|.
name|caseSensitiveMatchingState
operator|=
name|state
expr_stmt|;
block|}
end_function

begin_comment
comment|/* REMOVED because getTypemappings.remove(conceptType) can be used anyway      * Removes the mapping for the parsed concept type      * @param conceptType the concept type to remove the mapping      * @return the previously mapped dc:type value or<code>null</code> if      * no mapping for the parsed concept type was present     public UriRef removeTypeMapping(UriRef conceptType){         return typeMappings.remove(conceptType);     }      */
end_comment

begin_comment
comment|/**      *       * @param conceptType the type of the concept or<code>null</code> to      * add the default dc:type mapping. See also {@link #setDefaultDcType(UriRef)}      * @param dcType the dc:type for the parsed concept type      * @return the previously mapped dc:type value if an existing mapping      * was updated or<code>null</code> if a new mapping was added.      */
end_comment

begin_function
specifier|public
name|UriRef
name|setTypeMapping
parameter_list|(
name|String
name|conceptType
parameter_list|,
name|UriRef
name|dcType
parameter_list|)
block|{
if|if
condition|(
name|dcType
operator|==
literal|null
condition|)
block|{
return|return
name|typeMappings
operator|.
name|remove
argument_list|(
name|conceptType
operator|==
literal|null
condition|?
literal|null
else|:
operator|new
name|UriRef
argument_list|(
name|conceptType
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|conceptType
operator|==
literal|null
condition|)
block|{
comment|//handle setting of the default dc:type value
name|UriRef
name|oldDefault
init|=
name|getDefaultDcType
argument_list|()
decl_stmt|;
name|setDefaultDcType
argument_list|(
name|dcType
argument_list|)
expr_stmt|;
return|return
name|oldDefault
return|;
block|}
return|return
name|typeMappings
operator|.
name|put
argument_list|(
operator|new
name|UriRef
argument_list|(
name|conceptType
argument_list|)
argument_list|,
name|dcType
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**      * Setter for the default dc:type of linked entities if for none of the      * types of the suggestions a {@link #getTypeMappings()} exists. Set this      * to<code>null</code> to specify that no dc:type should be set in such      * cases.      * @param defaultDcType the defaultDcType to set      */
end_comment

begin_function
specifier|public
name|void
name|setDefaultDcType
parameter_list|(
name|UriRef
name|defaultDcType
parameter_list|)
block|{
name|this
operator|.
name|defaultDcType
operator|=
name|defaultDcType
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * The default type for Entities if no {@link #getTypeMappings() type mapping}      * is present.<code>null</code> means that no type should be set if no      * explicit mapping exists      * @return the defaultDcType      */
end_comment

begin_function
specifier|public
name|UriRef
name|getDefaultDcType
parameter_list|()
block|{
return|return
name|defaultDcType
return|;
block|}
end_function

begin_comment
comment|/**      * Setter for the mode on how to deal with redirects      * @param redirectProcessingMode the redirectProcessingMode to set      */
end_comment

begin_function
specifier|public
name|void
name|setRedirectProcessingMode
parameter_list|(
name|RedirectProcessingMode
name|redirectProcessingMode
parameter_list|)
block|{
name|this
operator|.
name|redirectProcessingMode
operator|=
name|redirectProcessingMode
expr_stmt|;
name|__selectedFields
operator|=
literal|null
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * Getter for the mode how to deal with redirects      * @return the redirectProcessingMode      */
end_comment

begin_function
specifier|public
name|RedirectProcessingMode
name|getRedirectProcessingMode
parameter_list|()
block|{
return|return
name|redirectProcessingMode
return|;
block|}
end_function

begin_comment
comment|/**      * Getter for the read only mappings of type mappings      * @return the type mappings (read only)      */
end_comment

begin_function
specifier|public
name|Map
argument_list|<
name|UriRef
argument_list|,
name|UriRef
argument_list|>
name|getTypeMappings
parameter_list|()
block|{
return|return
name|unmodTypeMappings
return|;
block|}
end_function

begin_comment
comment|/**      * Setter for the language of labels searched in addition to the current      * language of the text. Setting this to<code>null</code> (also the default)      * will cause to search labels without any defined language.<p>      * Changing this makes only sense if a dataset (such as dbpedia.org) adds      * language tags to labels even if they are typically used in any language.      * @param defaultLanguage the default language      */
end_comment

begin_function
specifier|public
name|void
name|setDefaultLanguage
parameter_list|(
name|String
name|defaultLanguage
parameter_list|)
block|{
name|this
operator|.
name|defaultLanguage
operator|=
name|defaultLanguage
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * Getter for the language of labels searched in addition to the current      * language of the text.      * @return the default language       */
end_comment

begin_function
specifier|public
name|String
name|getDefaultLanguage
parameter_list|()
block|{
return|return
name|defaultLanguage
return|;
block|}
end_function

begin_comment
comment|/**      * Getter for the maximum number of non-processable tokens that are       * allowed to not match before no further tokens are matched against a label       * of an Entity.<p>      * This allows e.g. to match "Dr. Richard Dogles" with "Dr Richard Dogles"      * as '.' is a non-processable token in the text that is missing in the      * label.      * @return the maxNotFound      */
end_comment

begin_function
specifier|public
name|int
name|getMaxNotFound
parameter_list|()
block|{
return|return
name|maxNotFound
return|;
block|}
end_function

begin_comment
comment|/**      * Setter for the maximum number of non-processable tokens that are       * allowed to not match before no further tokens are matched against a label       * of an Entity.<p>      * This allows e.g. to match "Dr. Richard Dogles" with "Dr Richard Dogles"      * as '.' is a non-processable token in the text that is missing in the      * label.      * @param maxNotFound the maxNotFound to set      */
end_comment

begin_function
specifier|public
name|void
name|setMaxNotFound
parameter_list|(
name|int
name|maxNotFound
parameter_list|)
block|{
if|if
condition|(
name|maxNotFound
operator|<
literal|0
condition|)
block|{
name|this
operator|.
name|maxNotFound
operator|=
name|DEFAULT_MAX_NOT_FOUND
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|maxNotFound
operator|=
name|maxNotFound
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**      * Getter for the minimum token match Factor.      * If Tokens match is determined by comparing them using some algorithm.      * Results need to be in the range [0..1]. This factor defines the minimum      * similarity value so that a match is assumed. Not that this factor only      * is used for filtering out non-matching tokens. The similarity value will      * still used for calculating the confidence      * @return the minTokenMatchFactor      */
end_comment

begin_function
specifier|public
name|float
name|getMinTokenMatchFactor
parameter_list|()
block|{
return|return
name|minTokenMatchFactor
return|;
block|}
end_function

begin_comment
comment|/**      * Setter for the minimum token match Factor.      * If Tokens match is determined by comparing them using some algorithm.      * Results need to be in the range [0..1]. This factor defines the minimum      * similarity value so that a match is assumed. Not that this factor only      * is used for filtering out non-matching tokens. The similarity value will      * still used for calculating the confidence      * @param minTokenMatchFactor the minTokenMatchFactor to set      */
end_comment

begin_function
specifier|public
name|void
name|setMinTokenMatchFactor
parameter_list|(
name|float
name|minTokenMatchFactor
parameter_list|)
block|{
if|if
condition|(
name|minTokenMatchFactor
operator|<
literal|0
condition|)
block|{
name|this
operator|.
name|minTokenMatchFactor
operator|=
name|DEFAULT_MIN_TOKEN_SCORE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|minTokenMatchFactor
operator|==
literal|0
operator|||
name|minTokenMatchFactor
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"minimum Token Match Facter MUST be> 0<= 1 (parsed: "
operator|+
name|minTokenMatchFactor
operator|+
literal|")!"
argument_list|)
throw|;
block|}
else|else
block|{
name|this
operator|.
name|minTokenMatchFactor
operator|=
name|minTokenMatchFactor
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**      * Getter for the maximum distance tokens are      * considered to be used (in addition to the currently processed on)      * for searches of Entities.      * @return the maximum search token distance      */
end_comment

begin_function
specifier|public
name|int
name|getMaxSearchDistance
parameter_list|()
block|{
return|return
name|maxSearchDistance
return|;
block|}
end_function

begin_comment
comment|/**     /**      * Getter for the maximum distance tokens are      * considered to be used (in addition to the currently processed on)      * for searches of Entities.      * @param maxSearchDistance the maximum search token distance. If      * values&lt;= 0 are parsed the value is set to      *  {@link #DEFAULT_MAX_SEARCH_DISTANCE}      */
end_comment

begin_function
specifier|public
name|void
name|setMaxSearchDistance
parameter_list|(
name|int
name|maxSearchDistance
parameter_list|)
block|{
if|if
condition|(
name|maxSearchDistance
operator|<=
literal|0
condition|)
block|{
name|maxSearchDistance
operator|=
name|DEFAULT_MAX_SEARCH_DISTANCE
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|maxSearchDistance
operator|=
name|maxSearchDistance
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|public
name|boolean
name|isLemmaMatching
parameter_list|()
block|{
return|return
name|lemmaMatchingState
return|;
block|}
end_function

begin_function
specifier|public
name|void
name|setLemmaMatchingState
parameter_list|(
name|Boolean
name|lemmaMatchingState
parameter_list|)
block|{
if|if
condition|(
name|lemmaMatchingState
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|lemmaMatchingState
operator|=
name|DEFAULT_LEMMA_MATCHING_STATE
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|lemmaMatchingState
operator|=
name|lemmaMatchingState
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**      * The minimum LabelScore required to suggest an Entity.<p>      * The "Label Score" [0..1] represents how much of the      * Label of an Entity matches with the Text. It compares the number      * of Tokens of the Label with the number of Tokens matched to the      * Text. Not exact matches for Tokens, or if the Tokens within the       * label do appear in an other order than in the text do also       * reduce this score.      * @return the minimum required LabelScore      */
end_comment

begin_function
specifier|public
name|double
name|getMinLabelScore
parameter_list|()
block|{
return|return
name|minLabelScore
return|;
block|}
end_function

begin_comment
comment|/**      * Setter for the minimum label score for suggested entities      * @param score the score [0..1] or<code>null</code> to reset      * to the default.      */
end_comment

begin_function
specifier|public
name|void
name|setMinLabelScore
parameter_list|(
name|Double
name|score
parameter_list|)
block|{
if|if
condition|(
name|score
operator|==
literal|null
condition|)
block|{
name|minLabelScore
operator|=
name|DEFAULT_MIN_LABEL_SCORE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|score
operator|>
literal|1
operator|||
name|score
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed MinLabelScore '"
operator|+
name|score
operator|+
literal|"' MUST BE in the range [0..1]!"
argument_list|)
throw|;
block|}
else|else
block|{
name|minLabelScore
operator|=
name|score
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**      * The minimum Text Score required to suggest an Entity.<p>      * The "Text Score" [0..1] represents how well the      * Label of an Entity matches to the selected Span in the Text.      * It compares the number of matched {@link Token} from      * the label with the number of Tokens enclosed by the Span      * in the Text an Entity is suggested for. Not exact matches       * for Tokens, or if the Tokens within the label do appear in      * an other order than in the text do also reduce this score      * @return the minimum required Text Score for labels of suggested      * Entities      */
end_comment

begin_function
specifier|public
name|double
name|getMinTextScore
parameter_list|()
block|{
return|return
name|minTextScore
return|;
block|}
end_function

begin_comment
comment|/**      * Setter for the minimum text score for suggested entities      * @param score the score [0..1] or<code>null</code> to reset      * to the default.      */
end_comment

begin_function
specifier|public
name|void
name|setMinTextScore
parameter_list|(
name|Double
name|score
parameter_list|)
block|{
if|if
condition|(
name|score
operator|==
literal|null
condition|)
block|{
name|minTextScore
operator|=
name|DEFAULT_MIN_TEXT_SCORE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|score
operator|>
literal|1
operator|||
name|score
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed MinTextScore '"
operator|+
name|score
operator|+
literal|"' MUST BE in the range [0..1]!"
argument_list|)
throw|;
block|}
else|else
block|{
name|minTextScore
operator|=
name|score
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**      * Getter for the minimum amount of matchable {@link Token}s an Entity must match      * within an {@link Chunk} to be considered (see STANBOL-1211).<p>      * The default is<code>&gt;0.5</code> to omit matches for a single token      * in a chunk - typically a noun phrase - including two words.      * @return the minimum chunk match score.      */
end_comment

begin_function
specifier|public
name|double
name|getMinChunkMatchScore
parameter_list|()
block|{
return|return
name|minChunkMatchScore
return|;
block|}
end_function

begin_comment
comment|/**      * Setter for the minimum amount of matchable {@link Token}s an Entity must match      * within an {@link Chunk} to be considered (see STANBOL-1211).<p>      * The default is<code>&gt;0.5</code> to omit matches for a single token      * in a chunk - typically a noun phrase - including two words.      * @param minChunkMatchScore the minimum chunk match score or<code>null</code>      * to reset to the default value      */
end_comment

begin_function
specifier|public
name|void
name|setMinChunkMatchScore
parameter_list|(
name|Double
name|minChunkMatchScore
parameter_list|)
block|{
if|if
condition|(
name|minChunkMatchScore
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|minChunkMatchScore
operator|=
name|DEFAULT_MIN_CHUNK_MATCH_SCORE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|minChunkMatchScore
argument_list|<
literal|0.0
operator|||
name|minChunkMatchScore
argument_list|>
literal|1.0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The minChunkMatchScore MUST BE "
operator|+
literal|"in the range [0..1] (parsed: "
operator|+
name|minChunkMatchScore
operator|+
literal|")!"
argument_list|)
throw|;
block|}
else|else
block|{
name|this
operator|.
name|minChunkMatchScore
operator|=
name|minChunkMatchScore
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**      * Getter for the minimum match Score of Entity labels against the      * Text.<p>      * This is the product of the {@link #getMinLabelScore()} with the      * {@link #getMinTextScore()} - meaning that this value represents      * both how well the label matches the text and how much of the      * label is matched with the text.      * @return      */
end_comment

begin_function
specifier|public
name|double
name|getMinMatchScore
parameter_list|()
block|{
return|return
name|minMatchScore
return|;
block|}
end_function

begin_comment
comment|/**      * Setter for the minimum text score for suggested entities      * @param score the score [0..1] or<code>null</code> to reset      * to the default.      */
end_comment

begin_function
specifier|public
name|void
name|setMinMatchScore
parameter_list|(
name|Double
name|score
parameter_list|)
block|{
if|if
condition|(
name|score
operator|==
literal|null
condition|)
block|{
name|minMatchScore
operator|=
name|DEFAULT_MIN_MATCH_SCORE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|score
operator|>
literal|1
operator|||
name|score
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed MinMatchScore '"
operator|+
name|score
operator|+
literal|"' MUST BE in the range [0..1]!"
argument_list|)
throw|;
block|}
else|else
block|{
name|minMatchScore
operator|=
name|score
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**      * Setter for the dereference entities state.      * @param state the state or<code>null</code> to set the      * default.      */
end_comment

begin_function
specifier|public
name|void
name|setDereferenceEntitiesState
parameter_list|(
name|Boolean
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|dereferenceEntitiesState
operator|=
name|DEFAULT_DEREFERENCE_ENTITIES_STATE
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|dereferenceEntitiesState
operator|=
name|state
expr_stmt|;
block|}
name|__selectedFields
operator|=
literal|null
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * Getter for the dereference entities state      * @return<code>true</code> if enabled otherwise<code>false</code>      */
end_comment

begin_function
specifier|public
name|boolean
name|isDereferenceEntitiesEnabled
parameter_list|()
block|{
return|return
name|dereferenceEntitiesState
return|;
block|}
end_function

begin_comment
comment|/**      * Getter for all fields that need to be selected based on the      * current EntityLinker configuration. This includes<ul>      *<li> {@link #getNameField()}      *<li> {@link #getTypeField()}      *<li> {@link #getRedirectField()} if {@link #getRedirectProcessingMode()}       * != {@link RedirectProcessingMode#IGNORE}      *<li> {@link #getDereferencedFields()} if {@link #isDereferenceEntitiesEnabled()}      *</ul>      * @return the selected fields for queries against the linked vocabulary.      */
end_comment

begin_function
specifier|public
name|Set
argument_list|<
name|UriRef
argument_list|>
name|getSelectedFields
parameter_list|()
block|{
if|if
condition|(
name|__selectedFields
operator|==
literal|null
condition|)
block|{
name|Set
argument_list|<
name|UriRef
argument_list|>
name|fields
init|=
operator|new
name|HashSet
argument_list|<
name|UriRef
argument_list|>
argument_list|()
decl_stmt|;
name|fields
operator|.
name|add
argument_list|(
name|nameField
argument_list|)
expr_stmt|;
name|fields
operator|.
name|add
argument_list|(
name|typeField
argument_list|)
expr_stmt|;
if|if
condition|(
name|redirectProcessingMode
operator|!=
name|RedirectProcessingMode
operator|.
name|IGNORE
condition|)
block|{
name|fields
operator|.
name|add
argument_list|(
name|redirectField
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dereferenceEntitiesState
condition|)
block|{
name|fields
operator|.
name|addAll
argument_list|(
name|dereferencedFields
argument_list|)
expr_stmt|;
block|}
name|__selectedFields
operator|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|fields
argument_list|)
expr_stmt|;
return|return
name|__selectedFields
return|;
block|}
else|else
block|{
return|return
name|__selectedFields
return|;
block|}
block|}
end_function

begin_comment
comment|/**      * If suggested entities that would have the same score (e.g. 1.0 - for a      * perfect match) should have their score slightly adapted so that they      * are sorted based on their entity ranking.<p>      * The entity ranking is defined as the importance (popularity, connectivity, ...)      * of an entity within the knowledge base      * @return the state      */
end_comment

begin_function
specifier|public
name|boolean
name|isRankEqualScoresBasedOnEntityRankings
parameter_list|()
block|{
return|return
name|rankEqualScoresBasedOnEntityRankings
return|;
block|}
end_function

begin_comment
comment|/**      * Setter for the state if suggested  that would have the same score (e.g. 1.0 - for a      * perfect match) should have their score slightly adapted so that they      * are sorted based on their entity ranking.<p>      * The entity ranking is defined as the importance (popularity, connectivity, ...)      * of an entity within the knowledge base      * @param state the state      */
end_comment

begin_function
specifier|public
name|void
name|setRankEqualScoresBasedOnEntityRankings
parameter_list|(
name|boolean
name|state
parameter_list|)
block|{
name|this
operator|.
name|rankEqualScoresBasedOnEntityRankings
operator|=
name|state
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * Adds an type to the blacklist      */
end_comment

begin_function
specifier|public
specifier|final
name|void
name|addBlacklistType
parameter_list|(
name|UriRef
name|type
parameter_list|,
name|Integer
name|order
parameter_list|)
block|{
if|if
condition|(
name|type
operator|!=
literal|null
operator|&&
name|order
operator|!=
literal|null
condition|)
block|{
name|blacklistedTypes
operator|.
name|put
argument_list|(
name|type
argument_list|,
name|order
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**      * Adds an type to the blacklist      */
end_comment

begin_function
specifier|public
specifier|final
name|void
name|addWhitelistType
parameter_list|(
name|UriRef
name|type
parameter_list|,
name|Integer
name|order
parameter_list|)
block|{
if|if
condition|(
name|type
operator|!=
literal|null
operator|&&
name|order
operator|!=
literal|null
condition|)
block|{
name|whitelistedTypes
operator|.
name|put
argument_list|(
name|type
argument_list|,
name|order
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|public
specifier|final
name|void
name|setDefaultWhitelistTypes
parameter_list|(
name|Boolean
name|state
parameter_list|)
block|{
name|this
operator|.
name|defaultWhitelistTypes
operator|=
name|state
expr_stmt|;
block|}
end_function

begin_function
specifier|public
specifier|final
name|boolean
name|isDefaultWhitelistTypes
parameter_list|()
block|{
if|if
condition|(
name|Boolean
operator|.
name|FALSE
operator|.
name|equals
argument_list|(
name|defaultWhitelistTypes
argument_list|)
operator|&&
name|whitelistedTypes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//illegal configuration ... ignore
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
name|defaultWhitelistTypes
operator|!=
literal|null
condition|?
name|defaultWhitelistTypes
operator|.
name|booleanValue
argument_list|()
else|:
name|whitelistedTypes
operator|.
name|isEmpty
argument_list|()
return|;
comment|//if whitelist is empty ... true
block|}
block|}
end_function

begin_comment
comment|/**      * @param ignoredTypes the ignoredTypes to set      */
end_comment

begin_function
specifier|public
specifier|final
name|Map
argument_list|<
name|UriRef
argument_list|,
name|Integer
argument_list|>
name|getBlacklistedTypes
parameter_list|()
block|{
return|return
name|blacklistedTypes
return|;
block|}
end_function

begin_comment
comment|/**      * @param ignoredTypes the ignoredTypes to set      */
end_comment

begin_function
specifier|public
specifier|final
name|Map
argument_list|<
name|UriRef
argument_list|,
name|Integer
argument_list|>
name|getWhitelistedTypes
parameter_list|()
block|{
return|return
name|whitelistedTypes
return|;
block|}
end_function

begin_comment
comment|/**      * checks if EntityType filtering is active or not      */
end_comment

begin_function
specifier|public
specifier|final
name|boolean
name|isEntityTypeFilteringActive
parameter_list|()
block|{
if|if
condition|(
name|whitelistedTypes
operator|.
name|isEmpty
argument_list|()
operator|&&
name|blacklistedTypes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
literal|true
return|;
block|}
block|}
end_function

unit|}
end_unit

