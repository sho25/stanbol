begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|tika
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|tika
operator|.
name|metadata
operator|.
name|OntologyMappings
operator|.
name|addDcMappings
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|tika
operator|.
name|metadata
operator|.
name|OntologyMappings
operator|.
name|addGeoMappings
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|tika
operator|.
name|metadata
operator|.
name|OntologyMappings
operator|.
name|addMediaResourceOntologyMappings
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|tika
operator|.
name|metadata
operator|.
name|OntologyMappings
operator|.
name|addNepomukExifMappings
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|tika
operator|.
name|metadata
operator|.
name|OntologyMappings
operator|.
name|addNepomukMessageMappings
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|tika
operator|.
name|metadata
operator|.
name|OntologyMappings
operator|.
name|addRdfsMappings
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|tika
operator|.
name|metadata
operator|.
name|OntologyMappings
operator|.
name|addSkosMappings
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|EnhancementEngineHelper
operator|.
name|randomUUID
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|mime
operator|.
name|MediaType
operator|.
name|TEXT_PLAIN
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStreamWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Writer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|AccessController
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedActionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Dictionary
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|commons
operator|.
name|rdf
operator|.
name|Graph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|commons
operator|.
name|rdf
operator|.
name|IRI
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|commons
operator|.
name|rdf
operator|.
name|impl
operator|.
name|utils
operator|.
name|PlainLiteralImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|commons
operator|.
name|rdf
operator|.
name|impl
operator|.
name|utils
operator|.
name|TripleImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Component
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Property
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Reference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Service
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|tika
operator|.
name|handler
operator|.
name|MultiHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|tika
operator|.
name|handler
operator|.
name|PlainTextHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|tika
operator|.
name|metadata
operator|.
name|OntologyMappings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|Blob
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|ContentItem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|ContentItemFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|ContentSink
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|EngineException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|EnhancementEngine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|ServiceProperties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|impl
operator|.
name|AbstractEnhancementEngine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|config
operator|.
name|TikaConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|detect
operator|.
name|Detector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|exception
operator|.
name|TikaException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|metadata
operator|.
name|Metadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|mime
operator|.
name|MediaType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|parser
operator|.
name|AutoDetectParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|parser
operator|.
name|ParseContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|parser
operator|.
name|Parser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|sax
operator|.
name|BodyContentHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tika
operator|.
name|sax
operator|.
name|ToXMLContentHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|service
operator|.
name|cm
operator|.
name|ConfigurationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|service
operator|.
name|component
operator|.
name|ComponentContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|ContentHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|SAXException
import|;
end_import

begin_comment
comment|/**  * EnhancementEngine based on Apache Tika that converts the content of parsed   * content items to xhtml and plain text. In addition it converts extracted   * metadata to RDF and adds them to the {@link ContentItem#getMetadata()}  *   * @author Rupert Westenthaler  *  */
end_comment

begin_class
annotation|@
name|Component
argument_list|(
name|immediate
operator|=
literal|true
argument_list|,
name|metatype
operator|=
literal|true
argument_list|,
name|inherit
operator|=
literal|true
argument_list|)
annotation|@
name|Service
annotation|@
name|Properties
argument_list|(
name|value
operator|=
block|{
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|EnhancementEngine
operator|.
name|PROPERTY_NAME
argument_list|,
name|value
operator|=
literal|"tika"
argument_list|)
block|,
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|TikaEngine
operator|.
name|SKIP_LINEBREAKS_WITHIN_CONTENT
argument_list|,
name|boolValue
operator|=
name|TikaEngine
operator|.
name|DEFAULT_SKIP_LINEBREAKS
argument_list|)
block|,
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|TikaEngine
operator|.
name|MAPPING_MEDIA_RESOURCE
argument_list|,
name|boolValue
operator|=
name|TikaEngine
operator|.
name|DEFAULT_MAPPING_MEDIA_RESOURCE_STATE
argument_list|)
block|,
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|TikaEngine
operator|.
name|MAPPING_DUBLIN_CORE_TERMS
argument_list|,
name|boolValue
operator|=
name|TikaEngine
operator|.
name|DEFAULT_MAPPING_DUBLIN_CORE_TERMS_STATE
argument_list|)
block|,
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|TikaEngine
operator|.
name|MAPPING_NEPOMUK_MESSAGE
argument_list|,
name|boolValue
operator|=
name|TikaEngine
operator|.
name|DEFAULT_MAPPING_NEPOMUK_MESSAGE_STATE
argument_list|)
block|,
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|TikaEngine
operator|.
name|MAPPING_NEPOMUK_EXIF
argument_list|,
name|boolValue
operator|=
name|TikaEngine
operator|.
name|DEFAULT_MAPPING_NEPOMUK_EXIF_STATE
argument_list|)
block|,
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|TikaEngine
operator|.
name|MAPPING_SKOS
argument_list|,
name|boolValue
operator|=
name|TikaEngine
operator|.
name|DEFAULT_MAPPING_SKOS_STATE
argument_list|)
block|,
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|TikaEngine
operator|.
name|MAPPING_RDFS
argument_list|,
name|boolValue
operator|=
name|TikaEngine
operator|.
name|DEFAULT_MAPPING_RDFS_STATE
argument_list|)
block|,
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|TikaEngine
operator|.
name|MAPPING_GEO
argument_list|,
name|boolValue
operator|=
name|TikaEngine
operator|.
name|DEFAULT_MAPPING_GEO_STATE
argument_list|)
block|,
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|TikaEngine
operator|.
name|UNMAPPED_PROPERTIES
argument_list|,
name|boolValue
operator|=
name|TikaEngine
operator|.
name|DEFAULT_UNMAPPED_PROPERTIES_STATE
argument_list|)
block|}
argument_list|)
specifier|public
class|class
name|TikaEngine
extends|extends
name|AbstractEnhancementEngine
argument_list|<
name|RuntimeException
argument_list|,
name|RuntimeException
argument_list|>
implements|implements
name|EnhancementEngine
implements|,
name|ServiceProperties
block|{
specifier|private
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TikaEngine
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|SKIP_LINEBREAKS_WITHIN_CONTENT
init|=
literal|"stanbol.engines.tika.skipLinebreaks"
decl_stmt|;
comment|//Metadata -> Ontology mapping configuration
specifier|public
specifier|static
specifier|final
name|String
name|MAPPING_MEDIA_RESOURCE
init|=
literal|"stanbol.engine.tika.mapping.mediaResource"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_MAPPING_MEDIA_RESOURCE_STATE
init|=
literal|true
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|MAPPING_DUBLIN_CORE_TERMS
init|=
literal|"stanbol.engine.tika.mapping.dcTerms"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_MAPPING_DUBLIN_CORE_TERMS_STATE
init|=
literal|true
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|MAPPING_NEPOMUK_MESSAGE
init|=
literal|"stanbol.engine.tika.mapping.nepomukMessage"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_MAPPING_NEPOMUK_MESSAGE_STATE
init|=
literal|true
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|MAPPING_NEPOMUK_EXIF
init|=
literal|"stanbol.engine.tika.mapping.nepomukExif"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_MAPPING_NEPOMUK_EXIF_STATE
init|=
literal|true
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|MAPPING_SKOS
init|=
literal|"stanbol.engine.tika.mapping.skos"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_MAPPING_SKOS_STATE
init|=
literal|false
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|MAPPING_RDFS
init|=
literal|"stanbol.engine.tika.mapping.rdfs"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_MAPPING_RDFS_STATE
init|=
literal|false
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|MAPPING_GEO
init|=
literal|"stanbol.engine.tika.mapping.geo"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_MAPPING_GEO_STATE
init|=
literal|true
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|UNMAPPED_PROPERTIES
init|=
literal|"stanbol.engine.tika.mapping.unmapped"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_UNMAPPED_PROPERTIES_STATE
init|=
literal|false
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_SKIP_LINEBREAKS
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|skipLinebreaks
init|=
name|DEFAULT_SKIP_LINEBREAKS
decl_stmt|;
comment|/**      * This prefix is used as prefix for Tika properties to ensure valid URN.       */
specifier|public
specifier|static
specifier|final
name|String
name|TIKA_URN_PREFIX
init|=
literal|"urn:tika.apache.org:tika:"
decl_stmt|;
comment|/**      * The default value for the Execution of this Engine. Currently set to      * {@link ServiceProperties#ORDERING_PRE_PROCESSING}      */
specifier|public
specifier|static
specifier|final
name|Integer
name|defaultOrder
init|=
name|ORDERING_PRE_PROCESSING
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|MediaType
name|XHTML
init|=
operator|new
name|MediaType
argument_list|(
literal|"application"
argument_list|,
literal|"xhtml+xml"
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|Charset
name|UTF8
init|=
name|Charset
operator|.
name|forName
argument_list|(
literal|"UTF-8"
argument_list|)
decl_stmt|;
specifier|private
name|TikaConfig
name|config
decl_stmt|;
specifier|private
name|Parser
name|parser
decl_stmt|;
specifier|private
name|Detector
name|detector
decl_stmt|;
specifier|private
name|OntologyMappings
name|ontologyMappings
decl_stmt|;
comment|/**      * The {@link ContentItemFactory} is used to create {@link Blob}s for the      * plain text and XHTML version of the processed ContentItem      */
annotation|@
name|Reference
specifier|private
name|ContentItemFactory
name|ciFactory
decl_stmt|;
comment|/**      * If<code>true</code> unmapped properties are added by using      *<code>urn:tika.apache.org:tika:{property-name}</code> to the URI of the      * contentItem.      */
specifier|private
name|boolean
name|includeUnmappedProperties
decl_stmt|;
comment|/**      * Include also properties without a namespace. Currently those are ignored      */
specifier|private
name|boolean
name|includeAllUnmappedProperties
init|=
literal|false
decl_stmt|;
specifier|private
specifier|static
class|class
name|MediaTypeAndStream
block|{
name|String
name|uri
decl_stmt|;
name|MediaType
name|mediaType
decl_stmt|;
name|InputStream
name|in
decl_stmt|;
block|}
comment|/**      * Default constructor used by OSGI      */
specifier|public
name|TikaEngine
parameter_list|()
block|{}
comment|/**      * Used by the unit tests to init the {@link ContentItemFactory} outside      * an OSGI environment.      * @param cifactory      */
name|TikaEngine
parameter_list|(
name|ContentItemFactory
name|cifactory
parameter_list|)
block|{
name|this
operator|.
name|ciFactory
operator|=
name|cifactory
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|canEnhance
parameter_list|(
name|ContentItem
name|ci
parameter_list|)
throws|throws
name|EngineException
block|{
return|return
name|ENHANCE_ASYNC
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|computeEnhancements
parameter_list|(
name|ContentItem
name|ci
parameter_list|)
throws|throws
name|EngineException
block|{
name|MediaTypeAndStream
name|mtas
init|=
name|extractMediaType
argument_list|(
name|ci
argument_list|)
decl_stmt|;
if|if
condition|(
name|mtas
operator|.
name|mediaType
operator|==
literal|null
condition|)
block|{
return|return;
comment|//unable to parse and detect content type
block|}
name|MediaType
name|plainMediaType
init|=
name|mtas
operator|.
name|mediaType
operator|.
name|getBaseType
argument_list|()
decl_stmt|;
if|if
condition|(
name|plainMediaType
operator|.
name|equals
argument_list|(
name|MediaType
operator|.
name|TEXT_PLAIN
argument_list|)
condition|)
block|{
return|return;
comment|//we need not to process plain text!
block|}
specifier|final
name|ParseContext
name|context
init|=
operator|new
name|ParseContext
argument_list|()
decl_stmt|;
name|context
operator|.
name|set
argument_list|(
name|Parser
operator|.
name|class
argument_list|,
name|parser
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|MediaType
argument_list|>
name|supproted
init|=
name|parser
operator|.
name|getSupportedTypes
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|supproted
operator|.
name|contains
argument_list|(
name|plainMediaType
argument_list|)
condition|)
block|{
specifier|final
name|InputStream
name|in
decl_stmt|;
if|if
condition|(
name|mtas
operator|.
name|in
operator|==
literal|null
condition|)
block|{
name|in
operator|=
name|ci
operator|.
name|getStream
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|in
operator|=
name|mtas
operator|.
name|in
expr_stmt|;
block|}
specifier|final
name|Metadata
name|metadata
init|=
operator|new
name|Metadata
argument_list|()
decl_stmt|;
comment|//set the already parsed contentType
name|metadata
operator|.
name|set
argument_list|(
name|Metadata
operator|.
name|CONTENT_TYPE
argument_list|,
name|mtas
operator|.
name|mediaType
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|//also explicitly set the charset as contentEncoding
name|String
name|charset
init|=
name|mtas
operator|.
name|mediaType
operator|.
name|getParameters
argument_list|()
operator|.
name|get
argument_list|(
literal|"charset"
argument_list|)
decl_stmt|;
if|if
condition|(
name|charset
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|set
argument_list|(
name|Metadata
operator|.
name|CONTENT_ENCODING
argument_list|,
name|charset
argument_list|)
expr_stmt|;
block|}
name|ContentSink
name|plainTextSink
decl_stmt|;
try|try
block|{
name|plainTextSink
operator|=
name|ciFactory
operator|.
name|createContentSink
argument_list|(
name|TEXT_PLAIN
operator|+
literal|"; charset="
operator|+
name|UTF8
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|in
argument_list|)
expr_stmt|;
comment|//close the input stream
throw|throw
operator|new
name|EngineException
argument_list|(
literal|"Error while initialising Blob for"
operator|+
literal|"writing the text/plain version of the parsed content"
argument_list|,
name|e
argument_list|)
throw|;
block|}
specifier|final
name|Writer
name|plainTextWriter
init|=
operator|new
name|OutputStreamWriter
argument_list|(
name|plainTextSink
operator|.
name|getOutputStream
argument_list|()
argument_list|,
name|UTF8
argument_list|)
decl_stmt|;
specifier|final
name|ContentHandler
name|textHandler
init|=
operator|new
name|BodyContentHandler
argument_list|(
comment|//only the Body
operator|new
name|PlainTextHandler
argument_list|(
name|plainTextWriter
argument_list|,
literal|false
argument_list|,
name|skipLinebreaks
argument_list|)
argument_list|)
decl_stmt|;
comment|//skip ignoreable
specifier|final
name|ToXMLContentHandler
name|xhtmlHandler
decl_stmt|;
specifier|final
name|ContentHandler
name|mainHandler
decl_stmt|;
name|ContentSink
name|xhtmlSink
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|plainMediaType
operator|.
name|equals
argument_list|(
name|XHTML
argument_list|)
condition|)
block|{
comment|//do not parse XHTML from XHTML
try|try
block|{
name|xhtmlSink
operator|=
name|ciFactory
operator|.
name|createContentSink
argument_list|(
name|XHTML
operator|+
literal|"; charset="
operator|+
name|UTF8
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|EngineException
argument_list|(
literal|"Error while initialising Blob for"
operator|+
literal|"writing the application/xhtml+xml version of the parsed content"
argument_list|,
name|e
argument_list|)
throw|;
block|}
try|try
block|{
name|xhtmlHandler
operator|=
operator|new
name|ToXMLContentHandler
argument_list|(
name|xhtmlSink
operator|.
name|getOutputStream
argument_list|()
argument_list|,
name|UTF8
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|EngineException
argument_list|(
literal|"This system does not support the encoding "
operator|+
name|UTF8
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|mainHandler
operator|=
operator|new
name|MultiHandler
argument_list|(
name|textHandler
argument_list|,
name|xhtmlHandler
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mainHandler
operator|=
name|textHandler
expr_stmt|;
name|xhtmlHandler
operator|=
literal|null
expr_stmt|;
name|xhtmlSink
operator|=
literal|null
expr_stmt|;
block|}
try|try
block|{
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
specifier|public
name|Object
name|run
parameter_list|()
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|TikaException
block|{
comment|/*                               * We need to replace the context Classloader with the Bundle ClassLoader                              * to ensure that Singleton instances of XML frameworks (such as node4j)                               * do not leak into the OSGI environment.                              *                               * Most Java XML libs prefer to load implementations by using the                               * {@link Thread#getContextClassLoader()}. However OSGI has no control over                              * this {@link ClassLoader}. Because of that there can be situations where                              * Interfaces are loaded via the Bundle Classloader and the implementations                              * are taken from the context Classloader. What can cause                               * {@link ClassCastException}, {@link ExceptionInInitializerError}s, ...                              *                               * Setting the context Classloader to the Bundle classloader helps to avoid                              * those situations.                              */
name|ClassLoader
name|contextClassLoader
init|=
name|updateContextClassLoader
argument_list|()
decl_stmt|;
try|try
block|{
name|parser
operator|.
name|parse
argument_list|(
name|in
argument_list|,
name|mainHandler
argument_list|,
name|metadata
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|//reset the previous context ClassLoader
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|setContextClassLoader
argument_list|(
name|contextClassLoader
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PrivilegedActionException
name|pae
parameter_list|)
block|{
name|Exception
name|e
init|=
name|pae
operator|.
name|getException
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|IOException
operator|||
name|e
operator|instanceof
name|SAXException
operator|||
name|e
operator|instanceof
name|TikaException
condition|)
block|{
throw|throw
operator|new
name|EngineException
argument_list|(
literal|"Unable to convert ContentItem "
operator|+
name|ci
operator|.
name|getUri
argument_list|()
operator|+
literal|" with mimeType '"
operator|+
name|ci
operator|.
name|getMimeType
argument_list|()
operator|+
literal|"' to "
operator|+
literal|"plain text!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
else|else
block|{
comment|//runtime exception
throw|throw
name|RuntimeException
operator|.
name|class
operator|.
name|cast
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
finally|finally
block|{
comment|//ensure that the writers are closed correctly
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|plainTextWriter
argument_list|)
expr_stmt|;
if|if
condition|(
name|xhtmlSink
operator|!=
literal|null
condition|)
block|{
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|xhtmlSink
operator|.
name|getOutputStream
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|String
name|random
init|=
name|randomUUID
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|IRI
name|textBlobUri
init|=
operator|new
name|IRI
argument_list|(
literal|"urn:tika:text:"
operator|+
name|random
argument_list|)
decl_stmt|;
name|ci
operator|.
name|addPart
argument_list|(
name|textBlobUri
argument_list|,
name|plainTextSink
operator|.
name|getBlob
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|xhtmlHandler
operator|!=
literal|null
condition|)
block|{
name|IRI
name|xhtmlBlobUri
init|=
operator|new
name|IRI
argument_list|(
literal|"urn:tika:xhtml:"
operator|+
name|random
argument_list|)
decl_stmt|;
name|ci
operator|.
name|addPart
argument_list|(
name|xhtmlBlobUri
argument_list|,
name|xhtmlSink
operator|.
name|getBlob
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//add the extracted metadata
if|if
condition|(
name|log
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
for|for
control|(
name|String
name|name
range|:
name|metadata
operator|.
name|names
argument_list|()
control|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"{}: {}"
argument_list|,
name|name
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|metadata
operator|.
name|getValues
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ci
operator|.
name|getLock
argument_list|()
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|Graph
name|graph
init|=
name|ci
operator|.
name|getMetadata
argument_list|()
decl_stmt|;
name|IRI
name|id
init|=
name|ci
operator|.
name|getUri
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|mapped
init|=
name|ontologyMappings
operator|.
name|apply
argument_list|(
name|graph
argument_list|,
name|id
argument_list|,
name|metadata
argument_list|)
decl_stmt|;
if|if
condition|(
name|includeUnmappedProperties
condition|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|unmapped
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|metadata
operator|.
name|names
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|unmapped
operator|.
name|removeAll
argument_list|(
name|mapped
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|name
range|:
name|unmapped
control|)
block|{
if|if
condition|(
name|name
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|)
operator|>=
literal|0
operator|||
name|includeAllUnmappedProperties
condition|)
block|{
comment|//only mapped
name|IRI
name|prop
init|=
operator|new
name|IRI
argument_list|(
operator|new
name|StringBuilder
argument_list|(
name|TIKA_URN_PREFIX
argument_list|)
operator|.
name|append
argument_list|(
name|name
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|value
range|:
name|metadata
operator|.
name|getValues
argument_list|(
name|name
argument_list|)
control|)
block|{
comment|//TODO: without the Property for the name we have no datatype
comment|//      information ... so we add PlainLiterals for now
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|id
argument_list|,
name|prop
argument_list|,
operator|new
name|PlainLiteralImpl
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
finally|finally
block|{
name|ci
operator|.
name|getLock
argument_list|()
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|//else not supported format
block|}
comment|/**      * Getter for the contentType. If not set or {@link MediaType#OCTET_STREAM}      * than the media type is detected.<p>      * This method returns the MediaType and the Stream used to detect the      * MimeType. This allows to reuse the stream and the mediaType      * @param ci      * @param mediaTypeArray      * @return      */
specifier|private
name|MediaTypeAndStream
name|extractMediaType
parameter_list|(
name|ContentItem
name|ci
parameter_list|)
block|{
name|MediaTypeAndStream
name|mtas
init|=
operator|new
name|MediaTypeAndStream
argument_list|()
decl_stmt|;
name|mtas
operator|.
name|mediaType
operator|=
name|getMediaType
argument_list|(
name|ci
operator|.
name|getBlob
argument_list|()
argument_list|)
expr_stmt|;
name|mtas
operator|.
name|uri
operator|=
name|ci
operator|.
name|getUri
argument_list|()
operator|.
name|getUnicodeString
argument_list|()
expr_stmt|;
if|if
condition|(
name|mtas
operator|.
name|mediaType
operator|==
literal|null
operator|||
name|mtas
operator|.
name|mediaType
operator|.
name|equals
argument_list|(
name|MediaType
operator|.
name|OCTET_STREAM
argument_list|)
condition|)
block|{
name|mtas
operator|.
name|in
operator|=
operator|new
name|BufferedInputStream
argument_list|(
name|ci
operator|.
name|getStream
argument_list|()
argument_list|)
expr_stmt|;
name|Metadata
name|m
init|=
operator|new
name|Metadata
argument_list|()
decl_stmt|;
name|m
operator|.
name|add
argument_list|(
name|Metadata
operator|.
name|RESOURCE_NAME_KEY
argument_list|,
name|mtas
operator|.
name|uri
argument_list|)
expr_stmt|;
try|try
block|{
name|mtas
operator|.
name|mediaType
operator|=
name|detector
operator|.
name|detect
argument_list|(
name|mtas
operator|.
name|in
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Exception while detection the MediaType of the"
operator|+
literal|"parsed ContentItem "
operator|+
name|ci
operator|.
name|getUri
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|mtas
operator|.
name|in
argument_list|)
expr_stmt|;
name|mtas
operator|.
name|in
operator|=
literal|null
expr_stmt|;
block|}
block|}
return|return
name|mtas
return|;
block|}
comment|/**      * @param ci      * @return      */
specifier|private
name|MediaType
name|getMediaType
parameter_list|(
name|Blob
name|blob
parameter_list|)
block|{
name|String
index|[]
name|mediaTypeArray
init|=
name|blob
operator|.
name|getMimeType
argument_list|()
operator|.
name|split
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
if|if
condition|(
name|mediaTypeArray
operator|.
name|length
operator|!=
literal|2
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Encounterd illegal formatted mediaType '{}'  -> will try "
operator|+
literal|"to detect the mediaType based on the parsed content!"
argument_list|,
name|blob
operator|.
name|getMimeType
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
operator|new
name|MediaType
argument_list|(
name|mediaTypeArray
index|[
literal|0
index|]
argument_list|,
name|mediaTypeArray
index|[
literal|1
index|]
argument_list|,
name|blob
operator|.
name|getParameter
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**      * Sets the Bundle {@link ClassLoader} context Classloader of the       *  {@link Thread#currentThread()}.      *<p>      * Users of this utility method need to make sure that the       * ClassLoader is reset to the original value - as      * returned by this method by adding a       *<pre><code>      *     ClassLoader classLoader = updateContextClassLoader();      *     try {      *         //the code that needs to be executed      *     } finally {      *         Thread.currentThread().setContextClassLoader(classLoader);      *     }      *</code></pre><p>      * @return the {@link ClassLoader} of {@link Thread#currentThread()} before      * calling this method      */
specifier|private
name|ClassLoader
name|updateContextClassLoader
parameter_list|()
block|{
name|ClassLoader
name|classLoader
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getContextClassLoader
argument_list|()
decl_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|setContextClassLoader
argument_list|(
name|TikaEngine
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|classLoader
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|activate
parameter_list|(
name|ComponentContext
name|ctx
parameter_list|)
throws|throws
name|ConfigurationException
block|{
name|super
operator|.
name|activate
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|config
operator|=
name|TikaConfig
operator|.
name|getDefaultConfig
argument_list|()
expr_stmt|;
name|this
operator|.
name|detector
operator|=
name|config
operator|.
name|getDetector
argument_list|()
expr_stmt|;
name|this
operator|.
name|parser
operator|=
operator|new
name|AutoDetectParser
argument_list|(
name|config
argument_list|)
expr_stmt|;
name|this
operator|.
name|skipLinebreaks
operator|=
name|getBoolean
argument_list|(
name|ctx
operator|.
name|getProperties
argument_list|()
argument_list|,
name|SKIP_LINEBREAKS_WITHIN_CONTENT
argument_list|,
name|DEFAULT_SKIP_LINEBREAKS
argument_list|)
expr_stmt|;
name|this
operator|.
name|ontologyMappings
operator|=
operator|new
name|OntologyMappings
argument_list|()
expr_stmt|;
if|if
condition|(
name|getBoolean
argument_list|(
name|ctx
operator|.
name|getProperties
argument_list|()
argument_list|,
name|MAPPING_MEDIA_RESOURCE
argument_list|,
name|DEFAULT_MAPPING_MEDIA_RESOURCE_STATE
argument_list|)
condition|)
block|{
name|addMediaResourceOntologyMappings
argument_list|(
name|ontologyMappings
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|getBoolean
argument_list|(
name|ctx
operator|.
name|getProperties
argument_list|()
argument_list|,
name|MAPPING_DUBLIN_CORE_TERMS
argument_list|,
name|DEFAULT_MAPPING_DUBLIN_CORE_TERMS_STATE
argument_list|)
condition|)
block|{
name|addDcMappings
argument_list|(
name|ontologyMappings
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|getBoolean
argument_list|(
name|ctx
operator|.
name|getProperties
argument_list|()
argument_list|,
name|MAPPING_NEPOMUK_MESSAGE
argument_list|,
name|DEFAULT_MAPPING_NEPOMUK_MESSAGE_STATE
argument_list|)
condition|)
block|{
name|addNepomukMessageMappings
argument_list|(
name|ontologyMappings
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|getBoolean
argument_list|(
name|ctx
operator|.
name|getProperties
argument_list|()
argument_list|,
name|MAPPING_NEPOMUK_EXIF
argument_list|,
name|DEFAULT_MAPPING_NEPOMUK_EXIF_STATE
argument_list|)
condition|)
block|{
name|addNepomukExifMappings
argument_list|(
name|ontologyMappings
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|getBoolean
argument_list|(
name|ctx
operator|.
name|getProperties
argument_list|()
argument_list|,
name|MAPPING_SKOS
argument_list|,
name|DEFAULT_MAPPING_SKOS_STATE
argument_list|)
condition|)
block|{
name|addSkosMappings
argument_list|(
name|ontologyMappings
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|getBoolean
argument_list|(
name|ctx
operator|.
name|getProperties
argument_list|()
argument_list|,
name|MAPPING_RDFS
argument_list|,
name|DEFAULT_MAPPING_RDFS_STATE
argument_list|)
condition|)
block|{
name|addRdfsMappings
argument_list|(
name|ontologyMappings
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|getBoolean
argument_list|(
name|ctx
operator|.
name|getProperties
argument_list|()
argument_list|,
name|MAPPING_GEO
argument_list|,
name|DEFAULT_MAPPING_GEO_STATE
argument_list|)
condition|)
block|{
name|addGeoMappings
argument_list|(
name|ontologyMappings
argument_list|)
expr_stmt|;
block|}
name|includeUnmappedProperties
operator|=
name|getBoolean
argument_list|(
name|ctx
operator|.
name|getProperties
argument_list|()
argument_list|,
name|UNMAPPED_PROPERTIES
argument_list|,
name|DEFAULT_UNMAPPED_PROPERTIES_STATE
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|deactivate
parameter_list|(
name|ComponentContext
name|ctx
parameter_list|)
throws|throws
name|RuntimeException
block|{
name|this
operator|.
name|config
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|parser
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|detector
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|skipLinebreaks
operator|=
name|DEFAULT_SKIP_LINEBREAKS
expr_stmt|;
name|this
operator|.
name|ontologyMappings
operator|=
literal|null
expr_stmt|;
name|super
operator|.
name|deactivate
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|boolean
name|getBoolean
parameter_list|(
name|Dictionary
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|properties
parameter_list|,
name|String
name|key
parameter_list|,
name|boolean
name|defaultState
parameter_list|)
block|{
name|Object
name|value
init|=
name|properties
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|value
operator|instanceof
name|Boolean
condition|?
operator|(
name|Boolean
operator|)
name|value
else|:
name|value
operator|!=
literal|null
condition|?
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
else|:
name|defaultState
return|;
block|}
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|getServiceProperties
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|Collections
operator|.
name|singletonMap
argument_list|(
name|ENHANCEMENT_ENGINE_ORDERING
argument_list|,
operator|(
name|Object
operator|)
name|defaultOrder
argument_list|)
argument_list|)
return|;
block|}
block|}
end_class

end_unit

