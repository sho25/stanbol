begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
package|package
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|core
operator|.
name|utils
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|datatype
operator|.
name|DatatypeConfigurationException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|datatype
operator|.
name|DatatypeFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|datatype
operator|.
name|Duration
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|datatype
operator|.
name|XMLGregorianCalendar
import|;
end_import

begin_import
import|import
name|org
operator|.
name|joda
operator|.
name|time
operator|.
name|DateTime
import|;
end_import

begin_import
import|import
name|org
operator|.
name|joda
operator|.
name|time
operator|.
name|DateTimeZone
import|;
end_import

begin_import
import|import
name|org
operator|.
name|joda
operator|.
name|time
operator|.
name|format
operator|.
name|DateTimeFormatter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|joda
operator|.
name|time
operator|.
name|format
operator|.
name|ISODateTimeFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|servicesapi
operator|.
name|defaults
operator|.
name|DataTypeEnum
import|;
end_import

begin_comment
comment|/**  * Utilities to parse/format Date and Time values for java {@link Date} objects.<p>  * Note that<ul>  *<li> all toString(..) methods format the parsed date in with time zone UTC  *<li> all toDate(..) methods correctly parse dates in any time zone  *<li> for {@link DataTypeEnum#DateTime} a parser with Date + optional Time is  *      used. Meaning that also dates with missing Time Element are excepted  *</ul>  *  * @author Rupert Westenthaler  *  */
end_comment

begin_class
specifier|public
class|class
name|TimeUtils
block|{
specifier|protected
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TimeUtils
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * Holds all the data types that represent a date or a time!      */
specifier|private
specifier|static
specifier|final
name|EnumSet
argument_list|<
name|DataTypeEnum
argument_list|>
name|dateOrTimeDataTypes
init|=
name|EnumSet
operator|.
name|of
argument_list|(
name|DataTypeEnum
operator|.
name|DateTime
argument_list|,
name|DataTypeEnum
operator|.
name|Time
argument_list|,
name|DataTypeEnum
operator|.
name|Date
argument_list|)
decl_stmt|;
comment|/**      * ShortNames of the supported date or time dataTypes. Only used to write      * meaning full error messages if unsupported data types are parsed!      */
specifier|private
specifier|static
specifier|final
name|Collection
argument_list|<
name|String
argument_list|>
name|dateTimeFormatShortNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|dateOrTimeDataTypes
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
static|static
block|{
for|for
control|(
name|DataTypeEnum
name|dateOrTimeDataType
range|:
name|dateOrTimeDataTypes
control|)
block|{
name|dateTimeFormatShortNames
operator|.
name|add
argument_list|(
name|dateOrTimeDataType
operator|.
name|getShortName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Used to encode XML DateTime strings with UTC time zone as used for      * {@link DataTypeEnum#DateTime}      */
specifier|protected
specifier|static
specifier|final
name|DateTimeFormatter
name|XML_DATE_TIME_FORMAT
init|=
name|ISODateTimeFormat
operator|.
name|dateTime
argument_list|()
operator|.
name|withZone
argument_list|(
name|DateTimeZone
operator|.
name|UTC
argument_list|)
decl_stmt|;
comment|/**      * The strict xsd:dateTime parser. It accepts only dateTimes that define      * all elements. Only the "fraction of second" part and the time zone      * are optional.<p>      * This parser is used for {@link DataTypeEnum#DateTime} if      *<code>strict=true</code> (default is<code>false</code>)      */
specifier|protected
specifier|static
specifier|final
name|DateTimeFormatter
name|XML_DATE_TIME_PARSER_STRICT
init|=
name|ISODateTimeFormat
operator|.
name|basicDateTime
argument_list|()
decl_stmt|;
comment|/**      * The default parser for {@link DataTypeEnum#DateTime}.<p>      * This parser not confirm to xsd:dateTime - that requires both date and time      * to be present - however the parsed value will be the beginning of the      * period (e.g. 2010-05-05 will be parsed to 2010-05-05T00:00:00.000Z).      * This is usually the intension of users that uses dateTimes with a missing      * time. One can parse<code>strict=true</code> to use the      * {@link #XML_DATE_TIME_PARSER_STRICT} instead.      */
specifier|protected
specifier|static
specifier|final
name|DateTimeFormatter
name|XML_DATE_TIME_PARSER
init|=
name|ISODateTimeFormat
operator|.
name|dateOptionalTimeParser
argument_list|()
decl_stmt|;
comment|/**      * Used to parse dateTime, date or time from a string<p>      * Based on the documentation of JodaTime this accepts all possible XML DateTimes      *<code><pre>      *      datetime          = time | date-opt-time      *     time              = 'T' time-element [offset]      *     date-opt-time     = date-element ['T' [time-element] [offset]]      *     date-element      = std-date-element | ord-date-element | week-date-element      *     std-date-element  = yyyy ['-' MM ['-' dd]]      *     ord-date-element  = yyyy ['-' DDD]      *     week-date-element = xxxx '-W' ww ['-' e]      *     time-element      = HH [minute-element] | [fraction]      *     minute-element    = ':' mm [second-element] | [fraction]      *     second-element    = ':' ss [fraction]      *     fraction          = ('.' | ',') digit+      *     offset            = 'Z' | (('+' | '-') HH [':' mm [':' ss [('.' | ',') SSS]]])      *<pre><code>      */
specifier|protected
specifier|static
specifier|final
name|DateTimeFormatter
name|XML_DATE_TIME_OR_DATE_OR_TIME_PARSER
init|=
name|ISODateTimeFormat
operator|.
name|dateTimeParser
argument_list|()
decl_stmt|;
comment|/**      * Used to encode XML DateTime strings without milliseconds with UTC time zone.<p>      * This can be use full if writing MPEG-7 times, because this std. uses a      * Format that allows fractions other than milliseconds      */
specifier|protected
specifier|static
specifier|final
name|DateTimeFormatter
name|XML_DATE_TIME_FORMAT_noMillis
init|=
name|ISODateTimeFormat
operator|.
name|dateTimeNoMillis
argument_list|()
operator|.
name|withZone
argument_list|(
name|DateTimeZone
operator|.
name|UTC
argument_list|)
decl_stmt|;
comment|/**      * used to encode XML Time string with UTC time zone as used by      * {@link DataTypeEnum#Time}      */
specifier|protected
specifier|static
specifier|final
name|DateTimeFormatter
name|XML_TIME_FORMAT
init|=
name|ISODateTimeFormat
operator|.
name|time
argument_list|()
operator|.
name|withZone
argument_list|(
name|DateTimeZone
operator|.
name|UTC
argument_list|)
decl_stmt|;
comment|/**      * Used to parse String claiming to be of type {@link DataTypeEnum#Time}<p>      * Based on the Joda Time documentation this parser accepts:      *<code><pre>      *   time           = ['T'] time-element [offset]      *   time-element   = HH [minute-element] | [fraction]      *   minute-element = ':' mm [second-element] | [fraction]      *   second-element = ':' ss [fraction]      *   fraction       = ('.' | ',') digit+      *   offset         = 'Z' | (('+' | '-') HH [':' mm [':' ss [('.' | ',') SSS]]])      *</pre><code>      */
specifier|protected
specifier|static
specifier|final
name|DateTimeFormatter
name|XML_TIME_PARSER
init|=
name|ISODateTimeFormat
operator|.
name|timeParser
argument_list|()
decl_stmt|;
comment|/**      * used to encode XML Date strings with UTC time zone as used by      * {@link DataTypeEnum#Date};      */
specifier|protected
specifier|static
specifier|final
name|DateTimeFormatter
name|XML_DATE_FORMAT
init|=
name|ISODateTimeFormat
operator|.
name|date
argument_list|()
operator|.
name|withZone
argument_list|(
name|DateTimeZone
operator|.
name|UTC
argument_list|)
decl_stmt|;
comment|/**      * Used to parse String claiming to be of type {@link DataTypeEnum#Date}<p>      * Based on the Joda Time documentation this parser accepts:      *<code><pre>      *   date              = date-element ['T' offset]      *   date-element      = std-date-element | ord-date-element | week-date-element      *   std-date-element  = yyyy ['-' MM ['-' dd]]      *   ord-date-element  = yyyy ['-' DDD]      *   week-date-element = xxxx '-W' ww ['-' e]      *   offset            = 'Z' | (('+' | '-') HH [':' mm [':' ss [('.' | ',') SSS]]])      *</pre><code>      */
specifier|protected
specifier|static
specifier|final
name|DateTimeFormatter
name|XML_DATE_PARSER
init|=
name|ISODateTimeFormat
operator|.
name|dateParser
argument_list|()
decl_stmt|;
comment|// TODO Future support for all XML date and time formats
comment|//    protected static final DateTimeFormatter XML_gYear_FORMAT = ISODateTimeFormat.year().withZone(DateTimeZone.UTC);
comment|//    protected static final DateTimeFormatter XML_gYearMonth_FORMAT = ISODateTimeFormat.yearMonth().withZone(DateTimeZone.UTC);
comment|/**      * Lazy initialisation to avoid Exceptions if {@link DatatypeConfigurationException}      * is thrown during initialisation of the Utility class.<p>      */
specifier|private
specifier|static
name|DatatypeFactory
name|__xmlDatatypeFactory
decl_stmt|;
comment|/**      * Inits the {@link #__xmlDatatypeFactory} if not already done.<p>      * @return the XML datatype factory      * @throws IllegalStateException if a {@link DatatypeConfigurationException}      * is encountered during {@link DatatypeFactory#newInstance()}      */
specifier|private
specifier|static
name|DatatypeFactory
name|getXmlDataTypeFactory
parameter_list|()
throws|throws
name|IllegalStateException
block|{
if|if
condition|(
name|__xmlDatatypeFactory
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|__xmlDatatypeFactory
operator|=
name|DatatypeFactory
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DatatypeConfigurationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to instantiate XML Datatype Factory!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|__xmlDatatypeFactory
return|;
block|}
specifier|public
specifier|static
name|String
name|toString
parameter_list|(
name|String
name|dataTypeUri
parameter_list|,
name|Date
name|value
parameter_list|)
block|{
name|DataTypeEnum
name|dataType
init|=
name|DataTypeEnum
operator|.
name|getDataType
argument_list|(
name|dataTypeUri
argument_list|)
decl_stmt|;
if|if
condition|(
name|dataType
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unknown dataType %s"
argument_list|,
name|dataType
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|toString
argument_list|(
name|dataType
argument_list|,
name|value
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|String
name|toString
parameter_list|(
name|DataTypeEnum
name|dataType
parameter_list|,
name|Date
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Date MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|dataType
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed DataType MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|dateOrTimeDataTypes
operator|.
name|contains
argument_list|(
name|dataType
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"The parsed DataType %s is not a date and/or time dataType! Supported dataTypes are %s"
argument_list|,
name|dataType
operator|.
name|getShortName
argument_list|()
argument_list|,
name|dateTimeFormatShortNames
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|DataTypeEnum
operator|.
name|DateTime
operator|==
name|dataType
condition|)
block|{
return|return
name|XML_DATE_TIME_FORMAT
operator|.
name|print
argument_list|(
name|value
operator|.
name|getTime
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|DataTypeEnum
operator|.
name|Time
operator|==
name|dataType
condition|)
block|{
return|return
name|XML_TIME_FORMAT
operator|.
name|print
argument_list|(
name|value
operator|.
name|getTime
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|DataTypeEnum
operator|.
name|Date
operator|==
name|dataType
condition|)
block|{
return|return
name|XML_DATE_FORMAT
operator|.
name|print
argument_list|(
name|value
operator|.
name|getTime
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unsupported but valid Date/Time DataType %s encountered. Pleas report this as a BUG!"
argument_list|,
name|dataType
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|/**      * Converts the parsed value to a Date      * @param dataType the dataType of Date that should be parsed form the parsed value      * @param value the value      * @return the date      * @throws IllegalArgumentException if the parsed value can not be converted to a date      */
specifier|public
specifier|static
name|Date
name|toDate
parameter_list|(
name|String
name|dataTypeUri
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
name|toDate
argument_list|(
name|dataTypeUri
argument_list|,
name|value
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Converts the parsed value to a Date      * @param dataType the dataType of Date that should be parsed form the parsed value      * @param value the value      * @param strict if<code>true</code> than all requirements defined by xsd are      * enforced (e.g. dateTimes without time will throw an exception)      * @return the date      * @throws IllegalArgumentException if the parsed value can not be converted to a date      */
specifier|public
specifier|static
name|Date
name|toDate
parameter_list|(
name|String
name|dataTypeUri
parameter_list|,
name|Object
name|value
parameter_list|,
name|boolean
name|strict
parameter_list|)
block|{
name|DataTypeEnum
name|dataType
init|=
name|DataTypeEnum
operator|.
name|getDataType
argument_list|(
name|dataTypeUri
argument_list|)
decl_stmt|;
if|if
condition|(
name|dataType
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unknown dataType %s"
argument_list|,
name|dataType
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|toDate
argument_list|(
name|dataType
argument_list|,
name|value
argument_list|,
name|strict
argument_list|)
return|;
block|}
comment|/**      * Converts the parsed value to a Date      * @param dataType the dataType of Date that should be parsed form the parsed value      * @param value the value      * @return the date      * @throws IllegalArgumentException if the parsed value can not be converted to a date      */
specifier|public
specifier|static
name|Date
name|toDate
parameter_list|(
name|DataTypeEnum
name|dataType
parameter_list|,
name|Object
name|value
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
return|return
name|toDate
argument_list|(
name|dataType
argument_list|,
name|value
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Converts the parsed value to a Date      * @param dataType the dataType of Date that should be parsed form the parsed value      * @param value the value      * @param strict if<code>true</code> than all requirements defined by xsd are      * enforced (e.g. dateTimes without time will throw an exception)      * @return the date      * @throws IllegalArgumentException if the parsed value can not be converted to a date      */
specifier|public
specifier|static
name|Date
name|toDate
parameter_list|(
name|DataTypeEnum
name|dataType
parameter_list|,
name|Object
name|value
parameter_list|,
name|boolean
name|strict
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|DateTime
name|dateTime
init|=
name|toDateTime
argument_list|(
name|dataType
argument_list|,
name|value
argument_list|,
name|strict
argument_list|)
decl_stmt|;
return|return
name|dateTime
operator|.
name|toDate
argument_list|()
return|;
block|}
comment|/**      * Converts the value to a xml Gregorian calendar by using      * {@link DatatypeFactory#newXMLGregorianCalendar(String)}.      * @param value the value      * @return the parsed instance      * @throws IllegalArgumentException if<code>null</code> is parsed      * @throws IllegalStateException if no {@link DatatypeFactory} could be      * instantiated.      */
specifier|public
specifier|static
name|XMLGregorianCalendar
name|toXMLCal
parameter_list|(
name|Object
name|value
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|IllegalStateException
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed value MUST NOT be NULL!"
argument_list|)
throw|;
block|}
return|return
name|getXmlDataTypeFactory
argument_list|()
operator|.
name|newXMLGregorianCalendar
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|Duration
name|toDuration
parameter_list|(
name|Object
name|value
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|IllegalStateException
block|{
return|return
name|toDuration
argument_list|(
name|value
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|Duration
name|toDuration
parameter_list|(
name|Object
name|value
parameter_list|,
name|boolean
name|nullAsZeroDuration
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|IllegalStateException
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|nullAsZeroDuration
condition|)
block|{
return|return
name|getXmlDataTypeFactory
argument_list|()
operator|.
name|newDuration
argument_list|(
literal|0
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed value MUST NOT be NULL. Parse \"boolean nullAsZeroDuration=true\" to enable creation of zero lenght durations for NULL values!"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
return|return
name|getXmlDataTypeFactory
argument_list|()
operator|.
name|newDuration
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
block|}
specifier|private
specifier|static
name|DateTime
name|toDateTime
parameter_list|(
name|DataTypeEnum
name|dataType
parameter_list|,
name|Object
name|value
parameter_list|,
name|boolean
name|strict
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Date MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|dataType
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed DataType MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|dateOrTimeDataTypes
operator|.
name|contains
argument_list|(
name|dataType
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"The parsed DataType %s is not a date and/or time dataType! Supported dataTypes are %s"
argument_list|,
name|dataType
operator|.
name|getShortName
argument_list|()
argument_list|,
name|dateTimeFormatShortNames
argument_list|)
argument_list|)
throw|;
block|}
specifier|final
name|DateTime
name|dateTime
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Date
condition|)
block|{
comment|//NOTE: returns a valid date for non date dataTypes
name|dateTime
operator|=
operator|new
name|DateTime
argument_list|(
operator|(
operator|(
name|Date
operator|)
name|value
operator|)
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|DateTime
condition|)
block|{
comment|//NOTE: returns a valid date for non date dataTypes
name|dateTime
operator|=
operator|(
name|DateTime
operator|)
name|value
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|DataTypeEnum
operator|.
name|DateTime
operator|==
name|dataType
condition|)
block|{
if|if
condition|(
name|strict
condition|)
block|{
name|dateTime
operator|=
name|XML_DATE_TIME_PARSER_STRICT
operator|.
name|parseDateTime
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dateTime
operator|=
name|XML_DATE_TIME_PARSER
operator|.
name|parseDateTime
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|DataTypeEnum
operator|.
name|Time
operator|==
name|dataType
condition|)
block|{
name|dateTime
operator|=
name|XML_TIME_PARSER
operator|.
name|parseDateTime
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DataTypeEnum
operator|.
name|Date
operator|==
name|dataType
condition|)
block|{
name|dateTime
operator|=
name|XML_DATE_PARSER
operator|.
name|parseDateTime
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|strValue
init|=
name|value
operator|.
name|toString
argument_list|()
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unsupported but valid Date/Time DataType %s encountered. Pleas report this as a BUG!"
argument_list|,
name|dataType
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Try to use the generic dateTime-or-Time-or-Date parser as fallback for unsupported but valid Date/Time DataType %s and value %s"
argument_list|,
name|dataType
argument_list|,
name|strValue
argument_list|)
argument_list|)
expr_stmt|;
name|dateTime
operator|=
name|XML_DATE_TIME_OR_DATE_OR_TIME_PARSER
operator|.
name|parseDateTime
argument_list|(
name|strValue
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|dateTime
return|;
block|}
block|}
end_class

end_unit

