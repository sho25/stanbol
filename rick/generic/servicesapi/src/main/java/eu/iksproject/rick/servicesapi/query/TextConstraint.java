begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
package|package
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|servicesapi
operator|.
name|query
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_class
specifier|public
class|class
name|TextConstraint
extends|extends
name|Constraint
block|{
specifier|public
specifier|static
enum|enum
name|PatternType
block|{
comment|/** 		 * Simple checks if the parsed constraint equals the value 		 */
name|none
block|,
comment|/** 		 * All kind of REGEX Patterns 		 */
name|regex
block|,
comment|/** 		 * WildCard based queries using * and ? 		 */
name|wildcard
comment|//TODO maybe add Prefix as additional type
block|}
specifier|private
specifier|final
name|PatternType
name|wildcardType
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|languages
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|caseSensitive
decl_stmt|;
specifier|private
specifier|final
name|String
name|text
decl_stmt|;
comment|/** 	 * Creates a TextConstraint for a text and languages.  	 * @param text the text or<code>null</code> to search for any text in active languages 	 * @param languages the set of active languages. 	 */
specifier|public
name|TextConstraint
parameter_list|(
name|String
name|text
parameter_list|,
name|String
modifier|...
name|languages
parameter_list|)
block|{
name|this
argument_list|(
name|text
argument_list|,
name|PatternType
operator|.
name|none
argument_list|,
literal|false
argument_list|,
name|languages
argument_list|)
expr_stmt|;
block|}
specifier|public
name|TextConstraint
parameter_list|(
name|String
name|text
parameter_list|,
name|boolean
name|caseSensitive
parameter_list|,
name|String
modifier|...
name|languages
parameter_list|)
block|{
name|this
argument_list|(
name|text
argument_list|,
name|PatternType
operator|.
name|none
argument_list|,
name|caseSensitive
argument_list|,
name|languages
argument_list|)
expr_stmt|;
block|}
specifier|public
name|TextConstraint
parameter_list|(
name|String
name|text
parameter_list|,
name|PatternType
name|wildcardType
parameter_list|,
name|boolean
name|caseSensitive
parameter_list|,
name|String
modifier|...
name|languages
parameter_list|)
block|{
name|super
argument_list|(
name|ConstraintType
operator|.
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|text
operator|==
literal|null
operator|||
name|text
operator|.
name|isEmpty
argument_list|()
operator|)
operator|&&
operator|(
name|languages
operator|==
literal|null
operator|||
name|languages
operator|.
name|length
operator|<
literal|1
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Text Constraint MUST define a non empty text OR a non empty list of language constraints"
argument_list|)
throw|;
block|}
name|this
operator|.
name|text
operator|=
name|text
expr_stmt|;
if|if
condition|(
name|wildcardType
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|wildcardType
operator|=
name|PatternType
operator|.
name|none
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|wildcardType
operator|=
name|wildcardType
expr_stmt|;
block|}
if|if
condition|(
name|languages
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|languages
operator|=
name|Collections
operator|.
name|emptySet
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Implementation NOTE: 			 *   We need to use a LinkedHashSet here to 			 *    1) ensure that there are no duplicates and 			 *    2) ensure ordering of the parsed constraints 			 *   Both is important: Duplicates might result in necessary calculations 			 *   and ordering might be important for users that expect that the  			 *   language parsed first is used as the preferred one 			 */
name|this
operator|.
name|languages
operator|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
operator|new
name|LinkedHashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|languages
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|caseSensitive
operator|=
name|caseSensitive
expr_stmt|;
block|}
comment|/** 	 * @return the wildcardType 	 */
specifier|public
specifier|final
name|PatternType
name|getPatternType
parameter_list|()
block|{
return|return
name|wildcardType
return|;
block|}
comment|/** 	 * @return the languages 	 */
specifier|public
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|getLanguages
parameter_list|()
block|{
return|return
name|languages
return|;
block|}
comment|/** 	 * @return the caseSensitive 	 */
specifier|public
specifier|final
name|boolean
name|isCaseSensitive
parameter_list|()
block|{
return|return
name|caseSensitive
return|;
block|}
comment|/** 	 * @return the text 	 */
specifier|public
specifier|final
name|String
name|getText
parameter_list|()
block|{
return|return
name|text
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"TextConstraint[value=%s|%s|case %sensitive|languages:%s]"
argument_list|,
name|text
argument_list|,
name|wildcardType
operator|.
name|name
argument_list|()
argument_list|,
name|caseSensitive
condition|?
literal|""
else|:
literal|"in"
argument_list|,
name|languages
argument_list|)
return|;
block|}
block|}
end_class

end_unit

