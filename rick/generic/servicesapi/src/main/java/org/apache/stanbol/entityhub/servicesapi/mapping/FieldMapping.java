begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|mapping
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Representation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|Constraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|TextConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|util
operator|.
name|PatternUtils
import|;
end_import

begin_comment
comment|/**  * A FieldMapping consisting of<ul>  *<li> a required field pattern that is matched against source field. Wildcards  *      can be used to define such patterns (e.g. http://myOntology.com/* to match  *      all properties defined within this Ontology)  *<li> a constraint that is used to filter values of the source field  *<li> a set of mappings (target field names) to copy the filtered values to. If  *      this set contains a<code>null</code> value, than a field with the same  *      name as the source field is created for the source.  *</ul>  * Note that a Filter with the pattern '*' no constraint and only an<code>null</code>  * value as mapping would create a 1:1 copy of the source.  * TODO: Is it OK to keep an actual implementation in the Service API package?  * @author Rupert Westenthaler  *  */
end_comment

begin_class
specifier|public
class|class
name|FieldMapping
block|{
specifier|protected
specifier|final
name|String
name|pattern
decl_stmt|;
specifier|protected
specifier|final
name|Pattern
name|regex
decl_stmt|;
specifier|protected
specifier|final
name|boolean
name|usesWildcard
decl_stmt|;
specifier|protected
name|Set
argument_list|<
name|String
argument_list|>
name|mappings
decl_stmt|;
specifier|protected
name|Constraint
name|filter
decl_stmt|;
specifier|protected
specifier|final
name|boolean
name|inverse
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|global
decl_stmt|;
comment|/**      * Returns<code>true</code> if fields that match the pattern are ignored.      * This is can only be the case if no Filter is defined ({@link #getFilter()}      * returns<code>null</code>).      * @return the ignore field state      */
specifier|public
specifier|final
name|boolean
name|ignoreField
parameter_list|()
block|{
return|return
name|inverse
operator|&&
name|filter
operator|==
literal|null
return|;
block|}
comment|/**      * Creates a FieldMapping that matches all fields but does not map any field.      * However it applies the filter to all other mappings if there is no more      * specific Filter applied.      * @param globalFilter The global filter. Typically a {@link TextConstraint}.      * @throws IllegalArgumentException if the parsed Filter is<code>null</code>      */
specifier|public
name|FieldMapping
parameter_list|(
name|Constraint
name|globalFilter
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|this
argument_list|(
literal|null
argument_list|,
literal|false
argument_list|,
name|globalFilter
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates an 1:1 mapping for all values of fields that confirm the the      * defined pattern.<p>      * NOTE<ul>      *<li> mappings are ignored if the fieldPattern uses a wildcard      *<li> parsing<code>null</code> as fieldPattern matches any field, but does      *      not map anything. This can be used to define global language filters-      *</ul>      * @param fieldPattern the pattern (typically the names pace followed by an *)      * @param mappedTo the list of target fields (if the mappings contain<code>null</code>      *    filtered values of the current field in the source {@link Representation}      *    are copied to the same field name in the target {@link Representation}.      * @throws IllegalArgumentException if<code>null</code> or an empty string is parsed as pattern      */
specifier|public
name|FieldMapping
parameter_list|(
name|String
name|fieldPattern
parameter_list|,
name|String
modifier|...
name|mappedTo
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|this
argument_list|(
name|fieldPattern
argument_list|,
literal|null
argument_list|,
name|mappedTo
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a Mapping the maps (<code>ignore = false)</code>) or ignores (      *<code>ignore = true</code>) fields that match the defined pattern.      * @param fieldPattern the pattern used to match field names      * @param ignoreField if<code>false</code> (the default) than fields that match      *   the parsed pattern are processed. If<code>true</code> than fields that      *   match the pattern are ignored.      * @param mappedTo the list of target fields (if the mappings contain<code>null</code>      *    filtered values of the current field in the source {@link Representation}      *    are copied to the same field name in the target {@link Representation}.      * @throws IllegalArgumentException if<code>null</code> or an empty string is parsed as pattern      */
specifier|public
name|FieldMapping
parameter_list|(
name|String
name|fieldPattern
parameter_list|,
name|boolean
name|ignoreField
parameter_list|,
name|String
modifier|...
name|mappedTo
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|this
argument_list|(
name|fieldPattern
argument_list|,
name|ignoreField
argument_list|,
literal|null
argument_list|,
name|mappedTo
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates an mapping based on the parsed parameter      * @param fieldPattern the pattern used to select fields of the source representation      * @param filter the constraint used to filter values of selected fields      * @param mappedTo the list of target fields (if the mappings contain<code>null</code>      *    filtered values of the current field in the source {@link Representation}      *    are copied to the same field name in the target {@link Representation}.      * @throws IllegalArgumentException if<code>null</code> or an empty string is parsed as pattern      */
specifier|public
name|FieldMapping
parameter_list|(
name|String
name|fieldPattern
parameter_list|,
name|Constraint
name|filter
parameter_list|,
name|String
modifier|...
name|mappedTo
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|this
argument_list|(
name|fieldPattern
argument_list|,
literal|false
argument_list|,
name|filter
argument_list|,
name|mappedTo
argument_list|)
expr_stmt|;
block|}
comment|/**      * Private internal constructor that does all the initialisation stuff. This      * is private because some combinations would not result in valid mappings!      * The public constructors can only create valid field mappings.      * See documentation of the public variants!      */
specifier|private
name|FieldMapping
parameter_list|(
name|String
name|fieldPattern
parameter_list|,
name|boolean
name|ignore
parameter_list|,
name|Constraint
name|filter
parameter_list|,
name|String
modifier|...
name|mappedTo
parameter_list|)
block|{
if|if
condition|(
name|fieldPattern
operator|==
literal|null
operator|||
name|fieldPattern
operator|.
name|length
argument_list|()
operator|<
literal|1
condition|)
block|{
if|if
condition|(
name|filter
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The Filter MUST NOT be NULL for the global Fieldmapping!"
argument_list|)
throw|;
block|}
name|this
operator|.
name|global
operator|=
literal|true
expr_stmt|;
name|fieldPattern
operator|=
literal|"*"
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|global
operator|=
literal|false
expr_stmt|;
block|}
name|this
operator|.
name|pattern
operator|=
name|fieldPattern
expr_stmt|;
name|this
operator|.
name|inverse
operator|=
name|ignore
expr_stmt|;
comment|//if ignore=true -> filter==null&& mappedTo.lenght==0
if|if
condition|(
name|PatternUtils
operator|.
name|usesWildCard
argument_list|(
name|fieldPattern
argument_list|)
condition|)
block|{
name|this
operator|.
name|regex
operator|=
name|Pattern
operator|.
name|compile
argument_list|(
name|PatternUtils
operator|.
name|wildcardToRegex
argument_list|(
name|fieldPattern
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|usesWildcard
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|regex
operator|=
literal|null
expr_stmt|;
name|usesWildcard
operator|=
literal|false
expr_stmt|;
block|}
name|this
operator|.
name|filter
operator|=
name|filter
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|global
condition|)
block|{
name|mappedTo
operator|=
operator|new
name|String
index|[]
block|{}
expr_stmt|;
comment|//set to empty -> if global than map nothing
block|}
elseif|else
if|if
condition|(
name|this
operator|.
name|usesWildcard
condition|)
block|{
name|mappedTo
operator|=
operator|new
name|String
index|[]
block|{
literal|null
block|}
expr_stmt|;
comment|//wildcard always maps the selected field 1:1
block|}
elseif|else
if|if
condition|(
name|mappedTo
operator|==
literal|null
operator|||
name|mappedTo
operator|.
name|length
operator|<
literal|1
condition|)
block|{
name|mappedTo
operator|=
operator|new
name|String
index|[]
block|{
literal|null
block|}
expr_stmt|;
comment|//if no mapping parse map the field 1:1
block|}
comment|//else used the parsed one
name|this
operator|.
name|mappings
operator|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|mappedTo
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns<code>true</code> if this fieldMapping maps any field. This      * means that the {@link #getFieldPattern()}<code>.equals("*")</code>      * @return if this is a global field mapping      */
specifier|public
specifier|final
name|boolean
name|isGlobal
parameter_list|()
block|{
return|return
name|global
return|;
block|}
comment|/**      * Getter for the RegexPettern representing the parsed wildcard.      * @return The regex pattern or<code>null</code> if this mapping does not      *     use wildcards within the field pattern.      */
specifier|public
specifier|final
name|Pattern
name|getRegexPattern
parameter_list|()
block|{
return|return
name|regex
return|;
block|}
comment|/**      * Returns<code>true</code> if the fieldPattern uses wildcards (? or *)      * @return Returns<code>true</code> if the fieldPattern uses wildcards      */
specifier|public
specifier|final
name|boolean
name|usesWildcard
parameter_list|()
block|{
return|return
name|usesWildcard
return|;
block|}
comment|/**      * The Wildcard Pattern (*,?) used to match field name against.      * @return the pattern      */
specifier|public
name|String
name|getFieldPattern
parameter_list|()
block|{
return|return
name|pattern
return|;
block|}
comment|/**      * The target fields values of the source fields are copied to      * @return the target fields      */
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getMappings
parameter_list|()
block|{
return|return
name|mappings
return|;
block|}
comment|/**      * The constraint used to filter values of the source field      * @return the constraint used to filter values of the source field      */
specifier|public
name|Constraint
name|getFilter
parameter_list|()
block|{
return|return
name|filter
return|;
block|}
comment|/**      * Setter for the filter used for values. If<code>null</code> is parsed      * the filter is removed.      * @param constraint the constraint or<code>null</code> to deactivate any      *     filtering.      */
specifier|public
name|void
name|setFilter
parameter_list|(
name|Constraint
name|constraint
parameter_list|)
block|{
name|this
operator|.
name|filter
operator|=
name|constraint
expr_stmt|;
block|}
comment|/**      * Removes any specified filter      */
specifier|public
name|void
name|removeFilter
parameter_list|()
block|{
name|setFilter
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Adds a mapping      * @param mapping the Mapping (use<code>null</code> to configure a 1:1 Mapping)      */
specifier|public
name|void
name|addMapping
parameter_list|(
name|String
name|mapping
parameter_list|)
block|{
name|mappings
operator|.
name|add
argument_list|(
name|mapping
argument_list|)
expr_stmt|;
block|}
comment|/**      * Removes the mapping from the list. Please note, that if the last mapping      * is removed, the<code>null</code> mapping is added to the list to preserve      * the default 1:1 mapping.      * @param mapping The mapping to remove      */
specifier|public
name|void
name|removeMapping
parameter_list|(
name|String
name|mapping
parameter_list|)
block|{
if|if
condition|(
name|mappings
operator|.
name|remove
argument_list|(
name|mapping
argument_list|)
operator|&&
name|mappings
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|mappings
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|//if the last element is removed add null to
comment|//preserve the 1:1 mapping
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|inverse
condition|?
literal|"!"
else|:
literal|""
operator|+
name|pattern
operator|+
operator|(
name|filter
operator|!=
literal|null
condition|?
literal|" | "
operator|+
name|filter
else|:
literal|""
operator|)
operator|+
literal|"> "
operator|+
name|mappings
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|pattern
operator|.
name|hashCode
argument_list|()
operator|+
name|mappings
operator|.
name|hashCode
argument_list|()
operator|+
operator|(
name|inverse
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
name|filter
operator|!=
literal|null
condition|?
name|filter
operator|.
name|hashCode
argument_list|()
else|:
literal|0
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
return|return
name|obj
operator|!=
literal|null
operator|&&
comment|//not null
name|obj
operator|instanceof
name|FieldMapping
operator|&&
comment|// check type
operator|(
operator|(
name|FieldMapping
operator|)
name|obj
operator|)
operator|.
name|pattern
operator|.
name|equals
argument_list|(
name|pattern
argument_list|)
operator|&&
comment|//check field pattern
operator|(
operator|(
name|FieldMapping
operator|)
name|obj
operator|)
operator|.
name|inverse
operator|==
name|inverse
operator|&&
comment|//check inverse
operator|(
operator|(
name|FieldMapping
operator|)
name|obj
operator|)
operator|.
name|mappings
operator|.
name|equals
argument_list|(
name|mappings
argument_list|)
operator|&&
comment|//check mappings
operator|(
comment|//check the optional value filter
operator|(
operator|(
operator|(
name|FieldMapping
operator|)
name|obj
operator|)
operator|.
name|filter
operator|==
literal|null
operator|&&
name|filter
operator|==
literal|null
operator|)
operator|||
operator|(
operator|(
operator|(
name|FieldMapping
operator|)
name|obj
operator|)
operator|.
name|filter
operator|!=
literal|null
operator|&&
operator|(
operator|(
name|FieldMapping
operator|)
name|obj
operator|)
operator|.
name|filter
operator|.
name|equals
argument_list|(
name|filter
argument_list|)
operator|)
operator|)
return|;
block|}
block|}
end_class

end_unit

