begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
package|package
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|clerezza
operator|.
name|impl
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Graph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|MGraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|TripleCollection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|UriRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|access
operator|.
name|LockableMGraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|access
operator|.
name|NoSuchEntityException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|access
operator|.
name|TcManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|impl
operator|.
name|SimpleMGraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|sparql
operator|.
name|ParseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|sparql
operator|.
name|QueryParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|sparql
operator|.
name|ResultSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|sparql
operator|.
name|SolutionMapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|sparql
operator|.
name|query
operator|.
name|Query
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|sparql
operator|.
name|query
operator|.
name|SelectQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|ontologies
operator|.
name|RDF
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|utils
operator|.
name|GraphNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Activate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Component
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|ConfigurationPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Deactivate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Reference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Service
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|service
operator|.
name|cm
operator|.
name|ConfigurationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|service
operator|.
name|component
operator|.
name|ComponentContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|core
operator|.
name|query
operator|.
name|QueryResultListImpl
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|core
operator|.
name|query
operator|.
name|QueryUtils
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|core
operator|.
name|utils
operator|.
name|AdaptingIterator
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|core
operator|.
name|yard
operator|.
name|AbstractYard
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|core
operator|.
name|yard
operator|.
name|DefaultYardConfig
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|model
operator|.
name|clerezza
operator|.
name|RdfRepresentation
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|model
operator|.
name|clerezza
operator|.
name|RdfValueFactory
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|model
operator|.
name|clerezza
operator|.
name|utils
operator|.
name|Resource2StringAdapter
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|query
operator|.
name|clerezza
operator|.
name|RdfQueryResultList
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|query
operator|.
name|clerezza
operator|.
name|SparqlFieldQuery
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|query
operator|.
name|clerezza
operator|.
name|SparqlFieldQueryFactory
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|query
operator|.
name|clerezza
operator|.
name|SparqlQueryUtils
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|query
operator|.
name|clerezza
operator|.
name|SparqlQueryUtils
operator|.
name|EndpointTypeEnum
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Representation
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|rdf
operator|.
name|RdfResourceEnum
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|FieldQuery
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|QueryResultList
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|servicesapi
operator|.
name|yard
operator|.
name|Yard
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|servicesapi
operator|.
name|yard
operator|.
name|YardException
import|;
end_import

begin_comment
comment|/**  * Implementation of the Yard Interface based on a RDF Triple Store. This  * Implementation uses Clerezza as RDF Framework. The actual Triple Store used  * to store the data depends on the configuration of Clerezza.<p>  * This implementation uses {@link LockableMGraph} interface for write locks  * when updating the graph. SPARQL queries are not within a write lock.<p>  *  * @author Rupert Westenthaler  *  */
end_comment

begin_class
annotation|@
name|Component
argument_list|(
comment|//name="eu.iksproject.rick.yard.clerezzaYard",
comment|//factory="eu.iksproject.rick.yard.clerezzaYardFactory",
name|configurationFactory
operator|=
literal|true
argument_list|,
name|policy
operator|=
name|ConfigurationPolicy
operator|.
name|REQUIRE
argument_list|,
comment|//the ID is required!
name|specVersion
operator|=
literal|"1.1"
argument_list|,
name|metatype
operator|=
literal|true
argument_list|)
annotation|@
name|Service
comment|//@Properties(value={
comment|//        @Property(name=Yard.ID,value="rickYard"),
comment|//        @Property(name=Yard.NAME,value="Rick Yard"),
comment|//        @Property(name=Yard.DESCRIPTION,value="Default values for configuring the RickYard without editing")
comment|//})
specifier|public
class|class
name|ClerezzaYard
extends|extends
name|AbstractYard
implements|implements
name|Yard
block|{
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ClerezzaYard
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|YARD_URI_PREFIX
init|=
literal|"urn:eu.iksproject:rick.yard:rdf.clerezza:"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|UriRef
name|REPRESENTATION
init|=
operator|new
name|UriRef
argument_list|(
name|RdfResourceEnum
operator|.
name|Representation
operator|.
name|getUri
argument_list|()
argument_list|)
decl_stmt|;
comment|/**      * This property is used to check if a URI in the graph represents a representation by      * calling {@link TripleCollection#filter(org.apache.clerezza.rdf.core.NonLiteral, UriRef, Resource)}      * with the reuqested ID as subject, this {@link UriRef} as property and      *<code>null</code> as value.<p>      * This is the easiest way to do that, because each representation MUST HAVE      * a rick:label. If this is requirements is changed in future, than the code      * using this property MUST BE changed accordingly!      */
specifier|private
specifier|static
name|UriRef
name|RICK_LABEL_URIREF
init|=
operator|new
name|UriRef
argument_list|(
name|RdfResourceEnum
operator|.
name|label
operator|.
name|getUri
argument_list|()
argument_list|)
decl_stmt|;
comment|//    protected ComponentContext context;
comment|//    protected Dictionary<String,?> properties;
annotation|@
name|Reference
specifier|private
name|TcManager
name|tcManager
decl_stmt|;
specifier|private
name|UriRef
name|yardGraphUri
decl_stmt|;
specifier|private
name|LockableMGraph
name|graph
decl_stmt|;
specifier|public
name|ClerezzaYard
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
specifier|public
name|ClerezzaYard
parameter_list|(
name|String
name|yardId
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Activate
specifier|protected
name|void
name|activate
parameter_list|(
name|ComponentContext
name|context
parameter_list|)
throws|throws
name|ConfigurationException
block|{
name|log
operator|.
name|info
argument_list|(
literal|"in "
operator|+
name|ClerezzaYard
operator|.
name|class
operator|+
literal|" activate with context "
operator|+
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|==
literal|null
operator|||
name|context
operator|.
name|getProperties
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"No valid"
operator|+
name|ComponentContext
operator|.
name|class
operator|+
literal|" parsed in activate!"
argument_list|)
throw|;
block|}
name|activate
argument_list|(
operator|new
name|DefaultYardConfig
argument_list|(
name|context
operator|.
name|getProperties
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|protected
specifier|final
name|void
name|activate
parameter_list|(
name|YardConfig
name|config
parameter_list|)
throws|throws
name|ConfigurationException
throws|,
name|IllegalArgumentException
block|{
name|super
operator|.
name|activate
argument_list|(
name|RdfValueFactory
operator|.
name|getInstance
argument_list|()
argument_list|,
name|SparqlFieldQueryFactory
operator|.
name|getInstance
argument_list|()
argument_list|,
name|config
argument_list|)
expr_stmt|;
name|this
operator|.
name|yardGraphUri
operator|=
operator|new
name|UriRef
argument_list|(
name|YARD_URI_PREFIX
operator|+
name|config
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|this
operator|.
name|graph
operator|=
name|tcManager
operator|.
name|getMGraph
argument_list|(
name|yardGraphUri
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"  ... (re)use existing Graph "
operator|+
name|yardGraphUri
operator|+
literal|" for Yard "
operator|+
name|config
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchEntityException
name|e
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"   ... create new Graph "
operator|+
name|yardGraphUri
operator|+
literal|" for Yard "
operator|+
name|config
operator|.
name|getName
argument_list|()
operator|+
literal|"!"
argument_list|)
expr_stmt|;
name|this
operator|.
name|graph
operator|=
name|tcManager
operator|.
name|createMGraph
argument_list|(
name|yardGraphUri
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Deactivate
specifier|protected
name|void
name|deactivate
parameter_list|(
name|ComponentContext
name|context
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"in "
operator|+
name|ClerezzaYard
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" deactivate with context "
operator|+
name|context
argument_list|)
expr_stmt|;
name|this
operator|.
name|yardGraphUri
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|graph
operator|=
literal|null
expr_stmt|;
name|super
operator|.
name|deactivate
argument_list|()
expr_stmt|;
block|}
comment|/**      * Getter for the URI used for the named graph. The returned value is      * {@link #YARD_URI_PREFIX}+{@link #getId()}.      * @return the URI used for the RDF graph that stores all the data of this      * yard.      */
specifier|public
name|String
name|getYardGraphUri
parameter_list|()
block|{
return|return
name|yardGraphUri
operator|.
name|getUnicodeString
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Representation
name|getRepresentation
parameter_list|(
name|String
name|id
parameter_list|)
block|{
if|if
condition|(
name|id
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|getRepresentation
argument_list|(
operator|new
name|UriRef
argument_list|(
name|id
argument_list|)
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Internally used to create Representations for URIs      * @param uri the uri      * @param check if<code>false</code> than there is no check if the URI      *     refers to a Resource in the graph that is of type {@link #REPRESENTATION}      * @return the Representation      */
specifier|protected
name|Representation
name|getRepresentation
parameter_list|(
name|UriRef
name|uri
parameter_list|,
name|boolean
name|check
parameter_list|)
block|{
if|if
condition|(
operator|!
name|check
operator|||
name|graph
operator|.
name|filter
argument_list|(
name|uri
argument_list|,
name|RICK_LABEL_URIREF
argument_list|,
literal|null
argument_list|)
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|/*              * We need to use an own graph for the Representation, because              * changes to the Representation should not be reflected in the              * Yard until a store() or update().              * Currently the GraphNode.getNodeContext() functionality is used              * to calculate the graph included for the Representation.              */
name|GraphNode
name|node
init|=
operator|new
name|GraphNode
argument_list|(
name|uri
argument_list|,
name|graph
argument_list|)
decl_stmt|;
comment|//create a changeable graph for the representation, because
comment|//node.getNodeContext returns an immutable Graph!
name|MGraph
name|nodeGraph
init|=
operator|new
name|SimpleMGraph
argument_list|(
name|node
operator|.
name|getNodeContext
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|RdfValueFactory
operator|)
name|valueFactory
operator|)
operator|.
name|createRdfRepresentation
argument_list|(
name|uri
argument_list|,
name|nodeGraph
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
comment|//not found
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isRepresentation
parameter_list|(
name|String
name|id
parameter_list|)
block|{
return|return
name|id
operator|!=
literal|null
condition|?
name|graph
operator|.
name|filter
argument_list|(
operator|new
name|UriRef
argument_list|(
name|id
argument_list|)
argument_list|,
name|RICK_LABEL_URIREF
argument_list|,
literal|null
argument_list|)
operator|.
name|hasNext
argument_list|()
else|:
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|(
name|String
name|id
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
name|id
operator|==
literal|null
condition|)
return|return;
name|UriRef
name|resource
init|=
operator|new
name|UriRef
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|Lock
name|writeLock
init|=
name|graph
operator|.
name|getLock
argument_list|()
operator|.
name|writeLock
argument_list|()
decl_stmt|;
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|graph
operator|.
name|filter
argument_list|(
name|resource
argument_list|,
name|RDF
operator|.
name|type
argument_list|,
name|REPRESENTATION
argument_list|)
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|GraphNode
name|node
init|=
operator|new
name|GraphNode
argument_list|(
name|resource
argument_list|,
name|graph
argument_list|)
decl_stmt|;
comment|/*                  * Currently the "context" of the Clerezza GraphNode implementation                  * is used for CRUD operations on Representations.                  * This includes incoming and outgoing relations the resource and                  * recursively bNodes.                  */
name|node
operator|.
name|deleteNodeContext
argument_list|()
expr_stmt|;
block|}
comment|//else not found  -> nothing to do
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|(
name|Iterable
argument_list|<
name|String
argument_list|>
name|ids
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|YardException
block|{
if|if
condition|(
name|ids
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Iterable over the IDs to remove MUST NOT be NULL!"
argument_list|)
throw|;
block|}
for|for
control|(
name|String
name|id
range|:
name|ids
control|)
block|{
name|remove
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Representation
name|store
parameter_list|(
name|Representation
name|representation
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|YardException
block|{
return|return
name|store
argument_list|(
name|representation
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Iterable
argument_list|<
name|Representation
argument_list|>
name|store
parameter_list|(
name|Iterable
argument_list|<
name|Representation
argument_list|>
name|representations
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|YardException
block|{
if|if
condition|(
name|representations
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Iterable over the Representations to store MUST NOT be NULL!"
argument_list|)
throw|;
block|}
return|return
name|store
argument_list|(
name|representations
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Representation
name|update
parameter_list|(
name|Representation
name|representation
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|YardException
block|{
return|return
name|store
argument_list|(
name|representation
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Iterable
argument_list|<
name|Representation
argument_list|>
name|update
parameter_list|(
name|Iterable
argument_list|<
name|Representation
argument_list|>
name|representations
parameter_list|)
throws|throws
name|YardException
throws|,
name|IllegalArgumentException
block|{
if|if
condition|(
name|representations
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Iterable over the Representations to update MUST NOT be NULL!"
argument_list|)
throw|;
block|}
return|return
name|store
argument_list|(
name|representations
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|protected
specifier|final
name|Iterable
argument_list|<
name|Representation
argument_list|>
name|store
parameter_list|(
name|Iterable
argument_list|<
name|Representation
argument_list|>
name|representations
parameter_list|,
name|boolean
name|allowCreate
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|YardException
block|{
name|ArrayList
argument_list|<
name|Representation
argument_list|>
name|added
init|=
operator|new
name|ArrayList
argument_list|<
name|Representation
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Representation
name|representation
range|:
name|representations
control|)
block|{
name|added
operator|.
name|add
argument_list|(
name|store
argument_list|(
name|representation
argument_list|,
name|allowCreate
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|added
return|;
block|}
specifier|protected
specifier|final
name|Representation
name|store
parameter_list|(
name|Representation
name|representation
parameter_list|,
name|boolean
name|allowCreate
parameter_list|,
name|boolean
name|canNotCreateIsError
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|YardException
block|{
name|log
operator|.
name|info
argument_list|(
literal|"store Representation "
operator|+
name|representation
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
comment|//        log.info("> rick size: "+graph.size());
if|if
condition|(
name|representation
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|isRepresentation
argument_list|(
name|representation
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
block|{
comment|//            log.info("> remove previous version");
name|remove
argument_list|(
name|representation
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
comment|//            log.info("> rick size: "+graph.size());
block|}
elseif|else
if|if
condition|(
operator|!
name|allowCreate
condition|)
block|{
if|if
condition|(
name|canNotCreateIsError
condition|)
block|{
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Parsed Representation "
operator|+
name|representation
operator|.
name|getId
argument_list|()
operator|+
literal|" in not managed by this Yard "
operator|+
name|getName
argument_list|()
operator|+
literal|"(id="
operator|+
name|getId
argument_list|()
operator|+
literal|")"
argument_list|)
throw|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|//get the graph for the Representation and add it to the store
name|RdfRepresentation
name|toAdd
init|=
operator|(
operator|(
name|RdfValueFactory
operator|)
name|valueFactory
operator|)
operator|.
name|toRdfRepresentation
argument_list|(
name|representation
argument_list|)
decl_stmt|;
comment|//        log.info("> add "+toAdd.size()+" triples to Yard "+getId());
name|Lock
name|writeLock
init|=
name|graph
operator|.
name|getLock
argument_list|()
operator|.
name|writeLock
argument_list|()
decl_stmt|;
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|graph
operator|.
name|addAll
argument_list|(
name|toAdd
operator|.
name|getRdfGraph
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|//        log.info("> currently "+graph.size()+" triples in Yard "+getId());
return|return
name|toAdd
return|;
block|}
annotation|@
name|Override
specifier|public
name|QueryResultList
argument_list|<
name|String
argument_list|>
name|findReferences
parameter_list|(
name|FieldQuery
name|parsedQuery
parameter_list|)
throws|throws
name|YardException
throws|,
name|IllegalArgumentException
block|{
if|if
condition|(
name|parsedQuery
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed query MUST NOT be NULL!"
argument_list|)
throw|;
block|}
specifier|final
name|SparqlFieldQuery
name|query
init|=
name|SparqlFieldQueryFactory
operator|.
name|getSparqlFieldQuery
argument_list|(
name|parsedQuery
argument_list|)
decl_stmt|;
name|int
name|limit
init|=
name|QueryUtils
operator|.
name|getLimit
argument_list|(
name|query
argument_list|,
name|config
operator|.
name|getDefaultQueryResultNumber
argument_list|()
argument_list|,
name|config
operator|.
name|getMaxQueryResultNumber
argument_list|()
argument_list|)
decl_stmt|;
name|SelectQuery
name|sparqlQuery
decl_stmt|;
name|String
name|sparqlQueryString
init|=
name|SparqlQueryUtils
operator|.
name|createSparqlSelectQuery
argument_list|(
name|query
argument_list|,
literal|false
argument_list|,
name|limit
argument_list|,
name|EndpointTypeEnum
operator|.
name|Standard
argument_list|)
decl_stmt|;
try|try
block|{
name|sparqlQuery
operator|=
operator|(
name|SelectQuery
operator|)
name|QueryParser
operator|.
name|getInstance
argument_list|()
operator|.
name|parse
argument_list|(
name|sparqlQueryString
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"ParseException for SPARQL Query in findRepresentation"
argument_list|)
expr_stmt|;
name|log
operator|.
name|error
argument_list|(
literal|"FieldQuery: "
operator|+
name|query
argument_list|)
expr_stmt|;
name|log
operator|.
name|error
argument_list|(
literal|"SPARQL Query: "
operator|+
name|sparqlQueryString
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to parse SPARQL query generated for the parse FieldQuery"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"ClassCastExeption because parsed SPARQL Query is not of Type "
operator|+
name|SelectQuery
operator|.
name|class
argument_list|)
expr_stmt|;
name|log
operator|.
name|error
argument_list|(
literal|"FieldQuery: "
operator|+
name|query
argument_list|)
expr_stmt|;
name|log
operator|.
name|error
argument_list|(
literal|"SPARQL Query: "
operator|+
name|sparqlQueryString
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to parse SPARQL SELECT query generated for the parse FieldQuery"
argument_list|,
name|e
argument_list|)
throw|;
block|}
specifier|final
name|ResultSet
name|result
init|=
name|tcManager
operator|.
name|executeSparqlQuery
argument_list|(
operator|(
name|SelectQuery
operator|)
name|sparqlQuery
argument_list|,
name|graph
argument_list|)
decl_stmt|;
comment|//A little bit complex construct ...
comment|// first we use the adaptingIterator to convert reseource to string
comment|// to get the resources we have to retrieve the root-variable of the
comment|// Iterator<SolutionMapping> provided by the ResultSet of the SPARQL query
name|Iterator
argument_list|<
name|String
argument_list|>
name|representationIdIterator
init|=
operator|new
name|AdaptingIterator
argument_list|<
name|Resource
argument_list|,
name|String
argument_list|>
argument_list|(
operator|new
name|Iterator
argument_list|<
name|Resource
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|result
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Resource
name|next
parameter_list|()
block|{
return|return
name|result
operator|.
name|next
argument_list|()
operator|.
name|get
argument_list|(
name|query
operator|.
name|getRootVariableName
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|result
operator|.
name|hasNext
argument_list|()
return|;
block|}
block|}
argument_list|,
operator|new
name|Resource2StringAdapter
argument_list|<
name|Resource
argument_list|>
argument_list|()
argument_list|,
name|String
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
operator|new
name|QueryResultListImpl
argument_list|<
name|String
argument_list|>
argument_list|(
name|query
argument_list|,
name|representationIdIterator
argument_list|,
name|String
operator|.
name|class
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|QueryResultList
argument_list|<
name|Representation
argument_list|>
name|findRepresentation
parameter_list|(
name|FieldQuery
name|parsedQuery
parameter_list|)
throws|throws
name|YardException
throws|,
name|IllegalArgumentException
block|{
if|if
condition|(
name|parsedQuery
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed query MUST NOT be NULL!"
argument_list|)
throw|;
block|}
specifier|final
name|SparqlFieldQuery
name|query
init|=
name|SparqlFieldQueryFactory
operator|.
name|getSparqlFieldQuery
argument_list|(
name|parsedQuery
argument_list|)
decl_stmt|;
name|int
name|limit
init|=
name|QueryUtils
operator|.
name|getLimit
argument_list|(
name|query
argument_list|,
name|config
operator|.
name|getDefaultQueryResultNumber
argument_list|()
argument_list|,
name|config
operator|.
name|getMaxQueryResultNumber
argument_list|()
argument_list|)
decl_stmt|;
name|SelectQuery
name|sparqlQuery
decl_stmt|;
name|String
name|sparqlQueryString
init|=
name|SparqlQueryUtils
operator|.
name|createSparqlSelectQuery
argument_list|(
name|query
argument_list|,
literal|false
argument_list|,
name|limit
argument_list|,
name|EndpointTypeEnum
operator|.
name|Standard
argument_list|)
decl_stmt|;
try|try
block|{
name|sparqlQuery
operator|=
operator|(
name|SelectQuery
operator|)
name|QueryParser
operator|.
name|getInstance
argument_list|()
operator|.
name|parse
argument_list|(
name|sparqlQueryString
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"ParseException for SPARQL Query in findRepresentation"
argument_list|)
expr_stmt|;
name|log
operator|.
name|error
argument_list|(
literal|"FieldQuery: "
operator|+
name|query
argument_list|)
expr_stmt|;
name|log
operator|.
name|error
argument_list|(
literal|"SPARQL Query: "
operator|+
name|sparqlQueryString
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to parse SPARQL query generated for the parse FieldQuery"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"ClassCastExeption because parsed SPARQL Query is not of Type "
operator|+
name|SelectQuery
operator|.
name|class
argument_list|)
expr_stmt|;
name|log
operator|.
name|error
argument_list|(
literal|"FieldQuery: "
operator|+
name|query
argument_list|)
expr_stmt|;
name|log
operator|.
name|error
argument_list|(
literal|"SPARQL Query: "
operator|+
name|sparqlQueryString
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to parse SPARQL SELECT query generated for the parse FieldQuery"
argument_list|,
name|e
argument_list|)
throw|;
block|}
specifier|final
name|ResultSet
name|result
init|=
name|tcManager
operator|.
name|executeSparqlQuery
argument_list|(
operator|(
name|SelectQuery
operator|)
name|sparqlQuery
argument_list|,
name|graph
argument_list|)
decl_stmt|;
comment|//Note: An other possibility would be to first iterate over all results and add it to
comment|//      a list and create this Iterator than based on the List. This would
comment|//      be the preferenced way if changes in the graph could affect the
comment|//     Iteration over the SPARQL query results.
name|Iterator
argument_list|<
name|Representation
argument_list|>
name|representationIterator
init|=
operator|new
name|AdaptingIterator
argument_list|<
name|SolutionMapping
argument_list|,
name|Representation
argument_list|>
argument_list|(
name|result
argument_list|,
operator|new
name|AdaptingIterator
operator|.
name|Adapter
argument_list|<
name|SolutionMapping
argument_list|,
name|Representation
argument_list|>
argument_list|()
block|{
comment|/**                      * Adapter that gets the rootVariable of the Query (selecting the ID)                      * and creates a Representation for it.                      * @param solution a solution of the query                      * @param type the type (no generics here)                      * @return the representation or<code>null</code> if result is                      * not an UriRef or there is no Representation for the result.                      */
annotation|@
name|Override
specifier|public
name|Representation
name|adapt
parameter_list|(
name|SolutionMapping
name|solution
parameter_list|,
name|Class
argument_list|<
name|Representation
argument_list|>
name|type
parameter_list|)
block|{
name|Resource
name|resource
init|=
name|solution
operator|.
name|get
argument_list|(
name|query
operator|.
name|getRootVariableName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|resource
operator|!=
literal|null
operator|&&
name|resource
operator|instanceof
name|UriRef
condition|)
block|{
try|try
block|{
return|return
name|getRepresentation
argument_list|(
operator|(
name|UriRef
operator|)
name|resource
argument_list|,
literal|false
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to create Representation for ID "
operator|+
name|resource
operator|+
literal|"! -> ignore query result"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
block|}
argument_list|,
name|Representation
operator|.
name|class
argument_list|)
decl_stmt|;
comment|//NOTE: currently this list iterates in the constructor over all elements
comment|//      of the Iterator. This means, that all the representations are
comment|//      created before the method returns.
return|return
operator|new
name|QueryResultListImpl
argument_list|<
name|Representation
argument_list|>
argument_list|(
name|query
argument_list|,
name|representationIterator
argument_list|,
name|Representation
operator|.
name|class
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|QueryResultList
argument_list|<
name|Representation
argument_list|>
name|find
parameter_list|(
name|FieldQuery
name|parsedQuery
parameter_list|)
throws|throws
name|YardException
throws|,
name|IllegalArgumentException
block|{
if|if
condition|(
name|parsedQuery
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed query MUST NOT be NULL!"
argument_list|)
throw|;
block|}
specifier|final
name|SparqlFieldQuery
name|query
init|=
name|SparqlFieldQueryFactory
operator|.
name|getSparqlFieldQuery
argument_list|(
name|parsedQuery
argument_list|)
decl_stmt|;
name|int
name|limit
init|=
name|QueryUtils
operator|.
name|getLimit
argument_list|(
name|query
argument_list|,
name|config
operator|.
name|getDefaultQueryResultNumber
argument_list|()
argument_list|,
name|config
operator|.
name|getMaxQueryResultNumber
argument_list|()
argument_list|)
decl_stmt|;
name|Query
name|sparqlQuery
decl_stmt|;
comment|//NOTE(s):
comment|// - parse RdfResourceEnum.representationType as additional field, because
comment|//   this info is needed to correctly init the Representations
comment|// - use the endpoint type standard, because we do not know what type of
comment|//   SPARQL implementation is configured for Clerezza via OSGI
name|String
name|sparqlQueryString
init|=
name|SparqlQueryUtils
operator|.
name|createSparqlConstructQuery
argument_list|(
name|query
argument_list|,
name|limit
argument_list|,
name|EndpointTypeEnum
operator|.
name|Standard
argument_list|,
name|RdfResourceEnum
operator|.
name|signType
operator|.
name|getUri
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|sparqlQuery
operator|=
name|QueryParser
operator|.
name|getInstance
argument_list|()
operator|.
name|parse
argument_list|(
name|sparqlQueryString
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"ParseException for SPARQL Query in findRepresentation"
argument_list|)
expr_stmt|;
name|log
operator|.
name|error
argument_list|(
literal|"FieldQuery: "
operator|+
name|query
argument_list|)
expr_stmt|;
name|log
operator|.
name|error
argument_list|(
literal|"SPARQL Query: "
operator|+
name|sparqlQueryString
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to parse SPARQL query generated for the parse FieldQuery"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|Object
name|resultObject
init|=
name|tcManager
operator|.
name|executeSparqlQuery
argument_list|(
name|sparqlQuery
argument_list|,
name|graph
argument_list|)
decl_stmt|;
specifier|final
name|MGraph
name|resultGraph
decl_stmt|;
if|if
condition|(
name|resultObject
operator|instanceof
name|MGraph
condition|)
block|{
name|resultGraph
operator|=
operator|(
name|MGraph
operator|)
name|resultObject
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|resultObject
operator|instanceof
name|Graph
condition|)
block|{
name|resultGraph
operator|=
operator|new
name|SimpleMGraph
argument_list|()
expr_stmt|;
name|resultGraph
operator|.
name|addAll
argument_list|(
operator|(
name|Graph
operator|)
name|resultObject
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Unable to create "
operator|+
name|MGraph
operator|.
name|class
operator|+
literal|" instance for query reults of type "
operator|+
name|resultObject
operator|.
name|getClass
argument_list|()
operator|+
literal|" (this indicates that the used SPARQL Query was not of type CONSTRUCT)"
argument_list|)
expr_stmt|;
name|log
operator|.
name|error
argument_list|(
literal|"FieldQuery: "
operator|+
name|query
argument_list|)
expr_stmt|;
name|log
operator|.
name|error
argument_list|(
literal|"SPARQL Query: "
operator|+
name|sparqlQueryString
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|YardException
argument_list|(
literal|"Unable to process results of Query"
argument_list|)
throw|;
block|}
return|return
operator|new
name|RdfQueryResultList
argument_list|(
name|query
argument_list|,
name|resultGraph
argument_list|)
return|;
block|}
block|}
end_class

end_unit

