begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
package|package
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|impl
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Representation
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|ValueFactory
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|Constraint
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|FieldQuery
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|Query
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|RangeConstraint
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|TextConstraint
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|servicesapi
operator|.
name|query
operator|.
name|ValueConstraint
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|defaults
operator|.
name|IndexDataTypeEnum
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|impl
operator|.
name|constraintEncoders
operator|.
name|AssignmentEncoder
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|impl
operator|.
name|constraintEncoders
operator|.
name|DataTypeEncoder
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|impl
operator|.
name|constraintEncoders
operator|.
name|FieldEncoder
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|impl
operator|.
name|constraintEncoders
operator|.
name|GeEncoder
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|impl
operator|.
name|constraintEncoders
operator|.
name|GtEncoder
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|impl
operator|.
name|constraintEncoders
operator|.
name|LangEncoder
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|impl
operator|.
name|constraintEncoders
operator|.
name|LeEncoder
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|impl
operator|.
name|constraintEncoders
operator|.
name|LtEncoder
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|impl
operator|.
name|constraintEncoders
operator|.
name|RegexEncoder
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|impl
operator|.
name|constraintEncoders
operator|.
name|WildcardEncoder
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|model
operator|.
name|FieldMapper
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|model
operator|.
name|IndexDataType
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|model
operator|.
name|IndexValue
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|model
operator|.
name|IndexValueFactory
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|model
operator|.
name|NoConverterException
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|query
operator|.
name|ConstraintTypePosition
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|query
operator|.
name|EncodedConstraintParts
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|query
operator|.
name|IndexConstraintTypeEncoder
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|query
operator|.
name|IndexConstraintTypeEnum
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|utils
operator|.
name|SolrUtil
import|;
end_import

begin_comment
comment|/**  * This class is responsible of converting the queries used by Rick to  * queries that can be executed via the Solr RESTfull interface.<p>  * For this conversion the {@link IndexValueFactory} and the {@link FieldMapper}  * as used to index the documents in the index must be parsed.<p>  * TODO: This class currently contains the<ul>  *<li> general usable functionality to convert {@link Query} instances to  * the according representation in index constraints (see  * {@link IndexConstraintTypeEnum} and {@link IndexConstraint}  *<li> general usable functionality to combine the constraints to an tree of  * AND and OR constraints  *<li> SolrSpecific configuration of {@link IndexConstraintTypeEncoder}. This  * need to be made generic to allow different encoder implementations for other  * Document Stores  *<li> the Solr Specific encodings of the AND and OR tree  *</ul>  * Splitting such things up in several different components should make it easy  * to add support for other DocumentStores!  *  * @author Rupert Westenthaler  *  */
end_comment

begin_class
specifier|public
class|class
name|SolrQueryFactory
block|{
comment|/**      * Allows to limit the maximum Numbers of Query Results for any kind of Query.      * For now it is set to 1024.      */
specifier|public
specifier|static
specifier|final
name|Integer
name|MAX_QUERY_RESULTS
init|=
literal|1024
decl_stmt|;
comment|/**      * The default limit of results for queries      */
specifier|public
specifier|static
specifier|final
name|Integer
name|DEFAULT_QUERY_RESULTS
init|=
literal|10
decl_stmt|;
specifier|protected
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SolrQueryFactory
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|FieldMapper
name|fieldMapper
decl_stmt|;
specifier|private
specifier|final
name|IndexValueFactory
name|indexValueFactory
decl_stmt|;
specifier|private
specifier|final
name|ValueFactory
name|valueFactory
decl_stmt|;
specifier|protected
specifier|final
name|Map
argument_list|<
name|IndexConstraintTypeEnum
argument_list|,
name|IndexConstraintTypeEncoder
argument_list|<
name|?
argument_list|>
argument_list|>
name|constraintEncoders
decl_stmt|;
specifier|protected
name|String
name|domain
decl_stmt|;
specifier|protected
name|Integer
name|maxQueryResults
init|=
name|MAX_QUERY_RESULTS
decl_stmt|;
specifier|protected
name|Integer
name|defaultQueryResults
init|=
name|DEFAULT_QUERY_RESULTS
decl_stmt|;
specifier|public
name|SolrQueryFactory
parameter_list|(
name|ValueFactory
name|valueFactory
parameter_list|,
name|IndexValueFactory
name|indexValueFactory
parameter_list|,
name|FieldMapper
name|fieldMapper
parameter_list|)
block|{
if|if
condition|(
name|fieldMapper
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed FieldMapper MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|indexValueFactory
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed IndexValueFactory MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|valueFactory
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed ValueFactory MUST NOT be NULL"
argument_list|)
throw|;
block|}
name|this
operator|.
name|valueFactory
operator|=
name|valueFactory
expr_stmt|;
name|this
operator|.
name|fieldMapper
operator|=
name|fieldMapper
expr_stmt|;
name|this
operator|.
name|indexValueFactory
operator|=
name|indexValueFactory
expr_stmt|;
name|this
operator|.
name|constraintEncoders
operator|=
operator|new
name|HashMap
argument_list|<
name|IndexConstraintTypeEnum
argument_list|,
name|IndexConstraintTypeEncoder
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
comment|//TODO: Make this configuration more flexible!
name|constraintEncoders
operator|.
name|put
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|LANG
argument_list|,
operator|new
name|LangEncoder
argument_list|(
name|fieldMapper
argument_list|)
argument_list|)
expr_stmt|;
name|constraintEncoders
operator|.
name|put
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|DATATYPE
argument_list|,
operator|new
name|DataTypeEncoder
argument_list|(
name|indexValueFactory
argument_list|,
name|fieldMapper
argument_list|)
argument_list|)
expr_stmt|;
name|constraintEncoders
operator|.
name|put
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|FIELD
argument_list|,
operator|new
name|FieldEncoder
argument_list|(
name|fieldMapper
argument_list|)
argument_list|)
expr_stmt|;
name|constraintEncoders
operator|.
name|put
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|EQ
argument_list|,
operator|new
name|AssignmentEncoder
argument_list|(
name|indexValueFactory
argument_list|)
argument_list|)
expr_stmt|;
name|constraintEncoders
operator|.
name|put
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|WILDCARD
argument_list|,
operator|new
name|WildcardEncoder
argument_list|()
argument_list|)
expr_stmt|;
name|constraintEncoders
operator|.
name|put
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|REGEX
argument_list|,
operator|new
name|RegexEncoder
argument_list|()
argument_list|)
expr_stmt|;
name|constraintEncoders
operator|.
name|put
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|GE
argument_list|,
operator|new
name|GeEncoder
argument_list|(
name|indexValueFactory
argument_list|)
argument_list|)
expr_stmt|;
name|constraintEncoders
operator|.
name|put
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|LE
argument_list|,
operator|new
name|LeEncoder
argument_list|(
name|indexValueFactory
argument_list|)
argument_list|)
expr_stmt|;
name|constraintEncoders
operator|.
name|put
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|GT
argument_list|,
operator|new
name|GtEncoder
argument_list|(
name|indexValueFactory
argument_list|)
argument_list|)
expr_stmt|;
name|constraintEncoders
operator|.
name|put
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|LT
argument_list|,
operator|new
name|LtEncoder
argument_list|(
name|indexValueFactory
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
enum|enum
name|SELECT
block|{
name|ID
block|,
name|QUERY
block|,
name|ALL
block|}
specifier|public
name|SolrQuery
name|parseFieldQuery
parameter_list|(
name|FieldQuery
name|fieldQuery
parameter_list|,
name|SELECT
name|select
parameter_list|)
block|{
name|SolrQuery
name|query
init|=
name|initSolrQuery
argument_list|(
name|fieldQuery
argument_list|)
decl_stmt|;
name|setSelected
argument_list|(
name|query
argument_list|,
name|fieldQuery
operator|.
name|getSelectedFields
argument_list|()
argument_list|,
name|select
argument_list|)
expr_stmt|;
name|StringBuilder
name|queryString
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Constraint
argument_list|>
name|fieldConstraint
range|:
name|fieldQuery
control|)
block|{
name|IndexConstraint
name|indexConstraint
init|=
name|createIndexConstraint
argument_list|(
name|fieldConstraint
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexConstraint
operator|.
name|isInvalied
argument_list|()
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unable to create IndexConstraint for Constraint %s (type: %s) and Field %s (Reosens: %s)"
argument_list|,
name|fieldConstraint
operator|.
name|getValue
argument_list|()
argument_list|,
name|fieldConstraint
operator|.
name|getValue
argument_list|()
operator|.
name|getType
argument_list|()
argument_list|,
name|fieldConstraint
operator|.
name|getKey
argument_list|()
argument_list|,
name|indexConstraint
operator|.
name|getInvalidMessages
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|queryString
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|" AND "
argument_list|)
expr_stmt|;
block|}
name|indexConstraint
operator|.
name|encode
argument_list|(
name|queryString
argument_list|)
expr_stmt|;
block|}
block|}
name|log
operator|.
name|info
argument_list|(
literal|"QueryStirng: "
operator|+
name|queryString
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|query
operator|.
name|setQuery
argument_list|(
name|queryString
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|query
return|;
block|}
comment|/**      * TODO: Currently I have no Idea how to determine all the fields to be      * selected, because There are any number of possibilities for field      * names in the index (different data types, different languages ...).      * Therefore currently I select all fields and apply the filter when      * converting the {@link SolrDocument}s in the result to the      * {@link Representation}.<p>      * The only thing I can do is to select only the ID if an empty list is      * parsed as selected.      * @param query      * @param selected      */
specifier|private
name|void
name|setSelected
parameter_list|(
name|SolrQuery
name|query
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|selected
parameter_list|,
name|SELECT
name|select
parameter_list|)
block|{
switch|switch
condition|(
name|select
condition|)
block|{
case|case
name|ID
case|:
name|query
operator|.
name|addField
argument_list|(
name|fieldMapper
operator|.
name|getDocumentIdField
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QUERY
case|:
if|if
condition|(
name|selected
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|query
operator|.
name|addField
argument_list|(
name|fieldMapper
operator|.
name|getDocumentIdField
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|query
operator|.
name|addField
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
comment|//See to do in java doc of this method
comment|//                for(String field : selected){
comment|//                    if(field != null&& !field.isEmpty()){
comment|//                        fieldMapper.getFieldNames(new IndexField(Arrays.asList(field), null, null));
comment|//                    }
comment|//                }
block|}
break|break;
case|case
name|ALL
case|:
name|query
operator|.
name|addField
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unknown SELECT status %s! Adapt this implementation to the new value of the Enumeration"
argument_list|,
name|select
argument_list|)
argument_list|)
throw|;
block|}
comment|//add the select for the score
name|query
operator|.
name|addField
argument_list|(
literal|"score"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|IndexConstraint
name|createIndexConstraint
parameter_list|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Constraint
argument_list|>
name|fieldConstraint
parameter_list|)
block|{
name|IndexConstraint
name|indexConstraint
init|=
operator|new
name|IndexConstraint
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|fieldConstraint
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|fieldConstraint
operator|.
name|getValue
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|value
case|:
name|initIndexConstraint
argument_list|(
name|indexConstraint
argument_list|,
operator|(
name|ValueConstraint
operator|)
name|fieldConstraint
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|text
case|:
name|initIndexConstraint
argument_list|(
name|indexConstraint
argument_list|,
operator|(
name|TextConstraint
operator|)
name|fieldConstraint
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|range
case|:
name|initIndexConstraint
argument_list|(
name|indexConstraint
argument_list|,
operator|(
name|RangeConstraint
operator|)
name|fieldConstraint
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|indexConstraint
operator|.
name|setInvalied
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"ConstraintType %s not supported by!"
argument_list|,
name|fieldConstraint
operator|.
name|getValue
argument_list|()
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|indexConstraint
return|;
block|}
comment|/**      * @param indexConstraint      * @param rangeConstraint      */
specifier|private
name|void
name|initIndexConstraint
parameter_list|(
name|IndexConstraint
name|indexConstraint
parameter_list|,
name|RangeConstraint
name|rangeConstraint
parameter_list|)
block|{
comment|//we need to find the Index DataType for the range query
name|IndexDataType
name|dataType
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|rangeConstraint
operator|.
name|getLowerBound
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|dataType
operator|=
name|indexValueFactory
operator|.
name|createIndexValue
argument_list|(
name|rangeConstraint
operator|.
name|getLowerBound
argument_list|()
argument_list|)
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|rangeConstraint
operator|.
name|getUpperBound
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|IndexDataType
name|upperDataType
init|=
name|indexValueFactory
operator|.
name|createIndexValue
argument_list|(
name|rangeConstraint
operator|.
name|getUpperBound
argument_list|()
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|dataType
operator|==
literal|null
condition|)
block|{
name|dataType
operator|=
name|upperDataType
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dataType
operator|!=
name|upperDataType
condition|)
block|{
name|indexConstraint
operator|.
name|setInvalied
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"A Range Query MUST use the same data type for the upper and lover Bound! (lower:[value=%s|datatype=%s] | upper:[value=%s|datatype=%s])"
argument_list|,
name|rangeConstraint
operator|.
name|getLowerBound
argument_list|()
argument_list|,
name|dataType
argument_list|,
name|rangeConstraint
operator|.
name|getUpperBound
argument_list|()
argument_list|,
name|upperDataType
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|dataType
operator|==
literal|null
condition|)
block|{
name|indexConstraint
operator|.
name|setInvalied
argument_list|(
literal|"A Range Constraint MUST define at least a lower or an upper bound!"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indexConstraint
operator|.
name|setFieldConstraint
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|DATATYPE
argument_list|,
name|dataType
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rangeConstraint
operator|.
name|isInclusive
argument_list|()
condition|)
block|{
name|indexConstraint
operator|.
name|setFieldConstraint
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|LE
argument_list|,
name|rangeConstraint
operator|.
name|getUpperBound
argument_list|()
argument_list|)
expr_stmt|;
name|indexConstraint
operator|.
name|setFieldConstraint
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|GE
argument_list|,
name|rangeConstraint
operator|.
name|getLowerBound
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indexConstraint
operator|.
name|setFieldConstraint
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|LT
argument_list|,
name|rangeConstraint
operator|.
name|getUpperBound
argument_list|()
argument_list|)
expr_stmt|;
name|indexConstraint
operator|.
name|setFieldConstraint
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|GT
argument_list|,
name|rangeConstraint
operator|.
name|getLowerBound
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * @param indexConstraint      * @param textConstraint      */
specifier|private
name|void
name|initIndexConstraint
parameter_list|(
name|IndexConstraint
name|indexConstraint
parameter_list|,
name|TextConstraint
name|textConstraint
parameter_list|)
block|{
name|Text
name|text
init|=
name|valueFactory
operator|.
name|createText
argument_list|(
name|textConstraint
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|indexConstraint
operator|.
name|setFieldConstraint
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|DATATYPE
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|indexConstraint
operator|.
name|setFieldConstraint
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|LANG
argument_list|,
name|textConstraint
operator|.
name|getLanguages
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|textConstraint
operator|.
name|getPatternType
argument_list|()
condition|)
block|{
case|case
name|none
case|:
name|indexConstraint
operator|.
name|setFieldConstraint
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|EQ
argument_list|,
name|text
argument_list|)
expr_stmt|;
break|break;
case|case
name|wildcard
case|:
name|indexConstraint
operator|.
name|setFieldConstraint
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|WILDCARD
argument_list|,
name|textConstraint
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|regex
case|:
name|indexConstraint
operator|.
name|setFieldConstraint
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|REGEX
argument_list|,
name|textConstraint
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|indexConstraint
operator|.
name|setInvalied
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"PatterType %s not supported for Solr Index Queries!"
argument_list|,
name|textConstraint
operator|.
name|getPatternType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * @param indexConstraint      * @param refConstraint      */
specifier|private
name|void
name|initIndexConstraint
parameter_list|(
name|IndexConstraint
name|indexConstraint
parameter_list|,
name|ValueConstraint
name|valueConstraint
parameter_list|)
block|{
if|if
condition|(
name|valueConstraint
operator|.
name|getValue
argument_list|()
operator|==
literal|null
condition|)
block|{
name|indexConstraint
operator|.
name|setInvalied
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"ValueConstraint without a value - that check only any value for the parsed datatypes %s is present - can not be supported by a Solr query!"
argument_list|,
name|valueConstraint
operator|.
name|getDataTypes
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//first process the parsed dataTypes to get the supported types
name|Collection
argument_list|<
name|IndexDataType
argument_list|>
name|indexDataTypes
init|=
operator|new
name|HashSet
argument_list|<
name|IndexDataType
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|valueConstraint
operator|.
name|getDataTypes
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|dataType
range|:
name|valueConstraint
operator|.
name|getDataTypes
argument_list|()
control|)
block|{
name|IndexDataTypeEnum
name|indexDataTypeEnumEntry
init|=
name|IndexDataTypeEnum
operator|.
name|forUri
argument_list|(
name|dataType
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexDataTypeEnumEntry
operator|!=
literal|null
condition|)
block|{
name|indexDataTypes
operator|.
name|add
argument_list|(
name|indexDataTypeEnumEntry
operator|.
name|getIndexType
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//TODO: Add possibility to add warnings to indexConstraints
name|log
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"A Datatype parsed for a ValueConstraint is not supported and will be ignored (dataTypeUri=%s)"
argument_list|,
name|dataType
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|indexDataTypes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//if no supported types are present
comment|//get the dataType based on the type of the value
try|try
block|{
name|IndexValue
name|indexValue
init|=
name|indexValueFactory
operator|.
name|createIndexValue
argument_list|(
name|valueConstraint
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
name|indexConstraint
operator|.
name|setFieldConstraint
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|EQ
argument_list|,
name|indexValue
argument_list|)
expr_stmt|;
name|indexConstraint
operator|.
name|setFieldConstraint
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|DATATYPE
argument_list|,
name|indexValue
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoConverterException
name|e
parameter_list|)
block|{
name|indexConstraint
operator|.
name|setInvalied
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//one or more supported dataTypes are present
for|for
control|(
name|IndexDataType
name|indexDataType
range|:
name|indexDataTypes
control|)
block|{
name|indexConstraint
operator|.
name|setFieldConstraint
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|DATATYPE
argument_list|,
name|indexDataType
argument_list|)
expr_stmt|;
block|}
comment|/*                  * NOTE: add only a single EQ constraints, because if different                  *       dataTypes would result in different representations of                  *       the parsed value this code would not work altogether!                  */
name|IndexValue
name|indexValue
decl_stmt|;
try|try
block|{
comment|//use the default converter for the value
name|indexValue
operator|=
name|indexValueFactory
operator|.
name|createIndexValue
argument_list|(
name|valueConstraint
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoConverterException
name|e
parameter_list|)
block|{
comment|//if not found use the toString() and the first parsed DataType
name|IndexDataType
name|indexDataType
init|=
name|indexDataTypes
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|log
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unable to create IndexValue for value %s (type: %s). Create IndexValue manually by using the first parsed IndexDataType %s"
argument_list|,
name|valueConstraint
operator|.
name|getValue
argument_list|()
argument_list|,
name|valueConstraint
operator|.
name|getValue
argument_list|()
operator|.
name|getClass
argument_list|()
argument_list|,
name|indexDataType
argument_list|)
argument_list|)
expr_stmt|;
name|indexValue
operator|=
operator|new
name|IndexValue
argument_list|(
name|valueConstraint
operator|.
name|getValue
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|indexDataType
argument_list|)
expr_stmt|;
block|}
name|indexConstraint
operator|.
name|setFieldConstraint
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|EQ
argument_list|,
name|indexValue
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|SolrQuery
name|initSolrQuery
parameter_list|(
name|Query
name|rickQuery
parameter_list|)
block|{
name|SolrQuery
name|query
init|=
operator|new
name|SolrQuery
argument_list|()
decl_stmt|;
comment|//first add a filterquery for the domain if present
if|if
condition|(
name|domain
operator|!=
literal|null
condition|)
block|{
name|query
operator|.
name|addFilterQuery
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"%s:%s"
argument_list|,
name|fieldMapper
operator|.
name|getDocumentDomainField
argument_list|()
argument_list|,
name|SolrUtil
operator|.
name|escapeSolrSpecialChars
argument_list|(
name|domain
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//than add the offset
name|query
operator|.
name|setStart
argument_list|(
name|rickQuery
operator|.
name|getOffset
argument_list|()
argument_list|)
expr_stmt|;
comment|//and the limit
if|if
condition|(
name|rickQuery
operator|.
name|getLimit
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|rickQuery
operator|.
name|getLimit
argument_list|()
operator|.
name|compareTo
argument_list|(
name|MAX_QUERY_RESULTS
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|query
operator|.
name|setRows
argument_list|(
name|rickQuery
operator|.
name|getLimit
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Parsed Number of QueryResults %d is greater than the allowed maximum of %d!"
argument_list|,
name|rickQuery
operator|.
name|getLimit
argument_list|()
argument_list|,
name|MAX_QUERY_RESULTS
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//maybe remove that to prevent to many results! But for now I would
comment|//rather like to have a default value within the FieldQuery!
comment|//e.g. set by the FieldQueryFactory when creating new queries!
name|query
operator|.
name|setRows
argument_list|(
name|MAX_QUERY_RESULTS
argument_list|)
expr_stmt|;
block|}
return|return
name|query
return|;
block|}
comment|/**      * Getter for the domain set as FilterQuery to all generated SolrQueries      * @return the domain or<code>null</code> if no domain is set      */
specifier|public
specifier|final
name|String
name|getDomain
parameter_list|()
block|{
return|return
name|domain
return|;
block|}
comment|/**      * Setter for the domain. If an empty string is parsed, than the domain is      * set to<code>null</code>, otherwise the parsed value is set. Parse      *<code>null</code> to deactivated the usage of domains      * @param domain the domain or<code>null</code> if no domain is active      */
specifier|public
specifier|final
name|void
name|setDomain
parameter_list|(
name|String
name|domain
parameter_list|)
block|{
if|if
condition|(
name|domain
operator|!=
literal|null
operator|&&
name|domain
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|this
operator|.
name|domain
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|domain
operator|=
name|domain
expr_stmt|;
block|}
block|}
comment|/**      * getter for the maximum number of results allowed      * @return the maximum number of results that can be set      */
specifier|public
specifier|final
name|Integer
name|getMaxQueryResults
parameter_list|()
block|{
return|return
name|maxQueryResults
return|;
block|}
comment|/**      * Setter for the maximum number of results allowed. If<code>null</code> is      * parsed than the value is set to {@link #MAX_QUERY_RESULTS}. If a value      * smaller than {@link #getDefaultQueryResults()} is parsed, than the      * value is set to {@link #getDefaultQueryResults()}.      * @param maxQueryResults The maximum number of queries allowed      */
specifier|public
specifier|final
name|void
name|setMaxQueryResults
parameter_list|(
name|Integer
name|maxQueryResults
parameter_list|)
block|{
if|if
condition|(
name|maxQueryResults
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|maxQueryResults
operator|=
name|MAX_QUERY_RESULTS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|maxQueryResults
operator|.
name|compareTo
argument_list|(
name|defaultQueryResults
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|this
operator|.
name|maxQueryResults
operator|=
name|defaultQueryResults
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|maxQueryResults
operator|=
name|maxQueryResults
expr_stmt|;
block|}
block|}
comment|/**      * Getter for the default number of query results. This is used if a parsed      * Query does not define the number of results.      * @return the default value for the number of query results      */
specifier|public
specifier|final
name|Integer
name|getDefaultQueryResults
parameter_list|()
block|{
return|return
name|defaultQueryResults
return|;
block|}
comment|/**      * Setter for the default number of query results. This is used if a parsed      * Query does not define the number of results. If<code>null</code> or a      * value<code><= 0</code>is parsed, than the value is set to the lower value      * of {@link #DEFAULT_QUERY_RESULTS} ({@value #DEFAULT_QUERY_RESULTS}) and      * {@link #getMaxQueryResults()}. If a value<code>>=</code>      * {@link #getMaxQueryResults()} is parsed, than the value is set to      * {@link #getMaxQueryResults()}.      * @param defaultQueryResults the default number of results for queries      */
specifier|public
specifier|final
name|void
name|setDefaultQueryResults
parameter_list|(
name|Integer
name|defaultQueryResults
parameter_list|)
block|{
if|if
condition|(
name|defaultQueryResults
operator|==
literal|null
operator|||
name|defaultQueryResults
operator|.
name|intValue
argument_list|()
operator|<=
literal|0
condition|)
block|{
name|this
operator|.
name|defaultQueryResults
operator|=
name|Math
operator|.
name|min
argument_list|(
name|DEFAULT_QUERY_RESULTS
argument_list|,
name|maxQueryResults
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|defaultQueryResults
operator|.
name|compareTo
argument_list|(
name|maxQueryResults
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|this
operator|.
name|defaultQueryResults
operator|=
name|maxQueryResults
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|defaultQueryResults
operator|=
name|defaultQueryResults
expr_stmt|;
block|}
block|}
comment|/**      * Class internally used to process FieldConstraint. This class accesses      * the {@link SolrQueryFactory#constraintEncoders} map.      * @author Rupert Westenthaler      *      */
specifier|private
class|class
name|IndexConstraint
block|{
specifier|private
specifier|final
name|Map
argument_list|<
name|IndexConstraintTypeEnum
argument_list|,
name|Object
argument_list|>
name|fieldConstraints
init|=
operator|new
name|EnumMap
argument_list|<
name|IndexConstraintTypeEnum
argument_list|,
name|Object
argument_list|>
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|invaliedMessages
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|/**          * Creates a Field Term for the parsed path          * @param path the path          * @throws IllegalArgumentException If the path is<code>null</code> empty.          */
specifier|public
name|IndexConstraint
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|field
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
name|field
operator|==
literal|null
operator|||
name|field
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed path MUST NOT be NULL nor empty!"
argument_list|)
throw|;
block|}
name|fieldConstraints
operator|.
name|put
argument_list|(
name|IndexConstraintTypeEnum
operator|.
name|FIELD
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
comment|/**          * Set to<code>true</code> to indicate, that this IndexConstraint can not          * be used. e.g. if the conversion of a {@link Constraint } to an          * {@link IndexConstraint} was unsuccessful!          * @param state the state          */
specifier|public
name|void
name|setInvalied
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|this
operator|.
name|invaliedMessages
operator|.
name|add
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
comment|/**          * Returns<code>true</code> if this index constraint is invalid and          * can not be used for the IndexQuery. If the state is<code>true</code>          * it indicates, that the conversion to a {@link Constraint } to an          * {@link IndexConstraint} was not successful!          * @return the state          */
specifier|public
name|boolean
name|isInvalied
parameter_list|()
block|{
return|return
operator|!
name|invaliedMessages
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|/**          * Getter for the Messages why this index constraint is not valid          * @return the messages. An empty List if {@link #isInvalied()} returns          *<code>false</code>          */
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getInvalidMessages
parameter_list|()
block|{
return|return
name|invaliedMessages
return|;
block|}
comment|/**          * Sets an IndexConstraintType to a specific value          * @param constraintType the type of the constraint          * @param value the value.<code>null</code> is permitted, but usually it is          * not needed to add<code>null</code> constraints, because they are automatically          * added if needed (e.g. a range constraint with an open lower bound)          * @throws IllegalArgumentException if<code>null</code> is parsed as constraint type          */
specifier|public
name|void
name|setFieldConstraint
parameter_list|(
name|IndexConstraintTypeEnum
name|constraintType
parameter_list|,
name|Object
name|value
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
name|constraintType
operator|==
literal|null
condition|)
block|{
comment|//just returning here would also be OK, but better to find errors early by
comment|//looking at stack traces
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Parameter IndexConstraintTypeEnum MUST NOT be NULL"
argument_list|)
throw|;
block|}
name|IndexConstraintTypeEncoder
argument_list|<
name|?
argument_list|>
name|encoder
init|=
name|constraintEncoders
operator|.
name|get
argument_list|(
name|constraintType
argument_list|)
decl_stmt|;
if|if
condition|(
name|encoder
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"No Encoder for IndexConstraintType %s present!"
argument_list|,
name|constraintType
argument_list|)
argument_list|)
throw|;
block|}
comment|//accept null values and values that are supported by the encoder!
if|if
condition|(
name|value
operator|==
literal|null
operator|||
name|encoder
operator|.
name|acceptsValueType
argument_list|()
operator|.
name|isAssignableFrom
argument_list|(
name|value
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
name|this
operator|.
name|fieldConstraints
operator|.
name|put
argument_list|(
name|constraintType
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|//we need also check the dependent types!
for|for
control|(
name|IndexConstraintTypeEnum
name|dependent
range|:
name|encoder
operator|.
name|dependsOn
argument_list|()
control|)
block|{
comment|//if a dependent type is missing, add it with the default value!
if|if
condition|(
operator|!
name|fieldConstraints
operator|.
name|containsKey
argument_list|(
name|dependent
argument_list|)
condition|)
block|{
comment|//if missing, set the dependent to null (default value)
name|setFieldConstraint
argument_list|(
name|dependent
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"The Encoder %s for IndexConstraintType %s does not support values of type %s (supported Type: %s)!"
argument_list|,
name|encoder
operator|.
name|getClass
argument_list|()
argument_list|,
name|constraintType
argument_list|,
name|value
operator|.
name|getClass
argument_list|()
argument_list|,
name|encoder
operator|.
name|acceptsValueType
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|void
name|encode
parameter_list|(
name|StringBuilder
name|queryString
parameter_list|)
block|{
if|if
condition|(
name|isInvalied
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unable to encode an invalid IndexConstraint (invalid messages: %s)"
argument_list|,
name|getInvalidMessages
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
else|else
block|{
name|EncodedConstraintParts
name|encodedConstraintParts
init|=
operator|new
name|EncodedConstraintParts
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|IndexConstraintTypeEnum
argument_list|,
name|Object
argument_list|>
name|constraint
range|:
name|fieldConstraints
operator|.
name|entrySet
argument_list|()
control|)
block|{
comment|//NOTE: type checks are already performed in the setFieldConstraint method!
operator|(
operator|(
name|IndexConstraintTypeEncoder
argument_list|<
name|Object
argument_list|>
operator|)
name|constraintEncoders
operator|.
name|get
argument_list|(
name|constraint
operator|.
name|getKey
argument_list|()
argument_list|)
operator|)
operator|.
name|encode
argument_list|(
name|encodedConstraintParts
argument_list|,
name|constraint
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//now take the parts and create the constraint!
name|encodeSolrConstraint
argument_list|(
name|queryString
argument_list|,
name|encodedConstraintParts
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|StringBuilder
name|encodeSolrConstraint
parameter_list|(
name|StringBuilder
name|queryString
parameter_list|,
name|EncodedConstraintParts
name|encodedConstraintParts
parameter_list|)
block|{
comment|//list of all constraints that need to be connected with OR
name|List
argument_list|<
name|StringBuilder
argument_list|>
name|constraints
init|=
operator|new
name|ArrayList
argument_list|<
name|StringBuilder
argument_list|>
argument_list|()
decl_stmt|;
comment|//init with a single constraint
name|constraints
operator|.
name|add
argument_list|(
operator|new
name|StringBuilder
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|ConstraintTypePosition
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|entry
range|:
name|encodedConstraintParts
control|)
block|{
comment|//one position may contain multiple options that need to be connected with OR
name|Set
argument_list|<
name|String
argument_list|>
name|parts
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|constraintsSize
init|=
name|constraints
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|part
range|:
name|parts
control|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|parts
operator|.
name|size
argument_list|()
condition|)
block|{
comment|//for the last iteration, append the part to the existing constraints
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|constraintsSize
condition|;
name|j
operator|++
control|)
block|{
name|constraints
operator|.
name|get
argument_list|(
name|j
argument_list|)
operator|.
name|append
argument_list|(
name|part
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//if there is more than one value, we need to generate new variants for
comment|//every option other than the last.
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|constraintsSize
condition|;
name|j
operator|++
control|)
block|{
name|StringBuilder
name|additional
init|=
operator|new
name|StringBuilder
argument_list|(
name|constraints
operator|.
name|get
argument_list|(
name|j
argument_list|)
argument_list|)
decl_stmt|;
name|additional
operator|.
name|append
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|constraints
operator|.
name|add
argument_list|(
name|additional
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|//now combine the different options to a single query string
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|StringBuilder
name|constraint
range|:
name|constraints
control|)
block|{
if|if
condition|(
name|constraint
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|first
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|" OR "
argument_list|)
expr_stmt|;
block|}
name|queryString
operator|.
name|append
argument_list|(
name|constraint
argument_list|)
expr_stmt|;
block|}
comment|//else ignore empty constraints
block|}
if|if
condition|(
operator|!
name|first
condition|)
block|{
name|queryString
operator|.
name|append
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
return|return
name|queryString
return|;
block|}
comment|//        /**
comment|//         * NOTE: removed, because currently not needed. If re-added, this Method needs also
comment|//         *       to remove (recursively) dependent with the default value
comment|//         * Removes the according index constraint if present
comment|//         * @param constraintType the constraint to remove
comment|//         * @throws IllegalArgumentException if<code>null</code> is parsed as constraint type
comment|//         */
comment|//        public void removeFieldConstraint(IndexConstraintTypeEnum constraintType) throws IllegalArgumentException {
comment|//            if(constraintType == null){
comment|//                //just returning here would also be OK, but better to find errors early by
comment|//                //looking at stack traces
comment|//                throw new IllegalArgumentException("Parameter IndexConstraintTypeEnum MUST NOT be NULL");
comment|//            }
comment|//            this.fieldConstraints.remove(constraintType);
comment|//        }
block|}
block|}
end_class

end_unit

