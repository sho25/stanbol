begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
package|package
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|impl
package|;
end_package

begin_import
import|import static
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|defaults
operator|.
name|SolrConst
operator|.
name|DEPENDENT_DOCUMENT_FIELD
import|;
end_import

begin_import
import|import static
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|defaults
operator|.
name|SolrConst
operator|.
name|DOCUMENT_ID_FIELD
import|;
end_import

begin_import
import|import static
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|defaults
operator|.
name|SolrConst
operator|.
name|DOMAIN_FIELD
import|;
end_import

begin_import
import|import static
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|defaults
operator|.
name|SolrConst
operator|.
name|LANG_MERGER_FIELD
import|;
end_import

begin_import
import|import static
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|defaults
operator|.
name|SolrConst
operator|.
name|PATH_SEPERATOR
import|;
end_import

begin_import
import|import static
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|defaults
operator|.
name|SolrConst
operator|.
name|REFERRED_DOCUMENT_FIELD
import|;
end_import

begin_import
import|import static
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|defaults
operator|.
name|SolrConst
operator|.
name|SPECIAL_CONFIG_FIELD
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|SolrServerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|client
operator|.
name|solrj
operator|.
name|response
operator|.
name|QueryResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|solr
operator|.
name|common
operator|.
name|SolrInputDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|core
operator|.
name|utils
operator|.
name|ModelUtils
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|servicesapi
operator|.
name|defaults
operator|.
name|NamespaceEnum
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|rdf
operator|.
name|RdfResourceEnum
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|defaults
operator|.
name|IndexDataTypeEnum
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|defaults
operator|.
name|SolrConst
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|model
operator|.
name|FieldMapper
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|model
operator|.
name|IndexDataType
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|model
operator|.
name|IndexField
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|model
operator|.
name|IndexValue
import|;
end_import

begin_import
import|import
name|eu
operator|.
name|iksproject
operator|.
name|rick
operator|.
name|yard
operator|.
name|solr
operator|.
name|utils
operator|.
name|SolrUtil
import|;
end_import

begin_comment
comment|/**  * Implementation of the FieldMapper for a Solr Index.  * @author Rupert Westenthaler  *  */
end_comment

begin_class
specifier|public
class|class
name|SolrFieldMapper
implements|implements
name|FieldMapper
block|{
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SolrFieldMapper
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * Char used to separate the prefix from the local name of uri's      */
specifier|private
specifier|static
specifier|final
name|char
name|NAMESPACE_PREFIX_SEPERATOR_CHAR
init|=
literal|':'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|LANG_MERGER_PREFIX
init|=
literal|""
operator|+
name|SolrConst
operator|.
name|SPECIAL_FIELD_PREFIX
operator|+
name|SolrConst
operator|.
name|MERGER_INDICATOR
operator|+
name|SolrConst
operator|.
name|LANG_INDICATOR
decl_stmt|;
comment|/**      * The size of the LRU cache for FieldName to IndexField as well as      * IndexField to collection of FieldNames mappings.<p>      * Note that both caches may have a maximum of elements as configured by this      * property.      */
specifier|private
specifier|static
specifier|final
name|int
name|LRU_MAPPINGS_CACHE_SIZE
init|=
literal|1024
decl_stmt|;
comment|/**      * The IndexField for the Solr score. This field is mapped to the field      * {@link RdfResourceEnum#resultScore} and uses {@link IndexDataTypeEnum#FLOAT}      */
specifier|private
specifier|static
specifier|final
name|IndexField
name|scoreField
init|=
operator|new
name|IndexField
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|RdfResourceEnum
operator|.
name|resultScore
operator|.
name|getUri
argument_list|()
argument_list|)
argument_list|,
name|IndexDataTypeEnum
operator|.
name|FLOAT
operator|.
name|getIndexType
argument_list|()
argument_list|)
decl_stmt|;
comment|/**      * Internally used as LRU Cache with {@link SolrFieldMapper#LRU_MAPPINGS_CACHE_SIZE}      * elements. This subclass of {@link LinkedHashMap} overrides the      * {@link LinkedHashMap#removeEldestEntry(Entry)} as suggested by the java      * doc. It also uses the constructor that activates the ordering based on      * access time rather tan insertion time.      *      * @author Rupert Westenthaler      *      * @param<K> generic type of the key      * @param<V> generic type of the value      */
specifier|private
specifier|static
specifier|final
class|class
name|LRU
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|LinkedHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
specifier|public
name|LRU
parameter_list|()
block|{
name|super
argument_list|(
literal|16
argument_list|,
literal|0.75f
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|//access order!
block|}
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
annotation|@
name|Override
specifier|protected
name|boolean
name|removeEldestEntry
parameter_list|(
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|eldest
parameter_list|)
block|{
return|return
name|size
argument_list|()
operator|>
name|LRU_MAPPINGS_CACHE_SIZE
return|;
block|}
block|}
comment|/**      * The assumption is, that only a handful of {@link IndexField}s are used      * very often.<p>      * So it makes sense to keep some mappings within a cache rather than calculating      * them again and again.      * @see LinkedHashMap#      */
specifier|private
specifier|final
name|LinkedHashMap
argument_list|<
name|IndexField
argument_list|,
name|Collection
argument_list|<
name|String
argument_list|>
argument_list|>
name|indexFieldMappings
init|=
operator|new
name|LRU
argument_list|<
name|IndexField
argument_list|,
name|Collection
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * The assumption is, that only a handful of fields appear in index documents.      * So it makes sense to keep some mappings within a cache rather than calculating      * them again and again.      */
specifier|private
specifier|final
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|IndexField
argument_list|>
name|fieldMappings
init|=
operator|new
name|LRU
argument_list|<
name|String
argument_list|,
name|IndexField
argument_list|>
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|SolrServer
name|server
decl_stmt|;
specifier|public
name|SolrFieldMapper
parameter_list|(
name|SolrServer
name|server
parameter_list|)
block|{
if|if
condition|(
name|server
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed SolrServer MUST NOT be NULL"
argument_list|)
throw|;
block|}
name|this
operator|.
name|server
operator|=
name|server
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|IndexField
name|getField
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
if|if
condition|(
name|fieldName
operator|==
literal|null
operator|||
name|fieldName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed field name MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|IndexField
name|field
init|=
name|fieldMappings
operator|.
name|get
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|getDocumentIdField
argument_list|()
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|)
operator|||
name|fieldName
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
name|SolrConst
operator|.
name|SPECIAL_FIELD_PREFIX
condition|)
block|{
comment|//in case of special field or the document ID, return null ->
comment|//   meaning, that this index document field does not represent
comment|//   an logical IndexField and should be ignored
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|SolrConst
operator|.
name|SCORE_FIELD
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
return|return
name|scoreField
return|;
block|}
comment|//parse the prefix and suffix
name|String
index|[]
name|tokens
init|=
name|fieldName
operator|.
name|split
argument_list|(
name|Character
operator|.
name|toString
argument_list|(
name|SolrConst
operator|.
name|PATH_SEPERATOR
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|numTokens
init|=
name|tokens
operator|.
name|length
decl_stmt|;
name|int
name|pathElements
init|=
name|numTokens
decl_stmt|;
name|String
name|prefix
init|=
literal|null
decl_stmt|;
name|String
name|suffix
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|tokens
operator|.
name|length
operator|>=
literal|2
condition|)
block|{
name|prefix
operator|=
name|tokens
index|[
literal|0
index|]
expr_stmt|;
name|pathElements
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|tokens
operator|.
name|length
operator|>=
literal|3
condition|)
block|{
name|suffix
operator|=
name|tokens
index|[
name|numTokens
operator|-
literal|1
index|]
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|pathElements
operator|--
expr_stmt|;
block|}
comment|//parse the path
name|String
index|[]
name|path
init|=
operator|new
name|String
index|[
name|pathElements
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|tokens
argument_list|,
name|prefix
operator|==
literal|null
condition|?
literal|0
else|:
literal|1
argument_list|,
name|path
argument_list|,
literal|0
argument_list|,
name|pathElements
argument_list|)
expr_stmt|;
name|tokens
operator|=
literal|null
expr_stmt|;
comment|//process the parsed data
name|field
operator|=
name|parseIndexField
argument_list|(
name|prefix
argument_list|,
name|suffix
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|!=
literal|null
condition|)
block|{
name|fieldMappings
operator|.
name|put
argument_list|(
name|fieldName
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|field
return|;
block|}
comment|/**      * This method does the dirty work of parsing the different parts of the      * field in the SolrDocument to the logical field as used by the semantic      * indexing API.      * This method assumes the following encoding      *<code><pre>      *   .        ... path separator      *   _        ... special field indicator      *   __       ... escaped special field      *   !        ... merger - collected values of other fields.      *                Such fields do not have an mapping to logical IndexFields.      *                All mergers are created by copyField configurations within the      *                Solr Schema configuration      *   @        ... '@' indicates a field in a given language      *     _@.&lt;field&gt;: A value for a field with no language defined      *     _@en.&lt;field&gt;: A value for a field in English      *     _!@.&lt;field&gt;: Contains all labels regardless of language      *     _!@en.&lt;field&gt;: Contains all labels of languages that start with "en"      *&lt;prefix&gt; ... indicates an dataType that used this prefix      *     _str.&lt;field&gt;: A string field (containing no language)      *     _ref.&lt;field&gt;: A reference (similar to xsd:anyURI)      *     _bool.&lt;field&gt;: A boolean value      *      * NOTE: Prefixes/Suffixes can be used to define a hierarchy of data types      * e.g. use Prefixes for dataTypes:      *   _n   ... any kind of numeric value      *   _ni  ... any kind of integer value (BigInteger)      *   _nib ... a byte      *   _nii ... a integer      *   _nil ... a long      *   _nd  ... a decimal value      *   _ndf ... float      *   _ndd ... double      *   _s   ... any kind of string value      *   _si  ... an string based ID      *   _sr  ... a reference      * e.g. use Suffixes for semantic meanings      *   ._ct ... a tag      *   ._cr ... a category using a reference to an entity ID (xsd:anyURI)      *   ._ci ... a categorisation using an local id (e.g 2 letter country codes)      *      *  one can now create Solr copyField commands to support searches spanning      *  over multiple types      *  _!n  ... search for any kind of numbers      *  _!ni ... search for any kind of integers      *  _!s  ... search in all kind of string values      *  _!sc ... search for all categories of this document      *      *</pre><code>      * @param prefix      * @param suffix      * @param pathElements      * @return      */
specifier|private
name|IndexField
name|parseIndexField
parameter_list|(
specifier|final
name|String
name|prefix
parameter_list|,
specifier|final
name|String
name|suffix
parameter_list|,
specifier|final
name|String
index|[]
name|pathElements
parameter_list|)
block|{
specifier|final
name|String
name|language
decl_stmt|;
name|boolean
name|isLanguage
init|=
literal|false
decl_stmt|;
specifier|final
name|String
name|dataTypePrefix
decl_stmt|;
comment|//first use the prefix to parse the language
comment|// -> note that the prefix might also be used for the data type!
if|if
condition|(
name|prefix
operator|!=
literal|null
operator|&&
operator|!
name|prefix
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|prefix
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
name|SolrConst
operator|.
name|LANG_INDICATOR
condition|)
block|{
name|isLanguage
operator|=
literal|true
expr_stmt|;
comment|//it is a language prefix!
comment|//set dataTypePrefix to null
name|dataTypePrefix
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|prefix
operator|.
name|length
argument_list|()
operator|>
literal|1
condition|)
block|{
name|language
operator|=
name|prefix
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//it is a language prefix, but for the default language!
name|language
operator|=
literal|null
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//it is no language prefix
name|language
operator|=
literal|null
expr_stmt|;
name|isLanguage
operator|=
literal|false
expr_stmt|;
name|dataTypePrefix
operator|=
name|prefix
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//no prefix at all
comment|//set no-language and the dataType prefix to null;
name|isLanguage
operator|=
literal|false
expr_stmt|;
name|language
operator|=
literal|null
expr_stmt|;
name|dataTypePrefix
operator|=
literal|null
expr_stmt|;
block|}
comment|//now parse the indexDataType!
name|IndexDataTypeEnum
name|dataTypeEnumEntry
init|=
name|IndexDataTypeEnum
operator|.
name|forPrefixSuffix
argument_list|(
name|dataTypePrefix
argument_list|,
name|suffix
argument_list|)
decl_stmt|;
if|if
condition|(
name|dataTypeEnumEntry
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"No IndexDataType registered for prefix: %s and suffix: %s -> unable to process path %s"
argument_list|,
name|dataTypePrefix
argument_list|,
name|suffix
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|pathElements
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
comment|// we might also throw an exception at this point
block|}
comment|//parse the path
name|List
argument_list|<
name|String
argument_list|>
name|path
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|pathElements
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|pathElement
range|:
name|pathElements
control|)
block|{
if|if
condition|(
name|pathElement
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
name|SolrConst
operator|.
name|SPECIAL_FIELD_PREFIX
condition|)
block|{
if|if
condition|(
name|pathElement
operator|.
name|charAt
argument_list|(
literal|1
argument_list|)
operator|==
name|SolrConst
operator|.
name|SPECIAL_FIELD_PREFIX
condition|)
block|{
name|path
operator|.
name|add
argument_list|(
name|getFullFieldName
argument_list|(
name|pathElement
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Found special field \"%s\" within the path \"%s\" -> Special fields are only allowed as prefix and suffix!"
argument_list|,
name|pathElement
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|pathElements
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|String
name|fullName
init|=
name|getFullFieldName
argument_list|(
name|pathElement
argument_list|)
decl_stmt|;
if|if
condition|(
name|fullName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unable to map PathElement %s to it's full Name (path=%s)!"
argument_list|,
name|pathElement
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|pathElements
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
else|else
block|{
name|path
operator|.
name|add
argument_list|(
name|fullName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|isLanguage
condition|)
block|{
return|return
operator|new
name|IndexField
argument_list|(
name|path
argument_list|,
name|dataTypeEnumEntry
operator|.
name|getIndexType
argument_list|()
argument_list|,
name|language
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|IndexField
argument_list|(
name|path
argument_list|,
name|dataTypeEnumEntry
operator|.
name|getIndexType
argument_list|()
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|getFieldNames
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|path
parameter_list|,
name|IndexValue
name|indexValue
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|IndexField
name|field
decl_stmt|;
if|if
condition|(
name|indexValue
operator|.
name|hasLanguage
argument_list|()
condition|)
block|{
name|field
operator|=
operator|new
name|IndexField
argument_list|(
name|path
argument_list|,
name|indexValue
operator|.
name|getType
argument_list|()
argument_list|,
name|indexValue
operator|.
name|getLanguage
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|field
operator|=
operator|new
name|IndexField
argument_list|(
name|path
argument_list|,
name|indexValue
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|getFieldNames
argument_list|(
name|field
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|getFieldNames
parameter_list|(
name|IndexField
name|indexField
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
name|indexField
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed IndexField name MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|Collection
argument_list|<
name|String
argument_list|>
name|fieldNames
init|=
name|indexFieldMappings
operator|.
name|get
argument_list|(
name|indexField
argument_list|)
decl_stmt|;
if|if
condition|(
name|fieldNames
operator|==
literal|null
condition|)
block|{
name|fieldNames
operator|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
comment|//Three things need to be done
comment|//1) Replace the path with the prefix:localName
name|StringBuilder
name|pathName
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|encodePathName
argument_list|(
name|pathName
argument_list|,
name|indexField
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
comment|//2) add the prefix and/or suffix for the IndexType
name|encodeDataType
argument_list|(
name|pathName
argument_list|,
name|indexField
operator|.
name|getDataType
argument_list|()
argument_list|)
expr_stmt|;
comment|//3) add the prefix for the languages
if|if
condition|(
name|indexField
operator|.
name|hasLanguage
argument_list|()
condition|)
block|{
name|fieldNames
operator|=
name|encodeLanguages
argument_list|(
name|pathName
operator|.
name|toString
argument_list|()
argument_list|,
name|indexField
operator|.
name|getLanguages
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fieldNames
operator|=
name|Collections
operator|.
name|singleton
argument_list|(
name|pathName
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//cache the mappings
name|indexFieldMappings
operator|.
name|put
argument_list|(
name|indexField
argument_list|,
name|fieldNames
argument_list|)
expr_stmt|;
block|}
return|return
name|fieldNames
return|;
block|}
comment|/**      * Getter for the string used to index a the parsed path. This method      * replaces the URI's of all elements within the path with      *<code>prefix+NAMESPACE_PREFIX_SEPERATOR_CHAR+localName</code>. In addition      * it places the<code>PATH_SEPERATOR</code> char between the elements.<p>      * NOTE: This Method assumes that both Parameters are not NULL and that      * the Path is not empty and contains no NULL nor emtpy element!      * @param pathName the StringBuilder used to add the path      * @param path the path to encode      */
specifier|private
name|void
name|encodePathName
parameter_list|(
name|StringBuilder
name|pathName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|path
parameter_list|)
block|{
comment|//Now Iterate over the Path
name|pathName
operator|.
name|append
argument_list|(
name|PATH_SEPERATOR
argument_list|)
expr_stmt|;
comment|//add the leading PathSeperator
name|Iterator
argument_list|<
name|String
argument_list|>
name|fields
init|=
name|path
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|fields
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|field
init|=
name|fields
operator|.
name|next
argument_list|()
decl_stmt|;
comment|//PathElement element = it.next();
name|String
index|[]
name|namespaceLocalName
init|=
name|ModelUtils
operator|.
name|getNamespaceLocalName
argument_list|(
name|field
argument_list|)
decl_stmt|;
comment|//QName qName = getQName(field);
if|if
condition|(
name|namespaceLocalName
index|[
literal|0
index|]
operator|!=
literal|null
operator|&&
operator|!
name|namespaceLocalName
index|[
literal|0
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|pathName
operator|.
name|append
argument_list|(
name|getPrefix
argument_list|(
name|namespaceLocalName
index|[
literal|0
index|]
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|//second the local name
name|pathName
operator|.
name|append
argument_list|(
name|NAMESPACE_PREFIX_SEPERATOR_CHAR
argument_list|)
expr_stmt|;
block|}
name|pathName
operator|.
name|append
argument_list|(
name|namespaceLocalName
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|//third add Path Separator if there are additional Elements
if|if
condition|(
name|fields
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|pathName
operator|.
name|append
argument_list|(
name|PATH_SEPERATOR
argument_list|)
expr_stmt|;
block|}
block|}
name|pathName
operator|.
name|append
argument_list|(
name|PATH_SEPERATOR
argument_list|)
expr_stmt|;
comment|//add the tailing PathSeperator
block|}
annotation|@
name|Override
specifier|public
name|String
name|encodePath
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|path
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|IndexField
operator|.
name|validatePath
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|encodePathName
argument_list|(
name|sb
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Encodes the prefix and/or Suffix that indicates the data type.<p>      * NOTE: This Method assumes that both parameters are not NULL.<p>      * TODO: Currently such mappings are "hard coded" within the      * {@link IndexDataTypeEnum}. It would be also possible to store such      * mappings within the Solr index. However this is currently not implemented      * because the Solr Server needs also to recognise such prefixes and suffixes      * - meaning they need to be configured in the SchemaXML used by the Solr      * Server. If there is a possibility to modify this configuration      * programmatically than adding new dataTypes should be exposed via the      * configuration tab of the OSGI Web Console!      * @param pathName the StringBuilder to add the prefix and the suffix. This      * method assumes, that the encoded path is already contained in the parsed      * StringBuilder.      * @param dataType the dataType to encode.      */
specifier|private
name|void
name|encodeDataType
parameter_list|(
name|StringBuilder
name|pathName
parameter_list|,
name|IndexDataType
name|dataType
parameter_list|)
block|{
name|IndexDataTypeEnum
name|dataTypeConfig
init|=
name|IndexDataTypeEnum
operator|.
name|forIndexType
argument_list|(
name|dataType
argument_list|)
decl_stmt|;
if|if
condition|(
name|dataTypeConfig
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"No Config found for the parsed IndexDataType %s"
argument_list|,
name|dataType
argument_list|)
argument_list|)
throw|;
block|}
name|String
index|[]
name|prefixSuffix
init|=
name|encodeDataType
argument_list|(
name|dataType
argument_list|)
decl_stmt|;
if|if
condition|(
name|prefixSuffix
index|[
literal|0
index|]
operator|!=
literal|null
condition|)
block|{
name|pathName
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
name|prefixSuffix
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prefixSuffix
index|[
literal|1
index|]
operator|!=
literal|null
condition|)
block|{
name|pathName
operator|.
name|append
argument_list|(
name|prefixSuffix
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
index|[]
name|encodeDataType
parameter_list|(
name|IndexDataType
name|dataType
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|IndexDataTypeEnum
name|dataTypeConfig
init|=
name|IndexDataTypeEnum
operator|.
name|forIndexType
argument_list|(
name|dataType
argument_list|)
decl_stmt|;
if|if
condition|(
name|dataTypeConfig
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"No Config found for the parsed IndexDataType %s"
argument_list|,
name|dataType
argument_list|)
argument_list|)
throw|;
block|}
name|String
index|[]
name|prefixSuffix
init|=
operator|new
name|String
index|[]
block|{
literal|null
block|,
literal|null
block|}
decl_stmt|;
if|if
condition|(
name|dataTypeConfig
operator|.
name|getPrefix
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|dataTypeConfig
operator|.
name|getPrefix
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|prefixSuffix
index|[
literal|0
index|]
operator|=
name|dataTypeConfig
operator|.
name|getPrefix
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dataTypeConfig
operator|.
name|getSuffix
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|dataTypeConfig
operator|.
name|getSuffix
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|prefixSuffix
index|[
literal|1
index|]
operator|=
name|dataTypeConfig
operator|.
name|getSuffix
argument_list|()
expr_stmt|;
block|}
return|return
name|prefixSuffix
return|;
block|}
comment|/**      * Encodes the prefixes for the parsed languages and returns the according      * field names for the languages.<p>      * Languages are encodes using the {@link SolrConst#LANG_INDICATOR} and the      * parsed language as field prefix.<p>      * Note the on the server there is typically a copy field configuration that      * adds all fields that start with the {@link SolrConst#LANG_INDICATOR} and      * fields of the {@link IndexDataTypeEnum#STR} to a field with the prefix      * {@link SolrConst#LANG_INDICATOR}{@link SolrConst#MERGER_INDICATOR}.      * This field can be used by queries to search for strings in any language!      * @param fieldName the string representing the field without encoded languages      * @param languages the languages.      * @return      */
specifier|private
name|Collection
argument_list|<
name|String
argument_list|>
name|encodeLanguages
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|languages
parameter_list|)
block|{
if|if
condition|(
name|languages
operator|==
literal|null
operator|||
name|languages
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//no language
return|return
name|Collections
operator|.
name|singleton
argument_list|(
name|fieldName
argument_list|)
return|;
comment|//just return the field
block|}
else|else
block|{
comment|//I assume that this will be the case in most of the calls
name|Collection
argument_list|<
name|String
argument_list|>
name|fieldNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|languages
operator|.
name|size
argument_list|()
operator|*
literal|2
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|prefix
range|:
name|encodeLanguages
argument_list|(
name|languages
argument_list|)
control|)
block|{
name|fieldNames
operator|.
name|add
argument_list|(
name|prefix
operator|+
name|fieldName
argument_list|)
expr_stmt|;
block|}
return|return
name|fieldNames
return|;
block|}
block|}
comment|/**      * Internally used instead of {@link #encodeLanguages(String...)}      * @param languages the languages      * @return the prefixes      * @see FieldMapper#encodeLanguages(String...)      */
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|encodeLanguages
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|languages
parameter_list|)
block|{
if|if
condition|(
name|languages
operator|==
literal|null
operator|||
name|languages
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//no language
return|return
name|Collections
operator|.
name|emptySet
argument_list|()
return|;
comment|//just return the field
block|}
elseif|else
if|if
condition|(
name|languages
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
return|return
name|encodeLanguage
argument_list|(
name|languages
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|langPrefixes
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|lang
range|:
name|languages
control|)
block|{
name|langPrefixes
operator|.
name|addAll
argument_list|(
name|encodeLanguage
argument_list|(
name|lang
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|langPrefixes
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|getLanguageMergerField
parameter_list|(
name|String
name|lang
parameter_list|)
block|{
return|return
name|LANG_MERGER_PREFIX
operator|+
operator|(
name|lang
operator|!=
literal|null
condition|?
name|lang
else|:
literal|""
operator|)
return|;
block|}
comment|/**      * Encodes the language prefixes of for the parsed language      * @param lang the language      * @return the field with the encoded language      */
specifier|private
name|Collection
argument_list|<
name|String
argument_list|>
name|encodeLanguage
parameter_list|(
name|String
name|lang
parameter_list|)
block|{
name|StringBuilder
name|langField
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|langField
operator|.
name|append
argument_list|(
name|SolrConst
operator|.
name|LANG_INDICATOR
argument_list|)
expr_stmt|;
if|if
condition|(
name|lang
operator|!=
literal|null
condition|)
block|{
name|langField
operator|.
name|append
argument_list|(
name|lang
argument_list|)
expr_stmt|;
block|}
return|return
name|Arrays
operator|.
name|asList
argument_list|(
name|langField
operator|.
name|toString
argument_list|()
argument_list|,
name|LANG_MERGER_FIELD
argument_list|)
return|;
block|}
comment|/*--------------------------------------------------------------------------      * The remaining (boring) methods that provide static field names for      * special fields.      * -------------------------------------------------------------------------      */
annotation|@
name|Override
specifier|public
name|String
name|getDocumentIdField
parameter_list|()
block|{
return|return
name|DOCUMENT_ID_FIELD
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getReferredDocumentField
parameter_list|()
block|{
return|return
name|REFERRED_DOCUMENT_FIELD
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getDependentDocumentField
parameter_list|()
block|{
return|return
name|DEPENDENT_DOCUMENT_FIELD
return|;
block|}
comment|/*--------------------------------------------------------------------------      * Helper Methods to store/read the Mapping Config within the index.      * TODO: Move this to an own class e.g. IndexConfig or something like that      * -------------------------------------------------------------------------      */
specifier|private
name|int
name|defaultNsPrefixNumber
init|=
literal|1
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|DEFAULT_NS_PREFIX_STRING
init|=
literal|"ns"
decl_stmt|;
comment|//private static final char NAMESPACE_PREFIX_SEPERATOR_CHAR = ':';
comment|/**      * Do never access this Map directly! Use {@link #getNamespaceMap()}!      */
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|__namespaceMap
init|=
literal|null
decl_stmt|;
comment|/**      * Getter for the namespace to prefix mapping      * @return the map holding the namespace to prefix mappings      */
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getNamespaceMap
parameter_list|()
block|{
if|if
condition|(
name|__namespaceMap
operator|==
literal|null
condition|)
block|{
name|loadNamespaceConfig
argument_list|()
expr_stmt|;
block|}
return|return
name|__namespaceMap
return|;
block|}
comment|/**      * Do never access this Map directly! Use {@link #getPrefixMap()}!      */
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|__prefixMap
init|=
literal|null
decl_stmt|;
comment|/**      * Getter for the prefix to namespace mappings      * @return the map holding the prefix to namespace mappings      */
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getPrefixMap
parameter_list|()
block|{
if|if
condition|(
name|__prefixMap
operator|==
literal|null
condition|)
block|{
name|loadNamespaceConfig
argument_list|()
expr_stmt|;
block|}
return|return
name|__prefixMap
return|;
block|}
comment|/**      * Getter for the full name based on the short name. The short name is defined      * as the prefix followed by the {@link #NAMESPACE_PREFIX_SEPERATOR_CHAR} and      * the local name of the field. The returned field name is defined as the      * namespace followed by the local name.<p>      * If the parsed short field name does not contain the      * {@link #NAMESPACE_PREFIX_SEPERATOR_CHAR} this method returns the parsed      * String.<p>      * The local name may contain the {@link #NAMESPACE_PREFIX_SEPERATOR_CHAR}      * {@link #NAMESPACE_PREFIX_SEPERATOR_CHAR}'. The prefix MUST NOT contain      * this char, because {@link String#indexOf(int)} is used to split prefix      * and local name.      * @param shortFieldName the short name      * @return the full name      * @throws IllegalArgumentException if<code>null</code> is parsed as shortFieldName      * @throws IllegalStateException if the found prefix is not contained in the configuration      */
specifier|protected
specifier|final
name|String
name|getFullFieldName
parameter_list|(
name|String
name|shortFieldName
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|IllegalStateException
block|{
if|if
condition|(
name|shortFieldName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Parameter shortFieldName MUST NOT be NULL"
argument_list|)
throw|;
block|}
name|int
name|seperatorIndex
init|=
name|shortFieldName
operator|.
name|indexOf
argument_list|(
name|NAMESPACE_PREFIX_SEPERATOR_CHAR
argument_list|)
decl_stmt|;
if|if
condition|(
name|seperatorIndex
operator|>=
literal|0
condition|)
block|{
name|String
name|prefix
init|=
name|shortFieldName
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|seperatorIndex
argument_list|)
decl_stmt|;
comment|//seperatorIndex does not include the separator char
name|String
name|namespace
init|=
name|getNamespace
argument_list|(
name|prefix
argument_list|)
decl_stmt|;
if|if
condition|(
name|namespace
operator|!=
literal|null
condition|)
block|{
return|return
name|namespace
operator|+
name|shortFieldName
operator|.
name|substring
argument_list|(
name|seperatorIndex
operator|+
literal|1
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unknown prefix "
operator|+
name|prefix
operator|+
literal|" (parsed from field "
operator|+
name|shortFieldName
operator|+
literal|")!"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
return|return
name|shortFieldName
return|;
block|}
block|}
specifier|protected
specifier|final
name|String
name|getNamespace
parameter_list|(
name|String
name|prefix
parameter_list|)
block|{
if|if
condition|(
name|prefix
operator|.
name|equals
argument_list|(
literal|"urn"
argument_list|)
condition|)
block|{
comment|//than the parsed URI is something like "urn:my.test.uuid-123"
comment|// -> this is no real prefix, but an urn with only one ':'
comment|//    we need to return "urn:" as namespace!
return|return
literal|"urn:"
return|;
block|}
else|else
block|{
comment|//else we have an real namespace -> use the current mappings!
return|return
name|getPrefixMap
argument_list|()
operator|.
name|get
argument_list|(
name|prefix
argument_list|)
return|;
block|}
block|}
specifier|protected
specifier|final
name|String
name|addNamespace
parameter_list|(
name|String
name|namespace
parameter_list|)
block|{
return|return
name|getPrefix
argument_list|(
name|namespace
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|protected
specifier|final
name|String
name|getPrefix
parameter_list|(
name|String
name|namespace
parameter_list|)
block|{
return|return
name|getPrefix
argument_list|(
name|namespace
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|protected
specifier|final
name|String
name|getPrefix
parameter_list|(
name|String
name|namespace
parameter_list|,
name|boolean
name|create
parameter_list|)
block|{
if|if
condition|(
name|namespace
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|prefixMap
init|=
name|getPrefixMap
argument_list|()
decl_stmt|;
name|String
name|prefix
init|=
name|getNamespaceMap
argument_list|()
operator|.
name|get
argument_list|(
name|namespace
argument_list|)
decl_stmt|;
if|if
condition|(
name|prefix
operator|!=
literal|null
condition|)
block|{
return|return
name|prefix
return|;
block|}
elseif|else
if|if
condition|(
name|create
condition|)
block|{
comment|//only if not present and prefix is true
name|NamespaceEnum
name|defaultMapping
init|=
name|NamespaceEnum
operator|.
name|forNamespace
argument_list|(
name|namespace
argument_list|)
decl_stmt|;
if|if
condition|(
name|defaultMapping
operator|!=
literal|null
operator|&&
operator|!
name|prefixMap
operator|.
name|containsKey
argument_list|(
name|defaultMapping
operator|.
name|getPrefix
argument_list|()
argument_list|)
condition|)
block|{
comment|/*                  * NOTE: we need to check here also if the default prefix is not                  * yet taken, because the Solr Index used to store the prefixes                  * might be older than the latest change within the NamespaceEnum.                  * Therefore there might be cases where a default prefix configured                  * by this Enum is already assigned to a different namespace within                  * the Solr index!                  * In such cases, we need to create a new prefix for this namespace                  */
name|prefix
operator|=
name|defaultMapping
operator|.
name|getPrefix
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|//need to generate a default mapping
name|prefix
operator|=
name|createPrefix
argument_list|(
name|prefixMap
argument_list|)
expr_stmt|;
block|}
name|addNamespaceMapping
argument_list|(
name|prefix
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
comment|//we need to add the new mapping
name|saveNamespaceConfig
argument_list|()
expr_stmt|;
comment|//save the configuration
comment|// (TODO: we do not make a flush here ... so maybe we need to ensure that a flush is called sometimes)
block|}
return|return
name|prefix
return|;
comment|//may return null if !create
block|}
specifier|private
name|String
name|createPrefix
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|prefixMap
parameter_list|)
block|{
name|String
name|defaultPrefix
decl_stmt|;
do|do
block|{
comment|//as long an prefix is not any of the default prefixes or one of the prefixes defined by NamespaceEnum
name|defaultNsPrefixNumber
operator|++
expr_stmt|;
name|defaultPrefix
operator|=
name|DEFAULT_NS_PREFIX_STRING
operator|+
name|defaultNsPrefixNumber
expr_stmt|;
block|}
do|while
condition|(
name|prefixMap
operator|.
name|containsKey
argument_list|(
name|defaultPrefix
argument_list|)
operator|||
name|NamespaceEnum
operator|.
name|forPrefix
argument_list|(
name|defaultPrefix
argument_list|)
operator|!=
literal|null
condition|)
do|;
return|return
name|defaultPrefix
return|;
block|}
specifier|private
name|void
name|addNamespaceMapping
parameter_list|(
name|String
name|prefix
parameter_list|,
name|String
name|namespace
parameter_list|)
block|{
name|getPrefixMap
argument_list|()
operator|.
name|put
argument_list|(
name|prefix
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
name|getNamespaceMap
argument_list|()
operator|.
name|put
argument_list|(
name|namespace
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
block|}
comment|/**      * Leads the prefix to namespace mappings from the configured Solr server      * and inits the two mapps holding the prefix&lt;-&gt; namespace mappings      */
specifier|private
name|void
name|loadNamespaceConfig
parameter_list|()
block|{
name|__prefixMap
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|__namespaceMap
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|SolrDocument
name|config
init|=
literal|null
decl_stmt|;
try|try
block|{
name|config
operator|=
name|getSolrDocument
argument_list|(
name|FieldMapper
operator|.
name|URI
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Unable to load PathField Config from Index. (may be OK for the first run!)"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Unable to load PathField Config from Index. (may be OK for the first run!)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|config
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"No PathFieldMapping Configuration present. Start with an empty mapping"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|String
name|fieldName
range|:
name|config
operator|.
name|getFieldNames
argument_list|()
control|)
block|{
name|String
index|[]
name|configFieldElements
init|=
name|fieldName
operator|.
name|split
argument_list|(
name|Character
operator|.
name|toString
argument_list|(
name|SolrConst
operator|.
name|PATH_SEPERATOR
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|SPECIAL_CONFIG_FIELD
operator|.
name|equals
argument_list|(
name|configFieldElements
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|SPECIAL_CONFIG_FIELD
operator|.
name|length
argument_list|()
operator|>
literal|1
condition|)
block|{
name|String
name|prefix
init|=
name|configFieldElements
index|[
literal|1
index|]
decl_stmt|;
name|Object
name|value
init|=
name|config
operator|.
name|getFieldValue
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|__namespaceMap
operator|.
name|containsKey
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"found two prefixes ("
operator|+
name|__namespaceMap
operator|.
name|get
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
operator|+
literal|" and "
operator|+
name|prefix
operator|+
literal|") for Namespace "
operator|+
name|value
operator|.
name|toString
argument_list|()
operator|+
literal|" keep the first one"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"> prefix: "
operator|+
name|prefix
operator|+
literal|" value: "
operator|+
name|value
argument_list|)
expr_stmt|;
name|__prefixMap
operator|.
name|put
argument_list|(
name|prefix
argument_list|,
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|__namespaceMap
operator|.
name|put
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
comment|//check for default NS
if|if
condition|(
name|prefix
operator|.
name|startsWith
argument_list|(
name|DEFAULT_NS_PREFIX_STRING
argument_list|)
condition|)
block|{
name|String
name|prefixNumber
init|=
name|prefix
operator|.
name|substring
argument_list|(
name|DEFAULT_NS_PREFIX_STRING
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|int
name|num
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|prefixNumber
argument_list|)
decl_stmt|;
if|if
condition|(
name|num
operator|>
name|defaultNsPrefixNumber
condition|)
block|{
name|defaultNsPrefixNumber
operator|=
name|num
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to parse Integer for Number part of default prefix "
operator|+
name|prefix
operator|+
literal|" (this is OK if by accident an other Namespace prefix starts with '"
operator|+
name|DEFAULT_NS_PREFIX_STRING
operator|+
literal|"')"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"No value for prefix "
operator|+
name|prefix
operator|+
literal|" found in the Configuration (Field Name: "
operator|+
name|fieldName
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"encountered wrong Formatted Config field "
operator|+
name|fieldName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
specifier|private
name|String
name|getConfigFieldName
parameter_list|(
name|String
name|configName
parameter_list|)
block|{
return|return
name|SPECIAL_CONFIG_FIELD
operator|+
name|PATH_SEPERATOR
operator|+
name|configName
return|;
block|}
comment|/**      * Saves the current configuration to the index!      */
specifier|private
name|void
name|saveNamespaceConfig
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|prefixMap
init|=
name|getPrefixMap
argument_list|()
decl_stmt|;
name|SolrInputDocument
name|inputDoc
init|=
operator|new
name|SolrInputDocument
argument_list|()
decl_stmt|;
name|inputDoc
operator|.
name|addField
argument_list|(
name|getDocumentIdField
argument_list|()
argument_list|,
name|FieldMapper
operator|.
name|URI
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|prefixMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|inputDoc
operator|.
name|addField
argument_list|(
name|getConfigFieldName
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|server
operator|.
name|add
argument_list|(
name|inputDoc
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Unable save Configuration to SolrProvider"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrServerException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Unable save Configuration to SolrProvider"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SolrException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Unable save Configuration to SolrProvider"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Getter for a SolrDocument based on the ID. Used to load the config from      * the index.      * @param inputDoc the document to store      */
specifier|protected
name|SolrDocument
name|getSolrDocument
parameter_list|(
name|String
name|uri
parameter_list|)
throws|throws
name|SolrServerException
throws|,
name|IOException
block|{
name|SolrQuery
name|solrQuery
init|=
operator|new
name|SolrQuery
argument_list|()
decl_stmt|;
name|solrQuery
operator|.
name|addField
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
comment|//select all fields
name|solrQuery
operator|.
name|setRows
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|//we query for the id, there is only one result
name|String
name|queryString
init|=
name|String
operator|.
name|format
argument_list|(
literal|"%s:%s"
argument_list|,
name|this
operator|.
name|getDocumentIdField
argument_list|()
argument_list|,
name|SolrUtil
operator|.
name|escapeSolrSpecialChars
argument_list|(
name|uri
argument_list|)
argument_list|)
decl_stmt|;
name|solrQuery
operator|.
name|setQuery
argument_list|(
name|queryString
argument_list|)
expr_stmt|;
name|QueryResponse
name|queryResponse
init|=
name|server
operator|.
name|query
argument_list|(
name|solrQuery
argument_list|)
decl_stmt|;
if|if
condition|(
name|queryResponse
operator|.
name|getResults
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|queryResponse
operator|.
name|getResults
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|getDocumentDomainField
parameter_list|()
block|{
return|return
name|DOMAIN_FIELD
return|;
block|}
block|}
end_class

end_unit

