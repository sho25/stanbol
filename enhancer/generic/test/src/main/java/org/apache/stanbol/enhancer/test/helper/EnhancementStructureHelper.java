begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|test
operator|.
name|helper
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|OntologicalClasses
operator|.
name|DBPEDIA_ORGANISATION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|OntologicalClasses
operator|.
name|DBPEDIA_PERSON
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|OntologicalClasses
operator|.
name|DBPEDIA_PLACE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|DC_LANGUAGE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|DC_RELATION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|DC_TYPE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|ENHANCER_END
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|ENHANCER_ENTITY_LABEL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|ENHANCER_ENTITY_REFERENCE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|ENHANCER_SELECTED_TEXT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|ENHANCER_SELECTION_CONTEXT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|ENHANCER_START
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|RDF_TYPE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|TechnicalClasses
operator|.
name|DCTERMS_LINGUISTIC_SYSTEM
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|TechnicalClasses
operator|.
name|ENHANCER_ENHANCEMENT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|TechnicalClasses
operator|.
name|ENHANCER_ENTITYANNOTATION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|TechnicalClasses
operator|.
name|ENHANCER_TEXTANNOTATION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|TechnicalClasses
operator|.
name|ENHANCER_TOPICANNOTATION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertFalse
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertNotNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Literal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|LiteralFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|MGraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|NonLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|PlainLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Triple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|TripleCollection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|TypedLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|UriRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|ontologies
operator|.
name|DCTERMS
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|ontologies
operator|.
name|XSD
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|EnhancementEngine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|EnhancementEngineHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|OntologicalClasses
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|TechnicalClasses
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|TechnicalClasses
operator|.
name|CONFIDENCE_LEVEL_ENUM
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import

begin_class
specifier|public
specifier|final
class|class
name|EnhancementStructureHelper
block|{
comment|/**     * Restrict instantiation     */
specifier|private
name|EnhancementStructureHelper
parameter_list|()
block|{}
specifier|private
specifier|static
specifier|final
name|LiteralFactory
name|lf
init|=
name|LiteralFactory
operator|.
name|getInstance
argument_list|()
decl_stmt|;
comment|/**      * Validates all TextAnnotations contained in the parsed enhancement graph      * @param enhancements the enhancement graph      * @param content the enhanced content      * @param expectedValues the expected values of all validated EntityAnnotations.      * Properties are used as keys. Typical example would be fise:extracted-from      * with the id of the ContentItem as value; dc-terms:creator with the      * {@link Class#getName()} as value.      * @return the number of found TextAnnotations      */
specifier|public
specifier|static
name|int
name|validateAllTextAnnotations
parameter_list|(
name|TripleCollection
name|enhancements
parameter_list|,
name|String
name|content
parameter_list|,
name|Map
argument_list|<
name|UriRef
argument_list|,
name|Resource
argument_list|>
name|expectedValues
parameter_list|)
block|{
return|return
name|validateAllTextAnnotations
argument_list|(
name|enhancements
argument_list|,
name|content
argument_list|,
name|expectedValues
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Validates all TextAnnotations contained in the parsed enhancement graph.      * If<code>validatePrefixSuffix</code> is      * enabled the fise:selection-prefix and fise:selection-suffix (as defined by      *<a href="https://issues.apache.org/jira/browse/STANBOL-987">STANBOL-987</a>      * are enforced and validated. If disabled those properties are not enforced but still      * validated when present.      * @param enhancements the enhancement graph      * @param content the enhanced content      * @param expectedValues the expected values of all validated EntityAnnotations.      * Properties are used as keys. Typical example would be fise:extracted-from      * with the id of the ContentItem as value; dc-terms:creator with the      * {@link Class#getName()} as value.      * @param validatePrefixSuffix enforce the presence of fise:selection-prefix and       * fise:selection-suffix if fise:start and fise:end are set.      * @return the number of found TextAnnotations      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|static
name|int
name|validateAllTextAnnotations
parameter_list|(
name|TripleCollection
name|enhancements
parameter_list|,
name|String
name|content
parameter_list|,
name|Map
argument_list|<
name|UriRef
argument_list|,
name|Resource
argument_list|>
name|expectedValues
parameter_list|,
name|boolean
name|validatePrefixSuffix
parameter_list|)
block|{
name|expectedValues
operator|=
name|expectedValues
operator|==
literal|null
condition|?
name|Collections
operator|.
name|EMPTY_MAP
else|:
name|expectedValues
expr_stmt|;
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|textAnnotationIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
literal|null
argument_list|,
name|RDF_TYPE
argument_list|,
name|ENHANCER_TEXTANNOTATION
argument_list|)
decl_stmt|;
comment|// test if a textAnnotation is present
comment|//assertTrue(textAnnotationIterator.hasNext());
comment|//  -> this might be used to test that there are no TextAnnotations
name|int
name|textAnnotationCount
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|textAnnotationIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|UriRef
name|textAnnotation
init|=
operator|(
name|UriRef
operator|)
name|textAnnotationIterator
operator|.
name|next
argument_list|()
operator|.
name|getSubject
argument_list|()
decl_stmt|;
comment|// test if selected Text is added
name|validateTextAnnotation
argument_list|(
name|enhancements
argument_list|,
name|textAnnotation
argument_list|,
name|content
argument_list|,
name|expectedValues
argument_list|,
name|validatePrefixSuffix
argument_list|)
expr_stmt|;
name|textAnnotationCount
operator|++
expr_stmt|;
block|}
return|return
name|textAnnotationCount
return|;
block|}
comment|/**      * Validates the parsed TextAnnotation with a fise:selected-text. This      * method also validates rules defined by fise:Enhancement by calling      * {@link #validateEnhancement(TripleCollection, UriRef, Map)}<p>      * NOTE: this method MUST NOT be used to validate fise:TextAnnotations that      * do NOT select a part of the text - meaning TextAnnotations about the      * whole parsed content.      * @param enhancements the enhancements graph containing the text annotation      * @param textAnnotation the TextAnnotation to validate      * @param content the enhanced content      * @param expectedValues expected values (properties for the values are used as keys)      */
specifier|public
specifier|static
name|void
name|validateTextAnnotation
parameter_list|(
name|TripleCollection
name|enhancements
parameter_list|,
name|UriRef
name|textAnnotation
parameter_list|,
name|String
name|content
parameter_list|,
name|Map
argument_list|<
name|UriRef
argument_list|,
name|Resource
argument_list|>
name|expectedValues
parameter_list|)
block|{
name|validateTextAnnotation
argument_list|(
name|enhancements
argument_list|,
name|textAnnotation
argument_list|,
name|content
argument_list|,
name|expectedValues
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Validates fise:TextAnnotations. If<code>validatePrefixSuffix</code> is      * enabled the fise:selection-prefix and fise:selection-suffix (as defined by      *<a href="https://issues.apache.org/jira/browse/STANBOL-987">STANBOL-987</a>      * are enforced and validated. If disabled those properties are not enforced but still      * validated when present.      * @param enhancements the enhancements graph containing the text annotation      * @param textAnnotation the TextAnnotation to validate      * @param content the enhanced content      * @param expectedValues expected values (properties for the values are used as keys)      * @param validatePrefixSuffix enforce the presence of fise:selection-prefix and       * fise:selection-suffix if fise:start and fise:end are set.      */
specifier|public
specifier|static
name|void
name|validateTextAnnotation
parameter_list|(
name|TripleCollection
name|enhancements
parameter_list|,
name|UriRef
name|textAnnotation
parameter_list|,
name|String
name|content
parameter_list|,
name|Map
argument_list|<
name|UriRef
argument_list|,
name|Resource
argument_list|>
name|expectedValues
parameter_list|,
name|boolean
name|validatePrefixSuffix
parameter_list|)
block|{
comment|//validate the rdf:type
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|rdfTypeIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|textAnnotation
argument_list|,
name|RDF_TYPE
argument_list|,
name|ENHANCER_TEXTANNOTATION
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Parsed Enhancement "
operator|+
name|textAnnotation
operator|+
literal|" is missing the fise:TextAnnotation type "
argument_list|,
name|rdfTypeIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|selectedTextIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|textAnnotation
argument_list|,
name|ENHANCER_SELECTED_TEXT
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// check if the selected text is added (or not)
name|Resource
name|selectedTextResource
decl_stmt|;
if|if
condition|(
name|selectedTextIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// test if the selected text is part of the TEXT_TO_TEST
name|selectedTextResource
operator|=
name|selectedTextIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
literal|"fise:selected-text MUST BE of type PlainLiteral (uri: "
operator|+
name|textAnnotation
operator|+
literal|")"
argument_list|,
name|selectedTextResource
operator|instanceof
name|PlainLiteral
argument_list|)
expr_stmt|;
name|Literal
name|selectedText
init|=
operator|(
name|Literal
operator|)
name|selectedTextResource
decl_stmt|;
name|assertTrue
argument_list|(
literal|"The parsed content MUST contain the fise:selected-text value '"
operator|+
name|selectedText
operator|.
name|getLexicalForm
argument_list|()
operator|+
literal|"' (uri: "
operator|+
name|textAnnotation
operator|+
literal|")!"
argument_list|,
name|content
operator|.
name|contains
argument_list|(
name|selectedText
operator|.
name|getLexicalForm
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertFalse
argument_list|(
literal|"fise:selected-text MUST be single valued (uri: "
operator|+
name|textAnnotation
operator|+
literal|")"
argument_list|,
name|selectedTextIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|selectedTextResource
operator|=
literal|null
expr_stmt|;
comment|//no selected text
block|}
comment|//check against an expected value
name|Resource
name|expectedSelectedText
init|=
name|expectedValues
operator|.
name|get
argument_list|(
name|ENHANCER_SELECTED_TEXT
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectedSelectedText
operator|!=
literal|null
condition|)
block|{
name|assertEquals
argument_list|(
literal|"The fise:selected-text is not the expected value "
operator|+
name|expectedSelectedText
operator|+
literal|" (uri: "
operator|+
name|textAnnotation
operator|+
literal|")!"
argument_list|,
name|expectedSelectedText
argument_list|,
name|selectedTextResource
argument_list|)
expr_stmt|;
block|}
comment|//check for fise:selection-head and fise:selection-tail (STANBOL-987)
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|selectionHeadIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|textAnnotation
argument_list|,
name|Properties
operator|.
name|ENHANCER_SELECTION_HEAD
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|selectedTextResource
operator|!=
literal|null
condition|)
block|{
name|Assert
operator|.
name|assertFalse
argument_list|(
literal|"If fise:selected-text is present fise:selection-head MUST NOT be present"
argument_list|,
name|selectionHeadIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Resource
name|selectionHeadResource
decl_stmt|;
if|if
condition|(
name|selectionHeadIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// test if the selected text is part of the TEXT_TO_TEST
name|selectionHeadResource
operator|=
name|selectionHeadIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
literal|"fise:selection-head MUST BE of type PlainLiteral (uri: "
operator|+
name|textAnnotation
operator|+
literal|")"
argument_list|,
name|selectionHeadResource
operator|instanceof
name|PlainLiteral
argument_list|)
expr_stmt|;
name|Literal
name|selectionHeadText
init|=
operator|(
name|Literal
operator|)
name|selectionHeadResource
decl_stmt|;
name|assertTrue
argument_list|(
literal|"The parsed content MUST contain the fise:selected-head value '"
operator|+
name|selectionHeadText
operator|.
name|getLexicalForm
argument_list|()
operator|+
literal|"' (uri: "
operator|+
name|textAnnotation
operator|+
literal|")!"
argument_list|,
name|content
operator|.
name|contains
argument_list|(
name|selectionHeadText
operator|.
name|getLexicalForm
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertFalse
argument_list|(
literal|"fise:selection-head MUST be single valued (uri: "
operator|+
name|textAnnotation
operator|+
literal|")"
argument_list|,
name|selectionHeadIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|selectionHeadResource
operator|=
literal|null
expr_stmt|;
block|}
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|selectionTailIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|textAnnotation
argument_list|,
name|Properties
operator|.
name|ENHANCER_SELECTION_TAIL
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|selectedTextResource
operator|!=
literal|null
condition|)
block|{
name|Assert
operator|.
name|assertFalse
argument_list|(
literal|"If fise:selected-text is present fise:selection-tail MUST NOT be present"
argument_list|,
name|selectionTailIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Resource
name|selectionTailResource
decl_stmt|;
if|if
condition|(
name|selectionTailIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// test if the selected text is part of the TEXT_TO_TEST
name|selectionTailResource
operator|=
name|selectionTailIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
literal|"fise:selection-head MUST BE of type PlainLiteral (uri: "
operator|+
name|textAnnotation
operator|+
literal|")"
argument_list|,
name|selectionTailResource
operator|instanceof
name|PlainLiteral
argument_list|)
expr_stmt|;
name|Literal
name|selectionTailText
init|=
operator|(
name|Literal
operator|)
name|selectionTailResource
decl_stmt|;
name|assertTrue
argument_list|(
literal|"The parsed content MUST contain the fise:selected-tail value '"
operator|+
name|selectionTailText
operator|.
name|getLexicalForm
argument_list|()
operator|+
literal|"' (uri: "
operator|+
name|textAnnotation
operator|+
literal|")!"
argument_list|,
name|content
operator|.
name|contains
argument_list|(
name|selectionTailText
operator|.
name|getLexicalForm
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertFalse
argument_list|(
literal|"fise:selection-tail MUST be single valued (uri: "
operator|+
name|textAnnotation
operator|+
literal|")"
argument_list|,
name|selectionTailIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|selectionTailResource
operator|=
literal|null
expr_stmt|;
block|}
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"Both fise:selection-tail AND fise:selection-head MUST BE defined "
operator|+
literal|"(if one of them is present) (uri: "
operator|+
name|textAnnotation
operator|+
literal|")"
argument_list|,
operator|(
name|selectionHeadResource
operator|!=
literal|null
operator|&&
name|selectionTailResource
operator|!=
literal|null
operator|)
operator|||
operator|(
name|selectionHeadResource
operator|==
literal|null
operator|&&
name|selectionTailResource
operator|==
literal|null
operator|)
argument_list|)
expr_stmt|;
name|Resource
name|selectionContextResource
decl_stmt|;
comment|// test if context is added
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|selectionContextIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|textAnnotation
argument_list|,
name|ENHANCER_SELECTION_CONTEXT
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|selectionContextIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|//context is optional
comment|//selection context is not allowed without selected-text
name|assertTrue
argument_list|(
literal|"If fise:selection-context is present also fise:selected-text or fise:selection-head and fise:selection-tail MUST BE present (uri: "
operator|+
name|textAnnotation
operator|+
literal|")"
argument_list|,
name|selectedTextResource
operator|!=
literal|null
operator|||
operator|(
name|selectionHeadResource
operator|!=
literal|null
operator|&&
name|selectionTailResource
operator|!=
literal|null
operator|)
argument_list|)
expr_stmt|;
comment|// test if the selected text is part of the TEXT_TO_TEST
name|selectionContextResource
operator|=
name|selectionContextIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
literal|"The fise:selection-context MUST BE of type PlainLiteral (uri: "
operator|+
name|textAnnotation
operator|+
literal|")"
argument_list|,
name|selectionContextResource
operator|instanceof
name|PlainLiteral
argument_list|)
expr_stmt|;
comment|//check that the content contains the context
name|assertTrue
argument_list|(
literal|"The fise:selection-context MUST BE contained in the Content | context= "
operator|+
name|selectionContextResource
argument_list|,
name|content
operator|.
name|contains
argument_list|(
operator|(
operator|(
name|Literal
operator|)
name|selectionContextResource
operator|)
operator|.
name|getLexicalForm
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|//check that the context contains the selected text
if|if
condition|(
name|selectedTextResource
operator|!=
literal|null
condition|)
block|{
name|assertTrue
argument_list|(
literal|"The fise:selected-text value MUST BE containted within the fise:selection-context value"
argument_list|,
operator|(
operator|(
name|Literal
operator|)
name|selectionContextResource
operator|)
operator|.
name|getLexicalForm
argument_list|()
operator|.
name|contains
argument_list|(
operator|(
operator|(
name|Literal
operator|)
name|selectedTextResource
operator|)
operator|.
name|getLexicalForm
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|selectionHeadResource
operator|!=
literal|null
condition|)
block|{
name|assertTrue
argument_list|(
literal|"The fise:selection-head value MUST BE containted within the fise:selection-context value"
argument_list|,
operator|(
operator|(
name|Literal
operator|)
name|selectionContextResource
operator|)
operator|.
name|getLexicalForm
argument_list|()
operator|.
name|contains
argument_list|(
operator|(
operator|(
name|Literal
operator|)
name|selectionHeadResource
operator|)
operator|.
name|getLexicalForm
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|selectionTailResource
operator|!=
literal|null
condition|)
block|{
name|assertTrue
argument_list|(
literal|"The fise:selection-tail value MUST BE containted within the fise:selection-context value"
argument_list|,
operator|(
operator|(
name|Literal
operator|)
name|selectionContextResource
operator|)
operator|.
name|getLexicalForm
argument_list|()
operator|.
name|contains
argument_list|(
operator|(
operator|(
name|Literal
operator|)
name|selectionTailResource
operator|)
operator|.
name|getLexicalForm
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|assertNull
argument_list|(
literal|"If no fise:selection-context is present also fise:selected-text MUST BE NOT present!"
argument_list|,
name|selectedTextResource
argument_list|)
expr_stmt|;
name|selectionContextResource
operator|=
literal|null
expr_stmt|;
block|}
name|Resource
name|expectedSelectionContext
init|=
name|expectedValues
operator|.
name|get
argument_list|(
name|ENHANCER_SELECTION_CONTEXT
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectedSelectionContext
operator|!=
literal|null
condition|)
block|{
name|assertEquals
argument_list|(
literal|"The value of fise:selection-context has not the expected value "
operator|+
name|expectedSelectionContext
argument_list|,
name|expectedSelectionContext
argument_list|,
name|selectionContextResource
argument_list|)
expr_stmt|;
block|}
comment|//test start/end if present
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|startPosIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|textAnnotation
argument_list|,
name|ENHANCER_START
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|endPosIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|textAnnotation
argument_list|,
name|ENHANCER_END
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|//start end is optional, but if start is present, that also end needs to be set
name|TypedLiteral
name|startPosLiteral
decl_stmt|;
name|TypedLiteral
name|endPosLiteral
decl_stmt|;
if|if
condition|(
name|startPosIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|//NOTE: TextAnnotations might be use to select whole sections of a text
comment|//      (e.g. see STANBOL-617) in those cases adding the text of the
comment|//      whole section is not feasible.
comment|//assertNotNull("If fise:start is present the fise:selection-context MUST also be present (uri: "+textAnnotation+")!",
comment|//    selectionContextResource);
name|Resource
name|resource
init|=
name|startPosIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
comment|//only a single start position is supported
name|assertFalse
argument_list|(
literal|"fise:start MUST HAVE only a single value (uri: "
operator|+
name|textAnnotation
operator|+
literal|")!"
argument_list|,
name|startPosIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"fise:start MUST be a typed Literal (uri: "
operator|+
name|textAnnotation
operator|+
literal|")!"
argument_list|,
name|resource
operator|instanceof
name|TypedLiteral
argument_list|)
expr_stmt|;
name|startPosLiteral
operator|=
operator|(
name|TypedLiteral
operator|)
name|resource
expr_stmt|;
name|assertEquals
argument_list|(
literal|"fise:start MUST use xsd:int as data type (uri: "
operator|+
name|textAnnotation
operator|+
literal|")"
argument_list|,
name|XSD
operator|.
name|int_
argument_list|,
name|startPosLiteral
operator|.
name|getDataType
argument_list|()
argument_list|)
expr_stmt|;
name|resource
operator|=
literal|null
expr_stmt|;
name|Integer
name|start
init|=
name|LiteralFactory
operator|.
name|getInstance
argument_list|()
operator|.
name|createObject
argument_list|(
name|Integer
operator|.
name|class
argument_list|,
name|startPosLiteral
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"Unable to parse Integer from TypedLiteral "
operator|+
name|startPosLiteral
argument_list|,
name|start
argument_list|)
expr_stmt|;
comment|//now get the end
comment|//end must be defined if start is present
name|assertTrue
argument_list|(
literal|"If fise:start is present also fise:end MUST BE defined (uri: "
operator|+
name|textAnnotation
operator|+
literal|")!"
argument_list|,
name|endPosIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|resource
operator|=
name|endPosIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
expr_stmt|;
comment|//only a single end position is supported
name|assertFalse
argument_list|(
literal|"fise:end MUST HAVE only a single value (uri: "
operator|+
name|textAnnotation
operator|+
literal|")!"
argument_list|,
name|endPosIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"fise:end values MUST BE TypedLiterals (uri: "
operator|+
name|textAnnotation
operator|+
literal|")"
argument_list|,
name|resource
operator|instanceof
name|TypedLiteral
argument_list|)
expr_stmt|;
name|endPosLiteral
operator|=
operator|(
name|TypedLiteral
operator|)
name|resource
expr_stmt|;
name|assertEquals
argument_list|(
literal|"fise:end MUST use xsd:int as data type (uri: "
operator|+
name|textAnnotation
operator|+
literal|")"
argument_list|,
name|XSD
operator|.
name|int_
argument_list|,
name|endPosLiteral
operator|.
name|getDataType
argument_list|()
argument_list|)
expr_stmt|;
name|resource
operator|=
literal|null
expr_stmt|;
name|Integer
name|end
init|=
name|LiteralFactory
operator|.
name|getInstance
argument_list|()
operator|.
name|createObject
argument_list|(
name|Integer
operator|.
name|class
argument_list|,
name|endPosLiteral
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"Unable to parse Integer from TypedLiteral "
operator|+
name|endPosLiteral
argument_list|,
name|end
argument_list|)
expr_stmt|;
comment|//check for equality of the selected text and the text on the selected position in the content
comment|//System.out.println("TA ["+start+"|"+end+"]"+selectedText.getLexicalForm()+"<->"+content.substring(start,end));
if|if
condition|(
name|selectedTextResource
operator|!=
literal|null
condition|)
block|{
name|assertEquals
argument_list|(
literal|"the substring [fise:start,fise:end] does not correspond to "
operator|+
literal|"the fise:selected-text value '"
operator|+
operator|(
operator|(
name|Literal
operator|)
name|selectedTextResource
operator|)
operator|.
name|getLexicalForm
argument_list|()
operator|+
literal|"' of this TextAnnotation!"
argument_list|,
name|content
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
argument_list|,
operator|(
operator|(
name|Literal
operator|)
name|selectedTextResource
operator|)
operator|.
name|getLexicalForm
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// else no selected-text present ... unable to test this
block|}
else|else
block|{
name|assertNull
argument_list|(
literal|"if fise:selected-text is present also fise:start AND fise:end MUST BE present!"
argument_list|,
name|selectedTextResource
argument_list|)
expr_stmt|;
name|assertNull
argument_list|(
literal|"If fise:selection-context is present also fise:start AND fise:end MUST BE present!"
argument_list|,
name|selectionContextResource
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"if fise:end is presnet also fise:start AND fise:selection-context MUST BE present!"
argument_list|,
name|endPosIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|startPosLiteral
operator|=
literal|null
expr_stmt|;
name|endPosLiteral
operator|=
literal|null
expr_stmt|;
block|}
name|Resource
name|expectedStartPos
init|=
name|expectedValues
operator|.
name|get
argument_list|(
name|ENHANCER_START
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectedStartPos
operator|!=
literal|null
condition|)
block|{
name|assertEquals
argument_list|(
literal|"The fise:start value is not the expected "
operator|+
name|expectedStartPos
argument_list|,
name|expectedStartPos
argument_list|,
name|startPosLiteral
argument_list|)
expr_stmt|;
block|}
name|Resource
name|expectedEndPos
init|=
name|expectedValues
operator|.
name|get
argument_list|(
name|ENHANCER_END
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectedEndPos
operator|!=
literal|null
condition|)
block|{
name|assertEquals
argument_list|(
literal|"The fise:end value is not the expected "
operator|+
name|expectedEndPos
argument_list|,
name|expectedEndPos
argument_list|,
name|endPosLiteral
argument_list|)
expr_stmt|;
block|}
comment|//fise:selection-prefix and fise:selection-suffix (STANBOL-987)
name|Literal
name|prefixLiteral
decl_stmt|;
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|selectionPrefixIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|textAnnotation
argument_list|,
name|Properties
operator|.
name|ENHANCER_SELECTION_PREFIX
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|startPosLiteral
operator|!=
literal|null
condition|)
block|{
comment|// check if the selectionPrefix text is present
name|assertTrue
argument_list|(
literal|"fise:selection-prefix property is missing for fise:TextAnnotation "
operator|+
name|textAnnotation
argument_list|,
name|selectionPrefixIterator
operator|.
name|hasNext
argument_list|()
operator|||
operator|!
name|validatePrefixSuffix
argument_list|)
expr_stmt|;
comment|//to support old and new fise:TextAnnotation model
comment|// test if the selected text is part of the TEXT_TO_TEST
if|if
condition|(
name|selectionPrefixIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Resource
name|selectionPrefixResource
init|=
name|selectionPrefixIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"fise:selection-prefix MUST BE of type PlainLiteral (uri: "
operator|+
name|textAnnotation
operator|+
literal|")"
argument_list|,
name|selectionPrefixResource
operator|instanceof
name|PlainLiteral
argument_list|)
expr_stmt|;
name|prefixLiteral
operator|=
operator|(
name|Literal
operator|)
name|selectionPrefixResource
expr_stmt|;
name|assertTrue
argument_list|(
literal|"The parsed content MUST contain the fise:selection-prefix value '"
operator|+
name|prefixLiteral
operator|.
name|getLexicalForm
argument_list|()
operator|+
literal|"' (uri: "
operator|+
name|textAnnotation
operator|+
literal|")!"
argument_list|,
name|content
operator|.
name|contains
argument_list|(
name|prefixLiteral
operator|.
name|getLexicalForm
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"fise:selection-prefix MUST BE single valued (uri: "
operator|+
name|textAnnotation
operator|+
literal|")!"
argument_list|,
name|selectionPrefixIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prefixLiteral
operator|=
literal|null
expr_stmt|;
block|}
block|}
else|else
block|{
name|prefixLiteral
operator|=
literal|null
expr_stmt|;
block|}
name|Literal
name|suffixLiteral
decl_stmt|;
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|selectionSuffixIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|textAnnotation
argument_list|,
name|Properties
operator|.
name|ENHANCER_SELECTION_SUFFIX
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|endPosLiteral
operator|!=
literal|null
condition|)
block|{
comment|// check if the selectionPrefix text is present
name|assertTrue
argument_list|(
literal|"fise:selection-suffix property is missing for fise:TextAnnotation "
operator|+
name|textAnnotation
argument_list|,
name|selectionSuffixIterator
operator|.
name|hasNext
argument_list|()
operator|||
operator|!
name|validatePrefixSuffix
argument_list|)
expr_stmt|;
comment|//to support old and new fise:TextAnnotation model
if|if
condition|(
name|selectionSuffixIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// test if the selected text is part of the TEXT_TO_TEST
name|Resource
name|selectionSuffixResource
init|=
name|selectionSuffixIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"fise:selection-suffix MUST BE of type PlainLiteral (uri: "
operator|+
name|textAnnotation
operator|+
literal|")"
argument_list|,
name|selectionSuffixResource
operator|instanceof
name|PlainLiteral
argument_list|)
expr_stmt|;
name|suffixLiteral
operator|=
operator|(
name|Literal
operator|)
name|selectionSuffixResource
expr_stmt|;
name|assertTrue
argument_list|(
literal|"The parsed content MUST contain the fise:selection-suffix value '"
operator|+
name|suffixLiteral
operator|.
name|getLexicalForm
argument_list|()
operator|+
literal|"' (uri: "
operator|+
name|textAnnotation
operator|+
literal|")!"
argument_list|,
name|content
operator|.
name|contains
argument_list|(
name|suffixLiteral
operator|.
name|getLexicalForm
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"fise:selection-suffix MUST BE single valued (uri: "
operator|+
name|textAnnotation
operator|+
literal|")!"
argument_list|,
name|selectionSuffixIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|suffixLiteral
operator|=
literal|null
expr_stmt|;
block|}
block|}
else|else
block|{
name|suffixLiteral
operator|=
literal|null
expr_stmt|;
block|}
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"Both fise:selection-prefix AND fise:selection-suffix need to be present "
operator|+
literal|"(if one of them is present) (uri: "
operator|+
name|textAnnotation
operator|+
literal|")"
argument_list|,
operator|(
name|suffixLiteral
operator|!=
literal|null
operator|&&
name|prefixLiteral
operator|!=
literal|null
operator|)
operator|||
operator|(
name|suffixLiteral
operator|==
literal|null
operator|&&
name|prefixLiteral
operator|==
literal|null
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefixLiteral
operator|!=
literal|null
operator|&&
name|selectedTextResource
operator|!=
literal|null
condition|)
block|{
name|String
name|occurrence
init|=
name|prefixLiteral
operator|.
name|getLexicalForm
argument_list|()
operator|+
operator|(
operator|(
name|Literal
operator|)
name|selectedTextResource
operator|)
operator|.
name|getLexicalForm
argument_list|()
operator|+
name|suffixLiteral
operator|.
name|getLexicalForm
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"The parsed content MUST contain the concated value of fise:selection-prefix,"
operator|+
literal|"fise:selected-text and fise:selection-suffix (value: '"
operator|+
name|occurrence
operator|+
literal|"' (uri: "
operator|+
name|textAnnotation
operator|+
literal|")!"
argument_list|,
name|content
operator|.
name|contains
argument_list|(
name|occurrence
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prefixLiteral
operator|!=
literal|null
operator|&&
name|selectionHeadResource
operator|!=
literal|null
condition|)
block|{
name|String
name|occurrence
init|=
name|prefixLiteral
operator|.
name|getLexicalForm
argument_list|()
operator|+
operator|(
operator|(
name|Literal
operator|)
name|selectionHeadResource
operator|)
operator|.
name|getLexicalForm
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"The parsed content MUST contain the concated value of fise:selection-prefix,"
operator|+
literal|"fise:selection-head (value: '"
operator|+
name|occurrence
operator|+
literal|"' (uri: "
operator|+
name|textAnnotation
operator|+
literal|")!"
argument_list|,
name|content
operator|.
name|contains
argument_list|(
name|occurrence
argument_list|)
argument_list|)
expr_stmt|;
name|occurrence
operator|=
operator|(
operator|(
name|Literal
operator|)
name|selectionTailResource
operator|)
operator|.
name|getLexicalForm
argument_list|()
operator|+
name|suffixLiteral
operator|.
name|getLexicalForm
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
literal|"The parsed content MUST contain the concated value of fise:selection-tail "
operator|+
literal|"and fise:selection-suffix (value: '"
operator|+
name|occurrence
operator|+
literal|"' (uri: "
operator|+
name|textAnnotation
operator|+
literal|")!"
argument_list|,
name|content
operator|.
name|contains
argument_list|(
name|occurrence
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//validate fise:Enhancement specific rules
name|validateEnhancement
argument_list|(
name|enhancements
argument_list|,
name|textAnnotation
argument_list|,
name|expectedValues
argument_list|)
expr_stmt|;
comment|//validate for special TextAnnotations
name|validateLanguageAnnotations
argument_list|(
name|enhancements
argument_list|,
name|textAnnotation
argument_list|)
expr_stmt|;
name|validateNERAnnotations
argument_list|(
name|enhancements
argument_list|,
name|textAnnotation
argument_list|,
name|selectedTextResource
argument_list|)
expr_stmt|;
block|}
comment|/**      * Validates the correctness of fise:TextAnnotations that annotate the language       * of the text as defined by       *<a href="https://issues.apache.org/jira/browse/STANBOL-613">STANBOL-613</a><p>      * Called by {@link #validateTextAnnotation(TripleCollection, UriRef, String, Map)}      * @param enhancements      * @param textAnnotation      */
specifier|private
specifier|static
name|void
name|validateLanguageAnnotations
parameter_list|(
name|TripleCollection
name|enhancements
parameter_list|,
name|UriRef
name|textAnnotation
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|dcLanguageIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|textAnnotation
argument_list|,
name|DC_LANGUAGE
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|dcLanguageIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|//a language annotation
name|Resource
name|dcLanguageResource
init|=
name|dcLanguageIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"The dc:language value MUST BE a PlainLiteral"
argument_list|,
name|dcLanguageResource
operator|instanceof
name|PlainLiteral
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"The dc:language value '"
operator|+
name|dcLanguageResource
operator|+
literal|"'MUST BE at least two chars long"
argument_list|,
operator|(
operator|(
name|Literal
operator|)
name|dcLanguageResource
operator|)
operator|.
name|getLexicalForm
argument_list|()
operator|.
name|length
argument_list|()
operator|>=
literal|2
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"TextAnnotations with the dc:language property MUST only have a single dc:language value (uri "
operator|+
name|textAnnotation
operator|+
literal|")"
argument_list|,
name|dcLanguageIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|dcTypeIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|textAnnotation
argument_list|,
name|DC_TYPE
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"TextAnnotations with the dc:language property MUST use dc:type dc:LinguisticSystem (uri "
operator|+
name|textAnnotation
operator|+
literal|")"
argument_list|,
name|dcTypeIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"TextAnnotations with the dc:language property MUST use dc:type dc:LinguisticSystem (uri "
operator|+
name|textAnnotation
operator|+
literal|")"
argument_list|,
name|DCTERMS_LINGUISTIC_SYSTEM
argument_list|,
name|dcTypeIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"TextAnnotations with the dc:language property MUST only have a single dc:type value (uri "
operator|+
name|textAnnotation
operator|+
literal|")"
argument_list|,
name|dcTypeIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
comment|//assert that the created TextAnnotation is correctly returned by the
comment|//EnhancementEngineHelper methods
name|List
argument_list|<
name|NonLiteral
argument_list|>
name|languageAnnotation
init|=
name|EnhancementEngineHelper
operator|.
name|getLanguageAnnotations
argument_list|(
name|enhancements
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Language annotation "
operator|+
name|textAnnotation
operator|+
literal|" was not returned by "
operator|+
literal|"EnhancementEngineHelper.getLanguageAnnotations(..)!"
argument_list|,
name|languageAnnotation
operator|.
name|contains
argument_list|(
name|textAnnotation
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//no language annotation
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|dcTypeIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|textAnnotation
argument_list|,
name|DC_TYPE
argument_list|,
literal|null
argument_list|)
decl_stmt|;
while|while
condition|(
name|dcTypeIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|assertFalse
argument_list|(
literal|"Only fise:TextAnnotations without a dc:language value MUST NOT use the "
operator|+
literal|"dc:type value dc:LinguisticSystem (uri "
operator|+
name|textAnnotation
operator|+
literal|")"
argument_list|,
name|DCTERMS_LINGUISTIC_SYSTEM
operator|.
name|equals
argument_list|(
name|dcTypeIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Validates that fise:TextAnnotations with the dc:type dbp-ont:Person,      * dbp-ont:Organisation and dbp-ont:Place do have a      * fise:selected-text value (this implicitly also checks that      * fise:selection-context, fise:start and fise:end are defined!<p>      * Called by {@link #validateTextAnnotation(TripleCollection, UriRef, String, Map)}      * @param enhancements      * @param textAnnotation      * @param selectedTextResource the fise:selected-text value      */
specifier|private
specifier|static
name|void
name|validateNERAnnotations
parameter_list|(
name|TripleCollection
name|enhancements
parameter_list|,
name|UriRef
name|textAnnotation
parameter_list|,
name|Resource
name|selectedTextResource
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|dcTypeIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|textAnnotation
argument_list|,
name|DC_TYPE
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|boolean
name|isNERAnnotation
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|dcTypeIterator
operator|.
name|hasNext
argument_list|()
operator|&&
operator|!
name|isNERAnnotation
condition|)
block|{
name|Resource
name|dcTypeValue
init|=
name|dcTypeIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|isNERAnnotation
operator|=
name|DBPEDIA_PERSON
operator|.
name|equals
argument_list|(
name|dcTypeValue
argument_list|)
operator|||
name|DBPEDIA_ORGANISATION
operator|.
name|equals
argument_list|(
name|dcTypeValue
argument_list|)
operator|||
name|DBPEDIA_PLACE
operator|.
name|equals
argument_list|(
name|dcTypeValue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isNERAnnotation
condition|)
block|{
name|assertNotNull
argument_list|(
literal|"fise:TextAnnotations with a dc:type of c:type dbp-ont:Person, "
operator|+
literal|"dbp-ont:Organisation or dbp-ont:Place MUST have a fise:selected-text value (uri "
operator|+
name|textAnnotation
operator|+
literal|")"
argument_list|,
name|selectedTextResource
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Validates all fise:EntityAnnotations contained by the parsed enhancements      * graph.      * @param enhancements the enhancement graph      * @param expectedValues the expected values of all validated EntityAnnotations.      * Properties are used as keys. Typical example would be fise:extracted-from      * with the id of the ContentItem as value; dc-terms:creator with the      * {@link Class#getName()} as value.      * @return the number of found and validated EntityAnnotations.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|static
name|int
name|validateAllEntityAnnotations
parameter_list|(
name|TripleCollection
name|enhancements
parameter_list|,
name|Map
argument_list|<
name|UriRef
argument_list|,
name|Resource
argument_list|>
name|expectedValues
parameter_list|)
block|{
name|expectedValues
operator|=
name|expectedValues
operator|==
literal|null
condition|?
name|Collections
operator|.
name|EMPTY_MAP
else|:
name|expectedValues
expr_stmt|;
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|entityAnnotationIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
literal|null
argument_list|,
name|RDF_TYPE
argument_list|,
name|ENHANCER_ENTITYANNOTATION
argument_list|)
decl_stmt|;
name|int
name|entityAnnotationCount
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|entityAnnotationIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|UriRef
name|entityAnnotation
init|=
operator|(
name|UriRef
operator|)
name|entityAnnotationIterator
operator|.
name|next
argument_list|()
operator|.
name|getSubject
argument_list|()
decl_stmt|;
comment|// test if selected Text is added
name|validateEntityAnnotation
argument_list|(
name|enhancements
argument_list|,
name|entityAnnotation
argument_list|,
name|expectedValues
argument_list|)
expr_stmt|;
name|entityAnnotationCount
operator|++
expr_stmt|;
block|}
return|return
name|entityAnnotationCount
return|;
block|}
comment|/**      * Checks if a fise:EntityAnnotation is valid. NOTE that this also validates      * all fise:Enhancement related requirements by calling      * {@link #validateEnhancement(TripleCollection, UriRef, Map)}      * @param enhancements the enhancements graph      * @param entityAnnotation the entity annotation to validate      * @param expectedValues expected values (properties for the values are used as keys)      */
specifier|public
specifier|static
name|void
name|validateEntityAnnotation
parameter_list|(
name|TripleCollection
name|enhancements
parameter_list|,
name|UriRef
name|entityAnnotation
parameter_list|,
name|Map
argument_list|<
name|UriRef
argument_list|,
name|Resource
argument_list|>
name|expectedValues
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|relationToTextAnnotationIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|entityAnnotation
argument_list|,
name|DC_RELATION
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// check if the relation to the text annotation is set
name|assertTrue
argument_list|(
name|relationToTextAnnotationIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
name|relationToTextAnnotationIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// test if the referred annotations are text annotations or
comment|// the referenced annotations is a fise:EntityAnnotation AND also a
comment|// dc:requires link is defined (STANBOL-766)
name|UriRef
name|referredTextAnnotation
init|=
operator|(
name|UriRef
operator|)
name|relationToTextAnnotationIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"fise:EntityAnnotations MUST BE dc:related to a fise:TextAnnotation OR dc:requires and dc:related to the same fise:EntityAnnotation"
argument_list|,
name|enhancements
operator|.
name|filter
argument_list|(
name|referredTextAnnotation
argument_list|,
name|RDF_TYPE
argument_list|,
name|ENHANCER_TEXTANNOTATION
argument_list|)
operator|.
name|hasNext
argument_list|()
operator|||
operator|(
name|enhancements
operator|.
name|filter
argument_list|(
name|referredTextAnnotation
argument_list|,
name|RDF_TYPE
argument_list|,
name|ENHANCER_ENTITYANNOTATION
argument_list|)
operator|.
name|hasNext
argument_list|()
operator|&&
name|enhancements
operator|.
name|filter
argument_list|(
name|entityAnnotation
argument_list|,
name|Properties
operator|.
name|DC_REQUIRES
argument_list|,
name|referredTextAnnotation
argument_list|)
operator|.
name|hasNext
argument_list|()
operator|)
argument_list|)
expr_stmt|;
block|}
comment|// test if an entity is referred
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|entityReferenceIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|entityAnnotation
argument_list|,
name|ENHANCER_ENTITY_REFERENCE
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"fise:entity-reference MUST BE present! (EntityAnnotation: '"
operator|+
name|entityAnnotation
operator|+
literal|"')'"
argument_list|,
name|entityReferenceIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|Resource
name|expectedReferencedEntity
init|=
name|expectedValues
operator|.
name|get
argument_list|(
name|ENHANCER_ENTITY_REFERENCE
argument_list|)
decl_stmt|;
while|while
condition|(
name|entityReferenceIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|//check possible multiple references
name|Resource
name|entityReferenceResource
init|=
name|entityReferenceIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
comment|// test if the reference is an URI
name|assertTrue
argument_list|(
literal|"fise:entity-reference value MUST BE of URIs"
argument_list|,
name|entityReferenceResource
operator|instanceof
name|UriRef
argument_list|)
expr_stmt|;
if|if
condition|(
name|expectedReferencedEntity
operator|!=
literal|null
operator|&&
name|expectedReferencedEntity
operator|.
name|equals
argument_list|(
name|entityReferenceResource
argument_list|)
condition|)
block|{
name|expectedReferencedEntity
operator|=
literal|null
expr_stmt|;
comment|//found
block|}
block|}
name|assertNull
argument_list|(
literal|"EntityAnnotation "
operator|+
name|entityAnnotation
operator|+
literal|"fise:entity-reference has not the expected value "
operator|+
name|expectedReferencedEntity
operator|+
literal|"!"
argument_list|,
name|expectedReferencedEntity
argument_list|)
expr_stmt|;
comment|//test if the entity label is set
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|entityLabelIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|entityAnnotation
argument_list|,
name|ENHANCER_ENTITY_LABEL
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|entityLabelIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|Resource
name|expectedEntityLabel
init|=
name|expectedValues
operator|.
name|get
argument_list|(
name|ENHANCER_ENTITY_LABEL
argument_list|)
decl_stmt|;
while|while
condition|(
name|entityLabelIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Resource
name|entityLabelResource
init|=
name|entityLabelIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"fise:entity-label values MUST BE PlainLiterals (EntityAnnotation: "
operator|+
name|entityAnnotation
operator|+
literal|")!"
argument_list|,
name|entityLabelResource
operator|instanceof
name|PlainLiteral
argument_list|)
expr_stmt|;
if|if
condition|(
name|expectedEntityLabel
operator|!=
literal|null
operator|&&
name|expectedEntityLabel
operator|.
name|equals
argument_list|(
name|entityLabelResource
argument_list|)
condition|)
block|{
name|expectedEntityLabel
operator|=
literal|null
expr_stmt|;
block|}
block|}
name|assertNull
argument_list|(
literal|"The expected EntityLabel "
operator|+
name|expectedEntityLabel
operator|+
literal|" was not found"
argument_list|,
name|expectedEntityLabel
argument_list|)
expr_stmt|;
comment|//test the optional entity types
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|entityTypeIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|entityAnnotation
argument_list|,
name|Properties
operator|.
name|ENHANCER_ENTITY_TYPE
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|Resource
name|expectedEntityType
init|=
name|expectedValues
operator|.
name|get
argument_list|(
name|Properties
operator|.
name|ENHANCER_ENTITY_TYPE
argument_list|)
decl_stmt|;
if|if
condition|(
name|entityTypeIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Resource
name|entityTypeResource
init|=
name|entityTypeIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"fise:entity-type values MUST BE URIs"
argument_list|,
name|entityTypeResource
operator|instanceof
name|UriRef
argument_list|)
expr_stmt|;
if|if
condition|(
name|expectedEntityType
operator|!=
literal|null
operator|&&
name|expectedEntityType
operator|.
name|equals
argument_list|(
name|entityTypeResource
argument_list|)
condition|)
block|{
name|expectedEntityType
operator|=
literal|null
expr_stmt|;
comment|//found
block|}
block|}
name|assertNull
argument_list|(
literal|"The expected fise:entity-type value "
operator|+
name|expectedEntityType
operator|+
literal|" was not found!"
argument_list|,
name|expectedEntityType
argument_list|)
expr_stmt|;
comment|//test all properties required by fise:Enhancement
name|validateEnhancement
argument_list|(
name|enhancements
argument_list|,
name|entityAnnotation
argument_list|,
name|expectedValues
argument_list|)
expr_stmt|;
block|}
comment|/**      * Validates all fise:Enhancement related properties and values. NOTE that      * this method is called by {@link #validateEntityAnnotation(TripleCollection, UriRef, Map)}      * and {@link #validateTextAnnotation(TripleCollection, UriRef, String)}.      * @param enhancements the enhancements graph      * @param enhancement the fise:Enhancement to validate      * @param expectedValues expected values (properties for the values are used as keys)      */
specifier|public
specifier|static
name|void
name|validateEnhancement
parameter_list|(
name|TripleCollection
name|enhancements
parameter_list|,
name|UriRef
name|enhancement
parameter_list|,
name|Map
argument_list|<
name|UriRef
argument_list|,
name|Resource
argument_list|>
name|expectedValues
parameter_list|)
block|{
comment|//validate the rdf:type
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|rdfTypeIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|enhancement
argument_list|,
name|RDF_TYPE
argument_list|,
name|ENHANCER_ENHANCEMENT
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Parsed Enhancement "
operator|+
name|enhancement
operator|+
literal|" is missing the fise:Enhancement type "
argument_list|,
name|rdfTypeIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
comment|//validate the creator
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|creatorIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|enhancement
argument_list|,
name|Properties
operator|.
name|DC_CREATOR
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Enhancements MUST HAVE a creator"
argument_list|,
name|creatorIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|Resource
name|creatorResource
init|=
name|creatorIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Creator MUST BE an TypedLiteral (found '"
operator|+
name|creatorResource
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"')!"
argument_list|,
name|creatorResource
operator|instanceof
name|TypedLiteral
operator|||
name|creatorResource
operator|instanceof
name|UriRef
argument_list|)
expr_stmt|;
if|if
condition|(
name|creatorResource
operator|instanceof
name|TypedLiteral
condition|)
block|{
name|assertEquals
argument_list|(
literal|"The dc:creator value MUST be of dataType xsd:string"
argument_list|,
name|XSD
operator|.
name|string
argument_list|,
operator|(
operator|(
name|TypedLiteral
operator|)
name|creatorResource
operator|)
operator|.
name|getDataType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Resource
name|expectedCreator
init|=
name|expectedValues
operator|.
name|get
argument_list|(
name|Properties
operator|.
name|DC_CREATOR
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectedCreator
operator|!=
literal|null
condition|)
block|{
name|assertEquals
argument_list|(
literal|"Creator is not the expected value!"
argument_list|,
name|expectedCreator
argument_list|,
name|creatorResource
argument_list|)
expr_stmt|;
block|}
name|assertFalse
argument_list|(
literal|"only a single creater MUST BE present for an Enhancement"
argument_list|,
name|creatorIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
comment|//validate the optional contributor
name|Resource
name|expectedContributor
init|=
name|expectedValues
operator|.
name|get
argument_list|(
name|DCTERMS
operator|.
name|contributor
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|contributorIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|enhancement
argument_list|,
name|DCTERMS
operator|.
name|contributor
argument_list|,
literal|null
argument_list|)
decl_stmt|;
while|while
condition|(
name|contributorIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Resource
name|contributorResource
init|=
name|contributorIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Creator MUST BE an TypedLiteral or an UriRef (found '"
operator|+
name|contributorResource
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"')!"
argument_list|,
name|contributorResource
operator|instanceof
name|TypedLiteral
operator|||
name|contributorResource
operator|instanceof
name|UriRef
argument_list|)
expr_stmt|;
if|if
condition|(
name|contributorResource
operator|instanceof
name|TypedLiteral
condition|)
block|{
name|assertEquals
argument_list|(
literal|"The dc:contributor value MUST be of dataType xsd:string"
argument_list|,
name|XSD
operator|.
name|string
argument_list|,
operator|(
operator|(
name|TypedLiteral
operator|)
name|contributorResource
operator|)
operator|.
name|getDataType
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expectedContributor
operator|!=
literal|null
operator|&&
name|expectedContributor
operator|.
name|equals
argument_list|(
name|expectedContributor
argument_list|)
condition|)
block|{
name|expectedContributor
operator|=
literal|null
expr_stmt|;
comment|//found
block|}
block|}
name|assertNull
argument_list|(
literal|"The expected contributor '"
operator|+
name|expectedContributor
operator|+
literal|"'was not present in the Enhancement"
argument_list|,
name|expectedContributor
argument_list|)
expr_stmt|;
comment|//validate creation date
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|createdIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|enhancement
argument_list|,
name|Properties
operator|.
name|DC_CREATED
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"The creation date MUST BE present for an Enhancement"
argument_list|,
name|createdIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|Resource
name|createdResource
init|=
name|createdIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Creation date MUST be a typed Literal"
argument_list|,
name|createdResource
operator|instanceof
name|TypedLiteral
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Creation date MUST have the dataTyoe xsd:dateTime"
argument_list|,
name|XSD
operator|.
name|dateTime
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|TypedLiteral
operator|)
name|createdResource
operator|)
operator|.
name|getDataType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Date
name|creationDate
init|=
name|LiteralFactory
operator|.
name|getInstance
argument_list|()
operator|.
name|createObject
argument_list|(
name|Date
operator|.
name|class
argument_list|,
operator|(
name|TypedLiteral
operator|)
name|createdResource
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"Unable to convert "
operator|+
name|createdResource
operator|+
literal|" to a Java Date object"
argument_list|,
name|creationDate
argument_list|)
expr_stmt|;
name|Date
name|now
init|=
operator|new
name|Date
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"CreationDate MUST NOT be in the Future"
argument_list|,
name|now
operator|.
name|after
argument_list|(
name|creationDate
argument_list|)
operator|||
name|now
operator|.
name|equals
argument_list|(
name|creationDate
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"Only a single createnDate MUST BE present"
argument_list|,
name|createdIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
comment|//validate optional modification date if present
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|modDateIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|enhancement
argument_list|,
name|DCTERMS
operator|.
name|modified
argument_list|,
literal|null
argument_list|)
decl_stmt|;
while|while
condition|(
name|modDateIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Resource
name|modDateResurce
init|=
name|modDateIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Creation date MUST be a typed Literal"
argument_list|,
name|modDateResurce
operator|instanceof
name|TypedLiteral
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Creation date MUST have the dataTyoe xsd:dateTime"
argument_list|,
name|XSD
operator|.
name|dateTime
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|TypedLiteral
operator|)
name|modDateResurce
operator|)
operator|.
name|getDataType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Date
name|modDate
init|=
name|LiteralFactory
operator|.
name|getInstance
argument_list|()
operator|.
name|createObject
argument_list|(
name|Date
operator|.
name|class
argument_list|,
operator|(
name|TypedLiteral
operator|)
name|modDateResurce
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"Unable to convert "
operator|+
name|modDateResurce
operator|+
literal|" to a Java Date object"
argument_list|,
name|modDate
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"CreationDate MUST NOT be in the Future"
argument_list|,
operator|new
name|Date
argument_list|()
operator|.
name|after
argument_list|(
name|modDate
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//validate the fise:extracted-from
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|extractedIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|enhancement
argument_list|,
name|Properties
operator|.
name|ENHANCER_EXTRACTED_FROM
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"The fise:extracted-from property MUST BE present for an Enhancement"
argument_list|,
name|extractedIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|Resource
name|extractedResource
init|=
name|extractedIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Creator MUST BE an UriRef (found '"
operator|+
name|extractedResource
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"')!"
argument_list|,
name|extractedResource
operator|instanceof
name|UriRef
argument_list|)
expr_stmt|;
name|Resource
name|expectedExtractedFrom
init|=
name|expectedValues
operator|.
name|get
argument_list|(
name|Properties
operator|.
name|ENHANCER_EXTRACTED_FROM
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectedExtractedFrom
operator|!=
literal|null
condition|)
block|{
name|assertEquals
argument_list|(
literal|"fise:extracted-from has not the expected value!"
argument_list|,
name|expectedExtractedFrom
argument_list|,
name|extractedResource
argument_list|)
expr_stmt|;
block|}
name|assertFalse
argument_list|(
literal|"only a single creater MUST BE present for an Enhancement"
argument_list|,
name|extractedIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
comment|//validate that all dc:requires and dc:relation link to resources of type fise:Enhancement
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|relatedIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|enhancement
argument_list|,
name|Properties
operator|.
name|DC_RELATION
argument_list|,
literal|null
argument_list|)
decl_stmt|;
while|while
condition|(
name|relatedIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Resource
name|relatedResource
init|=
name|relatedIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"dc:relation values MUST BE URIs"
argument_list|,
name|relatedResource
operator|instanceof
name|UriRef
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|relatedTypes
init|=
name|enhancements
operator|.
name|filter
argument_list|(
operator|(
name|UriRef
operator|)
name|relatedResource
argument_list|,
name|RDF_TYPE
argument_list|,
name|TechnicalClasses
operator|.
name|ENHANCER_ENHANCEMENT
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"dc:relation Resources MUST BE of rdf:type fise:Enhancement"
argument_list|,
name|relatedTypes
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|requiresIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|enhancement
argument_list|,
name|Properties
operator|.
name|DC_REQUIRES
argument_list|,
literal|null
argument_list|)
decl_stmt|;
while|while
condition|(
name|requiresIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Resource
name|requiredResource
init|=
name|requiresIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"dc:requires values MUST BE URIs"
argument_list|,
name|requiredResource
operator|instanceof
name|UriRef
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|relatedTypes
init|=
name|enhancements
operator|.
name|filter
argument_list|(
operator|(
name|UriRef
operator|)
name|requiredResource
argument_list|,
name|RDF_TYPE
argument_list|,
name|TechnicalClasses
operator|.
name|ENHANCER_ENHANCEMENT
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"dc:requires Resources MUST BE of rdf:type fise:Enhancement"
argument_list|,
name|relatedTypes
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//validate that fise:confidence has [0..1] values and are of type xsd:float
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|confidenceIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|enhancement
argument_list|,
name|Properties
operator|.
name|ENHANCER_CONFIDENCE
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|boolean
name|confidenceRequired
init|=
name|expectedValues
operator|.
name|containsKey
argument_list|(
name|Properties
operator|.
name|ENHANCER_CONFIDENCE
argument_list|)
decl_stmt|;
if|if
condition|(
name|confidenceIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|//confidence is optional
name|Resource
name|confidenceResource
init|=
name|confidenceIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"fise:confidence value MUST BE a TypedLiteral"
argument_list|,
name|confidenceResource
operator|instanceof
name|TypedLiteral
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"fise:confidence MUST BE xsd:double"
argument_list|,
name|XSD
operator|.
name|double_
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|TypedLiteral
operator|)
name|confidenceResource
operator|)
operator|.
name|getDataType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Double
name|confidence
init|=
name|LiteralFactory
operator|.
name|getInstance
argument_list|()
operator|.
name|createObject
argument_list|(
name|Double
operator|.
name|class
argument_list|,
operator|(
name|TypedLiteral
operator|)
name|confidenceResource
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"Unable to convert TypedLiteral '"
operator|+
name|confidenceResource
operator|+
literal|"' to a Java Double value"
argument_list|,
name|confidence
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"fise:confidence MUST HAVE [0..1] values"
argument_list|,
name|confidenceIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
comment|//STANBOL-630: confidence [0..1]
name|assertTrue
argument_list|(
literal|"fise:confidence MUST BE<= 1 (value= '"
operator|+
name|confidence
operator|+
literal|"',enhancement "
operator|+
name|enhancement
operator|+
literal|")"
argument_list|,
literal|1.0
operator|>=
name|confidence
operator|.
name|doubleValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"fise:confidence MUST BE>= 0 (value= '"
operator|+
name|confidence
operator|+
literal|"',enhancement "
operator|+
name|enhancement
operator|+
literal|")"
argument_list|,
literal|0.0
operator|<=
name|confidence
operator|.
name|doubleValue
argument_list|()
argument_list|)
expr_stmt|;
name|Resource
name|expectedConfidence
init|=
name|expectedValues
operator|.
name|get
argument_list|(
name|Properties
operator|.
name|ENHANCER_CONFIDENCE
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectedConfidence
operator|!=
literal|null
condition|)
block|{
name|assertEquals
argument_list|(
literal|"The fise:confidence for enhancement "
operator|+
name|enhancement
operator|+
literal|" does not have the expected value"
argument_list|,
name|expectedConfidence
argument_list|,
name|confidenceResource
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|assertFalse
argument_list|(
literal|"The required fise:confidence value is missing for enhancement "
operator|+
name|enhancement
argument_list|,
name|confidenceRequired
argument_list|)
expr_stmt|;
block|}
comment|//validate that the (optional) dc:type is an URI and that there are not multiple values
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|dcTypeIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|enhancement
argument_list|,
name|Properties
operator|.
name|DC_TYPE
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|Resource
name|expectedDcType
init|=
name|expectedValues
operator|.
name|get
argument_list|(
name|Properties
operator|.
name|DC_TYPE
argument_list|)
decl_stmt|;
if|if
condition|(
name|dcTypeIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|//dc:type is optional
name|Resource
name|dcTypeResource
init|=
name|dcTypeIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"dc:type values MUST BE URIs"
argument_list|,
name|dcTypeResource
operator|instanceof
name|UriRef
argument_list|)
expr_stmt|;
if|if
condition|(
name|expectedDcType
operator|!=
literal|null
condition|)
block|{
name|assertEquals
argument_list|(
literal|"The dc:type value is not the expected "
operator|+
name|expectedDcType
operator|+
literal|"!"
argument_list|,
name|expectedDcType
argument_list|,
name|dcTypeResource
argument_list|)
expr_stmt|;
block|}
name|assertFalse
argument_list|(
literal|"Only a single dc:type value is allowed!"
argument_list|,
name|dcTypeIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//validate the fise:confidence-value introduced by STANBOL-631
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|confidenceLevelIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|enhancement
argument_list|,
name|Properties
operator|.
name|ENHANCER_CONFIDENCE_LEVEL
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|Resource
name|expectedConfidenceValue
init|=
name|expectedValues
operator|.
name|get
argument_list|(
name|Properties
operator|.
name|ENHANCER_CONFIDENCE_LEVEL
argument_list|)
decl_stmt|;
if|if
condition|(
name|confidenceLevelIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Resource
name|confidenceLevelResource
init|=
name|confidenceLevelIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"fise:confidence-level values MUST BE URIs but found "
operator|+
name|confidenceLevelResource
argument_list|,
name|confidenceLevelResource
operator|instanceof
name|UriRef
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
literal|"The fise:confidence-level value MUST BE one of the four "
operator|+
literal|"values defined in the ontology! (found: "
operator|+
name|confidenceLevelResource
operator|+
literal|" | enhancement "
operator|+
name|enhancement
operator|+
literal|")"
argument_list|,
name|CONFIDENCE_LEVEL_ENUM
operator|.
name|getConfidenceLevel
argument_list|(
operator|(
name|UriRef
operator|)
name|confidenceLevelResource
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"The fise:confidence-level property is functional and MUST "
operator|+
literal|"HAVE only a single value (enhancement "
operator|+
name|enhancement
operator|+
literal|")!"
argument_list|,
name|confidenceLevelIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertNull
argument_list|(
literal|"fise:confidence-level "
operator|+
name|expectedConfidenceValue
operator|+
literal|"expected for Enhancement "
operator|+
name|enhancement
operator|+
literal|"but no 'fise:confidence-level' value present!"
argument_list|,
name|expectedConfidenceValue
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Validates all fise:TopicAnnotations contained by the parsed enhancements      * graph.      * @param enhancements the enhancement graph      * @param expectedValues the expected values of all validated TopicAnnotations.      * Properties are used as keys. Typical example would be fise:extracted-from      * with the id of the ContentItem as value; dc-terms:creator with the      * {@link Class#getName()} as value.      * @return the number of found and validated TopicAnnotations.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|static
name|int
name|validateAllTopicAnnotations
parameter_list|(
name|TripleCollection
name|enhancements
parameter_list|,
name|Map
argument_list|<
name|UriRef
argument_list|,
name|Resource
argument_list|>
name|expectedValues
parameter_list|)
block|{
name|expectedValues
operator|=
name|expectedValues
operator|==
literal|null
condition|?
name|Collections
operator|.
name|EMPTY_MAP
else|:
name|expectedValues
expr_stmt|;
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|topicAnnotationIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
literal|null
argument_list|,
name|RDF_TYPE
argument_list|,
name|ENHANCER_TOPICANNOTATION
argument_list|)
decl_stmt|;
name|int
name|topicAnnotationCount
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|topicAnnotationIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|UriRef
name|topicAnnotation
init|=
operator|(
name|UriRef
operator|)
name|topicAnnotationIterator
operator|.
name|next
argument_list|()
operator|.
name|getSubject
argument_list|()
decl_stmt|;
comment|// test if selected Text is added
name|validateTopicAnnotation
argument_list|(
name|enhancements
argument_list|,
name|topicAnnotation
argument_list|,
name|expectedValues
argument_list|)
expr_stmt|;
name|topicAnnotationCount
operator|++
expr_stmt|;
block|}
return|return
name|topicAnnotationCount
return|;
block|}
comment|/**      * Checks if a fise:TopicAnnotation is valid as defined by       *<a herf="https://issues.apache.org/jira/browse/STANBOL-617">STANBOL-617</a>.       * NOTE that this also validates all fise:Enhancement related requirements by       * calling {@link #validateEnhancement(TripleCollection, UriRef, Map)}      * @param enhancements the enhancements graph      * @param topicAnnotation the topic annotation to validate      * @param expectedValues expected values (properties for the values are used as keys)      */
specifier|public
specifier|static
name|void
name|validateTopicAnnotation
parameter_list|(
name|TripleCollection
name|enhancements
parameter_list|,
name|UriRef
name|topicAnnotation
parameter_list|,
name|Map
argument_list|<
name|UriRef
argument_list|,
name|Resource
argument_list|>
name|expectedValues
parameter_list|)
block|{
comment|//validate the rdf:type
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|rdfTypeIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|topicAnnotation
argument_list|,
name|RDF_TYPE
argument_list|,
name|ENHANCER_TOPICANNOTATION
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Parsed Enhancement "
operator|+
name|topicAnnotation
operator|+
literal|" is missing the fise:TopicAnnotation type "
argument_list|,
name|rdfTypeIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
comment|//TopicAnnotations need to be linked to TextAnnotations describing the
comment|//section of the text that has a specific Topic.
comment|//If the topic is for the whole text the TextAnnotation will have no
comment|//selected-text value
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|relationToTextAnnotationIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|topicAnnotation
argument_list|,
name|DC_RELATION
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// check if the relation to the text annotation is set
name|assertTrue
argument_list|(
name|relationToTextAnnotationIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
name|relationToTextAnnotationIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// test if the referred annotations are text annotations
name|UriRef
name|referredTextAnnotation
init|=
operator|(
name|UriRef
operator|)
name|relationToTextAnnotationIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|enhancements
operator|.
name|filter
argument_list|(
name|referredTextAnnotation
argument_list|,
name|RDF_TYPE
argument_list|,
name|ENHANCER_TEXTANNOTATION
argument_list|)
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// test if an entity (the topic) is referred (NOTE: in contrast to
comment|// fise:EntityAnnotations this property is NOT required - cardinality [0..*]
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|entityReferenceIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|topicAnnotation
argument_list|,
name|ENHANCER_ENTITY_REFERENCE
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|Resource
name|expectedReferencedEntity
init|=
name|expectedValues
operator|.
name|get
argument_list|(
name|ENHANCER_ENTITY_REFERENCE
argument_list|)
decl_stmt|;
while|while
condition|(
name|entityReferenceIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|//check possible multiple references
name|Resource
name|entityReferenceResource
init|=
name|entityReferenceIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
comment|// test if the reference is an URI
name|assertTrue
argument_list|(
literal|"fise:entity-reference value MUST BE of URIs"
argument_list|,
name|entityReferenceResource
operator|instanceof
name|UriRef
argument_list|)
expr_stmt|;
if|if
condition|(
name|expectedReferencedEntity
operator|!=
literal|null
operator|&&
name|expectedReferencedEntity
operator|.
name|equals
argument_list|(
name|entityReferenceResource
argument_list|)
condition|)
block|{
name|expectedReferencedEntity
operator|=
literal|null
expr_stmt|;
comment|//found
block|}
block|}
name|assertNull
argument_list|(
literal|"EntityAnnotation "
operator|+
name|topicAnnotation
operator|+
literal|"fise:entity-reference has not the expected value "
operator|+
name|expectedReferencedEntity
operator|+
literal|"!"
argument_list|,
name|expectedReferencedEntity
argument_list|)
expr_stmt|;
comment|//test if the entity label is set (required)
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|entityLabelIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|topicAnnotation
argument_list|,
name|ENHANCER_ENTITY_LABEL
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|entityLabelIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|Resource
name|expectedEntityLabel
init|=
name|expectedValues
operator|.
name|get
argument_list|(
name|ENHANCER_ENTITY_LABEL
argument_list|)
decl_stmt|;
while|while
condition|(
name|entityLabelIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Resource
name|entityLabelResource
init|=
name|entityLabelIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"fise:entity-label values MUST BE PlainLiterals (EntityAnnotation: "
operator|+
name|topicAnnotation
operator|+
literal|")!"
argument_list|,
name|entityLabelResource
operator|instanceof
name|PlainLiteral
argument_list|)
expr_stmt|;
if|if
condition|(
name|expectedEntityLabel
operator|!=
literal|null
operator|&&
name|expectedEntityLabel
operator|.
name|equals
argument_list|(
name|entityLabelResource
argument_list|)
condition|)
block|{
name|expectedEntityLabel
operator|=
literal|null
expr_stmt|;
block|}
block|}
name|assertNull
argument_list|(
literal|"The expected EntityLabel "
operator|+
name|expectedEntityLabel
operator|+
literal|" was not found"
argument_list|,
name|expectedEntityLabel
argument_list|)
expr_stmt|;
comment|// test fise:entity-type(s). NOTE: this is not required - cardinality [0..*]
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|entityTypeIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|topicAnnotation
argument_list|,
name|Properties
operator|.
name|ENHANCER_ENTITY_TYPE
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|Resource
name|expectedEntityType
init|=
name|expectedValues
operator|.
name|get
argument_list|(
name|Properties
operator|.
name|ENHANCER_ENTITY_TYPE
argument_list|)
decl_stmt|;
if|if
condition|(
name|entityTypeIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Resource
name|entityTypeResource
init|=
name|entityTypeIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"fise:entity-type values MUST BE URIs"
argument_list|,
name|entityTypeResource
operator|instanceof
name|UriRef
argument_list|)
expr_stmt|;
if|if
condition|(
name|expectedEntityType
operator|!=
literal|null
operator|&&
name|expectedEntityType
operator|.
name|equals
argument_list|(
name|entityTypeResource
argument_list|)
condition|)
block|{
name|expectedEntityType
operator|=
literal|null
expr_stmt|;
comment|//found
block|}
block|}
name|assertNull
argument_list|(
literal|"The expected fise:entity-type value "
operator|+
name|expectedEntityType
operator|+
literal|" was not found!"
argument_list|,
name|expectedEntityType
argument_list|)
expr_stmt|;
comment|//test all properties required by fise:Enhancement
name|validateEnhancement
argument_list|(
name|enhancements
argument_list|,
name|topicAnnotation
argument_list|,
name|expectedValues
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

