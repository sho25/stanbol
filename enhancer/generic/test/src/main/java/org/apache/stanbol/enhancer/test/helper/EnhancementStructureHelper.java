begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|test
operator|.
name|helper
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|DC_RELATION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|ENHANCER_END
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|ENHANCER_ENTITY_LABEL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|ENHANCER_ENTITY_REFERENCE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|ENHANCER_SELECTED_TEXT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|ENHANCER_SELECTION_CONTEXT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|ENHANCER_START
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|RDF_TYPE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|TechnicalClasses
operator|.
name|ENHANCER_ENTITYANNOTATION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|TechnicalClasses
operator|.
name|ENHANCER_TEXTANNOTATION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertFalse
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertNotNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Literal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|LiteralFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|PlainLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Triple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|TripleCollection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|TypedLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|UriRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|ontologies
operator|.
name|DCTERMS
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|ontologies
operator|.
name|XSD
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|EnhancementEngine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|TechnicalClasses
import|;
end_import

begin_class
specifier|public
class|class
name|EnhancementStructureHelper
block|{
comment|/**      * Validates all TextAnnotations contained in the parsed enhancement graph      * @param enhancements the enhancement graph      * @param content the enhanced content      * @param expectedValues the expected values of all validated EntityAnnotations.      * Properties are used as keys. Typical example would be fise:extracted-from      * with the id of the ContentItem as value; dc-terms:creator with the      * {@link Class#getName()} as value.      * @return the number of found TextAnnotations      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|static
name|int
name|validateAllTextAnnotations
parameter_list|(
name|TripleCollection
name|enhancements
parameter_list|,
name|String
name|content
parameter_list|,
name|Map
argument_list|<
name|UriRef
argument_list|,
name|Resource
argument_list|>
name|expectedValues
parameter_list|)
block|{
name|expectedValues
operator|=
name|expectedValues
operator|==
literal|null
condition|?
name|Collections
operator|.
name|EMPTY_MAP
else|:
name|expectedValues
expr_stmt|;
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|textAnnotationIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
literal|null
argument_list|,
name|RDF_TYPE
argument_list|,
name|ENHANCER_TEXTANNOTATION
argument_list|)
decl_stmt|;
comment|// test if a textAnnotation is present
name|assertTrue
argument_list|(
name|textAnnotationIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|textAnnotationCount
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|textAnnotationIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|UriRef
name|textAnnotation
init|=
operator|(
name|UriRef
operator|)
name|textAnnotationIterator
operator|.
name|next
argument_list|()
operator|.
name|getSubject
argument_list|()
decl_stmt|;
comment|// test if selected Text is added
name|validateTextAnnotation
argument_list|(
name|enhancements
argument_list|,
name|textAnnotation
argument_list|,
name|content
argument_list|,
name|expectedValues
argument_list|)
expr_stmt|;
name|textAnnotationCount
operator|++
expr_stmt|;
block|}
return|return
name|textAnnotationCount
return|;
block|}
comment|/**      * Validates the parsed TextAnnotation with a fise:selected-text. This      * method also validates rules defined by fise:Enhancement by calling      * {@link #validateEnhancement(TripleCollection, UriRef, Map)}<p>      * NOTE: this method MUST NOT be used to validate fise:TextAnnotations that      * do NOT select a part of the text - meaning TextAnnotations about the      * whole parsed content.      * @param enhancements the enhancements graph containing the text annotation      * @param textAnnotation the TextAnnotation to validate      * @param content the enhanced content      * @param expectedValues expected values (properties for the values are used as keys)      */
specifier|public
specifier|static
name|void
name|validateTextAnnotation
parameter_list|(
name|TripleCollection
name|enhancements
parameter_list|,
name|UriRef
name|textAnnotation
parameter_list|,
name|String
name|content
parameter_list|,
name|Map
argument_list|<
name|UriRef
argument_list|,
name|Resource
argument_list|>
name|expectedValues
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|selectedTextIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|textAnnotation
argument_list|,
name|ENHANCER_SELECTED_TEXT
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// check if the selected text is added
name|assertTrue
argument_list|(
literal|"TextAnnotations MUST have a fise:selected-text value"
argument_list|,
name|selectedTextIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
comment|// test if the selected text is part of the TEXT_TO_TEST
name|Resource
name|selectedTextResource
init|=
name|selectedTextIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"fise:selected-text MUST BE of type PlainLiteral"
argument_list|,
name|selectedTextResource
operator|instanceof
name|PlainLiteral
argument_list|)
expr_stmt|;
name|Literal
name|selectedText
init|=
operator|(
name|Literal
operator|)
name|selectedTextResource
decl_stmt|;
name|assertTrue
argument_list|(
literal|"The parsed content MUST contain the fise:selected-text value '"
operator|+
name|selectedText
operator|.
name|getLexicalForm
argument_list|()
operator|+
literal|"'!"
argument_list|,
name|content
operator|.
name|contains
argument_list|(
name|selectedText
operator|.
name|getLexicalForm
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Resource
name|expectedSelectedText
init|=
name|expectedValues
operator|.
name|get
argument_list|(
name|ENHANCER_SELECTED_TEXT
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectedSelectedText
operator|!=
literal|null
condition|)
block|{
name|assertEquals
argument_list|(
literal|"The fise:selected-text is not the expected value "
operator|+
name|expectedSelectedText
operator|+
literal|"!"
argument_list|,
name|expectedSelectedText
argument_list|,
name|selectedText
argument_list|)
expr_stmt|;
block|}
name|Resource
name|selectionContextResource
decl_stmt|;
comment|// test if context is added
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|selectionContextIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|textAnnotation
argument_list|,
name|ENHANCER_SELECTION_CONTEXT
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|selectionContextIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|//context is optional
comment|// test if the selected text is part of the TEXT_TO_TEST
name|selectionContextResource
operator|=
name|selectionContextIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
literal|"The fise:selection-context MUST BE of type PlainLiteral"
argument_list|,
name|selectionContextResource
operator|instanceof
name|PlainLiteral
argument_list|)
expr_stmt|;
comment|//check that the content contains the context
name|assertTrue
argument_list|(
literal|"The fise:selection-context MUST BE contained in the Content | context= "
operator|+
name|selectionContextResource
argument_list|,
name|content
operator|.
name|contains
argument_list|(
operator|(
operator|(
name|Literal
operator|)
name|selectionContextResource
operator|)
operator|.
name|getLexicalForm
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|//check that the context contains the selected text
name|assertTrue
argument_list|(
literal|"The fise:selected-text value MUST BE containted within the fise:selection-context value"
argument_list|,
operator|(
operator|(
name|Literal
operator|)
name|selectionContextResource
operator|)
operator|.
name|getLexicalForm
argument_list|()
operator|.
name|contains
argument_list|(
name|selectedText
operator|.
name|getLexicalForm
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|selectionContextResource
operator|=
literal|null
expr_stmt|;
block|}
name|Resource
name|expectedSelectionContext
init|=
name|expectedValues
operator|.
name|get
argument_list|(
name|ENHANCER_SELECTION_CONTEXT
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectedSelectionContext
operator|!=
literal|null
condition|)
block|{
name|assertEquals
argument_list|(
literal|"The value of fise:selection-context has not the expected value "
operator|+
name|expectedSelectionContext
argument_list|,
name|expectedSelectionContext
argument_list|,
name|selectionContextResource
argument_list|)
expr_stmt|;
block|}
comment|//test start/end if present
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|startPosIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|textAnnotation
argument_list|,
name|ENHANCER_START
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|endPosIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|textAnnotation
argument_list|,
name|ENHANCER_END
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|//start end is optional, but if start is present, that also end needs to be set
name|TypedLiteral
name|startPosLiteral
decl_stmt|;
name|TypedLiteral
name|endPosLiteral
decl_stmt|;
if|if
condition|(
name|startPosIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|assertNotNull
argument_list|(
literal|"If fise:start is present the fise:selection-context MUST also be present!"
argument_list|,
name|selectionContextResource
argument_list|)
expr_stmt|;
name|Resource
name|resource
init|=
name|startPosIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
comment|//only a single start position is supported
name|assertFalse
argument_list|(
literal|"fise:start MUST HAVE only a single value!"
argument_list|,
name|startPosIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"fise:start MUST be a typed Literal!"
argument_list|,
name|resource
operator|instanceof
name|TypedLiteral
argument_list|)
expr_stmt|;
name|startPosLiteral
operator|=
operator|(
name|TypedLiteral
operator|)
name|resource
expr_stmt|;
name|assertEquals
argument_list|(
literal|"fise:start MUST use xsd:int as data type"
argument_list|,
name|XSD
operator|.
name|int_
argument_list|,
name|startPosLiteral
operator|.
name|getDataType
argument_list|()
argument_list|)
expr_stmt|;
name|resource
operator|=
literal|null
expr_stmt|;
name|Integer
name|start
init|=
name|LiteralFactory
operator|.
name|getInstance
argument_list|()
operator|.
name|createObject
argument_list|(
name|Integer
operator|.
name|class
argument_list|,
name|startPosLiteral
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"Unable to parse Integer from TypedLiteral "
operator|+
name|startPosLiteral
argument_list|,
name|start
argument_list|)
expr_stmt|;
comment|//now get the end
comment|//end must be defined if start is present
name|assertTrue
argument_list|(
literal|"If fise:start is present also fise:end MUST BE defined!"
argument_list|,
name|endPosIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|resource
operator|=
name|endPosIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
expr_stmt|;
comment|//only a single end position is supported
name|assertFalse
argument_list|(
literal|"fise:end MUST HAVE only a single value!"
argument_list|,
name|endPosIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"fise:end values MUST BE TypedLiterals"
argument_list|,
name|resource
operator|instanceof
name|TypedLiteral
argument_list|)
expr_stmt|;
name|endPosLiteral
operator|=
operator|(
name|TypedLiteral
operator|)
name|resource
expr_stmt|;
name|assertEquals
argument_list|(
literal|"fise:end MUST use xsd:int as data type"
argument_list|,
name|XSD
operator|.
name|int_
argument_list|,
name|endPosLiteral
operator|.
name|getDataType
argument_list|()
argument_list|)
expr_stmt|;
name|resource
operator|=
literal|null
expr_stmt|;
name|Integer
name|end
init|=
name|LiteralFactory
operator|.
name|getInstance
argument_list|()
operator|.
name|createObject
argument_list|(
name|Integer
operator|.
name|class
argument_list|,
name|endPosLiteral
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"Unable to parse Integer from TypedLiteral "
operator|+
name|endPosLiteral
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|endPosLiteral
operator|=
literal|null
expr_stmt|;
comment|//check for equality of the selected text and the text on the selected position in the content
comment|//System.out.println("TA ["+start+"|"+end+"]"+selectedText.getLexicalForm()+"<->"+content.substring(start,end));
name|assertEquals
argument_list|(
literal|"the substring [fise:start,fise:end] does not correspond to "
operator|+
literal|"the fise:selected-text value '"
operator|+
name|selectedText
operator|.
name|getLexicalForm
argument_list|()
operator|+
literal|"' of this TextAnnotation!"
argument_list|,
name|content
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
argument_list|,
name|selectedText
operator|.
name|getLexicalForm
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertNull
argument_list|(
literal|"If fise:selection-context is present also fise:start AND fise:end MUST BE present!"
argument_list|,
name|selectionContextResource
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"if fise:end is presnet also fise:start AND fise:selection-context MUST BE present!"
argument_list|,
name|endPosIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|startPosLiteral
operator|=
literal|null
expr_stmt|;
name|endPosLiteral
operator|=
literal|null
expr_stmt|;
block|}
name|Resource
name|expectedStartPos
init|=
name|expectedValues
operator|.
name|get
argument_list|(
name|ENHANCER_START
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectedStartPos
operator|!=
literal|null
condition|)
block|{
name|assertEquals
argument_list|(
literal|"The fise:start value is not the expected "
operator|+
name|expectedStartPos
argument_list|,
name|expectedStartPos
argument_list|,
name|startPosLiteral
argument_list|)
expr_stmt|;
block|}
name|Resource
name|expectedEndPos
init|=
name|expectedValues
operator|.
name|get
argument_list|(
name|ENHANCER_END
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectedEndPos
operator|!=
literal|null
condition|)
block|{
name|assertEquals
argument_list|(
literal|"The fise:end value is not the expected "
operator|+
name|expectedEndPos
argument_list|,
name|expectedEndPos
argument_list|,
name|endPosLiteral
argument_list|)
expr_stmt|;
block|}
comment|//validate fise:Enhancement specific rules
name|validateEnhancement
argument_list|(
name|enhancements
argument_list|,
name|textAnnotation
argument_list|,
name|expectedValues
argument_list|)
expr_stmt|;
block|}
comment|/**      * Validates all fise:EntityAnnotations contained by the parsed enhancements      * graph.      * @param enhancements the enhancement graph      * @param expectedValues the expected values of all validated EntityAnnotations.      * Properties are used as keys. Typical example would be fise:extracted-from      * with the id of the ContentItem as value; dc-terms:creator with the      * {@link Class#getName()} as value.      * @return the number of found and validated EntityAnnotations.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|static
name|int
name|validateAllEntityAnnotations
parameter_list|(
name|TripleCollection
name|enhancements
parameter_list|,
name|Map
argument_list|<
name|UriRef
argument_list|,
name|Resource
argument_list|>
name|expectedValues
parameter_list|)
block|{
name|expectedValues
operator|=
name|expectedValues
operator|==
literal|null
condition|?
name|Collections
operator|.
name|EMPTY_MAP
else|:
name|expectedValues
expr_stmt|;
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|entityAnnotationIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
literal|null
argument_list|,
name|RDF_TYPE
argument_list|,
name|ENHANCER_ENTITYANNOTATION
argument_list|)
decl_stmt|;
name|int
name|entityAnnotationCount
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|entityAnnotationIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|UriRef
name|entityAnnotation
init|=
operator|(
name|UriRef
operator|)
name|entityAnnotationIterator
operator|.
name|next
argument_list|()
operator|.
name|getSubject
argument_list|()
decl_stmt|;
comment|// test if selected Text is added
name|validateEntityAnnotation
argument_list|(
name|enhancements
argument_list|,
name|entityAnnotation
argument_list|,
name|expectedValues
argument_list|)
expr_stmt|;
name|entityAnnotationCount
operator|++
expr_stmt|;
block|}
return|return
name|entityAnnotationCount
return|;
block|}
comment|/**      * Checks if a fise:EntityAnnotation is valid. NOTE that this also validates      * all fise:Enhancement related requirements by calling      * {@link #validateEnhancement(TripleCollection, UriRef, Map)}      * @param enhancements the enhancements graph      * @param entityAnnotation the entity annotation to validate      * @param expectedValues expected values (properties for the values are used as keys)      */
specifier|public
specifier|static
name|void
name|validateEntityAnnotation
parameter_list|(
name|TripleCollection
name|enhancements
parameter_list|,
name|UriRef
name|entityAnnotation
parameter_list|,
name|Map
argument_list|<
name|UriRef
argument_list|,
name|Resource
argument_list|>
name|expectedValues
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|relationToTextAnnotationIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|entityAnnotation
argument_list|,
name|DC_RELATION
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// check if the relation to the text annotation is set
comment|//TODO: currently it is not required that all EntityAnnotations are linked to
comment|//      an TextAnnotation, because EntityAnnotations are also used for
comment|//      Topics (that do not explicitly occur in texts.
comment|//      This might change as soon there is an own Topic type!
comment|//assertTrue(relationToTextAnnotationIterator.hasNext());
while|while
condition|(
name|relationToTextAnnotationIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// test if the referred annotations are text annotations
name|UriRef
name|referredTextAnnotation
init|=
operator|(
name|UriRef
operator|)
name|relationToTextAnnotationIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|enhancements
operator|.
name|filter
argument_list|(
name|referredTextAnnotation
argument_list|,
name|RDF_TYPE
argument_list|,
name|ENHANCER_TEXTANNOTATION
argument_list|)
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// test if an entity is referred
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|entityReferenceIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|entityAnnotation
argument_list|,
name|ENHANCER_ENTITY_REFERENCE
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"fise:entity-reference MUST BE present! (EntityAnnotation: '"
operator|+
name|entityAnnotation
operator|+
literal|"')'"
argument_list|,
name|entityReferenceIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|Resource
name|expectedReferencedEntity
init|=
name|expectedValues
operator|.
name|get
argument_list|(
name|ENHANCER_ENTITY_REFERENCE
argument_list|)
decl_stmt|;
while|while
condition|(
name|entityReferenceIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|//check possible multiple references
name|Resource
name|entityReferenceResource
init|=
name|entityReferenceIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
comment|// test if the reference is an URI
name|assertTrue
argument_list|(
literal|"fise:entity-reference value MUST BE of URIs"
argument_list|,
name|entityReferenceResource
operator|instanceof
name|UriRef
argument_list|)
expr_stmt|;
if|if
condition|(
name|expectedReferencedEntity
operator|!=
literal|null
operator|&&
name|expectedReferencedEntity
operator|.
name|equals
argument_list|(
name|entityReferenceResource
argument_list|)
condition|)
block|{
name|expectedReferencedEntity
operator|=
literal|null
expr_stmt|;
comment|//found
block|}
block|}
name|assertNull
argument_list|(
literal|"EntityAnnotation "
operator|+
name|entityAnnotation
operator|+
literal|"fise:entity-reference has not the expected value "
operator|+
name|expectedReferencedEntity
operator|+
literal|"!"
argument_list|,
name|expectedReferencedEntity
argument_list|)
expr_stmt|;
comment|//test if the entity label is set
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|entityLabelIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|entityAnnotation
argument_list|,
name|ENHANCER_ENTITY_LABEL
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|entityLabelIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|Resource
name|expectedEntityLabel
init|=
name|expectedValues
operator|.
name|get
argument_list|(
name|ENHANCER_ENTITY_LABEL
argument_list|)
decl_stmt|;
while|while
condition|(
name|entityLabelIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Resource
name|entityLabelResource
init|=
name|entityLabelIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"fise:entity-label values MUST BE PlainLiterals (EntityAnnotation: "
operator|+
name|entityAnnotation
operator|+
literal|")!"
argument_list|,
name|entityLabelResource
operator|instanceof
name|PlainLiteral
argument_list|)
expr_stmt|;
if|if
condition|(
name|expectedEntityLabel
operator|!=
literal|null
operator|&&
name|expectedEntityLabel
operator|.
name|equals
argument_list|(
name|entityLabelResource
argument_list|)
condition|)
block|{
name|expectedEntityLabel
operator|=
literal|null
expr_stmt|;
block|}
block|}
name|assertNull
argument_list|(
literal|"The expected EntityLabel "
operator|+
name|expectedEntityLabel
operator|+
literal|" was not found"
argument_list|,
name|expectedEntityLabel
argument_list|)
expr_stmt|;
comment|//test the optional entity types
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|entityTypeIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|entityAnnotation
argument_list|,
name|Properties
operator|.
name|ENHANCER_ENTITY_TYPE
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|Resource
name|expectedEntityType
init|=
name|expectedValues
operator|.
name|get
argument_list|(
name|Properties
operator|.
name|ENHANCER_ENTITY_TYPE
argument_list|)
decl_stmt|;
if|if
condition|(
name|entityTypeIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Resource
name|entityTypeResource
init|=
name|entityTypeIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"fise:entity-type values MUST BE URIs"
argument_list|,
name|entityTypeResource
operator|instanceof
name|UriRef
argument_list|)
expr_stmt|;
if|if
condition|(
name|expectedEntityType
operator|!=
literal|null
operator|&&
name|expectedEntityType
operator|.
name|equals
argument_list|(
name|entityTypeResource
argument_list|)
condition|)
block|{
name|expectedEntityType
operator|=
literal|null
expr_stmt|;
comment|//found
block|}
block|}
name|assertNull
argument_list|(
literal|"The expected fise:entity-type value "
operator|+
name|expectedEntityType
operator|+
literal|" was not found!"
argument_list|,
name|expectedEntityType
argument_list|)
expr_stmt|;
comment|//test all properties required by fise:Enhancement
name|validateEnhancement
argument_list|(
name|enhancements
argument_list|,
name|entityAnnotation
argument_list|,
name|expectedValues
argument_list|)
expr_stmt|;
block|}
comment|/**      * Validates all fise:Enhancement related properties and values. NOTE that      * this method is called by {@link #validateEntityAnnotation(TripleCollection, UriRef, Map)}      * and {@link #validateTextAnnotation(TripleCollection, UriRef, String)}.      * @param enhancements the enhancements graph      * @param enhancement the fise:Enhancement to validate      * @param expectedValues expected values (properties for the values are used as keys)      */
specifier|public
specifier|static
name|void
name|validateEnhancement
parameter_list|(
name|TripleCollection
name|enhancements
parameter_list|,
name|UriRef
name|enhancement
parameter_list|,
name|Map
argument_list|<
name|UriRef
argument_list|,
name|Resource
argument_list|>
name|expectedValues
parameter_list|)
block|{
comment|//validate the creator
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|creatorIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|enhancement
argument_list|,
name|Properties
operator|.
name|DC_CREATOR
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Enhancements MUST HAVE a creator"
argument_list|,
name|creatorIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|Resource
name|creatorResource
init|=
name|creatorIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Creator MUST BE an TypedLiteral (found '"
operator|+
name|creatorResource
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"')!"
argument_list|,
name|creatorResource
operator|instanceof
name|TypedLiteral
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"The dc:creator value MUST be of dataType xsd:string"
argument_list|,
name|XSD
operator|.
name|string
argument_list|,
operator|(
operator|(
name|TypedLiteral
operator|)
name|creatorResource
operator|)
operator|.
name|getDataType
argument_list|()
argument_list|)
expr_stmt|;
name|Resource
name|expectedCreator
init|=
name|expectedValues
operator|.
name|get
argument_list|(
name|Properties
operator|.
name|DC_CREATOR
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectedCreator
operator|!=
literal|null
condition|)
block|{
name|assertEquals
argument_list|(
literal|"Creator is not the expected value!"
argument_list|,
name|expectedCreator
argument_list|,
name|creatorResource
argument_list|)
expr_stmt|;
block|}
name|assertFalse
argument_list|(
literal|"only a single creater MUST BE present for an Enhancement"
argument_list|,
name|creatorIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
comment|//validate the optional contributor
name|Resource
name|expectedContributor
init|=
name|expectedValues
operator|.
name|get
argument_list|(
name|DCTERMS
operator|.
name|contributor
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|contributorIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|enhancement
argument_list|,
name|DCTERMS
operator|.
name|contributor
argument_list|,
literal|null
argument_list|)
decl_stmt|;
while|while
condition|(
name|contributorIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Resource
name|contributorResource
init|=
name|contributorIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Creator MUST BE an UriRef (found '"
operator|+
name|contributorResource
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"')!"
argument_list|,
name|contributorResource
operator|instanceof
name|UriRef
argument_list|)
expr_stmt|;
if|if
condition|(
name|expectedContributor
operator|!=
literal|null
operator|&&
name|expectedContributor
operator|.
name|equals
argument_list|(
name|expectedContributor
argument_list|)
condition|)
block|{
name|expectedContributor
operator|=
literal|null
expr_stmt|;
comment|//found
block|}
block|}
name|assertNull
argument_list|(
literal|"The expected contributor '"
operator|+
name|expectedContributor
operator|+
literal|"'was not present in the Enhancement"
argument_list|,
name|expectedContributor
argument_list|)
expr_stmt|;
comment|//validate creation date
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|createdIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|enhancement
argument_list|,
name|Properties
operator|.
name|DC_CREATED
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"The creation date MUST BE present for an Enhancement"
argument_list|,
name|createdIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|Resource
name|createdResource
init|=
name|createdIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Creation date MUST be a typed Literal"
argument_list|,
name|createdResource
operator|instanceof
name|TypedLiteral
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Creation date MUST have the dataTyoe xsd:dateTime"
argument_list|,
name|XSD
operator|.
name|dateTime
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|TypedLiteral
operator|)
name|createdResource
operator|)
operator|.
name|getDataType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Date
name|creationDate
init|=
name|LiteralFactory
operator|.
name|getInstance
argument_list|()
operator|.
name|createObject
argument_list|(
name|Date
operator|.
name|class
argument_list|,
operator|(
name|TypedLiteral
operator|)
name|createdResource
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"Unable to convert "
operator|+
name|createdResource
operator|+
literal|" to a Java Date object"
argument_list|,
name|creationDate
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"CreationDate MUST NOT be in the Future"
argument_list|,
operator|new
name|Date
argument_list|()
operator|.
name|after
argument_list|(
name|creationDate
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"Only a single createnDate MUST BE present"
argument_list|,
name|createdIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
comment|//validate optional modification date if present
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|modDateIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|enhancement
argument_list|,
name|DCTERMS
operator|.
name|modified
argument_list|,
literal|null
argument_list|)
decl_stmt|;
while|while
condition|(
name|modDateIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Resource
name|modDateResurce
init|=
name|modDateIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Creation date MUST be a typed Literal"
argument_list|,
name|modDateResurce
operator|instanceof
name|TypedLiteral
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Creation date MUST have the dataTyoe xsd:dateTime"
argument_list|,
name|XSD
operator|.
name|dateTime
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|TypedLiteral
operator|)
name|modDateResurce
operator|)
operator|.
name|getDataType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Date
name|modDate
init|=
name|LiteralFactory
operator|.
name|getInstance
argument_list|()
operator|.
name|createObject
argument_list|(
name|Date
operator|.
name|class
argument_list|,
operator|(
name|TypedLiteral
operator|)
name|modDateResurce
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"Unable to convert "
operator|+
name|modDateResurce
operator|+
literal|" to a Java Date object"
argument_list|,
name|modDate
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"CreationDate MUST NOT be in the Future"
argument_list|,
operator|new
name|Date
argument_list|()
operator|.
name|after
argument_list|(
name|modDate
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//validate the fise:extracted-from
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|extractedIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|enhancement
argument_list|,
name|Properties
operator|.
name|ENHANCER_EXTRACTED_FROM
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"The fise:extracted-from property MUST BE present for an Enhancement"
argument_list|,
name|extractedIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|Resource
name|extractedResource
init|=
name|extractedIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Creator MUST BE an UriRef (found '"
operator|+
name|extractedResource
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"')!"
argument_list|,
name|extractedResource
operator|instanceof
name|UriRef
argument_list|)
expr_stmt|;
name|Resource
name|expectedExtractedFrom
init|=
name|expectedValues
operator|.
name|get
argument_list|(
name|Properties
operator|.
name|ENHANCER_EXTRACTED_FROM
argument_list|)
decl_stmt|;
if|if
condition|(
name|expectedExtractedFrom
operator|!=
literal|null
condition|)
block|{
name|assertEquals
argument_list|(
literal|"Creator is not the expected value!"
argument_list|,
name|extractedResource
argument_list|,
name|expectedExtractedFrom
argument_list|)
expr_stmt|;
block|}
name|assertFalse
argument_list|(
literal|"only a single creater MUST BE present for an Enhancement"
argument_list|,
name|extractedIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
comment|//validate that all dc:requires and dc:relation link to resources of type fise:Enhancement
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|relatedIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|enhancement
argument_list|,
name|Properties
operator|.
name|DC_RELATION
argument_list|,
literal|null
argument_list|)
decl_stmt|;
while|while
condition|(
name|relatedIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Resource
name|relatedResource
init|=
name|relatedIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"dc:relation values MUST BE URIs"
argument_list|,
name|relatedResource
operator|instanceof
name|UriRef
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|relatedTypes
init|=
name|enhancements
operator|.
name|filter
argument_list|(
operator|(
name|UriRef
operator|)
name|relatedResource
argument_list|,
name|RDF_TYPE
argument_list|,
name|TechnicalClasses
operator|.
name|ENHANCER_ENHANCEMENT
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"dc:relation Resources MUST BE of rdf:type fise:Enhancement"
argument_list|,
name|relatedTypes
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|requiresIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|enhancement
argument_list|,
name|Properties
operator|.
name|DC_REQUIRES
argument_list|,
literal|null
argument_list|)
decl_stmt|;
while|while
condition|(
name|requiresIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Resource
name|requiredResource
init|=
name|requiresIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"dc:requires values MUST BE URIs"
argument_list|,
name|requiredResource
operator|instanceof
name|UriRef
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|relatedTypes
init|=
name|enhancements
operator|.
name|filter
argument_list|(
operator|(
name|UriRef
operator|)
name|requiredResource
argument_list|,
name|RDF_TYPE
argument_list|,
name|TechnicalClasses
operator|.
name|ENHANCER_ENHANCEMENT
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"dc:requires Resources MUST BE of rdf:type fise:Enhancement"
argument_list|,
name|relatedTypes
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//validate that fise:confidence has [0..1] values and are of type xsd:float
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|confidenceIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|enhancement
argument_list|,
name|Properties
operator|.
name|ENHANCER_CONFIDENCE
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|confidenceIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|//confidence is optional
name|Resource
name|confidenceResource
init|=
name|confidenceIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"fise:confidence value MUST BE a TypedLiteral"
argument_list|,
name|confidenceResource
operator|instanceof
name|TypedLiteral
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"fise:confidence MUST BE xsd:double"
argument_list|,
name|XSD
operator|.
name|double_
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|TypedLiteral
operator|)
name|confidenceResource
operator|)
operator|.
name|getDataType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Double
name|value
init|=
name|LiteralFactory
operator|.
name|getInstance
argument_list|()
operator|.
name|createObject
argument_list|(
name|Double
operator|.
name|class
argument_list|,
operator|(
name|TypedLiteral
operator|)
name|confidenceResource
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"Unable to convert TypedLiteral '"
operator|+
name|confidenceResource
operator|+
literal|"' to a Java Float value"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"fise:confidence value "
operator|+
name|value
operator|+
literal|" MUST BE> 0"
argument_list|,
literal|0f
operator|<
name|value
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"fise:confidence MUST HAVE [0..1] values"
argument_list|,
name|confidenceIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//validate that the (optional) dc:type is an URI and that there are not multiple values
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|dcTypeIterator
init|=
name|enhancements
operator|.
name|filter
argument_list|(
name|enhancement
argument_list|,
name|Properties
operator|.
name|DC_TYPE
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|Resource
name|expectedDcType
init|=
name|expectedValues
operator|.
name|get
argument_list|(
name|Properties
operator|.
name|DC_TYPE
argument_list|)
decl_stmt|;
if|if
condition|(
name|dcTypeIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|//dc:type is optional
name|Resource
name|dcTypeResource
init|=
name|dcTypeIterator
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"dc:type values MUST BE URIs"
argument_list|,
name|dcTypeResource
operator|instanceof
name|UriRef
argument_list|)
expr_stmt|;
if|if
condition|(
name|expectedDcType
operator|!=
literal|null
condition|)
block|{
name|assertEquals
argument_list|(
literal|"The dc:type value is not the expected "
operator|+
name|expectedDcType
operator|+
literal|"!"
argument_list|,
name|expectedDcType
argument_list|,
name|dcTypeResource
argument_list|)
expr_stmt|;
block|}
name|assertFalse
argument_list|(
literal|"Only a single dc:type value is allowed!"
argument_list|,
name|dcTypeIterator
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

