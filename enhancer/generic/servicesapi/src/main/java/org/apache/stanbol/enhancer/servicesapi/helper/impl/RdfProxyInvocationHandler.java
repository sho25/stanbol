begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_comment
comment|/**  *  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|impl
package|;
end_package

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationHandler
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|ParameterizedType
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|MalformedURLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractCollection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|LiteralFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|NoConvertorException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|NonLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Triple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|TypedLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|UriRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|impl
operator|.
name|TripleImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|Rdf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|RdfEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
import|;
end_import

begin_class
specifier|public
class|class
name|RdfProxyInvocationHandler
implements|implements
name|InvocationHandler
block|{
comment|/**      * The getID method of the RdfEntity Interface      */
specifier|protected
specifier|static
specifier|final
name|Method
name|getIDMethod
decl_stmt|;
comment|/**      * The toString Method of {@link Object}      */
specifier|protected
specifier|static
specifier|final
name|Method
name|toString
decl_stmt|;
comment|/**      * The equals Method of {@link Object}      */
specifier|protected
specifier|static
specifier|final
name|Method
name|equals
decl_stmt|;
comment|/**      * The hashCode Method of {@link Object}      */
specifier|protected
specifier|static
specifier|final
name|Method
name|hashCode
decl_stmt|;
static|static
block|{
try|try
block|{
name|getIDMethod
operator|=
name|RdfEntity
operator|.
name|class
operator|.
name|getMethod
argument_list|(
literal|"getId"
argument_list|,
operator|new
name|Class
argument_list|<
name|?
argument_list|>
index|[]
block|{}
block|)
empty_stmt|;
name|toString
operator|=
name|Object
operator|.
name|class
operator|.
name|getMethod
argument_list|(
literal|"toString"
argument_list|,
operator|new
name|Class
argument_list|<
name|?
argument_list|>
index|[]
block|{}
block|)
empty_stmt|;
name|equals
operator|=
name|Object
operator|.
name|class
operator|.
name|getMethod
argument_list|(
literal|"equals"
argument_list|,
operator|new
name|Class
argument_list|<
name|?
argument_list|>
index|[]
block|{
name|Object
operator|.
name|class
block|}
block|)
class|;
end_class

begin_expr_stmt
name|hashCode
operator|=
name|Object
operator|.
name|class
operator|.
name|getMethod
argument_list|(
literal|"hashCode"
argument_list|,
operator|new
name|Class
argument_list|<
name|?
argument_list|>
index|[]
block|{}
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_expr_stmt
unit|} catch
operator|(
name|SecurityException
name|e
operator|)
block|{
throw|throw
argument_list|new
name|IllegalStateException
argument_list|(
literal|"Unable to access getId Method in the "
operator|+
name|RdfEntity
operator|.
name|class
operator|+
literal|" Interface"
argument_list|,
name|e
argument_list|)
block|;         }
end_expr_stmt

begin_catch
catch|catch
parameter_list|(
name|NoSuchMethodException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to find getId Method in the "
operator|+
name|RdfEntity
operator|.
name|class
operator|+
literal|" Interface"
argument_list|,
name|e
argument_list|)
throw|;
block|}
end_catch

begin_comment
unit|}
comment|/**      * The logger TODO: Question: How to get the dependencies for logging working with maven :(      */
end_comment

begin_comment
comment|//    private static final Logger log = LoggerFactory.getLogger(RdfProxyInvocationHandler.class);
end_comment

begin_decl_stmt
unit|protected
name|SimpleRdfEntityFactory
name|factory
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|protected
name|LiteralFactory
name|literalFactory
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|protected
name|NonLiteral
name|rdfNode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|private
specifier|final
name|Set
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|interfaces
decl_stmt|;
end_decl_stmt

begin_constructor
specifier|public
name|RdfProxyInvocationHandler
parameter_list|(
name|SimpleRdfEntityFactory
name|factory
parameter_list|,
name|NonLiteral
name|rdfNode
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|parsedInterfaces
parameter_list|,
name|LiteralFactory
name|literalFactory
parameter_list|)
block|{
name|this
operator|.
name|rdfNode
operator|=
name|rdfNode
expr_stmt|;
name|this
operator|.
name|factory
operator|=
name|factory
expr_stmt|;
name|this
operator|.
name|literalFactory
operator|=
name|literalFactory
expr_stmt|;
comment|//TODO If slow implement this by directly using the MGraph Interface!
name|Collection
argument_list|<
name|UriRef
argument_list|>
name|nodeTypes
init|=
name|getValues
argument_list|(
name|Properties
operator|.
name|RDF_TYPE
argument_list|,
name|UriRef
operator|.
name|class
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|interfaceSet
init|=
operator|new
name|HashSet
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
range|:
name|parsedInterfaces
control|)
block|{
if|if
condition|(
operator|!
name|clazz
operator|.
name|isInterface
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Parsed Class "
operator|+
name|clazz
operator|+
literal|" is not an interface!"
argument_list|)
throw|;
block|}
name|interfaceSet
operator|.
name|add
argument_list|(
name|clazz
argument_list|)
expr_stmt|;
name|getSuperInterfaces
argument_list|(
name|clazz
argument_list|,
name|interfaceSet
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|interfaces
operator|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|interfaceSet
argument_list|)
expr_stmt|;
comment|//nobody should be able to change this!
for|for
control|(
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
range|:
name|this
operator|.
name|interfaces
control|)
block|{
name|Rdf
name|classAnnotation
init|=
name|clazz
operator|.
name|getAnnotation
argument_list|(
name|Rdf
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|classAnnotation
operator|==
literal|null
condition|)
block|{             }
else|else
block|{
comment|//check of the type statement is present
name|UriRef
name|typeRef
init|=
operator|new
name|UriRef
argument_list|(
name|classAnnotation
operator|.
name|id
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|nodeTypes
operator|.
name|contains
argument_list|(
name|typeRef
argument_list|)
condition|)
block|{
comment|//TODO: Question: How to get the dependencies for logging working with maven :(
comment|//log.debug("add type "+typeRef+" for interface "+clazz+" to node "+rdfNode);
name|addValue
argument_list|(
name|Properties
operator|.
name|RDF_TYPE
argument_list|,
name|typeRef
argument_list|)
expr_stmt|;
comment|//add the missing type!
block|}
else|else
block|{
comment|// else the type is already present ... nothing to do
comment|//TODO: Question: How to get the dependencies for logging working with maven :(
comment|//log.debug("type "+typeRef+" for interface "+clazz+" is already present for node "+rdfNode);
block|}
block|}
block|}
block|}
end_constructor

begin_function
specifier|private
specifier|static
name|void
name|getSuperInterfaces
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|interfaze
parameter_list|,
name|Collection
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|interfaces
parameter_list|)
block|{
for|for
control|(
name|Class
argument_list|<
name|?
argument_list|>
name|superInterface
range|:
name|interfaze
operator|.
name|getInterfaces
argument_list|()
control|)
block|{
if|if
condition|(
name|superInterface
operator|!=
literal|null
condition|)
block|{
name|interfaces
operator|.
name|add
argument_list|(
name|superInterface
argument_list|)
expr_stmt|;
name|getSuperInterfaces
argument_list|(
name|superInterface
argument_list|,
name|interfaces
argument_list|)
expr_stmt|;
comment|//recursive
block|}
block|}
block|}
end_function

begin_function
annotation|@
name|Override
specifier|public
name|Object
name|invoke
parameter_list|(
name|Object
name|proxy
parameter_list|,
name|Method
name|method
parameter_list|,
name|Object
index|[]
name|args
parameter_list|)
throws|throws
name|Throwable
block|{
comment|//RdfEntity rdfEntity;
if|if
condition|(
operator|!
operator|(
name|proxy
operator|instanceof
name|RdfEntity
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Parsed proxy instance is not of type "
operator|+
name|RdfEntity
operator|.
name|class
operator|+
literal|". This RdfWrapperInvocationHandler implementations only work for proxies implementing this interface!"
argument_list|)
throw|;
block|}
comment|//First check for Methods defined in RDFEntity and java.lang.Object
comment|//implementation of the RffEntity Interface method!
if|if
condition|(
name|method
operator|.
name|equals
argument_list|(
name|getIDMethod
argument_list|)
condition|)
block|{
return|return
name|rdfNode
return|;
block|}
comment|//implement toString
if|if
condition|(
name|method
operator|.
name|equals
argument_list|(
name|equals
argument_list|)
condition|)
block|{
return|return
name|args
index|[
literal|0
index|]
operator|!=
literal|null
operator|&&
name|args
index|[
literal|0
index|]
operator|instanceof
name|RdfEntity
operator|&&
operator|(
operator|(
name|RdfEntity
operator|)
name|args
index|[
literal|0
index|]
operator|)
operator|.
name|getId
argument_list|()
operator|.
name|equals
argument_list|(
name|rdfNode
argument_list|)
return|;
block|}
comment|//implement hashCode
if|if
condition|(
name|method
operator|.
name|equals
argument_list|(
name|hashCode
argument_list|)
condition|)
block|{
return|return
name|rdfNode
operator|.
name|toString
argument_list|()
operator|.
name|hashCode
argument_list|()
return|;
block|}
comment|//implement toString
if|if
condition|(
name|method
operator|.
name|equals
argument_list|(
name|toString
argument_list|)
condition|)
block|{
return|return
literal|"Proxy for Node "
operator|+
name|rdfNode
operator|+
literal|" and interfaces "
operator|+
name|interfaces
return|;
block|}
name|Rdf
name|rdf
init|=
name|method
operator|.
name|getAnnotation
argument_list|(
name|Rdf
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|rdf
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Invoked Method does not have an Rdf annotation!"
argument_list|)
throw|;
block|}
name|UriRef
name|property
decl_stmt|;
if|if
condition|(
name|rdf
operator|.
name|id
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"http://"
argument_list|)
operator|||
name|rdf
operator|.
name|id
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"urn:"
argument_list|)
condition|)
block|{
name|property
operator|=
operator|new
name|UriRef
argument_list|(
name|rdf
operator|.
name|id
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"The id=\""
operator|+
name|rdf
operator|.
name|id
argument_list|()
operator|+
literal|"\"provided by the rdf annotation is not an valid URI"
argument_list|)
throw|;
block|}
comment|//check for Write (Setter) Method
if|if
condition|(
name|method
operator|.
name|getReturnType
argument_list|()
operator|.
name|equals
argument_list|(
name|void
operator|.
name|class
argument_list|)
condition|)
block|{
name|Type
index|[]
name|parameterTypes
init|=
name|method
operator|.
name|getGenericParameterTypes
argument_list|()
decl_stmt|;
comment|//check the parameter types to improve error messages!
comment|//Only methods with a single parameter are supported
if|if
condition|(
name|parameterTypes
operator|.
name|length
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unsupported parameters for Method "
operator|+
name|method
operator|.
name|toString
argument_list|()
operator|+
literal|"! Only setter methodes with a singe parameter are supported."
argument_list|)
throw|;
block|}
specifier|final
name|Type
name|parameterType
init|=
name|parameterTypes
index|[
literal|0
index|]
decl_stmt|;
comment|//now check if args != null and has an element
if|if
condition|(
name|args
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"NULL parsed as \"Object[] args\". An array with a single value is expected when calling "
operator|+
name|method
operator|.
name|toString
argument_list|()
operator|+
literal|"!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|args
operator|.
name|length
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"An empty array was parsed as \"Object[] args\". An array with a single value is expected when calling method "
operator|+
name|method
operator|.
name|toString
argument_list|()
operator|+
literal|"!"
argument_list|)
throw|;
block|}
specifier|final
name|Object
name|value
init|=
name|args
index|[
literal|0
index|]
decl_stmt|;
comment|//Handle Arrays
if|if
condition|(
name|parameterType
operator|instanceof
name|Class
argument_list|<
name|?
argument_list|>
operator|&&
operator|(
operator|(
name|Class
argument_list|<
name|?
argument_list|>
operator|)
name|parameterType
operator|)
operator|.
name|isArray
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"No support for Arrays right now. Use "
operator|+
name|Collection
operator|.
name|class
operator|+
literal|" instead"
argument_list|)
throw|;
block|}
comment|//if null is parsed as value we need to delete all values
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|removeValues
argument_list|(
name|property
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
comment|//setter methods are void -> return null
block|}
comment|//if a collection is parsed we need to check the generic type
if|if
condition|(
name|Collection
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|value
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
name|Type
name|genericType
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|parameterTypes
index|[
literal|0
index|]
operator|instanceof
name|ParameterizedType
condition|)
block|{
for|for
control|(
name|Type
name|typeArgument
range|:
operator|(
operator|(
name|ParameterizedType
operator|)
name|parameterTypes
index|[
literal|0
index|]
operator|)
operator|.
name|getActualTypeArguments
argument_list|()
control|)
block|{
if|if
condition|(
name|genericType
operator|==
literal|null
condition|)
block|{
name|genericType
operator|=
name|typeArgument
expr_stmt|;
block|}
else|else
block|{
comment|//TODO: replace with a warning but for testing start with an exception
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Multiple generic type definition for method "
operator|+
name|method
operator|.
name|toString
argument_list|()
operator|+
literal|" (generic types: "
operator|+
operator|(
operator|(
name|ParameterizedType
operator|)
name|parameterTypes
index|[
literal|0
index|]
operator|)
operator|.
name|getActualTypeArguments
argument_list|()
operator|+
literal|")"
argument_list|)
throw|;
block|}
block|}
block|}
name|setValues
argument_list|(
name|property
argument_list|,
operator|(
name|Collection
argument_list|<
name|?
argument_list|>
operator|)
name|value
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
block|{
name|setValue
argument_list|(
name|property
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
else|else
block|{
comment|//assume an read (getter) method
name|Class
argument_list|<
name|?
argument_list|>
name|returnType
init|=
name|method
operator|.
name|getReturnType
argument_list|()
decl_stmt|;
if|if
condition|(
name|Collection
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|returnType
argument_list|)
condition|)
block|{
name|Type
name|genericType
init|=
literal|null
decl_stmt|;
name|Type
name|genericReturnType
init|=
name|method
operator|.
name|getGenericReturnType
argument_list|()
decl_stmt|;
if|if
condition|(
name|genericReturnType
operator|instanceof
name|ParameterizedType
condition|)
block|{
name|ParameterizedType
name|type
init|=
operator|(
name|ParameterizedType
operator|)
name|genericReturnType
decl_stmt|;
for|for
control|(
name|Type
name|typeArgument
range|:
name|type
operator|.
name|getActualTypeArguments
argument_list|()
control|)
block|{
if|if
condition|(
name|genericType
operator|==
literal|null
condition|)
block|{
name|genericType
operator|=
name|typeArgument
expr_stmt|;
block|}
else|else
block|{
comment|//TODO: replace with a warning but for testing start with an exception
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Multiple generic type definition for method "
operator|+
name|method
operator|.
name|toString
argument_list|()
operator|+
literal|" (generic types: "
operator|+
name|type
operator|.
name|getActualTypeArguments
argument_list|()
operator|+
literal|")"
argument_list|)
throw|;
block|}
block|}
block|}
if|if
condition|(
name|genericType
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Generic Type not defined for Collection in Method "
operator|+
name|method
operator|.
name|toString
argument_list|()
operator|+
literal|" (generic type is needed to correctly map rdf values for property "
operator|+
name|property
argument_list|)
throw|;
block|}
return|return
name|getValues
argument_list|(
name|property
argument_list|,
operator|(
name|Class
argument_list|<
name|?
argument_list|>
operator|)
name|genericType
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|getValue
argument_list|(
name|property
argument_list|,
name|returnType
argument_list|)
return|;
block|}
block|}
block|}
end_function

begin_function
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
parameter_list|<
name|T
parameter_list|>
name|T
name|getValue
parameter_list|(
name|UriRef
name|property
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|results
init|=
name|factory
operator|.
name|getGraph
argument_list|()
operator|.
name|filter
argument_list|(
name|rdfNode
argument_list|,
name|property
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|results
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Resource
name|result
init|=
name|results
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|instanceof
name|NonLiteral
condition|)
block|{
if|if
condition|(
name|RdfEntity
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|type
argument_list|)
condition|)
block|{
return|return
operator|(
name|T
operator|)
name|factory
operator|.
name|getProxy
argument_list|(
operator|(
name|NonLiteral
operator|)
name|result
argument_list|,
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|RdfEntity
argument_list|>
operator|)
name|type
argument_list|)
return|;
block|}
else|else
block|{
comment|//check result for UriRef and types UriRef, URI or URL
if|if
condition|(
name|result
operator|instanceof
name|UriRef
condition|)
block|{
if|if
condition|(
name|UriRef
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|type
argument_list|)
condition|)
block|{
return|return
operator|(
name|T
operator|)
name|result
return|;
block|}
elseif|else
if|if
condition|(
name|URI
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|type
argument_list|)
condition|)
block|{
try|try
block|{
return|return
operator|(
name|T
operator|)
operator|new
name|URI
argument_list|(
operator|(
operator|(
name|UriRef
operator|)
name|result
operator|)
operator|.
name|getUnicodeString
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to parse "
operator|+
name|URI
operator|.
name|class
operator|+
literal|" for "
operator|+
name|UriRef
operator|.
name|class
operator|+
literal|" value="
operator|+
operator|(
operator|(
name|UriRef
operator|)
name|result
operator|)
operator|.
name|getUnicodeString
argument_list|()
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|URL
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|type
argument_list|)
condition|)
block|{
try|try
block|{
return|return
operator|(
name|T
operator|)
operator|new
name|URL
argument_list|(
operator|(
operator|(
name|UriRef
operator|)
name|result
operator|)
operator|.
name|getUnicodeString
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|MalformedURLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to parse "
operator|+
name|URL
operator|.
name|class
operator|+
literal|" for "
operator|+
name|UriRef
operator|.
name|class
operator|+
literal|" value="
operator|+
operator|(
operator|(
name|UriRef
operator|)
name|result
operator|)
operator|.
name|getUnicodeString
argument_list|()
argument_list|)
throw|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Parsed Type "
operator|+
name|type
operator|+
literal|" is not compatible for result type "
operator|+
name|result
operator|.
name|getClass
argument_list|()
operator|+
literal|" (value "
operator|+
name|result
operator|+
literal|") of node "
operator|+
name|rdfNode
operator|+
literal|" and property "
operator|+
name|property
operator|+
literal|"! (Subclass of RdfEntity, UriRef, URI or URL is expected for NonLiteral Values)"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Parsed Type "
operator|+
name|type
operator|+
literal|" is not compatible for result type "
operator|+
name|result
operator|.
name|getClass
argument_list|()
operator|+
literal|" (value "
operator|+
name|result
operator|+
literal|") of node "
operator|+
name|rdfNode
operator|+
literal|" and property "
operator|+
name|property
operator|+
literal|"! (Subclass of RdfEntity expected as type for NonLiteral values that are no instanceof UriRef)"
argument_list|)
throw|;
block|}
block|}
block|}
else|else
block|{
return|return
name|literalFactory
operator|.
name|createObject
argument_list|(
name|type
argument_list|,
operator|(
name|TypedLiteral
operator|)
name|result
argument_list|)
return|;
block|}
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
end_function

begin_function
specifier|private
parameter_list|<
name|T
parameter_list|>
name|Collection
argument_list|<
name|T
argument_list|>
name|getValues
parameter_list|(
name|UriRef
name|property
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
block|{
return|return
operator|new
name|RdfProxyPropertyCollection
argument_list|<
name|T
argument_list|>
argument_list|(
name|property
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_function
specifier|private
name|void
name|setValue
parameter_list|(
name|UriRef
name|property
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|removeValues
argument_list|(
name|property
argument_list|)
expr_stmt|;
name|addValue
argument_list|(
name|property
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|private
name|void
name|setValues
parameter_list|(
name|UriRef
name|property
parameter_list|,
name|Collection
argument_list|<
name|?
argument_list|>
name|values
parameter_list|)
block|{
name|removeValues
argument_list|(
name|property
argument_list|)
expr_stmt|;
for|for
control|(
name|Object
name|value
range|:
name|values
control|)
block|{
name|addValue
argument_list|(
name|property
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|protected
name|Resource
name|getRdfResource
parameter_list|(
name|Object
name|value
parameter_list|)
throws|throws
name|NoConvertorException
block|{
if|if
condition|(
name|value
operator|instanceof
name|Resource
condition|)
block|{
comment|//if the parsed object is already a Resource
return|return
operator|(
name|Resource
operator|)
name|value
return|;
comment|//return it
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|RdfEntity
condition|)
block|{
comment|//check for other proxies
return|return
operator|(
operator|(
name|RdfEntity
operator|)
name|value
operator|)
operator|.
name|getId
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|URI
condition|)
block|{
comment|//or URI links
return|return
operator|new
name|UriRef
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|URL
condition|)
block|{
comment|//or URL links
return|return
operator|new
name|UriRef
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
comment|//nothing of that
comment|//try to make an Literal (Clarezza internal Adapters)
return|return
name|literalFactory
operator|.
name|createTypedLiteral
argument_list|(
name|value
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|private
name|boolean
name|addValue
parameter_list|(
name|UriRef
name|property
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|Resource
name|rdfValue
decl_stmt|;
try|try
block|{
name|rdfValue
operator|=
name|getRdfResource
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|factory
operator|.
name|getGraph
argument_list|()
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|rdfNode
argument_list|,
name|property
argument_list|,
name|rdfValue
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NoConvertorException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unable to transform "
operator|+
name|value
operator|.
name|getClass
argument_list|()
operator|+
literal|" to an RDF Node. Only "
operator|+
name|RdfEntity
operator|.
name|class
operator|+
literal|" and RDF Literal Types are supported"
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
specifier|private
name|boolean
name|removeValue
parameter_list|(
name|UriRef
name|property
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|Resource
name|rdfValue
decl_stmt|;
try|try
block|{
name|rdfValue
operator|=
name|getRdfResource
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|factory
operator|.
name|getGraph
argument_list|()
operator|.
name|remove
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|rdfNode
argument_list|,
name|property
argument_list|,
name|rdfValue
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NoConvertorException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unable to transform "
operator|+
name|value
operator|.
name|getClass
argument_list|()
operator|+
literal|" to an RDF Node. Only "
operator|+
name|RdfEntity
operator|.
name|class
operator|+
literal|" and RDF Literal Types are supported"
argument_list|)
throw|;
block|}
block|}
end_function

begin_function
specifier|private
name|void
name|removeValues
parameter_list|(
name|UriRef
name|proptery
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|toRemove
init|=
name|factory
operator|.
name|getGraph
argument_list|()
operator|.
name|filter
argument_list|(
name|rdfNode
argument_list|,
name|proptery
argument_list|,
literal|null
argument_list|)
decl_stmt|;
while|while
condition|(
name|toRemove
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|factory
operator|.
name|getGraph
argument_list|()
operator|.
name|remove
argument_list|(
name|toRemove
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**      * We need this class to apply changes in the collection to the MGraph.      * This collection implementation is a stateless wrapper over the      * triples selected by the subject,property pair over the MGraph!<br>      * Default implementation of {@link AbstractCollection} are very poor      * performance. Because of that this class overrides some methods      * already implemented by its abstract super class.      * @author westei      *      * @param<T>      */
end_comment

begin_class
specifier|private
class|class
name|RdfProxyPropertyCollection
parameter_list|<
name|T
parameter_list|>
extends|extends
name|AbstractCollection
argument_list|<
name|T
argument_list|>
block|{
comment|//private final NonLiteral resource;
specifier|private
specifier|final
name|UriRef
name|property
decl_stmt|;
specifier|private
specifier|final
name|Class
argument_list|<
name|T
argument_list|>
name|genericType
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|entity
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|uri
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|url
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|uriRef
decl_stmt|;
specifier|private
name|RdfProxyPropertyCollection
parameter_list|(
name|UriRef
name|property
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|genericType
parameter_list|)
block|{
name|this
operator|.
name|property
operator|=
name|property
expr_stmt|;
name|this
operator|.
name|genericType
operator|=
name|genericType
expr_stmt|;
name|entity
operator|=
name|RdfEntity
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|genericType
argument_list|)
expr_stmt|;
name|uri
operator|=
name|URI
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|genericType
argument_list|)
expr_stmt|;
name|url
operator|=
name|URL
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|genericType
argument_list|)
expr_stmt|;
name|uriRef
operator|=
name|UriRef
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|genericType
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|results
init|=
name|factory
operator|.
name|getGraph
argument_list|()
operator|.
name|filter
argument_list|(
name|rdfNode
argument_list|,
name|property
argument_list|,
literal|null
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|results
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
specifier|public
name|T
name|next
parameter_list|()
block|{
name|Resource
name|value
init|=
name|results
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|entity
condition|)
block|{
comment|//type checks are done within the constructor
return|return
operator|(
name|T
operator|)
name|factory
operator|.
name|getProxy
argument_list|(
operator|(
name|NonLiteral
operator|)
name|value
argument_list|,
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|RdfEntity
argument_list|>
operator|)
name|genericType
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|uri
condition|)
block|{
try|try
block|{
return|return
operator|(
name|T
operator|)
operator|new
name|URI
argument_list|(
operator|(
operator|(
name|UriRef
operator|)
name|value
operator|)
operator|.
name|getUnicodeString
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to parse "
operator|+
name|URI
operator|.
name|class
operator|+
literal|" for "
operator|+
name|UriRef
operator|.
name|class
operator|+
literal|" value="
operator|+
operator|(
operator|(
name|UriRef
operator|)
name|value
operator|)
operator|.
name|getUnicodeString
argument_list|()
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|url
condition|)
block|{
try|try
block|{
return|return
operator|(
name|T
operator|)
operator|new
name|URL
argument_list|(
operator|(
operator|(
name|UriRef
operator|)
name|value
operator|)
operator|.
name|getUnicodeString
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|MalformedURLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to parse "
operator|+
name|URL
operator|.
name|class
operator|+
literal|" for "
operator|+
name|UriRef
operator|.
name|class
operator|+
literal|" value="
operator|+
operator|(
operator|(
name|UriRef
operator|)
name|value
operator|)
operator|.
name|getUnicodeString
argument_list|()
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|uriRef
condition|)
block|{
return|return
operator|(
name|T
operator|)
name|value
return|;
block|}
else|else
block|{
return|return
name|literalFactory
operator|.
name|createObject
argument_list|(
name|genericType
argument_list|,
operator|(
name|TypedLiteral
operator|)
name|value
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|results
operator|.
name|remove
argument_list|()
expr_stmt|;
comment|//no Idea if Clerezza implements that ^
block|}
block|}
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|results
init|=
name|factory
operator|.
name|getGraph
argument_list|()
operator|.
name|filter
argument_list|(
name|rdfNode
argument_list|,
name|property
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|results
operator|.
name|hasNext
argument_list|()
condition|;
name|size
operator|++
control|)
block|{
name|results
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
specifier|public
name|boolean
name|add
parameter_list|(
name|T
name|value
parameter_list|)
block|{
return|return
name|addValue
argument_list|(
name|property
argument_list|,
name|value
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
return|return
name|removeValue
argument_list|(
name|property
argument_list|,
name|value
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
operator|!
name|factory
operator|.
name|getGraph
argument_list|()
operator|.
name|filter
argument_list|(
name|rdfNode
argument_list|,
name|property
argument_list|,
literal|null
argument_list|)
operator|.
name|hasNext
argument_list|()
return|;
block|}
block|}
end_class

unit|}
end_unit

