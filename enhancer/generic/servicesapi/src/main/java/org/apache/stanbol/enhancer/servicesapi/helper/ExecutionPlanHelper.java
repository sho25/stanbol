begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|EnhancementEngineHelper
operator|.
name|EXECUTION_ORDER_COMPARATOR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|EnhancementEngineHelper
operator|.
name|get
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|EnhancementEngineHelper
operator|.
name|getEngineOrder
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|EnhancementEngineHelper
operator|.
name|getString
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|ExecutionPlan
operator|.
name|CHAIN
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|ExecutionPlan
operator|.
name|DEPENDS_ON
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|ExecutionPlan
operator|.
name|ENGINE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|ExecutionPlan
operator|.
name|EXECUTION_NODE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|ExecutionPlan
operator|.
name|EXECUTION_PLAN
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|ExecutionPlan
operator|.
name|HAS_EXECUTION_NODE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|ExecutionPlan
operator|.
name|OPTIONAL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|RDF_TYPE
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|BNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Graph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Literal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|LiteralFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|MGraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|NoConvertorException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|NonLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Triple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|TripleCollection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|TypedLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|UriRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|impl
operator|.
name|PlainLiteralImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|impl
operator|.
name|TripleImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|indexedgraph
operator|.
name|IndexedMGraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|ChainException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|EnhancementEngine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|EnhancementEngineManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|ServiceProperties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|impl
operator|.
name|EnginesTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|ExecutionPlan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|NamespaceEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_class
specifier|public
specifier|final
class|class
name|ExecutionPlanHelper
block|{
specifier|private
specifier|final
specifier|static
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ExecutionPlanHelper
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|LiteralFactory
name|lf
init|=
name|LiteralFactory
operator|.
name|getInstance
argument_list|()
decl_stmt|;
specifier|private
name|ExecutionPlanHelper
parameter_list|()
block|{
comment|/* Do not allow instances of utility classes*/
block|}
comment|/**      * Writes all triples for an ep:ExecutionNode to the parsed {@link MGraph}.      * An {@link BNode} is use for representing the execution node resource.      * @param graph the graph to write the triples. MUST NOT be empty      * @param epNode the NonLiteral representing the ep:ExecutionPlan      * @param engineName the name of the engine. MUST NOT be<code>null</code> nor empty      * @param optional if the execution of this node is optional or required      * @param dependsOn other nodes that MUST BE executed before this one. Parse       *<code>null</code> or an empty set if none.      * @return the resource representing the added ep:ExecutionNode.      * @deprecated use {@link #writeExecutionNode(MGraph, NonLiteral, String, boolean, Set, Map)}      * with<code>null</code> as last parameter      */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|NonLiteral
name|writeExecutionNode
parameter_list|(
name|MGraph
name|graph
parameter_list|,
name|NonLiteral
name|epNode
parameter_list|,
name|String
name|engineName
parameter_list|,
name|boolean
name|optional
parameter_list|,
name|Set
argument_list|<
name|NonLiteral
argument_list|>
name|dependsOn
parameter_list|)
block|{
return|return
name|writeExecutionNode
argument_list|(
name|graph
argument_list|,
name|epNode
argument_list|,
name|engineName
argument_list|,
name|optional
argument_list|,
name|dependsOn
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Writes all triples for an ep:ExecutionNode to the parsed {@link MGraph}.      * An {@link BNode} is use for representing the execution node resource.      * @param graph the graph to write the triples. MUST NOT be empty      * @param epNode the NonLiteral representing the ep:ExecutionPlan      * @param engineName the name of the engine. MUST NOT be<code>null</code> nor empty      * @param optional if the execution of this node is optional or required      * @param dependsOn other nodes that MUST BE executed before this one. Parse       *<code>null</code> or an empty set if none.      * @param enhProps the EnhancementProperties for this ExecutionNode or      *<code>null</code> if none      * @return the resource representing the added ep:ExecutionNode.      * @since 0.12.1      */
specifier|public
specifier|static
name|NonLiteral
name|writeExecutionNode
parameter_list|(
name|MGraph
name|graph
parameter_list|,
name|NonLiteral
name|epNode
parameter_list|,
name|String
name|engineName
parameter_list|,
name|boolean
name|optional
parameter_list|,
name|Set
argument_list|<
name|NonLiteral
argument_list|>
name|dependsOn
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|enhProps
parameter_list|)
block|{
if|if
condition|(
name|graph
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed MGraph MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|engineName
operator|==
literal|null
operator|||
name|engineName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Engine name MUST NOT be NULL nor empty!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|epNode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The ep:ExecutionPlan instance MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|NonLiteral
name|node
init|=
operator|new
name|BNode
argument_list|()
decl_stmt|;
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|epNode
argument_list|,
name|HAS_EXECUTION_NODE
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|node
argument_list|,
name|RDF_TYPE
argument_list|,
name|EXECUTION_NODE
argument_list|)
argument_list|)
expr_stmt|;
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|node
argument_list|,
name|ENGINE
argument_list|,
operator|new
name|PlainLiteralImpl
argument_list|(
name|engineName
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dependsOn
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|NonLiteral
name|dependend
range|:
name|dependsOn
control|)
block|{
if|if
condition|(
name|dependend
operator|!=
literal|null
condition|)
block|{
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|node
argument_list|,
name|DEPENDS_ON
argument_list|,
name|dependend
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|node
argument_list|,
name|OPTIONAL
argument_list|,
name|lf
operator|.
name|createTypedLiteral
argument_list|(
name|optional
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|writeEnhancementProperties
argument_list|(
name|graph
argument_list|,
name|node
argument_list|,
name|engineName
argument_list|,
name|enhProps
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
comment|/**      * Creates an ExecutionPlan for the parsed chainName in the parsed Graph      * @param graph the graph      * @param chainName the chain name      * @return the node representing the ex:ExecutionPlan      * @deprecated use {@link #createExecutionPlan(MGraph, String, Map)} with      * parsing<code>null</code> as last parameter      */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|NonLiteral
name|createExecutionPlan
parameter_list|(
name|MGraph
name|graph
parameter_list|,
name|String
name|chainName
parameter_list|)
block|{
return|return
name|createExecutionPlan
argument_list|(
name|graph
argument_list|,
name|chainName
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Creates an ExecutionPlan for the parsed chainName in the parsed Graph      * @param graph the graph      * @param chainName the chain name      * @param enhProps the map with the enhancement properties defined for the      * chain or<code>null</code> if none      * @return the node representing the ex:ExecutionPlan      * @since 0.12.1      */
specifier|public
specifier|static
name|NonLiteral
name|createExecutionPlan
parameter_list|(
name|MGraph
name|graph
parameter_list|,
name|String
name|chainName
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|enhProps
parameter_list|)
block|{
if|if
condition|(
name|graph
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed MGraph MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|chainName
operator|==
literal|null
operator|||
name|chainName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Chain name MUST NOT be NULL nor empty!"
argument_list|)
throw|;
block|}
name|NonLiteral
name|node
init|=
operator|new
name|BNode
argument_list|()
decl_stmt|;
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|node
argument_list|,
name|RDF_TYPE
argument_list|,
name|EXECUTION_PLAN
argument_list|)
argument_list|)
expr_stmt|;
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|node
argument_list|,
name|CHAIN
argument_list|,
operator|new
name|PlainLiteralImpl
argument_list|(
name|chainName
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|writeEnhancementProperties
argument_list|(
name|graph
argument_list|,
name|node
argument_list|,
literal|null
argument_list|,
name|enhProps
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
comment|/**      * Evaluates the parsed {@link Graph execution plan} and the set of already executed      * {@link ExecutionPlan#EXECUTION_NODE ep:ExecutionNode}s to find the next      * nodes that can be executed.       * @param executionPlan the execution plan      * @param executed the already executed {@link ExecutionPlan#EXECUTION_NODE node}s      * or an empty set to determine the nodes to start the execution.      * @return the set of nodes that can be executed next or an empty set if      * there are no more nodes to execute.      */
specifier|public
specifier|static
name|Set
argument_list|<
name|NonLiteral
argument_list|>
name|getExecutable
parameter_list|(
name|TripleCollection
name|executionPlan
parameter_list|,
name|Set
argument_list|<
name|NonLiteral
argument_list|>
name|executed
parameter_list|)
block|{
name|Set
argument_list|<
name|NonLiteral
argument_list|>
name|executeable
init|=
operator|new
name|HashSet
argument_list|<
name|NonLiteral
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|nodes
init|=
name|executionPlan
operator|.
name|filter
argument_list|(
literal|null
argument_list|,
name|RDF_TYPE
argument_list|,
name|EXECUTION_NODE
argument_list|)
init|;
name|nodes
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|NonLiteral
name|node
init|=
name|nodes
operator|.
name|next
argument_list|()
operator|.
name|getSubject
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|executed
operator|.
name|contains
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|dependsIt
init|=
name|executionPlan
operator|.
name|filter
argument_list|(
name|node
argument_list|,
name|DEPENDS_ON
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|boolean
name|dependendExecuted
init|=
literal|true
decl_stmt|;
while|while
condition|(
name|dependsIt
operator|.
name|hasNext
argument_list|()
operator|&&
name|dependendExecuted
condition|)
block|{
name|dependendExecuted
operator|=
name|executed
operator|.
name|contains
argument_list|(
name|dependsIt
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dependendExecuted
condition|)
block|{
name|executeable
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|executeable
return|;
block|}
comment|/**      * Creates an execution plan based on the       * {@link ServiceProperties#ENHANCEMENT_ENGINE_ORDERING} of the parsed      * EnhancementEngines. NOTE that the parsed list is modified as it is sorted by      * using the {@link EnhancementEngineHelper#EXECUTION_ORDER_COMPARATOR}.<p>      * A second parameter with the set of optional engines can be used to define      * what {@link ExecutionPlan#EXECUTION_NODE} in the execution plan should be       * marked as {@link ExecutionPlan#OPTIONAL}.      * @param chainName the name of the Chain to build the execution plan for      * @param availableEngines the list of engines      * @param optional the names of optional engines.      * @param missing the names of missing engines      * @return the execution plan      * @deprecated use {@link #calculateExecutionPlan(String, List, Set, Set, Map)}      * with<code>null</code> as last argument instead      */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|Graph
name|calculateExecutionPlan
parameter_list|(
name|String
name|chainName
parameter_list|,
name|List
argument_list|<
name|EnhancementEngine
argument_list|>
name|availableEngines
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|optional
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|missing
parameter_list|)
block|{
return|return
name|calculateExecutionPlan
argument_list|(
name|chainName
argument_list|,
name|availableEngines
argument_list|,
name|optional
argument_list|,
name|missing
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Creates an execution plan based on the       * {@link ServiceProperties#ENHANCEMENT_ENGINE_ORDERING} of the parsed      * EnhancementEngines. NOTE that the parsed list is modified as it is sorted by      * using the {@link EnhancementEngineHelper#EXECUTION_ORDER_COMPARATOR}.<p>      * A second parameter with the set of optional engines can be used to define      * what {@link ExecutionPlan#EXECUTION_NODE} in the execution plan should be       * marked as {@link ExecutionPlan#OPTIONAL}.      * @param chainName the name of the Chain to build the execution plan for      * @param availableEngines the list of engines      * @param optional the names of optional engines.      * @param missing the names of missing engines      * @param enhProps chain scoped enhancement properties. The key of the outer      * map are the name of the engine or<code>null</code> for the chain. The      * inner map uses the property as key and the value(s) as value. Multiple      * values can be parsed as {@link Collection}. Single values will be      * converted to RDF {@link TypedLiteral}s by using the {@link LiteralFactory}.      * For types not supported by the LiteralFactory the<code>toString()</code>      * method will be used.<code>null</code> can be parsed if no enhancement      * properties are present.      * @return the execution plan      * @since 0.12.1      */
specifier|public
specifier|static
name|Graph
name|calculateExecutionPlan
parameter_list|(
name|String
name|chainName
parameter_list|,
name|List
argument_list|<
name|EnhancementEngine
argument_list|>
name|availableEngines
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|optional
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|missing
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|>
name|enhProps
parameter_list|)
block|{
if|if
condition|(
name|chainName
operator|==
literal|null
operator|||
name|chainName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed ChainName MUST NOT be empty!"
argument_list|)
throw|;
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|availableEngines
argument_list|,
name|EXECUTION_ORDER_COMPARATOR
argument_list|)
expr_stmt|;
comment|//now we have all required and possible also optional engines
comment|//  -> build the execution plan
name|MGraph
name|ep
init|=
operator|new
name|IndexedMGraph
argument_list|()
decl_stmt|;
name|NonLiteral
name|epNode
init|=
name|createExecutionPlan
argument_list|(
name|ep
argument_list|,
name|chainName
argument_list|,
name|enhProps
operator|!=
literal|null
condition|?
name|enhProps
operator|.
name|get
argument_list|(
literal|null
argument_list|)
else|:
literal|null
argument_list|)
decl_stmt|;
name|Integer
name|prevOrder
init|=
literal|null
decl_stmt|;
name|Set
argument_list|<
name|NonLiteral
argument_list|>
name|prev
init|=
literal|null
decl_stmt|;
name|Set
argument_list|<
name|NonLiteral
argument_list|>
name|current
init|=
operator|new
name|HashSet
argument_list|<
name|NonLiteral
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|missing
control|)
block|{
name|boolean
name|optionalMissing
init|=
name|optional
operator|.
name|contains
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|NonLiteral
name|node
init|=
name|writeExecutionNode
argument_list|(
name|ep
argument_list|,
name|epNode
argument_list|,
name|name
argument_list|,
name|optionalMissing
argument_list|,
literal|null
argument_list|,
name|enhProps
operator|==
literal|null
condition|?
literal|null
else|:
name|enhProps
operator|.
name|get
argument_list|(
name|name
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|optionalMissing
condition|)
block|{
name|current
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
comment|// else add missing optional engines without any dependsOn restrictions
block|}
for|for
control|(
name|EnhancementEngine
name|engine
range|:
name|availableEngines
control|)
block|{
name|String
name|name
init|=
name|engine
operator|.
name|getName
argument_list|()
decl_stmt|;
name|Integer
name|order
init|=
name|getEngineOrder
argument_list|(
name|engine
argument_list|)
decl_stmt|;
if|if
condition|(
name|prevOrder
operator|==
literal|null
operator|||
operator|!
name|prevOrder
operator|.
name|equals
argument_list|(
name|order
argument_list|)
condition|)
block|{
name|prev
operator|=
name|current
expr_stmt|;
name|current
operator|=
operator|new
name|HashSet
argument_list|<
name|NonLiteral
argument_list|>
argument_list|()
expr_stmt|;
name|prevOrder
operator|=
name|order
expr_stmt|;
block|}
try|try
block|{
name|NonLiteral
name|executionNode
init|=
name|writeExecutionNode
argument_list|(
name|ep
argument_list|,
name|epNode
argument_list|,
name|name
argument_list|,
name|optional
operator|.
name|contains
argument_list|(
name|name
argument_list|)
argument_list|,
name|prev
argument_list|,
name|enhProps
operator|==
literal|null
condition|?
literal|null
else|:
name|enhProps
operator|.
name|get
argument_list|(
name|name
argument_list|)
argument_list|)
decl_stmt|;
name|current
operator|.
name|add
argument_list|(
name|executionNode
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
comment|//add the engine and class to ease debugging in such cases
name|log
operator|.
name|error
argument_list|(
literal|"Exception while writing ExecutionNode for Enhancement Eninge: "
operator|+
name|engine
operator|+
literal|"(class: "
operator|+
name|engine
operator|.
name|getClass
argument_list|()
operator|+
literal|")"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
comment|//rethrow it
block|}
block|}
return|return
name|ep
operator|.
name|getGraph
argument_list|()
return|;
block|}
comment|/**      * Writes the enhancementProperties for an engine/chain to the parsed       * ExecutionNode      * @param ep The RDF graph holding the execution plan      * @param node the execution node of the engine (or chain) to add the      * enhancement properties      * @param engineName the name of the engine or<code>null</code> in case      * of the chain      * @param enhProps the chain scoped enhancement properties or<code>null</code>      * if none      * @since 0.12.1      */
specifier|private
specifier|static
name|void
name|writeEnhancementProperties
parameter_list|(
name|MGraph
name|ep
parameter_list|,
name|NonLiteral
name|node
parameter_list|,
name|String
name|engineName
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|enhProps
parameter_list|)
block|{
if|if
condition|(
name|enhProps
operator|==
literal|null
condition|)
block|{
comment|//no enhancement properties for this engine
return|return;
block|}
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|enhprop
range|:
name|enhProps
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|enhprop
operator|.
name|getKey
argument_list|()
operator|==
literal|null
operator|||
name|enhprop
operator|.
name|getValue
argument_list|()
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Invalid Enhancement Property {} for {} {}"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|enhprop
block|,
name|engineName
operator|==
literal|null
condition|?
literal|"Chain"
else|:
literal|"engine"
block|,
name|engineName
operator|==
literal|null
condition|?
literal|""
else|:
name|engineName
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writeEnhancementProperty
argument_list|(
name|ep
argument_list|,
name|node
argument_list|,
operator|new
name|UriRef
argument_list|(
name|NamespaceEnum
operator|.
name|ehprop
operator|+
name|enhprop
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|,
name|enhprop
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Writes enhancement property value(s) for the parsed node, property to the      * execution plan graph.      * @param ep the RDF graph holding the execution plan      * @param epNode the execution node      * @param property the property      * @param value the value(s). {@link Collection} and<code>Object[]</code> are      * supported for multiple values.      * @throws NullPointerException if any of the parsed parameter is<code>null</code>      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
specifier|static
name|void
name|writeEnhancementProperty
parameter_list|(
name|MGraph
name|ep
parameter_list|,
name|NonLiteral
name|epNode
parameter_list|,
name|UriRef
name|property
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|Collection
argument_list|<
name|Object
argument_list|>
name|values
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Collection
argument_list|<
name|?
argument_list|>
condition|)
block|{
name|values
operator|=
operator|(
name|Collection
argument_list|<
name|Object
argument_list|>
operator|)
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Object
index|[]
condition|)
block|{
name|values
operator|=
name|Arrays
operator|.
name|asList
argument_list|(
operator|(
name|Object
index|[]
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|values
operator|=
name|Collections
operator|.
name|singleton
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Object
name|v
range|:
name|values
control|)
block|{
if|if
condition|(
name|v
operator|!=
literal|null
condition|)
block|{
name|Literal
name|literal
decl_stmt|;
if|if
condition|(
name|v
operator|instanceof
name|String
condition|)
block|{
name|literal
operator|=
operator|new
name|PlainLiteralImpl
argument_list|(
operator|(
name|String
operator|)
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|literal
operator|=
name|lf
operator|.
name|createTypedLiteral
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoConvertorException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Use toString() value '{}' for EnhancementProperty "
operator|+
literal|"'{}' as no TypedLiteral converter is registered for "
operator|+
literal|"class {}"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|v
block|,
name|property
block|,
name|v
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
block|}
argument_list|)
expr_stmt|;
name|literal
operator|=
operator|new
name|PlainLiteralImpl
argument_list|(
name|v
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|ep
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|epNode
argument_list|,
name|property
argument_list|,
name|literal
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Utility that checks if the parsed graph contains a valid execution      * plan. This method is intended to be used by components that need to      * ensure that an parsed graph contains a valid execution plan.<p>      * This especially checks:<ul>      *<li> if for all {@link ExecutionPlan#EXECUTION_NODE}s      *<li> if they define a unary and valid value for the      * {@link ExecutionPlan#ENGINE} property and      *<li> if all {@link ExecutionPlan#DEPENDS_ON} values do actually point      * to an other execution node in the parsed graph      *<ul><p>      * This method does not modify the parsed graph. Therefore it is save      * to parse a {@link Graph} object.<p>      * TODO: There is no check for cycles implemented yet.      * @param the graph to check      * @return the engine names referenced by the validated execution plan-      * @throws ChainException      */
specifier|public
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|validateExecutionPlan
parameter_list|(
name|TripleCollection
name|executionPlan
parameter_list|)
throws|throws
name|ChainException
block|{
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|executionNodeIt
init|=
name|executionPlan
operator|.
name|filter
argument_list|(
literal|null
argument_list|,
name|RDF_TYPE
argument_list|,
name|EXECUTION_NODE
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|engineNames
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|NonLiteral
argument_list|,
name|Collection
argument_list|<
name|NonLiteral
argument_list|>
argument_list|>
name|nodeDependencies
init|=
operator|new
name|HashMap
argument_list|<
name|NonLiteral
argument_list|,
name|Collection
argument_list|<
name|NonLiteral
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|//1. check the ExecutionNodes
while|while
condition|(
name|executionNodeIt
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|NonLiteral
name|node
init|=
name|executionNodeIt
operator|.
name|next
argument_list|()
operator|.
name|getSubject
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|engines
init|=
name|EnhancementEngineHelper
operator|.
name|getStrings
argument_list|(
name|executionPlan
argument_list|,
name|node
argument_list|,
name|ENGINE
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|engines
operator|.
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ChainException
argument_list|(
literal|"Execution Node "
operator|+
name|node
operator|+
literal|" does not define "
operator|+
literal|"the required property "
operator|+
name|ENGINE
operator|+
literal|"!"
argument_list|)
throw|;
block|}
name|String
name|engine
init|=
name|engines
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|engines
operator|.
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ChainException
argument_list|(
literal|"Execution Node "
operator|+
name|node
operator|+
literal|" does not define "
operator|+
literal|"multiple values for the property "
operator|+
name|ENGINE
operator|+
literal|"!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|engine
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ChainException
argument_list|(
literal|"Execution Node "
operator|+
name|node
operator|+
literal|" does not define "
operator|+
literal|"an empty String as engine name (property "
operator|+
name|ENGINE
operator|+
literal|")!"
argument_list|)
throw|;
block|}
name|engineNames
operator|.
name|add
argument_list|(
name|engine
argument_list|)
expr_stmt|;
name|Collection
argument_list|<
name|NonLiteral
argument_list|>
name|dependsOn
init|=
operator|new
name|HashSet
argument_list|<
name|NonLiteral
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|t
init|=
name|executionPlan
operator|.
name|filter
argument_list|(
name|node
argument_list|,
name|DEPENDS_ON
argument_list|,
literal|null
argument_list|)
init|;
name|t
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Resource
name|o
init|=
name|t
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|o
operator|instanceof
name|NonLiteral
condition|)
block|{
name|dependsOn
operator|.
name|add
argument_list|(
operator|(
name|NonLiteral
operator|)
name|o
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|ChainException
argument_list|(
literal|"Execution Node "
operator|+
name|node
operator|+
literal|" defines the literal '"
operator|+
name|o
operator|+
literal|"' as value for the "
operator|+
name|DEPENDS_ON
operator|+
literal|" property. However this"
operator|+
literal|"property requires values to be bNodes or URIs."
argument_list|)
throw|;
block|}
block|}
name|nodeDependencies
operator|.
name|put
argument_list|(
name|node
argument_list|,
name|dependsOn
argument_list|)
expr_stmt|;
block|}
comment|//2. now check the dependency graph
for|for
control|(
name|Entry
argument_list|<
name|NonLiteral
argument_list|,
name|Collection
argument_list|<
name|NonLiteral
argument_list|>
argument_list|>
name|entry
range|:
name|nodeDependencies
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|getValue
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|NonLiteral
name|dependent
range|:
name|entry
operator|.
name|getValue
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|nodeDependencies
operator|.
name|containsKey
argument_list|(
name|dependent
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ChainException
argument_list|(
literal|"Execution Node "
operator|+
name|entry
operator|.
name|getKey
argument_list|()
operator|+
literal|" defines a dependency to an non existent ex:ExectutionNode "
operator|+
name|dependent
operator|+
literal|"!"
argument_list|)
throw|;
block|}
comment|//else the dependency is valid
block|}
block|}
comment|//no dependencies
block|}
comment|//done ... the parsed graph survived all consistency checks :)
return|return
name|engineNames
return|;
block|}
specifier|public
specifier|static
name|Set
argument_list|<
name|NonLiteral
argument_list|>
name|getDependend
parameter_list|(
name|TripleCollection
name|executionPlan
parameter_list|,
name|NonLiteral
name|executionNode
parameter_list|)
block|{
name|Set
argument_list|<
name|NonLiteral
argument_list|>
name|dependend
init|=
operator|new
name|HashSet
argument_list|<
name|NonLiteral
argument_list|>
argument_list|()
decl_stmt|;
name|addDependend
argument_list|(
name|dependend
argument_list|,
name|executionPlan
argument_list|,
name|executionNode
argument_list|)
expr_stmt|;
return|return
name|dependend
return|;
block|}
specifier|public
specifier|static
name|void
name|addDependend
parameter_list|(
name|Collection
argument_list|<
name|NonLiteral
argument_list|>
name|collection
parameter_list|,
name|TripleCollection
name|executionPlan
parameter_list|,
name|NonLiteral
name|executionNode
parameter_list|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|it
init|=
name|executionPlan
operator|.
name|filter
argument_list|(
name|executionNode
argument_list|,
name|DEPENDS_ON
argument_list|,
literal|null
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
name|collection
operator|.
name|add
argument_list|(
operator|(
name|NonLiteral
operator|)
name|it
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
argument_list|)
control|)
empty_stmt|;
block|}
specifier|public
specifier|static
name|boolean
name|isOptional
parameter_list|(
name|TripleCollection
name|executionPlan
parameter_list|,
name|NonLiteral
name|executionNode
parameter_list|)
block|{
name|Boolean
name|optional
init|=
name|get
argument_list|(
name|executionPlan
argument_list|,
name|executionNode
argument_list|,
name|OPTIONAL
argument_list|,
name|Boolean
operator|.
name|class
argument_list|,
name|lf
argument_list|)
decl_stmt|;
return|return
name|optional
operator|==
literal|null
condition|?
literal|false
else|:
name|optional
operator|.
name|booleanValue
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|String
name|getEngine
parameter_list|(
name|TripleCollection
name|executionPlan
parameter_list|,
name|NonLiteral
name|executionNode
parameter_list|)
block|{
return|return
name|getString
argument_list|(
name|executionPlan
argument_list|,
name|executionNode
argument_list|,
name|ENGINE
argument_list|)
return|;
block|}
comment|/**      * Calculates a sorted list of active EnhancementEngines form the given      * ExecutinPlan      * @param engineManager The engine manager (OSGI service or {@link EnginesTracker})      * @param ep the execution plan      * @return      */
specifier|public
specifier|static
name|List
argument_list|<
name|EnhancementEngine
argument_list|>
name|getActiveEngines
parameter_list|(
name|EnhancementEngineManager
name|engineManager
parameter_list|,
name|TripleCollection
name|ep
parameter_list|)
block|{
name|List
argument_list|<
name|EnhancementEngine
argument_list|>
name|engines
init|=
operator|new
name|ArrayList
argument_list|<
name|EnhancementEngine
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|NonLiteral
argument_list|>
name|visited
init|=
operator|new
name|HashSet
argument_list|<
name|NonLiteral
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|NonLiteral
argument_list|>
name|executeable
decl_stmt|;
do|do
block|{
name|executeable
operator|=
name|getExecutable
argument_list|(
name|ep
argument_list|,
name|visited
argument_list|)
expr_stmt|;
for|for
control|(
name|NonLiteral
name|node
range|:
name|executeable
control|)
block|{
name|String
name|engineName
init|=
name|getString
argument_list|(
name|ep
argument_list|,
name|node
argument_list|,
name|ENGINE
argument_list|)
decl_stmt|;
name|EnhancementEngine
name|engine
init|=
name|engineManager
operator|.
name|getEngine
argument_list|(
name|engineName
argument_list|)
decl_stmt|;
if|if
condition|(
name|engine
operator|!=
literal|null
condition|)
block|{
name|engines
operator|.
name|add
argument_list|(
name|engine
argument_list|)
expr_stmt|;
block|}
name|visited
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|executeable
operator|.
name|isEmpty
argument_list|()
condition|)
do|;
return|return
name|engines
return|;
block|}
comment|/**      * Getter for the {@link ExecutionPlan#EXECUTION_PLAN} node of an execution      * plan for the given chainNmame. This method is handy for components that      * need to get an execution plan for a graph that might potentially contain      * more than a single execution plan.      * @param graph the graph      * @param chainName the chain name      * @return the node or<code>null</code> if not found      */
specifier|public
specifier|static
name|NonLiteral
name|getExecutionPlan
parameter_list|(
name|TripleCollection
name|graph
parameter_list|,
name|String
name|chainName
parameter_list|)
block|{
if|if
condition|(
name|graph
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed graph MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|chainName
operator|==
literal|null
operator|||
name|chainName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed chain name MUST NOT be NULL nor empty!"
argument_list|)
throw|;
block|}
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|it
init|=
name|graph
operator|.
name|filter
argument_list|(
literal|null
argument_list|,
name|CHAIN
argument_list|,
operator|new
name|PlainLiteralImpl
argument_list|(
name|chainName
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
return|return
name|it
operator|.
name|next
argument_list|()
operator|.
name|getSubject
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Getter for the set of ExecutionNodes part of an execution plan.      * @param ep the execution plan graph      * @param executionPlanNode the execution plan node      */
specifier|public
specifier|static
name|Set
argument_list|<
name|NonLiteral
argument_list|>
name|getExecutionNodes
parameter_list|(
name|TripleCollection
name|ep
parameter_list|,
specifier|final
name|NonLiteral
name|executionPlanNode
parameter_list|)
block|{
if|if
condition|(
name|ep
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed graph with the Executionplan MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|executionPlanNode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed execution plan node MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|Set
argument_list|<
name|NonLiteral
argument_list|>
name|executionNodes
init|=
operator|new
name|HashSet
argument_list|<
name|NonLiteral
argument_list|>
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|it
init|=
name|ep
operator|.
name|filter
argument_list|(
name|executionPlanNode
argument_list|,
name|HAS_EXECUTION_NODE
argument_list|,
literal|null
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Triple
name|t
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|Resource
name|node
init|=
name|t
operator|.
name|getObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|node
operator|instanceof
name|NonLiteral
condition|)
block|{
name|executionNodes
operator|.
name|add
argument_list|(
operator|(
name|NonLiteral
operator|)
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"The value of the "
operator|+
name|HAS_EXECUTION_NODE
operator|+
literal|" property MUST BE a NonLiteral (triple: "
operator|+
name|t
operator|+
literal|")!"
argument_list|)
throw|;
block|}
block|}
return|return
name|executionNodes
return|;
block|}
block|}
end_class

end_unit

