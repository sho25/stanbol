begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
package|;
end_package

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|singleton
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|TechnicalClasses
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|UUID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Language
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Literal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|LiteralFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|MGraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|NonLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Triple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|TripleCollection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|TypedLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|UriRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|impl
operator|.
name|PlainLiteralImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|impl
operator|.
name|TripleImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|Chain
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|ContentItem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|EnhancementEngine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|ServiceProperties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_class
specifier|public
class|class
name|EnhancementEngineHelper
block|{
comment|/**      * The maximum size of the prefix/suffix for the selection context      * @since 0.11.0      */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_SELECTION_CONTEXT_PREFIX_SUFFIX_SIZE
init|=
literal|50
decl_stmt|;
comment|/**      * The minimum size of the prefix/suffix for the selection context      * @since 0.11.0      */
specifier|public
specifier|static
specifier|final
name|int
name|MIN_SELECTION_CONTEXT_PREFIX_SUFFIX_SIZE
init|=
literal|15
decl_stmt|;
comment|/**      * The minimum length of the selected text so that fise:selection-head and      * fise:selection.tail are being used instead of fise:selected-text. The      * actual size is calculated by using<code>prefixSuffixLength*5</code>.      * So if a user does not chage the {@link #DEFAULT_PREFIX_SUFFIX_LENGTH} the      * default value us<code>10 * 5 = 50</code> chars.      */
specifier|public
specifier|static
specifier|final
name|int
name|MIN_SELECTEN_HEAD_TAIL_USAGE_LENGTH
init|=
literal|30
decl_stmt|;
comment|/**      * The default length of fise:selection-prefix and fise:selection-suffix      * literals (value = 10).      */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_PREFIX_SUFFIX_LENGTH
init|=
literal|10
decl_stmt|;
comment|/**      * The minimum size for fise:selection-prefix and fise:selection-suffix      * literals (value = 3).      */
specifier|public
specifier|static
specifier|final
name|int
name|MIN_PREFIX_SUFFIX_SIZE
init|=
literal|3
decl_stmt|;
specifier|protected
specifier|final
specifier|static
name|Random
name|rng
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|EnhancementEngineHelper
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|LiteralFactory
name|lf
init|=
name|LiteralFactory
operator|.
name|getInstance
argument_list|()
decl_stmt|;
specifier|public
specifier|static
name|void
name|setSeed
parameter_list|(
name|long
name|seed
parameter_list|)
block|{
name|rng
operator|.
name|setSeed
argument_list|(
name|seed
argument_list|)
expr_stmt|;
block|}
comment|/**      * Create a new instance with the types enhancer:Enhancement and      * enhancer:TextAnnotation in the metadata-graph of the content      * item along with default properties (dc:creator and dc:created) and return      * the UriRef of the extraction so that engines can further add.      *      * @param ci the ContentItem being under analysis      * @param engine the Engine performing the analysis      *      * @return the URI of the new enhancement instance      */
specifier|public
specifier|static
name|UriRef
name|createTextEnhancement
parameter_list|(
name|ContentItem
name|ci
parameter_list|,
name|EnhancementEngine
name|engine
parameter_list|)
block|{
return|return
name|createTextEnhancement
argument_list|(
name|ci
operator|.
name|getMetadata
argument_list|()
argument_list|,
name|engine
argument_list|,
operator|new
name|UriRef
argument_list|(
name|ci
operator|.
name|getUri
argument_list|()
operator|.
name|getUnicodeString
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Create a new instance with the types enhancer:Enhancement and      * enhancer:TextAnnotation in the parsed graph along with default properties      * (dc:creator, dc:created and enhancer:extracted-form) and return      * the UriRef of the extraction so that engines can further add.      *      * @param metadata the graph      * @param engine the engine      * @param contentItemId the id      *      * @return the URI of the new enhancement instance      */
specifier|public
specifier|static
name|UriRef
name|createTextEnhancement
parameter_list|(
name|MGraph
name|metadata
parameter_list|,
name|EnhancementEngine
name|engine
parameter_list|,
name|UriRef
name|contentItemId
parameter_list|)
block|{
name|UriRef
name|enhancement
init|=
name|createEnhancement
argument_list|(
name|metadata
argument_list|,
name|engine
argument_list|,
name|contentItemId
argument_list|)
decl_stmt|;
comment|//add the Text Annotation Type
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|enhancement
argument_list|,
name|RDF_TYPE
argument_list|,
name|ENHANCER_TEXTANNOTATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|enhancement
return|;
block|}
comment|/**      * This method sets the fise:start, fise:end, fise:selection-prefix,       * fise:selected-text and fise:selection-suffix properties for the       * parsed fise:TextAnnotation instance according to the parsed parameters.<p>      * While it is intended to be used for TextAnnotations this method can also      * be used to add the mentioned properties to {@link UriRef}s with different      * type.<p>      *<b>NOTE</b> the<code>allowSelectionHeadTail</code>: This parameter allows      * to deactivate the usage of fise:selection-head and fise:selection-tail.      * Typically users should parse<code>false</code> in case of 'named entities'      * and<code>true</code> in case sections of the text (e.g. phrases, sentences,      * chapters ...) are selected.      * @param metadata The RDF graph to add the information      * @param textAnnotation the UriRef of the fise:TextAnnotation      * @param content the plain text content as String      * @param start the start index of the occurrence       * @param end the end index of the occurrence      * @param lang the lanugage of the content or<code>null</code> if not known      * @param prefixSuffixSize the size of the prefix, suffix. If the parsed      * value&lt; 3 than the default 10 is used.      * @param allowSelectionHeadTail if<code>true</code> the fise:selection-head      * and fise:selection-tail properties are used instead of fise:selected-text      * if the selected text is longer as<code>Math.max(30, prefixSuffixSize*5);</code>.      * If<code>false</code> the fise:selected-text is added regardless of the      * size of the selected area.      * @since 0.11.0      */
specifier|public
specifier|static
name|void
name|setOccurrence
parameter_list|(
name|MGraph
name|metadata
parameter_list|,
name|UriRef
name|textAnnotation
parameter_list|,
name|String
name|content
parameter_list|,
name|Integer
name|start
parameter_list|,
name|Integer
name|end
parameter_list|,
name|Language
name|lang
parameter_list|,
name|int
name|prefixSuffixSize
parameter_list|,
name|boolean
name|allowSelectionHeadTail
parameter_list|)
block|{
comment|//set start, end
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|textAnnotation
argument_list|,
name|ENHANCER_START
argument_list|,
name|lf
operator|.
name|createTypedLiteral
argument_list|(
name|start
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|textAnnotation
argument_list|,
name|ENHANCER_END
argument_list|,
name|lf
operator|.
name|createTypedLiteral
argument_list|(
name|end
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|//set selection prefix and suffix (TextAnnotation new model)
name|prefixSuffixSize
operator|=
name|prefixSuffixSize
operator|<
name|MIN_PREFIX_SUFFIX_SIZE
condition|?
name|DEFAULT_PREFIX_SUFFIX_LENGTH
else|:
name|prefixSuffixSize
expr_stmt|;
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|textAnnotation
argument_list|,
name|ENHANCER_SELECTION_PREFIX
argument_list|,
operator|new
name|PlainLiteralImpl
argument_list|(
name|content
operator|.
name|substring
argument_list|(
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|start
operator|-
name|prefixSuffixSize
argument_list|)
argument_list|,
name|start
argument_list|)
argument_list|,
name|lang
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|textAnnotation
argument_list|,
name|ENHANCER_SELECTION_SUFFIX
argument_list|,
operator|new
name|PlainLiteralImpl
argument_list|(
name|content
operator|.
name|substring
argument_list|(
name|end
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|content
operator|.
name|length
argument_list|()
argument_list|,
name|end
operator|+
name|prefixSuffixSize
argument_list|)
argument_list|)
argument_list|,
name|lang
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|//set the selected text (or alternatively head and tail)
name|int
name|maxSelectedTextSize
init|=
name|Math
operator|.
name|max
argument_list|(
name|MIN_SELECTEN_HEAD_TAIL_USAGE_LENGTH
argument_list|,
name|prefixSuffixSize
operator|*
literal|5
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|allowSelectionHeadTail
operator|||
name|end
operator|-
name|start
operator|<=
name|maxSelectedTextSize
condition|)
block|{
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|textAnnotation
argument_list|,
name|ENHANCER_SELECTED_TEXT
argument_list|,
operator|new
name|PlainLiteralImpl
argument_list|(
name|content
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
argument_list|,
name|lang
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//selected area to long for fise:selected-text
comment|//use fise:selection-head and fise:selection-tail instead
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|textAnnotation
argument_list|,
name|ENHANCER_SELECTION_HEAD
argument_list|,
operator|new
name|PlainLiteralImpl
argument_list|(
name|content
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|start
operator|+
name|prefixSuffixSize
argument_list|)
argument_list|,
name|lang
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|textAnnotation
argument_list|,
name|ENHANCER_SELECTION_TAIL
argument_list|,
operator|new
name|PlainLiteralImpl
argument_list|(
name|content
operator|.
name|substring
argument_list|(
name|end
operator|-
name|prefixSuffixSize
argument_list|,
name|end
argument_list|)
argument_list|,
name|lang
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Extracts the selection context based on the content, selection and      * the start char offset of the selection. Tries to cut of the context       * on whole words. The size of the prefix/suffix is set to      * {@link #DEFAULT_SELECTION_CONTEXT_PREFIX_SUFFIX_SIZE}.      * @param content the content      * @param selection the selected text      * @param selectionStartPos the start char position of the selection      * @return the context      * @since 0.11.0      */
specifier|public
specifier|static
name|String
name|getSelectionContext
parameter_list|(
name|String
name|content
parameter_list|,
name|String
name|selection
parameter_list|,
name|int
name|selectionStartPos
parameter_list|)
block|{
return|return
name|getSelectionContext
argument_list|(
name|content
argument_list|,
name|selection
argument_list|,
name|selectionStartPos
argument_list|,
name|DEFAULT_SELECTION_CONTEXT_PREFIX_SUFFIX_SIZE
argument_list|)
return|;
block|}
comment|/**      * Extracts the selection context based on the content, selection and      * the start char offset of the selection. Tries to cut of the context       * on whole words.      * @param content the content      * @param selection the selected text      * @param selectionStartPos the start char position of the selection      * @param contextSize the size of the prefix/suffix. If less than zero the      * {@link #DEFAULT_SELECTION_CONTEXT_PREFIX_SUFFIX_SIZE} is used. If in the      * range [0..{@link #MIN_SELECTION_CONTEXT_PREFIX_SUFFIX_SIZE}] than the      * size is set to {@link #MIN_SELECTION_CONTEXT_PREFIX_SUFFIX_SIZE}      * @return the context      * @since 0.11.0      */
specifier|public
specifier|static
name|String
name|getSelectionContext
parameter_list|(
name|String
name|content
parameter_list|,
name|String
name|selection
parameter_list|,
name|int
name|selectionStartPos
parameter_list|,
name|int
name|contextSize
parameter_list|)
block|{
if|if
condition|(
name|contextSize
operator|<
literal|0
condition|)
block|{
name|contextSize
operator|=
name|DEFAULT_SELECTION_CONTEXT_PREFIX_SUFFIX_SIZE
expr_stmt|;
block|}
if|if
condition|(
name|contextSize
operator|<
name|MIN_SELECTION_CONTEXT_PREFIX_SUFFIX_SIZE
condition|)
block|{
name|contextSize
operator|=
name|MIN_PREFIX_SUFFIX_SIZE
expr_stmt|;
block|}
comment|//extract the selection context
name|int
name|beginPos
decl_stmt|;
if|if
condition|(
name|selectionStartPos
operator|<=
name|DEFAULT_SELECTION_CONTEXT_PREFIX_SUFFIX_SIZE
condition|)
block|{
name|beginPos
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|int
name|start
init|=
name|selectionStartPos
operator|-
name|DEFAULT_SELECTION_CONTEXT_PREFIX_SUFFIX_SIZE
decl_stmt|;
name|beginPos
operator|=
name|content
operator|.
name|indexOf
argument_list|(
literal|' '
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|beginPos
operator|<
literal|0
operator|||
name|beginPos
operator|>=
name|selectionStartPos
condition|)
block|{
comment|//no words
name|beginPos
operator|=
name|start
expr_stmt|;
comment|//begin within a word
block|}
block|}
name|int
name|endPos
decl_stmt|;
if|if
condition|(
name|selectionStartPos
operator|+
name|selection
operator|.
name|length
argument_list|()
operator|+
name|DEFAULT_SELECTION_CONTEXT_PREFIX_SUFFIX_SIZE
operator|>=
name|content
operator|.
name|length
argument_list|()
condition|)
block|{
name|endPos
operator|=
name|content
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|int
name|start
init|=
name|selectionStartPos
operator|+
name|selection
operator|.
name|length
argument_list|()
operator|+
name|DEFAULT_SELECTION_CONTEXT_PREFIX_SUFFIX_SIZE
decl_stmt|;
name|endPos
operator|=
name|content
operator|.
name|lastIndexOf
argument_list|(
literal|' '
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|endPos
operator|<=
name|selectionStartPos
operator|+
name|selection
operator|.
name|length
argument_list|()
condition|)
block|{
name|endPos
operator|=
name|start
expr_stmt|;
comment|//end within a word;
block|}
block|}
return|return
name|content
operator|.
name|substring
argument_list|(
name|beginPos
argument_list|,
name|endPos
argument_list|)
return|;
block|}
comment|/**      * Create a new instance with the types enhancer:Enhancement and      * enhancer:EntityAnnotation in the metadata-graph of the content      * item along with default properties (dc:creator and dc:created) and return      * the UriRef of the extraction so that engines can further add      *      * @param ci the ContentItem being under analysis      * @param engine the Engine performing the analysis      * @return the URI of the new enhancement instance      */
specifier|public
specifier|static
name|UriRef
name|createEntityEnhancement
parameter_list|(
name|ContentItem
name|ci
parameter_list|,
name|EnhancementEngine
name|engine
parameter_list|)
block|{
return|return
name|createEntityEnhancement
argument_list|(
name|ci
operator|.
name|getMetadata
argument_list|()
argument_list|,
name|engine
argument_list|,
operator|new
name|UriRef
argument_list|(
name|ci
operator|.
name|getUri
argument_list|()
operator|.
name|getUnicodeString
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Create a new instance with the types enhancer:Enhancement and      * enhancer:EntityAnnotation in the parsed graph along with default properties      * (dc:creator, dc:created and enhancer:extracted-form) and return      * the UriRef of the extraction so that engines can further add.      *      * @param metadata the graph      * @param engine the engine      * @param contentItemId the id      *      * @return the URI of the new enhancement instance      */
specifier|public
specifier|static
name|UriRef
name|createEntityEnhancement
parameter_list|(
name|MGraph
name|metadata
parameter_list|,
name|EnhancementEngine
name|engine
parameter_list|,
name|UriRef
name|contentItemId
parameter_list|)
block|{
name|UriRef
name|enhancement
init|=
name|createEnhancement
argument_list|(
name|metadata
argument_list|,
name|engine
argument_list|,
name|contentItemId
argument_list|)
decl_stmt|;
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|enhancement
argument_list|,
name|RDF_TYPE
argument_list|,
name|ENHANCER_ENTITYANNOTATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|enhancement
return|;
block|}
comment|/**      * Create a new instance with the types enhancer:Enhancement and      * enhancer:TopicAnnotation in the parsed graph along with default properties      * (dc:creator, dc:created and enhancer:extracted-form) and return      * the UriRef of the extraction so that engines can further add.      *      * @param metadata the graph      * @param engine the engine      * @param contentItemId the id      *      * @return the URI of the new enhancement instance      */
specifier|public
specifier|static
name|UriRef
name|createTopicEnhancement
parameter_list|(
name|MGraph
name|metadata
parameter_list|,
name|EnhancementEngine
name|engine
parameter_list|,
name|UriRef
name|contentItemId
parameter_list|)
block|{
name|UriRef
name|enhancement
init|=
name|createEnhancement
argument_list|(
name|metadata
argument_list|,
name|engine
argument_list|,
name|contentItemId
argument_list|)
decl_stmt|;
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|enhancement
argument_list|,
name|RDF_TYPE
argument_list|,
name|ENHANCER_TOPICANNOTATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|enhancement
return|;
block|}
comment|/**      * Create a new instance with the types enhancer:Enhancement and      * enhancer:TopicAnnotation in the metadata-graph of the content      * item along with default properties (dc:creator and dc:created) and return      * the UriRef of the extraction so that engines can further add      *      * @param ci the ContentItem being under analysis      * @param engine the Engine performing the analysis      * @return the URI of the new enhancement instance      */
specifier|public
specifier|static
name|UriRef
name|createTopicEnhancement
parameter_list|(
name|ContentItem
name|ci
parameter_list|,
name|EnhancementEngine
name|engine
parameter_list|)
block|{
return|return
name|createTopicEnhancement
argument_list|(
name|ci
operator|.
name|getMetadata
argument_list|()
argument_list|,
name|engine
argument_list|,
operator|new
name|UriRef
argument_list|(
name|ci
operator|.
name|getUri
argument_list|()
operator|.
name|getUnicodeString
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Create a new enhancement instance in the metadata-graph of the content      * item along with default properties (dc:creator and dc:created) and return      * the UriRef of the extraction so that engines can further add.      *      * @param ci the ContentItem being under analysis      * @param engine the Engine performing the analysis      *      * @return the URI of the new enhancement instance      */
specifier|protected
specifier|static
name|UriRef
name|createEnhancement
parameter_list|(
name|MGraph
name|metadata
parameter_list|,
name|EnhancementEngine
name|engine
parameter_list|,
name|UriRef
name|contentItemId
parameter_list|)
block|{
name|LiteralFactory
name|literalFactory
init|=
name|LiteralFactory
operator|.
name|getInstance
argument_list|()
decl_stmt|;
name|UriRef
name|enhancement
init|=
operator|new
name|UriRef
argument_list|(
literal|"urn:enhancement-"
operator|+
name|EnhancementEngineHelper
operator|.
name|randomUUID
argument_list|()
argument_list|)
decl_stmt|;
comment|//add the Enhancement Type
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|enhancement
argument_list|,
name|RDF_TYPE
argument_list|,
name|ENHANCER_ENHANCEMENT
argument_list|)
argument_list|)
expr_stmt|;
comment|//add the extracted from content item
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|enhancement
argument_list|,
name|ENHANCER_EXTRACTED_FROM
argument_list|,
name|contentItemId
argument_list|)
argument_list|)
expr_stmt|;
comment|// creation date
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|enhancement
argument_list|,
name|DC_CREATED
argument_list|,
name|literalFactory
operator|.
name|createTypedLiteral
argument_list|(
operator|new
name|Date
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// the engines that extracted the data
comment|// TODO: add some kind of versioning info for the extractor?
comment|// TODO: use a public dereferencing URI instead? that would allow for
comment|// explicit versioning too
comment|/* NOTE (Rupert Westenthaler 2010-05-26):          * The Idea is to use the  ComponentContext in the activate() method of          * an Enhancer to get the bundle name/version and use that as an          * URI for the creator.          * We would need to add getEnhancerID() method to the enhancer interface          * to access this information           */
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|enhancement
argument_list|,
name|DC_CREATOR
argument_list|,
name|literalFactory
operator|.
name|createTypedLiteral
argument_list|(
name|engine
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|enhancement
return|;
block|}
comment|/**      * Adds the parsed {@link EnhancementEngine} as dc:contributer to the      * enhancement and also sets the dc:modified property accordingly      * @param metadata the {@link ContentItem#getMetadata()}      * @param enhancement the enhancement      * @param engine the engine      */
specifier|public
specifier|static
name|void
name|addContributingEngine
parameter_list|(
name|MGraph
name|metadata
parameter_list|,
name|UriRef
name|enhancement
parameter_list|,
name|EnhancementEngine
name|engine
parameter_list|)
block|{
name|LiteralFactory
name|literalFactory
init|=
name|LiteralFactory
operator|.
name|getInstance
argument_list|()
decl_stmt|;
comment|// TODO: use a public dereferencing URI instead?
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|enhancement
argument_list|,
name|DC_CONTRIBUTOR
argument_list|,
name|literalFactory
operator|.
name|createTypedLiteral
argument_list|(
name|engine
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|//set the modification date to the current date.
name|set
argument_list|(
name|metadata
argument_list|,
name|enhancement
argument_list|,
name|DC_MODIFIED
argument_list|,
operator|new
name|Date
argument_list|()
argument_list|,
name|literalFactory
argument_list|)
expr_stmt|;
block|}
comment|/**      * Create a new extraction instance in the metadata-graph of the content      * item along with default properties (dc:creator and dc:created) and return      * the UriRef of the extraction so that engines can further add      *      * @param ci the ContentItem being under analysis      * @param engine the Engine performing the analysis      * @return the URI of the new extraction instance      * @deprecated will be remove with 1.0      * @see EnhancementEngineHelper#createEntityEnhancement(ContentItem, EnhancementEngine)      * @see EnhancementEngineHelper#createTextEnhancement(ContentItem, EnhancementEngine)      */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|UriRef
name|createNewExtraction
parameter_list|(
name|ContentItem
name|ci
parameter_list|,
name|EnhancementEngine
name|engine
parameter_list|)
block|{
name|LiteralFactory
name|literalFactory
init|=
name|LiteralFactory
operator|.
name|getInstance
argument_list|()
decl_stmt|;
name|MGraph
name|metadata
init|=
name|ci
operator|.
name|getMetadata
argument_list|()
decl_stmt|;
name|UriRef
name|extraction
init|=
operator|new
name|UriRef
argument_list|(
literal|"urn:extraction-"
operator|+
name|EnhancementEngineHelper
operator|.
name|randomUUID
argument_list|()
argument_list|)
decl_stmt|;
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|extraction
argument_list|,
name|RDF_TYPE
argument_list|,
name|ENHANCER_EXTRACTION
argument_list|)
argument_list|)
expr_stmt|;
comment|// relate the extraction to the content item
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|extraction
argument_list|,
name|ENHANCER_RELATED_CONTENT_ITEM
argument_list|,
operator|new
name|UriRef
argument_list|(
name|ci
operator|.
name|getUri
argument_list|()
operator|.
name|getUnicodeString
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// creation date
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|extraction
argument_list|,
name|DC_CREATED
argument_list|,
name|literalFactory
operator|.
name|createTypedLiteral
argument_list|(
operator|new
name|Date
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// the engines that extracted the data
comment|// TODO: add some kind of versioning info for the extractor?
comment|// TODO: use a public dereferencing URI instead? that would allow for
comment|// explicit versioning too
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|extraction
argument_list|,
name|DC_CREATOR
argument_list|,
name|literalFactory
operator|.
name|createTypedLiteral
argument_list|(
name|engine
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|extraction
return|;
block|}
comment|/**      * Random UUID generator with re-seedable RNG for the tests.      *      * @return a new Random UUID      */
specifier|public
specifier|static
name|UUID
name|randomUUID
parameter_list|()
block|{
return|return
operator|new
name|UUID
argument_list|(
name|rng
operator|.
name|nextLong
argument_list|()
argument_list|,
name|rng
operator|.
name|nextLong
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Getter for the first typed literal value of the property for a resource.      *      * @param<T> the java class the literal value needs to be converted to.      * Note that the parsed LiteralFactory needs to support this conversion      * @param graph the graph used to query for the property value      * @param resource the resource      * @param property the property      * @param type the type the literal needs to be converted to      * @param literalFactory the literalFactory      * @return the value      */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|get
parameter_list|(
name|TripleCollection
name|graph
parameter_list|,
name|NonLiteral
name|resource
parameter_list|,
name|UriRef
name|property
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
name|LiteralFactory
name|literalFactory
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|results
init|=
name|graph
operator|.
name|filter
argument_list|(
name|resource
argument_list|,
name|property
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|results
operator|.
name|hasNext
argument_list|()
condition|)
block|{
while|while
condition|(
name|results
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Triple
name|result
init|=
name|results
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|.
name|getObject
argument_list|()
operator|instanceof
name|TypedLiteral
condition|)
block|{
return|return
name|literalFactory
operator|.
name|createObject
argument_list|(
name|type
argument_list|,
operator|(
name|TypedLiteral
operator|)
name|result
operator|.
name|getObject
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Triple {} does not have a TypedLiteral as object! -> ignore"
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
block|}
name|log
operator|.
name|info
argument_list|(
literal|"No value for {} and property {} had the requested Type {} -> return null"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|resource
block|,
name|property
block|,
name|type
block|}
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"No Triple found for {} and property {}! -> return null"
argument_list|,
name|resource
argument_list|,
name|property
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Replaces all current values of the property for the resource      * with the parsed value      * @param graph the graph      * @param resource the resource      * @param property the property      * @param value the value      */
specifier|public
specifier|static
name|void
name|set
parameter_list|(
name|MGraph
name|graph
parameter_list|,
name|NonLiteral
name|resource
parameter_list|,
name|UriRef
name|property
parameter_list|,
name|Resource
name|value
parameter_list|)
block|{
name|set
argument_list|(
name|graph
argument_list|,
name|resource
argument_list|,
name|property
argument_list|,
name|value
operator|==
literal|null
condition|?
literal|null
else|:
name|singleton
argument_list|(
name|value
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Replaces all current values of the property for the resource      * with the parsed values      * @param graph the graph      * @param resource the resource      * @param property the property      * @param value the value      */
specifier|public
specifier|static
name|void
name|set
parameter_list|(
name|MGraph
name|graph
parameter_list|,
name|NonLiteral
name|resource
parameter_list|,
name|UriRef
name|property
parameter_list|,
name|Collection
argument_list|<
name|Resource
argument_list|>
name|values
parameter_list|)
block|{
name|set
argument_list|(
name|graph
argument_list|,
name|resource
argument_list|,
name|property
argument_list|,
name|values
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Replaces all current values of the property for the resource      * with the parsed value      * @param graph the graph      * @param resource the resource      * @param property the property      * @param value the value. In case it is an instance of {@link Resource} it      * is directly added to the graph. Otherwise the parsed {@link LiteralFactory}      * is used to create a {@link TypedLiteral} for the parsed value.      * @param literalFactory the {@link LiteralFactory} used in case the parsed      * value is not an {@link Resource}      */
specifier|public
specifier|static
name|void
name|set
parameter_list|(
name|MGraph
name|graph
parameter_list|,
name|NonLiteral
name|resource
parameter_list|,
name|UriRef
name|property
parameter_list|,
name|Object
name|value
parameter_list|,
name|LiteralFactory
name|literalFactory
parameter_list|)
block|{
name|set
argument_list|(
name|graph
argument_list|,
name|resource
argument_list|,
name|property
argument_list|,
name|value
operator|==
literal|null
condition|?
literal|null
else|:
name|singleton
argument_list|(
name|value
argument_list|)
argument_list|,
name|literalFactory
argument_list|)
expr_stmt|;
block|}
comment|/**      * Replaces all current values of the property for the resource      * with the parsed values      * @param graph the graph      * @param resource the resource      * @param property the property      * @param value the value. In case it is an instance of {@link Resource} it      * is directly added to the graph. Otherwise the parsed {@link LiteralFactory}      * is used to create a {@link TypedLiteral} for the parsed value.      * @param literalFactory the {@link LiteralFactory} used in case the parsed      * value is not an {@link Resource}      */
specifier|public
specifier|static
name|void
name|set
parameter_list|(
name|MGraph
name|graph
parameter_list|,
name|NonLiteral
name|resource
parameter_list|,
name|UriRef
name|property
parameter_list|,
name|Collection
argument_list|<
name|?
argument_list|>
name|values
parameter_list|,
name|LiteralFactory
name|literalFactory
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|currentValues
init|=
name|graph
operator|.
name|filter
argument_list|(
name|resource
argument_list|,
name|property
argument_list|,
literal|null
argument_list|)
decl_stmt|;
while|while
condition|(
name|currentValues
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|currentValues
operator|.
name|next
argument_list|()
expr_stmt|;
name|currentValues
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|values
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Object
name|value
range|:
name|values
control|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Resource
condition|)
block|{
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|resource
argument_list|,
name|property
argument_list|,
operator|(
name|Resource
operator|)
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|resource
argument_list|,
name|property
argument_list|,
name|literalFactory
operator|.
name|createTypedLiteral
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Getter for the typed literal values of the property for a resource      * @param<T> the java class the literal value needs to be converted to.      * Note that the parsed LiteralFactory needs to support this conversion      * @param graph the graph used to query for the property value      * @param resource the resource      * @param property the property      * @param type the type the literal needs to be converted to      * @param literalFactory the literalFactory      * @return the value      */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterator
argument_list|<
name|T
argument_list|>
name|getValues
parameter_list|(
name|TripleCollection
name|graph
parameter_list|,
name|NonLiteral
name|resource
parameter_list|,
name|UriRef
name|property
parameter_list|,
specifier|final
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
specifier|final
name|LiteralFactory
name|literalFactory
parameter_list|)
block|{
specifier|final
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|results
init|=
name|graph
operator|.
name|filter
argument_list|(
name|resource
argument_list|,
name|property
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
operator|new
name|Iterator
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
comment|//TODO: dose not check if the object of the triple is of type UriRef
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|results
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|T
name|next
parameter_list|()
block|{
return|return
name|literalFactory
operator|.
name|createObject
argument_list|(
name|type
argument_list|,
operator|(
name|TypedLiteral
operator|)
name|results
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|results
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
comment|/**      * Getter for the first String literal value the property for a resource      * @param graph the graph used to query for the property value      * @param resource the resource      * @param property the property      * @return the value      */
specifier|public
specifier|static
name|String
name|getString
parameter_list|(
name|TripleCollection
name|graph
parameter_list|,
name|NonLiteral
name|resource
parameter_list|,
name|UriRef
name|property
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|results
init|=
name|graph
operator|.
name|filter
argument_list|(
name|resource
argument_list|,
name|property
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|results
operator|.
name|hasNext
argument_list|()
condition|)
block|{
while|while
condition|(
name|results
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Triple
name|result
init|=
name|results
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|.
name|getObject
argument_list|()
operator|instanceof
name|Literal
condition|)
block|{
return|return
operator|(
operator|(
name|Literal
operator|)
name|result
operator|.
name|getObject
argument_list|()
operator|)
operator|.
name|getLexicalForm
argument_list|()
return|;
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Triple {} does not have a literal as object! -> ignore"
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
block|}
name|log
operator|.
name|info
argument_list|(
literal|"No Literal value for {} and property {} -> return null"
argument_list|,
name|resource
argument_list|,
name|property
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"No Triple found for "
operator|+
name|resource
operator|+
literal|" and property "
operator|+
name|property
operator|+
literal|"! -> return null"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Getter for the string literal values the property for a resource      * @param graph the graph used to query for the property value      * @param resource the resource      * @param property the property      * @return the value      */
specifier|public
specifier|static
name|Iterator
argument_list|<
name|String
argument_list|>
name|getStrings
parameter_list|(
name|TripleCollection
name|graph
parameter_list|,
name|NonLiteral
name|resource
parameter_list|,
name|UriRef
name|property
parameter_list|)
block|{
specifier|final
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|results
init|=
name|graph
operator|.
name|filter
argument_list|(
name|resource
argument_list|,
name|property
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
operator|new
name|Iterator
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
comment|//TODO: dose not check if the object of the triple is of type UriRef
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|results
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|next
parameter_list|()
block|{
return|return
operator|(
operator|(
name|Literal
operator|)
name|results
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
operator|)
operator|.
name|getLexicalForm
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|results
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
comment|/**      * Getter for the first value of the data type property for a resource      * @param graph the graph used to query for the property value      * @param resource the resource      * @param property the property      * @return the value      */
specifier|public
specifier|static
name|UriRef
name|getReference
parameter_list|(
name|TripleCollection
name|graph
parameter_list|,
name|NonLiteral
name|resource
parameter_list|,
name|UriRef
name|property
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|results
init|=
name|graph
operator|.
name|filter
argument_list|(
name|resource
argument_list|,
name|property
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|results
operator|.
name|hasNext
argument_list|()
condition|)
block|{
while|while
condition|(
name|results
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Triple
name|result
init|=
name|results
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|.
name|getObject
argument_list|()
operator|instanceof
name|UriRef
condition|)
block|{
return|return
operator|(
name|UriRef
operator|)
name|result
operator|.
name|getObject
argument_list|()
return|;
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Triple "
operator|+
name|result
operator|+
literal|" does not have a UriRef as object! -> ignore"
argument_list|)
expr_stmt|;
block|}
block|}
name|log
operator|.
name|info
argument_list|(
literal|"No UriRef value for {} and property {} -> return null"
argument_list|,
name|resource
argument_list|,
name|property
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"No Triple found for {} and property {}! -> return null"
argument_list|,
name|resource
argument_list|,
name|property
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Getter for the values of the data type property for a resource.      *      * @param graph the graph used to query for the property value      * @param resource the resource      * @param property the property      * @return The iterator over all the values (      */
specifier|public
specifier|static
name|Iterator
argument_list|<
name|UriRef
argument_list|>
name|getReferences
parameter_list|(
name|TripleCollection
name|graph
parameter_list|,
name|NonLiteral
name|resource
parameter_list|,
name|UriRef
name|property
parameter_list|)
block|{
specifier|final
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|results
init|=
name|graph
operator|.
name|filter
argument_list|(
name|resource
argument_list|,
name|property
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
operator|new
name|Iterator
argument_list|<
name|UriRef
argument_list|>
argument_list|()
block|{
comment|//TODO: dose not check if the object of the triple is of type UriRef
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|results
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|UriRef
name|next
parameter_list|()
block|{
return|return
operator|(
name|UriRef
operator|)
name|results
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|results
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
comment|/**      * Comparator that allows to sort a list/array of {@link EnhancementEngine}s      * based on there {@link ServiceProperties#ENHANCEMENT_ENGINE_ORDERING}.      */
specifier|public
specifier|static
specifier|final
name|Comparator
argument_list|<
name|EnhancementEngine
argument_list|>
name|EXECUTION_ORDER_COMPARATOR
init|=
operator|new
name|Comparator
argument_list|<
name|EnhancementEngine
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|EnhancementEngine
name|engine1
parameter_list|,
name|EnhancementEngine
name|engine2
parameter_list|)
block|{
name|Integer
name|order1
init|=
name|getEngineOrder
argument_list|(
name|engine1
argument_list|)
decl_stmt|;
name|Integer
name|order2
init|=
name|getEngineOrder
argument_list|(
name|engine2
argument_list|)
decl_stmt|;
comment|//start with the highest number finish with the lowest ...
return|return
name|order1
operator|==
name|order2
condition|?
literal|0
else|:
name|order1
operator|<
name|order2
condition|?
literal|1
else|:
operator|-
literal|1
return|;
block|}
block|}
decl_stmt|;
comment|/**      * Gets the {@link ServiceProperties#ENHANCEMENT_ENGINE_ORDERING} value      * for the parsed EnhancementEngine. If the Engine does not implement the      * {@link ServiceProperties} interface or does not provide the      * {@link ServiceProperties#ENHANCEMENT_ENGINE_ORDERING} the       * {@link ServiceProperties#ORDERING_DEFAULT} is returned<p>      * This method is guaranteed to NOT return<code>null</code>.      * @param engine the engine      * @return the ordering      */
specifier|public
specifier|static
name|Integer
name|getEngineOrder
parameter_list|(
name|EnhancementEngine
name|engine
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"getOrder "
operator|+
name|engine
argument_list|)
expr_stmt|;
if|if
condition|(
name|engine
operator|instanceof
name|ServiceProperties
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|" ... implements ServiceProperties"
argument_list|)
expr_stmt|;
name|Object
name|value
init|=
operator|(
operator|(
name|ServiceProperties
operator|)
name|engine
operator|)
operator|.
name|getServiceProperties
argument_list|()
operator|.
name|get
argument_list|(
name|ServiceProperties
operator|.
name|ENHANCEMENT_ENGINE_ORDERING
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"> value = "
operator|+
name|value
operator|+
literal|" "
operator|+
name|value
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
name|value
operator|instanceof
name|Integer
condition|)
block|{
return|return
operator|(
name|Integer
operator|)
name|value
return|;
block|}
block|}
return|return
name|ServiceProperties
operator|.
name|ORDERING_DEFAULT
return|;
block|}
comment|/**      * Getter for the Resources of fise:TextAnnotations that do have a value       * of the dc:language property. The returned list is sorted by 'fise:confidence'.      * Annotations with missing confidence are ranked last.<p>      * NOTE that the returned list will likely contain annotations for the same language      * if multiple language identification are used in the same {@link Chain}.      * @param graph the graph with the enhancement.       * Typically {@link ContentItem#getMetadata()}      * @return the sorted list of language annotations or an empty list if none.      * @throws IllegalArgumentException if<code>null</code> is parsed as graph      */
specifier|public
specifier|static
name|List
argument_list|<
name|NonLiteral
argument_list|>
name|getLanguageAnnotations
parameter_list|(
name|TripleCollection
name|graph
parameter_list|)
block|{
if|if
condition|(
name|graph
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed graph MUST NOT be NULL!"
argument_list|)
throw|;
block|}
comment|// I do not use SPARQL, because I do not want to instantiate a QueryEngine
specifier|final
name|Map
argument_list|<
name|NonLiteral
argument_list|,
name|Double
argument_list|>
name|confidences
init|=
operator|new
name|HashMap
argument_list|<
name|NonLiteral
argument_list|,
name|Double
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|NonLiteral
argument_list|>
name|langAnnotations
init|=
operator|new
name|ArrayList
argument_list|<
name|NonLiteral
argument_list|>
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|textAnnoataions
init|=
name|graph
operator|.
name|filter
argument_list|(
literal|null
argument_list|,
name|RDF_TYPE
argument_list|,
name|ENHANCER_TEXTANNOTATION
argument_list|)
decl_stmt|;
while|while
condition|(
name|textAnnoataions
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|NonLiteral
name|textAnnotation
init|=
name|textAnnoataions
operator|.
name|next
argument_list|()
operator|.
name|getSubject
argument_list|()
decl_stmt|;
name|String
name|language
init|=
name|getString
argument_list|(
name|graph
argument_list|,
name|textAnnotation
argument_list|,
name|DC_LANGUAGE
argument_list|)
decl_stmt|;
if|if
condition|(
name|language
operator|!=
literal|null
condition|)
block|{
name|Double
name|confidence
init|=
name|get
argument_list|(
name|graph
argument_list|,
name|textAnnotation
argument_list|,
name|ENHANCER_CONFIDENCE
argument_list|,
name|Double
operator|.
name|class
argument_list|,
name|lf
argument_list|)
decl_stmt|;
name|confidences
operator|.
name|put
argument_list|(
name|textAnnotation
argument_list|,
name|confidence
argument_list|)
expr_stmt|;
name|langAnnotations
operator|.
name|add
argument_list|(
name|textAnnotation
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|langAnnotations
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|langAnnotations
argument_list|,
operator|new
name|Comparator
argument_list|<
name|NonLiteral
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|NonLiteral
name|o1
parameter_list|,
name|NonLiteral
name|o2
parameter_list|)
block|{
name|Double
name|c1
init|=
name|confidences
operator|.
name|get
argument_list|(
name|o1
argument_list|)
decl_stmt|;
name|Double
name|c2
init|=
name|confidences
operator|.
name|get
argument_list|(
name|o2
argument_list|)
decl_stmt|;
comment|//decrising order (values without confidence last)
if|if
condition|(
name|c1
operator|==
literal|null
condition|)
block|{
return|return
name|c2
operator|==
literal|null
condition|?
literal|0
else|:
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|c2
operator|==
literal|null
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
return|return
name|c2
operator|.
name|compareTo
argument_list|(
name|c1
argument_list|)
return|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
return|return
name|langAnnotations
return|;
block|}
comment|/**      * Getter for language identified for (extracted-from) the parsed      * ContentItem. The returned value is the Annotation with the highest      * 'fise:confidence' value - or if no annotations are present - the      * 'dc-terms:language' value of the {@link ContentItem#getUri()}.<p>      * Users that want to obtain all language annotations should use      * {@link #getLanguageAnnotations(TripleCollection)} instead.<p>      * This method ensures a write lock on the {@link ContentItem}.      * @param ci the contentItem      * @return the identified language of the parsed {@link ContentItem}.      *<code>null</code> if not available.      * @throws IllegalArgumentException if<code>null</code> is parsed as content item      * @see #getLanguageAnnotations(TripleCollection)      */
specifier|public
specifier|static
name|String
name|getLanguage
parameter_list|(
name|ContentItem
name|ci
parameter_list|)
block|{
if|if
condition|(
name|ci
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed ContentItem MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|ci
operator|.
name|getLock
argument_list|()
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|List
argument_list|<
name|NonLiteral
argument_list|>
name|langAnnotations
init|=
name|getLanguageAnnotations
argument_list|(
name|ci
operator|.
name|getMetadata
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|langAnnotations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//fallback
return|return
name|getString
argument_list|(
name|ci
operator|.
name|getMetadata
argument_list|()
argument_list|,
name|ci
operator|.
name|getUri
argument_list|()
argument_list|,
name|DC_LANGUAGE
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|getString
argument_list|(
name|ci
operator|.
name|getMetadata
argument_list|()
argument_list|,
name|langAnnotations
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|DC_LANGUAGE
argument_list|)
return|;
block|}
block|}
finally|finally
block|{
name|ci
operator|.
name|getLock
argument_list|()
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

