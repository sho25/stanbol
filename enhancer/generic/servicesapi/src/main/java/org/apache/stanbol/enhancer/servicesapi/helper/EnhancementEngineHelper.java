begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
package|;
end_package

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|singleton
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|TechnicalClasses
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Array
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Dictionary
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|UUID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|commons
operator|.
name|rdf
operator|.
name|BlankNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|InvalidLiteralTypeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|commons
operator|.
name|rdf
operator|.
name|Language
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|commons
operator|.
name|rdf
operator|.
name|Literal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|commons
operator|.
name|rdf
operator|.
name|Graph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|commons
operator|.
name|rdf
operator|.
name|BlankNodeOrIRI
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|commons
operator|.
name|rdf
operator|.
name|RDFTerm
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|commons
operator|.
name|rdf
operator|.
name|Triple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|commons
operator|.
name|rdf
operator|.
name|Graph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|commons
operator|.
name|rdf
operator|.
name|IRI
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|commons
operator|.
name|rdf
operator|.
name|impl
operator|.
name|utils
operator|.
name|PlainLiteralImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|commons
operator|.
name|rdf
operator|.
name|impl
operator|.
name|utils
operator|.
name|TripleImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|LiteralFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|Chain
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|ContentItem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|EnhancementEngine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|EnhancementPropertyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|NoSuchPartException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|ServiceProperties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|ExecutionPlan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|NamespaceEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|service
operator|.
name|cm
operator|.
name|ConfigurationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_class
specifier|public
specifier|final
class|class
name|EnhancementEngineHelper
block|{
comment|/**      * Restrict instantiation      */
specifier|private
name|EnhancementEngineHelper
parameter_list|()
block|{}
comment|/**      * The maximum size of the prefix/suffix for the selection context      * @since 0.11.0      */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_SELECTION_CONTEXT_PREFIX_SUFFIX_SIZE
init|=
literal|50
decl_stmt|;
comment|/**      * The minimum size of the prefix/suffix for the selection context      * @since 0.11.0      */
specifier|public
specifier|static
specifier|final
name|int
name|MIN_SELECTION_CONTEXT_PREFIX_SUFFIX_SIZE
init|=
literal|15
decl_stmt|;
comment|/**      * The minimum length of the selected text so that fise:selection-head and      * fise:selection.tail are being used instead of fise:selected-text. The      * actual size is calculated by using<code>prefixSuffixLength*5</code>.      * So if a user does not chage the {@link #DEFAULT_PREFIX_SUFFIX_LENGTH} the      * default value us<code>10 * 5 = 50</code> chars.      */
specifier|public
specifier|static
specifier|final
name|int
name|MIN_SELECTEN_HEAD_TAIL_USAGE_LENGTH
init|=
literal|30
decl_stmt|;
comment|/**      * The default length of fise:selection-prefix and fise:selection-suffix      * literals (value = 10).      */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_PREFIX_SUFFIX_LENGTH
init|=
literal|10
decl_stmt|;
comment|/**      * The minimum size for fise:selection-prefix and fise:selection-suffix      * literals (value = 3).      */
specifier|public
specifier|static
specifier|final
name|int
name|MIN_PREFIX_SUFFIX_SIZE
init|=
literal|3
decl_stmt|;
specifier|protected
specifier|final
specifier|static
name|Random
name|rng
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|EnhancementEngineHelper
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|LiteralFactory
name|lf
init|=
name|LiteralFactory
operator|.
name|getInstance
argument_list|()
decl_stmt|;
specifier|public
specifier|static
name|void
name|setSeed
parameter_list|(
name|long
name|seed
parameter_list|)
block|{
name|rng
operator|.
name|setSeed
argument_list|(
name|seed
argument_list|)
expr_stmt|;
block|}
comment|/**      * Create a new instance with the types enhancer:Enhancement and      * enhancer:TextAnnotation in the metadata-graph of the content      * item along with default properties (dc:creator and dc:created) and return      * the IRI of the extraction so that engines can further add.      *      * @param ci the ContentItem being under analysis      * @param engine the Engine performing the analysis      *      * @return the URI of the new enhancement instance      */
specifier|public
specifier|static
name|IRI
name|createTextEnhancement
parameter_list|(
name|ContentItem
name|ci
parameter_list|,
name|EnhancementEngine
name|engine
parameter_list|)
block|{
return|return
name|createTextEnhancement
argument_list|(
name|ci
operator|.
name|getMetadata
argument_list|()
argument_list|,
name|engine
argument_list|,
operator|new
name|IRI
argument_list|(
name|ci
operator|.
name|getUri
argument_list|()
operator|.
name|getUnicodeString
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Create a new instance with the types enhancer:Enhancement and      * enhancer:TextAnnotation in the parsed graph along with default properties      * (dc:creator, dc:created and enhancer:extracted-form) and return      * the IRI of the extraction so that engines can further add.      *      * @param metadata the graph      * @param engine the engine      * @param contentItemId the id      *      * @return the URI of the new enhancement instance      */
specifier|public
specifier|static
name|IRI
name|createTextEnhancement
parameter_list|(
name|Graph
name|metadata
parameter_list|,
name|EnhancementEngine
name|engine
parameter_list|,
name|IRI
name|contentItemId
parameter_list|)
block|{
name|IRI
name|enhancement
init|=
name|createEnhancement
argument_list|(
name|metadata
argument_list|,
name|engine
argument_list|,
name|contentItemId
argument_list|)
decl_stmt|;
comment|//add the Text Annotation Type
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|enhancement
argument_list|,
name|RDF_TYPE
argument_list|,
name|ENHANCER_TEXTANNOTATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|enhancement
return|;
block|}
comment|/**      * This method sets the fise:start, fise:end, fise:selection-prefix,       * fise:selected-text and fise:selection-suffix properties for the       * parsed fise:TextAnnotation instance according to the parsed parameters.<p>      * While it is intended to be used for TextAnnotations this method can also      * be used to add the mentioned properties to {@link IRI}s with different      * type.<p>      *<b>NOTE</b> the<code>allowSelectionHeadTail</code>: This parameter allows      * to deactivate the usage of fise:selection-head and fise:selection-tail.      * Typically users should parse<code>false</code> in case of 'named entities'      * and<code>true</code> in case sections of the text (e.g. phrases, sentences,      * chapters ...) are selected.      * @param metadata The RDF graph to add the information      * @param textAnnotation the IRI of the fise:TextAnnotation      * @param content the plain text content as String      * @param start the start index of the occurrence       * @param end the end index of the occurrence      * @param lang the lanugage of the content or<code>null</code> if not known      * @param prefixSuffixSize the size of the prefix, suffix. If the parsed      * value&lt; 3 than the default 10 is used.      * @param allowSelectionHeadTail if<code>true</code> the fise:selection-head      * and fise:selection-tail properties are used instead of fise:selected-text      * if the selected text is longer as<code>Math.max(30, prefixSuffixSize*5);</code>.      * If<code>false</code> the fise:selected-text is added regardless of the      * size of the selected area.      * @since 0.11.0      */
specifier|public
specifier|static
name|void
name|setOccurrence
parameter_list|(
name|Graph
name|metadata
parameter_list|,
name|IRI
name|textAnnotation
parameter_list|,
name|String
name|content
parameter_list|,
name|Integer
name|start
parameter_list|,
name|Integer
name|end
parameter_list|,
name|Language
name|lang
parameter_list|,
name|int
name|prefixSuffixSize
parameter_list|,
name|boolean
name|allowSelectionHeadTail
parameter_list|)
block|{
comment|//set start, end
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|textAnnotation
argument_list|,
name|ENHANCER_START
argument_list|,
name|lf
operator|.
name|createTypedLiteral
argument_list|(
name|start
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|textAnnotation
argument_list|,
name|ENHANCER_END
argument_list|,
name|lf
operator|.
name|createTypedLiteral
argument_list|(
name|end
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|//set selection prefix and suffix (TextAnnotation new model)
name|prefixSuffixSize
operator|=
name|prefixSuffixSize
operator|<
name|MIN_PREFIX_SUFFIX_SIZE
condition|?
name|DEFAULT_PREFIX_SUFFIX_LENGTH
else|:
name|prefixSuffixSize
expr_stmt|;
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|textAnnotation
argument_list|,
name|ENHANCER_SELECTION_PREFIX
argument_list|,
operator|new
name|PlainLiteralImpl
argument_list|(
name|content
operator|.
name|substring
argument_list|(
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|start
operator|-
name|prefixSuffixSize
argument_list|)
argument_list|,
name|start
argument_list|)
argument_list|,
name|lang
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|textAnnotation
argument_list|,
name|ENHANCER_SELECTION_SUFFIX
argument_list|,
operator|new
name|PlainLiteralImpl
argument_list|(
name|content
operator|.
name|substring
argument_list|(
name|end
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|content
operator|.
name|length
argument_list|()
argument_list|,
name|end
operator|+
name|prefixSuffixSize
argument_list|)
argument_list|)
argument_list|,
name|lang
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|//set the selected text (or alternatively head and tail)
name|int
name|maxSelectedTextSize
init|=
name|Math
operator|.
name|max
argument_list|(
name|MIN_SELECTEN_HEAD_TAIL_USAGE_LENGTH
argument_list|,
name|prefixSuffixSize
operator|*
literal|5
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|allowSelectionHeadTail
operator|||
name|end
operator|-
name|start
operator|<=
name|maxSelectedTextSize
condition|)
block|{
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|textAnnotation
argument_list|,
name|ENHANCER_SELECTED_TEXT
argument_list|,
operator|new
name|PlainLiteralImpl
argument_list|(
name|content
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
argument_list|,
name|lang
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//selected area to long for fise:selected-text
comment|//use fise:selection-head and fise:selection-tail instead
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|textAnnotation
argument_list|,
name|ENHANCER_SELECTION_HEAD
argument_list|,
operator|new
name|PlainLiteralImpl
argument_list|(
name|content
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|start
operator|+
name|prefixSuffixSize
argument_list|)
argument_list|,
name|lang
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|textAnnotation
argument_list|,
name|ENHANCER_SELECTION_TAIL
argument_list|,
operator|new
name|PlainLiteralImpl
argument_list|(
name|content
operator|.
name|substring
argument_list|(
name|end
operator|-
name|prefixSuffixSize
argument_list|,
name|end
argument_list|)
argument_list|,
name|lang
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Extracts the selection context based on the content, selection and      * the start char offset of the selection. Tries to cut of the context       * on whole words. The size of the prefix/suffix is set to      * {@link #DEFAULT_SELECTION_CONTEXT_PREFIX_SUFFIX_SIZE}.      * @param content the content      * @param selection the selected text      * @param selectionStartPos the start char position of the selection      * @return the context      * @since 0.11.0      */
specifier|public
specifier|static
name|String
name|getSelectionContext
parameter_list|(
name|String
name|content
parameter_list|,
name|String
name|selection
parameter_list|,
name|int
name|selectionStartPos
parameter_list|)
block|{
return|return
name|getSelectionContext
argument_list|(
name|content
argument_list|,
name|selection
argument_list|,
name|selectionStartPos
argument_list|,
name|DEFAULT_SELECTION_CONTEXT_PREFIX_SUFFIX_SIZE
argument_list|)
return|;
block|}
comment|/**      * Extracts the selection context based on the content, selection and      * the start char offset of the selection. Tries to cut of the context       * on whole words.      * @param content the content      * @param selection the selected text      * @param selectionStartPos the start char position of the selection      * @param contextSize the size of the prefix/suffix. If less than zero the      * {@link #DEFAULT_SELECTION_CONTEXT_PREFIX_SUFFIX_SIZE} is used. If in the      * range [0..{@link #MIN_SELECTION_CONTEXT_PREFIX_SUFFIX_SIZE}] than the      * size is set to {@link #MIN_SELECTION_CONTEXT_PREFIX_SUFFIX_SIZE}      * @return the context      * @since 0.11.0      */
specifier|public
specifier|static
name|String
name|getSelectionContext
parameter_list|(
name|String
name|content
parameter_list|,
name|String
name|selection
parameter_list|,
name|int
name|selectionStartPos
parameter_list|,
name|int
name|contextSize
parameter_list|)
block|{
if|if
condition|(
name|contextSize
operator|<
literal|0
condition|)
block|{
name|contextSize
operator|=
name|DEFAULT_SELECTION_CONTEXT_PREFIX_SUFFIX_SIZE
expr_stmt|;
block|}
if|if
condition|(
name|contextSize
operator|<
name|MIN_SELECTION_CONTEXT_PREFIX_SUFFIX_SIZE
condition|)
block|{
name|contextSize
operator|=
name|MIN_PREFIX_SUFFIX_SIZE
expr_stmt|;
block|}
comment|//extract the selection context
name|int
name|beginPos
decl_stmt|;
if|if
condition|(
name|selectionStartPos
operator|<=
name|DEFAULT_SELECTION_CONTEXT_PREFIX_SUFFIX_SIZE
condition|)
block|{
name|beginPos
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|int
name|start
init|=
name|selectionStartPos
operator|-
name|DEFAULT_SELECTION_CONTEXT_PREFIX_SUFFIX_SIZE
decl_stmt|;
name|beginPos
operator|=
name|content
operator|.
name|indexOf
argument_list|(
literal|' '
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|beginPos
operator|<
literal|0
operator|||
name|beginPos
operator|>=
name|selectionStartPos
condition|)
block|{
comment|//no words
name|beginPos
operator|=
name|start
expr_stmt|;
comment|//begin within a word
block|}
block|}
name|int
name|endPos
decl_stmt|;
if|if
condition|(
name|selectionStartPos
operator|+
name|selection
operator|.
name|length
argument_list|()
operator|+
name|DEFAULT_SELECTION_CONTEXT_PREFIX_SUFFIX_SIZE
operator|>=
name|content
operator|.
name|length
argument_list|()
condition|)
block|{
name|endPos
operator|=
name|content
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|int
name|start
init|=
name|selectionStartPos
operator|+
name|selection
operator|.
name|length
argument_list|()
operator|+
name|DEFAULT_SELECTION_CONTEXT_PREFIX_SUFFIX_SIZE
decl_stmt|;
name|endPos
operator|=
name|content
operator|.
name|lastIndexOf
argument_list|(
literal|' '
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|endPos
operator|<=
name|selectionStartPos
operator|+
name|selection
operator|.
name|length
argument_list|()
condition|)
block|{
name|endPos
operator|=
name|start
expr_stmt|;
comment|//end within a word;
block|}
block|}
return|return
name|content
operator|.
name|substring
argument_list|(
name|beginPos
argument_list|,
name|endPos
argument_list|)
return|;
block|}
comment|/**      * Create a new instance with the types enhancer:Enhancement and      * enhancer:EntityAnnotation in the metadata-graph of the content      * item along with default properties (dc:creator and dc:created) and return      * the IRI of the extraction so that engines can further add      *      * @param ci the ContentItem being under analysis      * @param engine the Engine performing the analysis      * @return the URI of the new enhancement instance      */
specifier|public
specifier|static
name|IRI
name|createEntityEnhancement
parameter_list|(
name|ContentItem
name|ci
parameter_list|,
name|EnhancementEngine
name|engine
parameter_list|)
block|{
return|return
name|createEntityEnhancement
argument_list|(
name|ci
operator|.
name|getMetadata
argument_list|()
argument_list|,
name|engine
argument_list|,
operator|new
name|IRI
argument_list|(
name|ci
operator|.
name|getUri
argument_list|()
operator|.
name|getUnicodeString
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Create a new instance with the types enhancer:Enhancement and      * enhancer:EntityAnnotation in the parsed graph along with default properties      * (dc:creator, dc:created and enhancer:extracted-form) and return      * the IRI of the extraction so that engines can further add.      *      * @param metadata the graph      * @param engine the engine      * @param contentItemId the id      *      * @return the URI of the new enhancement instance      */
specifier|public
specifier|static
name|IRI
name|createEntityEnhancement
parameter_list|(
name|Graph
name|metadata
parameter_list|,
name|EnhancementEngine
name|engine
parameter_list|,
name|IRI
name|contentItemId
parameter_list|)
block|{
name|IRI
name|enhancement
init|=
name|createEnhancement
argument_list|(
name|metadata
argument_list|,
name|engine
argument_list|,
name|contentItemId
argument_list|)
decl_stmt|;
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|enhancement
argument_list|,
name|RDF_TYPE
argument_list|,
name|ENHANCER_ENTITYANNOTATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|enhancement
return|;
block|}
comment|/**      * Create a new instance with the types enhancer:Enhancement and      * enhancer:TopicAnnotation in the parsed graph along with default properties      * (dc:creator, dc:created and enhancer:extracted-form) and return      * the IRI of the extraction so that engines can further add.      *      * @param metadata the graph      * @param engine the engine      * @param contentItemId the id      *      * @return the URI of the new enhancement instance      */
specifier|public
specifier|static
name|IRI
name|createTopicEnhancement
parameter_list|(
name|Graph
name|metadata
parameter_list|,
name|EnhancementEngine
name|engine
parameter_list|,
name|IRI
name|contentItemId
parameter_list|)
block|{
name|IRI
name|enhancement
init|=
name|createEnhancement
argument_list|(
name|metadata
argument_list|,
name|engine
argument_list|,
name|contentItemId
argument_list|)
decl_stmt|;
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|enhancement
argument_list|,
name|RDF_TYPE
argument_list|,
name|ENHANCER_TOPICANNOTATION
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|enhancement
return|;
block|}
comment|/**      * Create a new instance with the types enhancer:Enhancement and      * enhancer:TopicAnnotation in the metadata-graph of the content      * item along with default properties (dc:creator and dc:created) and return      * the IRI of the extraction so that engines can further add      *      * @param ci the ContentItem being under analysis      * @param engine the Engine performing the analysis      * @return the URI of the new enhancement instance      */
specifier|public
specifier|static
name|IRI
name|createTopicEnhancement
parameter_list|(
name|ContentItem
name|ci
parameter_list|,
name|EnhancementEngine
name|engine
parameter_list|)
block|{
return|return
name|createTopicEnhancement
argument_list|(
name|ci
operator|.
name|getMetadata
argument_list|()
argument_list|,
name|engine
argument_list|,
operator|new
name|IRI
argument_list|(
name|ci
operator|.
name|getUri
argument_list|()
operator|.
name|getUnicodeString
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Create a new enhancement instance in the metadata-graph of the content      * item along with default properties (dc:creator and dc:created) and return      * the IRI of the extraction so that engines can further add.<p>      *<i>NOTE:</i> This method was protected prior to<code>0.12.1</code> (see      *<a href="https://issues.apache.org/jira/browse/STANBOL-1321">STANBOL-1321</a>)      *      * @param ci the ContentItem being under analysis      * @param engine the Engine performing the analysis      *      * @return the URI of the new enhancement instance      * @since 0.12.1      */
specifier|public
specifier|static
name|IRI
name|createEnhancement
parameter_list|(
name|Graph
name|metadata
parameter_list|,
name|EnhancementEngine
name|engine
parameter_list|,
name|IRI
name|contentItemId
parameter_list|)
block|{
name|LiteralFactory
name|literalFactory
init|=
name|LiteralFactory
operator|.
name|getInstance
argument_list|()
decl_stmt|;
name|IRI
name|enhancement
init|=
operator|new
name|IRI
argument_list|(
literal|"urn:enhancement-"
operator|+
name|EnhancementEngineHelper
operator|.
name|randomUUID
argument_list|()
argument_list|)
decl_stmt|;
comment|//add the Enhancement Type
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|enhancement
argument_list|,
name|RDF_TYPE
argument_list|,
name|ENHANCER_ENHANCEMENT
argument_list|)
argument_list|)
expr_stmt|;
comment|//add the extracted from content item
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|enhancement
argument_list|,
name|ENHANCER_EXTRACTED_FROM
argument_list|,
name|contentItemId
argument_list|)
argument_list|)
expr_stmt|;
comment|// creation date
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|enhancement
argument_list|,
name|DC_CREATED
argument_list|,
name|literalFactory
operator|.
name|createTypedLiteral
argument_list|(
operator|new
name|Date
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// the engines that extracted the data
comment|// TODO: add some kind of versioning info for the extractor?
comment|// TODO: use a public dereferencing URI instead? that would allow for
comment|// explicit versioning too
comment|/* NOTE (Rupert Westenthaler 2010-05-26):          * The Idea is to use the  ComponentContext in the activate() method of          * an Enhancer to get the bundle name/version and use that as an          * URI for the creator.          * We would need to add getEnhancerID() method to the enhancer interface          * to access this information           */
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|enhancement
argument_list|,
name|DC_CREATOR
argument_list|,
name|literalFactory
operator|.
name|createTypedLiteral
argument_list|(
name|engine
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|enhancement
return|;
block|}
comment|/**      * Adds the parsed {@link EnhancementEngine} as dc:contributer to the      * enhancement and also sets the dc:modified property accordingly      * @param metadata the {@link ContentItem#getMetadata()}      * @param enhancement the enhancement      * @param engine the engine      */
specifier|public
specifier|static
name|void
name|addContributingEngine
parameter_list|(
name|Graph
name|metadata
parameter_list|,
name|IRI
name|enhancement
parameter_list|,
name|EnhancementEngine
name|engine
parameter_list|)
block|{
name|LiteralFactory
name|literalFactory
init|=
name|LiteralFactory
operator|.
name|getInstance
argument_list|()
decl_stmt|;
comment|// TODO: use a public dereferencing URI instead?
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|enhancement
argument_list|,
name|DC_CONTRIBUTOR
argument_list|,
name|literalFactory
operator|.
name|createTypedLiteral
argument_list|(
name|engine
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|//set the modification date to the current date.
name|set
argument_list|(
name|metadata
argument_list|,
name|enhancement
argument_list|,
name|DC_MODIFIED
argument_list|,
operator|new
name|Date
argument_list|()
argument_list|,
name|literalFactory
argument_list|)
expr_stmt|;
block|}
comment|/**      * Create a new extraction instance in the metadata-graph of the content      * item along with default properties (dc:creator and dc:created) and return      * the IRI of the extraction so that engines can further add      *      * @param ci the ContentItem being under analysis      * @param engine the Engine performing the analysis      * @return the URI of the new extraction instance      * @deprecated will be remove with 1.0      * @see EnhancementEngineHelper#createEntityEnhancement(ContentItem, EnhancementEngine)      * @see EnhancementEngineHelper#createTextEnhancement(ContentItem, EnhancementEngine)      */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|IRI
name|createNewExtraction
parameter_list|(
name|ContentItem
name|ci
parameter_list|,
name|EnhancementEngine
name|engine
parameter_list|)
block|{
name|LiteralFactory
name|literalFactory
init|=
name|LiteralFactory
operator|.
name|getInstance
argument_list|()
decl_stmt|;
name|Graph
name|metadata
init|=
name|ci
operator|.
name|getMetadata
argument_list|()
decl_stmt|;
name|IRI
name|extraction
init|=
operator|new
name|IRI
argument_list|(
literal|"urn:extraction-"
operator|+
name|EnhancementEngineHelper
operator|.
name|randomUUID
argument_list|()
argument_list|)
decl_stmt|;
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|extraction
argument_list|,
name|RDF_TYPE
argument_list|,
name|ENHANCER_EXTRACTION
argument_list|)
argument_list|)
expr_stmt|;
comment|// relate the extraction to the content item
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|extraction
argument_list|,
name|ENHANCER_RELATED_CONTENT_ITEM
argument_list|,
operator|new
name|IRI
argument_list|(
name|ci
operator|.
name|getUri
argument_list|()
operator|.
name|getUnicodeString
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// creation date
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|extraction
argument_list|,
name|DC_CREATED
argument_list|,
name|literalFactory
operator|.
name|createTypedLiteral
argument_list|(
operator|new
name|Date
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// the engines that extracted the data
comment|// TODO: add some kind of versioning info for the extractor?
comment|// TODO: use a public dereferencing URI instead? that would allow for
comment|// explicit versioning too
name|metadata
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|extraction
argument_list|,
name|DC_CREATOR
argument_list|,
name|literalFactory
operator|.
name|createTypedLiteral
argument_list|(
name|engine
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|extraction
return|;
block|}
comment|/**      * Random UUID generator with re-seedable RNG for the tests.      *      * @return a new Random UUID      */
specifier|public
specifier|static
name|UUID
name|randomUUID
parameter_list|()
block|{
return|return
operator|new
name|UUID
argument_list|(
name|rng
operator|.
name|nextLong
argument_list|()
argument_list|,
name|rng
operator|.
name|nextLong
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Getter for the first typed literal value of the property for a resource.      *      * @param<T> the java class the literal value needs to be converted to.      * Note that the parsed LiteralFactory needs to support this conversion      * @param graph the graph used to query for the property value      * @param resource the resource      * @param property the property      * @param type the type the literal needs to be converted to      * @param literalFactory the literalFactory      * @return the value      */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|get
parameter_list|(
name|Graph
name|graph
parameter_list|,
name|BlankNodeOrIRI
name|resource
parameter_list|,
name|IRI
name|property
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
name|LiteralFactory
name|literalFactory
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|results
init|=
name|graph
operator|.
name|filter
argument_list|(
name|resource
argument_list|,
name|property
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|results
operator|.
name|hasNext
argument_list|()
condition|)
block|{
while|while
condition|(
name|results
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Triple
name|result
init|=
name|results
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|.
name|getObject
argument_list|()
operator|instanceof
name|Literal
condition|)
block|{
return|return
name|literalFactory
operator|.
name|createObject
argument_list|(
name|type
argument_list|,
operator|(
name|Literal
operator|)
name|result
operator|.
name|getObject
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Triple {} does not have a Literal as object! -> ignore"
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
block|}
name|log
operator|.
name|info
argument_list|(
literal|"No value for {} and property {} had the requested Type {} -> return null"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|resource
block|,
name|property
block|,
name|type
block|}
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"No Triple found for {} and property {}! -> return null"
argument_list|,
name|resource
argument_list|,
name|property
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Replaces all current values of the property for the resource      * with the parsed value      * @param graph the graph      * @param resource the resource      * @param property the property      * @param value the value      */
specifier|public
specifier|static
name|void
name|set
parameter_list|(
name|Graph
name|graph
parameter_list|,
name|BlankNodeOrIRI
name|resource
parameter_list|,
name|IRI
name|property
parameter_list|,
name|RDFTerm
name|value
parameter_list|)
block|{
name|set
argument_list|(
name|graph
argument_list|,
name|resource
argument_list|,
name|property
argument_list|,
name|value
operator|==
literal|null
condition|?
literal|null
else|:
name|singleton
argument_list|(
name|value
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Replaces all current values of the property for the resource      * with the parsed values      * @param graph the graph      * @param resource the resource      * @param property the property      * @param value the value      */
specifier|public
specifier|static
name|void
name|set
parameter_list|(
name|Graph
name|graph
parameter_list|,
name|BlankNodeOrIRI
name|resource
parameter_list|,
name|IRI
name|property
parameter_list|,
name|Collection
argument_list|<
name|RDFTerm
argument_list|>
name|values
parameter_list|)
block|{
name|set
argument_list|(
name|graph
argument_list|,
name|resource
argument_list|,
name|property
argument_list|,
name|values
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Replaces all current values of the property for the resource      * with the parsed value      * @param graph the graph      * @param resource the resource      * @param property the property      * @param value the value. In case it is an instance of {@link RDFTerm} it      * is directly added to the graph. Otherwise the parsed {@link LiteralFactory}      * is used to create a {@link TypedLiteral} for the parsed value.      * @param literalFactory the {@link LiteralFactory} used in case the parsed      * value is not an {@link RDFTerm}      */
specifier|public
specifier|static
name|void
name|set
parameter_list|(
name|Graph
name|graph
parameter_list|,
name|BlankNodeOrIRI
name|resource
parameter_list|,
name|IRI
name|property
parameter_list|,
name|Object
name|value
parameter_list|,
name|LiteralFactory
name|literalFactory
parameter_list|)
block|{
name|set
argument_list|(
name|graph
argument_list|,
name|resource
argument_list|,
name|property
argument_list|,
name|value
operator|==
literal|null
condition|?
literal|null
else|:
name|singleton
argument_list|(
name|value
argument_list|)
argument_list|,
name|literalFactory
argument_list|)
expr_stmt|;
block|}
comment|/**      * Replaces all current values of the property for the resource      * with the parsed values      * @param graph the graph      * @param resource the resource      * @param property the property      * @param value the value. In case it is an instance of {@link RDFTerm} it      * is directly added to the graph. Otherwise the parsed {@link LiteralFactory}      * is used to create a {@link TypedLiteral} for the parsed value.      * @param literalFactory the {@link LiteralFactory} used in case the parsed      * value is not an {@link RDFTerm}      */
specifier|public
specifier|static
name|void
name|set
parameter_list|(
name|Graph
name|graph
parameter_list|,
name|BlankNodeOrIRI
name|resource
parameter_list|,
name|IRI
name|property
parameter_list|,
name|Collection
argument_list|<
name|?
argument_list|>
name|values
parameter_list|,
name|LiteralFactory
name|literalFactory
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|currentValues
init|=
name|graph
operator|.
name|filter
argument_list|(
name|resource
argument_list|,
name|property
argument_list|,
literal|null
argument_list|)
decl_stmt|;
while|while
condition|(
name|currentValues
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|currentValues
operator|.
name|next
argument_list|()
expr_stmt|;
name|currentValues
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|values
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Object
name|value
range|:
name|values
control|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|RDFTerm
condition|)
block|{
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|resource
argument_list|,
name|property
argument_list|,
operator|(
name|RDFTerm
operator|)
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|resource
argument_list|,
name|property
argument_list|,
name|literalFactory
operator|.
name|createTypedLiteral
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Getter for the typed literal values of the property for a resource      * @param<T> the java class the literal value needs to be converted to.      * Note that the parsed LiteralFactory needs to support this conversion      * @param graph the graph used to query for the property value      * @param resource the resource      * @param property the property      * @param type the type the literal needs to be converted to      * @param literalFactory the literalFactory      * @return the value      */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Iterator
argument_list|<
name|T
argument_list|>
name|getValues
parameter_list|(
name|Graph
name|graph
parameter_list|,
name|BlankNodeOrIRI
name|resource
parameter_list|,
name|IRI
name|property
parameter_list|,
specifier|final
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
specifier|final
name|LiteralFactory
name|literalFactory
parameter_list|)
block|{
specifier|final
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|results
init|=
name|graph
operator|.
name|filter
argument_list|(
name|resource
argument_list|,
name|property
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
operator|new
name|Iterator
argument_list|<
name|T
argument_list|>
argument_list|()
block|{
comment|//TODO: dose not check if the object of the triple is of type IRI
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|results
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|T
name|next
parameter_list|()
block|{
return|return
name|literalFactory
operator|.
name|createObject
argument_list|(
name|type
argument_list|,
operator|(
name|Literal
operator|)
name|results
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|results
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
comment|/**      * Getter for the first String literal value the property for a resource      * @param graph the graph used to query for the property value      * @param resource the resource      * @param property the property      * @return the value      */
specifier|public
specifier|static
name|String
name|getString
parameter_list|(
name|Graph
name|graph
parameter_list|,
name|BlankNodeOrIRI
name|resource
parameter_list|,
name|IRI
name|property
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|results
init|=
name|graph
operator|.
name|filter
argument_list|(
name|resource
argument_list|,
name|property
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|results
operator|.
name|hasNext
argument_list|()
condition|)
block|{
while|while
condition|(
name|results
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Triple
name|result
init|=
name|results
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|.
name|getObject
argument_list|()
operator|instanceof
name|Literal
condition|)
block|{
return|return
operator|(
operator|(
name|Literal
operator|)
name|result
operator|.
name|getObject
argument_list|()
operator|)
operator|.
name|getLexicalForm
argument_list|()
return|;
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Triple {} does not have a literal as object! -> ignore"
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
block|}
name|log
operator|.
name|info
argument_list|(
literal|"No Literal value for {} and property {} -> return null"
argument_list|,
name|resource
argument_list|,
name|property
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"No Triple found for "
operator|+
name|resource
operator|+
literal|" and property "
operator|+
name|property
operator|+
literal|"! -> return null"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Getter for the string literal values the property for a resource      * @param graph the graph used to query for the property value      * @param resource the resource      * @param property the property      * @return the value      */
specifier|public
specifier|static
name|Iterator
argument_list|<
name|String
argument_list|>
name|getStrings
parameter_list|(
name|Graph
name|graph
parameter_list|,
name|BlankNodeOrIRI
name|resource
parameter_list|,
name|IRI
name|property
parameter_list|)
block|{
specifier|final
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|results
init|=
name|graph
operator|.
name|filter
argument_list|(
name|resource
argument_list|,
name|property
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
operator|new
name|Iterator
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
comment|//TODO: dose not check if the object of the triple is of type IRI
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|results
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|next
parameter_list|()
block|{
return|return
operator|(
operator|(
name|Literal
operator|)
name|results
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
operator|)
operator|.
name|getLexicalForm
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|results
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
comment|/**      * Getter for the first value of the data type property for a resource      * @param graph the graph used to query for the property value      * @param resource the resource      * @param property the property      * @return the value      */
specifier|public
specifier|static
name|IRI
name|getReference
parameter_list|(
name|Graph
name|graph
parameter_list|,
name|BlankNodeOrIRI
name|resource
parameter_list|,
name|IRI
name|property
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|results
init|=
name|graph
operator|.
name|filter
argument_list|(
name|resource
argument_list|,
name|property
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|results
operator|.
name|hasNext
argument_list|()
condition|)
block|{
while|while
condition|(
name|results
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Triple
name|result
init|=
name|results
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|.
name|getObject
argument_list|()
operator|instanceof
name|IRI
condition|)
block|{
return|return
operator|(
name|IRI
operator|)
name|result
operator|.
name|getObject
argument_list|()
return|;
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Triple "
operator|+
name|result
operator|+
literal|" does not have a IRI as object! -> ignore"
argument_list|)
expr_stmt|;
block|}
block|}
name|log
operator|.
name|info
argument_list|(
literal|"No IRI value for {} and property {} -> return null"
argument_list|,
name|resource
argument_list|,
name|property
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"No Triple found for {} and property {}! -> return null"
argument_list|,
name|resource
argument_list|,
name|property
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Getter for the values of the data type property for a resource.      *      * @param graph the graph used to query for the property value      * @param resource the resource      * @param property the property      * @return The iterator over all the values (      */
specifier|public
specifier|static
name|Iterator
argument_list|<
name|IRI
argument_list|>
name|getReferences
parameter_list|(
name|Graph
name|graph
parameter_list|,
name|BlankNodeOrIRI
name|resource
parameter_list|,
name|IRI
name|property
parameter_list|)
block|{
specifier|final
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|results
init|=
name|graph
operator|.
name|filter
argument_list|(
name|resource
argument_list|,
name|property
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
operator|new
name|Iterator
argument_list|<
name|IRI
argument_list|>
argument_list|()
block|{
comment|//TODO: dose not check if the object of the triple is of type IRI
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|results
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|IRI
name|next
parameter_list|()
block|{
return|return
operator|(
name|IRI
operator|)
name|results
operator|.
name|next
argument_list|()
operator|.
name|getObject
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|results
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
return|;
block|}
comment|/**      * Comparator that allows to sort a list/array of {@link EnhancementEngine}s      * based on there {@link ServiceProperties#ENHANCEMENT_ENGINE_ORDERING}.      */
specifier|public
specifier|static
specifier|final
name|Comparator
argument_list|<
name|EnhancementEngine
argument_list|>
name|EXECUTION_ORDER_COMPARATOR
init|=
operator|new
name|Comparator
argument_list|<
name|EnhancementEngine
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|EnhancementEngine
name|engine1
parameter_list|,
name|EnhancementEngine
name|engine2
parameter_list|)
block|{
name|Integer
name|order1
init|=
name|getEngineOrder
argument_list|(
name|engine1
argument_list|)
decl_stmt|;
name|Integer
name|order2
init|=
name|getEngineOrder
argument_list|(
name|engine2
argument_list|)
decl_stmt|;
comment|//start with the highest number finish with the lowest ...
return|return
name|order1
operator|==
name|order2
condition|?
literal|0
else|:
name|order1
operator|<
name|order2
condition|?
literal|1
else|:
operator|-
literal|1
return|;
block|}
block|}
decl_stmt|;
comment|/**      * Gets the {@link ServiceProperties#ENHANCEMENT_ENGINE_ORDERING} value      * for the parsed EnhancementEngine. If the Engine does not implement the      * {@link ServiceProperties} interface or does not provide the      * {@link ServiceProperties#ENHANCEMENT_ENGINE_ORDERING} the       * {@link ServiceProperties#ORDERING_DEFAULT} is returned<p>      * This method is guaranteed to NOT return<code>null</code>.      * @param engine the engine      * @return the ordering      */
specifier|public
specifier|static
name|Integer
name|getEngineOrder
parameter_list|(
name|EnhancementEngine
name|engine
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"getOrder "
operator|+
name|engine
argument_list|)
expr_stmt|;
if|if
condition|(
name|engine
operator|instanceof
name|ServiceProperties
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|" ... implements ServiceProperties"
argument_list|)
expr_stmt|;
name|Object
name|value
init|=
operator|(
operator|(
name|ServiceProperties
operator|)
name|engine
operator|)
operator|.
name|getServiceProperties
argument_list|()
operator|.
name|get
argument_list|(
name|ServiceProperties
operator|.
name|ENHANCEMENT_ENGINE_ORDERING
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"> value = "
operator|+
name|value
operator|+
literal|" "
operator|+
name|value
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
name|value
operator|instanceof
name|Integer
condition|)
block|{
return|return
operator|(
name|Integer
operator|)
name|value
return|;
block|}
block|}
return|return
name|ServiceProperties
operator|.
name|ORDERING_DEFAULT
return|;
block|}
comment|/**      * Getter for the Resources of fise:TextAnnotations that do have a value       * of the dc:language property. The returned list is sorted by 'fise:confidence'.      * Annotations with missing confidence are ranked last.<p>      * NOTE that the returned list will likely contain annotations for the same language      * if multiple language identification are used in the same {@link Chain}.      * @param graph the graph with the enhancement.       * Typically {@link ContentItem#getMetadata()}      * @return the sorted list of language annotations or an empty list if none.      * @throws IllegalArgumentException if<code>null</code> is parsed as graph      */
specifier|public
specifier|static
name|List
argument_list|<
name|BlankNodeOrIRI
argument_list|>
name|getLanguageAnnotations
parameter_list|(
name|Graph
name|graph
parameter_list|)
block|{
if|if
condition|(
name|graph
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed graph MUST NOT be NULL!"
argument_list|)
throw|;
block|}
comment|// I do not use SPARQL, because I do not want to instantiate a QueryEngine
specifier|final
name|Map
argument_list|<
name|BlankNodeOrIRI
argument_list|,
name|Double
argument_list|>
name|confidences
init|=
operator|new
name|HashMap
argument_list|<
name|BlankNodeOrIRI
argument_list|,
name|Double
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|BlankNodeOrIRI
argument_list|>
name|langAnnotations
init|=
operator|new
name|ArrayList
argument_list|<
name|BlankNodeOrIRI
argument_list|>
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|textAnnoataions
init|=
name|graph
operator|.
name|filter
argument_list|(
literal|null
argument_list|,
name|RDF_TYPE
argument_list|,
name|ENHANCER_TEXTANNOTATION
argument_list|)
decl_stmt|;
while|while
condition|(
name|textAnnoataions
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|BlankNodeOrIRI
name|textAnnotation
init|=
name|textAnnoataions
operator|.
name|next
argument_list|()
operator|.
name|getSubject
argument_list|()
decl_stmt|;
name|String
name|language
init|=
name|getString
argument_list|(
name|graph
argument_list|,
name|textAnnotation
argument_list|,
name|DC_LANGUAGE
argument_list|)
decl_stmt|;
if|if
condition|(
name|language
operator|!=
literal|null
condition|)
block|{
name|Double
name|confidence
init|=
literal|null
decl_stmt|;
try|try
block|{
name|confidence
operator|=
name|get
argument_list|(
name|graph
argument_list|,
name|textAnnotation
argument_list|,
name|ENHANCER_CONFIDENCE
argument_list|,
name|Double
operator|.
name|class
argument_list|,
name|lf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidLiteralTypeException
name|e
parameter_list|)
block|{
comment|// STANBOL-1417: not a double value
try|try
block|{
comment|//try with float
name|Float
name|fconf
init|=
name|get
argument_list|(
name|graph
argument_list|,
name|textAnnotation
argument_list|,
name|ENHANCER_CONFIDENCE
argument_list|,
name|Float
operator|.
name|class
argument_list|,
name|lf
argument_list|)
decl_stmt|;
if|if
condition|(
name|fconf
operator|!=
literal|null
condition|)
block|{
name|confidence
operator|=
name|Double
operator|.
name|valueOf
argument_list|(
name|fconf
operator|.
name|doubleValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InvalidLiteralTypeException
name|e1
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to parse confidence for language annotation "
operator|+
name|textAnnotation
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|confidences
operator|.
name|put
argument_list|(
name|textAnnotation
argument_list|,
name|confidence
argument_list|)
expr_stmt|;
name|langAnnotations
operator|.
name|add
argument_list|(
name|textAnnotation
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|langAnnotations
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|langAnnotations
argument_list|,
operator|new
name|Comparator
argument_list|<
name|BlankNodeOrIRI
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|BlankNodeOrIRI
name|o1
parameter_list|,
name|BlankNodeOrIRI
name|o2
parameter_list|)
block|{
name|Double
name|c1
init|=
name|confidences
operator|.
name|get
argument_list|(
name|o1
argument_list|)
decl_stmt|;
name|Double
name|c2
init|=
name|confidences
operator|.
name|get
argument_list|(
name|o2
argument_list|)
decl_stmt|;
comment|//decrising order (values without confidence last)
if|if
condition|(
name|c1
operator|==
literal|null
condition|)
block|{
return|return
name|c2
operator|==
literal|null
condition|?
literal|0
else|:
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|c2
operator|==
literal|null
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
return|return
name|c2
operator|.
name|compareTo
argument_list|(
name|c1
argument_list|)
return|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
return|return
name|langAnnotations
return|;
block|}
comment|/**      * Getter for language identified for (extracted-from) the parsed      * ContentItem. The returned value is the Annotation with the highest      * 'fise:confidence' value - or if no annotations are present - the      * 'dc-terms:language' value of the {@link ContentItem#getUri()}.<p>      * Users that want to obtain all language annotations should use      * {@link #getLanguageAnnotations(Graph)} instead.<p>      * This method ensures a write lock on the {@link ContentItem}.      * @param ci the contentItem      * @return the identified language of the parsed {@link ContentItem}.      *<code>null</code> if not available.      * @throws IllegalArgumentException if<code>null</code> is parsed as content item      * @see #getLanguageAnnotations(Graph)      */
specifier|public
specifier|static
name|String
name|getLanguage
parameter_list|(
name|ContentItem
name|ci
parameter_list|)
block|{
if|if
condition|(
name|ci
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed ContentItem MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|ci
operator|.
name|getLock
argument_list|()
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|List
argument_list|<
name|BlankNodeOrIRI
argument_list|>
name|langAnnotations
init|=
name|getLanguageAnnotations
argument_list|(
name|ci
operator|.
name|getMetadata
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|langAnnotations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//fallback
return|return
name|getString
argument_list|(
name|ci
operator|.
name|getMetadata
argument_list|()
argument_list|,
name|ci
operator|.
name|getUri
argument_list|()
argument_list|,
name|DC_LANGUAGE
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|getString
argument_list|(
name|ci
operator|.
name|getMetadata
argument_list|()
argument_list|,
name|langAnnotations
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|DC_LANGUAGE
argument_list|)
return|;
block|}
block|}
finally|finally
block|{
name|ci
operator|.
name|getLock
argument_list|()
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*       * Helper Methods for retrieving EnhancementProperties in 0.12 from the      * parsed ContentItem (see STANBOL-1280).      * NOTE: in 1.0.0 those are obsolete as EnhancementProperties will be parsed      * as additional parameter to the computeEnhancement method.      */
specifier|private
specifier|static
specifier|final
name|String
name|EHPROP_NS
init|=
name|NamespaceEnum
operator|.
name|ehp
operator|.
name|getNamespace
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|EHPROP_NS_LENGTH
init|=
name|EHPROP_NS
operator|.
name|length
argument_list|()
decl_stmt|;
comment|/**      * Retrieves the Enhancement Properties for the parsed Engine from the ContentItem.      *<p>      * The returned map will contain:<ol>      *<li> Request scoped properties defined for the parsed enhancement engines      *<li> Request scoped properties defined for chain      *<li> Chain scoped properties defined for the parsed enhancement engine      *<li> Chain scoped properties defined for the chain.      *</ol>      * NOTES:<ul>      *<li> The specification (see<a href="https://issues.apache.org/jira/browse/STANBOL-488">STANBOL-488</a>)      * required properties to start with '<code>enhancer.</code>'. While this      * implementation does not enforce this requirement non compliant properties      * will most likely get filtered earlier and not be part of the returned map.      *<li> Properties of an higher priority do override those with an lower one.      *</ul>      * @param engine the enhancement engine requesting the properties      * @param ci the content item (representing the enhancement request).      * @return The enhancement properties. This is a read/write copy of the      * read-only configuration.      * @see #getEnhancementPropertyDict(EnhancementEngine, ContentItem)      */
specifier|public
specifier|static
name|Dictionary
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|getEnhancementPropertyDict
parameter_list|(
name|EnhancementEngine
name|engine
parameter_list|,
name|ContentItem
name|ci
parameter_list|)
block|{
return|return
operator|new
name|DictionaryAdapter
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|(
name|getEnhancementProperties
argument_list|(
name|engine
argument_list|,
name|ci
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Retrieves the Enhancement Properties for the parsed Engine from the ContentItem.      *<p>      * The returned map will contain:<ol>      *<li> Request scoped properties defined for the parsed enhancement engines      *<li> Request scoped properties defined for chain      *<li> Chain scoped properties defined for the parsed enhancement engine      *<li> Chain scoped properties defined for the chain.      *</ol>      * NOTES:<ul>      *<li> The specification (see<a href="https://issues.apache.org/jira/browse/STANBOL-488">STANBOL-488</a>)      * required properties to start with '<code>enhancer.</code>'. While this      * implementation does not enforce this requirement non compliant properties      * will most likely get filtered earlier and not be part of the returned map.      *<li> Properties of an higher priority do override those with an lower one.      *</ul>      * @param engine the enhancement engine requesting the properties      * @param ci the content item (representing the enhancement request).      * @return The enhancement properties. This is a read/write copy of the      * read-only configuration.      * @see #getEnhancementPropertyDict(EnhancementEngine, ContentItem)      */
specifier|public
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|getEnhancementProperties
parameter_list|(
name|EnhancementEngine
name|engine
parameter_list|,
name|ContentItem
name|ci
parameter_list|)
block|{
if|if
condition|(
name|engine
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed EnhancementEngine MUST NOT be NULL"
argument_list|)
throw|;
block|}
if|if
condition|(
name|ci
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed ContentItem MUST NOT be NULL"
argument_list|)
throw|;
block|}
comment|//(1) retrieve Chain scope Enhancement Properties
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|chainExProps
init|=
name|getChainExecutionProperties
argument_list|(
name|engine
argument_list|,
name|ci
argument_list|)
decl_stmt|;
comment|//(2) retrieve Request specific EnhancementProperties
comment|//TODO: in future Stanbol version request specific EnhancementProperties
comment|//      will get stored in the ExecutionMetadata. Chain level properties
comment|//      with the `em:ChainExecution` node and engine specific properties
comment|//      with the `em:EngineExecution` node.
comment|//      So this code will need to be refactored similar to the above one
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|epContentPart
init|=
name|ContentItemHelper
operator|.
name|getRequestPropertiesContentPart
argument_list|(
name|ci
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|chainProperties
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|engineProperties
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|epContentPart
operator|!=
literal|null
condition|)
block|{
name|String
name|enginePrefix
init|=
operator|new
name|StringBuilder
argument_list|(
name|engine
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Retrieve EnhancementProperties for Engine {} and ContentItem {}"
argument_list|,
name|engine
operator|.
name|getName
argument_list|()
argument_list|,
name|ci
operator|.
name|getUri
argument_list|()
argument_list|)
expr_stmt|;
comment|//Set<String> engineKeys = new HashSet<String>();
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|entry
range|:
name|epContentPart
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|int
name|sepIndex
init|=
name|key
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
name|sepIndex
operator|<
literal|0
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|" ... add chain request level property {}='{}'"
argument_list|,
name|key
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|chainProperties
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|key
operator|.
name|startsWith
argument_list|(
name|enginePrefix
argument_list|)
operator|&&
name|key
operator|.
name|length
argument_list|()
operator|>
name|enginePrefix
operator|.
name|length
argument_list|()
condition|)
block|{
name|key
operator|=
name|key
operator|.
name|substring
argument_list|(
name|enginePrefix
operator|.
name|length
argument_list|()
argument_list|,
name|key
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|" ... add engine request level property {}='{}'"
argument_list|,
name|key
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|engineProperties
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// else not a enhancement property for the current engine.
block|}
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|" - no Request scope EnhancementProperties for ContentItem"
argument_list|,
name|ci
operator|.
name|getUri
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//Now we need to merge the properties based on the Enhancement Properties Precedence
comment|//defined by STANBOL-488
comment|// engineProp> engineEx> chainProp> chainExProp
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|properties
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|(
name|chainExProps
argument_list|)
decl_stmt|;
name|properties
operator|.
name|putAll
argument_list|(
name|chainProperties
argument_list|)
expr_stmt|;
name|properties
operator|.
name|putAll
argument_list|(
name|engineProperties
argument_list|)
expr_stmt|;
return|return
name|properties
return|;
block|}
comment|/**      * Getter for the {@link Chain} scoped (chain and chain-engine scoped) properties       * for the parsed enhancement engine and content item.      * @param engine the enhancement engine      * @param ci the content item      * @return the chain scoped enhancement properties. This will not include any      * request scoped properties.      * @since 0.12.1 (<a href="https://issues.apache.org/jira/browse/STANBOL-1361">STANBOL-1361</a>)      */
specifier|public
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|getChainExecutionProperties
parameter_list|(
name|EnhancementEngine
name|engine
parameter_list|,
name|ContentItem
name|ci
parameter_list|)
block|{
if|if
condition|(
name|engine
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed EnhancementEngine MUST NOT be NULL"
argument_list|)
throw|;
block|}
if|if
condition|(
name|ci
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed ContentItem MUST NOT be NULL"
argument_list|)
throw|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|chainExProps
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|engineExProps
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|ci
operator|.
name|getLock
argument_list|()
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|Graph
name|em
init|=
name|ExecutionMetadataHelper
operator|.
name|getExecutionMetadata
argument_list|(
name|ci
argument_list|)
decl_stmt|;
comment|//(1.a) retrieve EnhancementProperties from the ep:ExecutionPlan
name|log
operator|.
name|debug
argument_list|(
literal|"> extract EnhancementProperties form the ExecutionPlan"
argument_list|)
expr_stmt|;
name|BlankNodeOrIRI
name|executionPlanNode
init|=
name|ExecutionMetadataHelper
operator|.
name|getExecutionPlanNode
argument_list|(
name|em
argument_list|,
name|ExecutionMetadataHelper
operator|.
name|getChainExecution
argument_list|(
name|em
argument_list|,
name|ci
operator|.
name|getUri
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|extractEnhancementProperties
argument_list|(
name|chainExProps
argument_list|,
name|em
argument_list|,
name|executionPlanNode
argument_list|,
literal|"Chain Execution"
argument_list|)
expr_stmt|;
comment|//(1.b) retrieve Enhancement Properties from the ep:ExectutionNode
comment|//      for the parsed EnhancementEngine
name|log
operator|.
name|debug
argument_list|(
literal|"> extract EnhancementProperties form the ExecutionNode of Engine {}"
argument_list|,
name|engine
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|engineExecutions
init|=
name|em
operator|.
name|filter
argument_list|(
literal|null
argument_list|,
name|ExecutionPlan
operator|.
name|ENGINE
argument_list|,
operator|new
name|PlainLiteralImpl
argument_list|(
name|engine
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|//NOTE: we expect only a single execution node for an engine, but if
comment|//      there are multiple we will merge the properties of those
while|while
condition|(
name|engineExecutions
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|BlankNodeOrIRI
name|engineExecution
init|=
name|engineExecutions
operator|.
name|next
argument_list|()
operator|.
name|getSubject
argument_list|()
decl_stmt|;
if|if
condition|(
name|em
operator|.
name|contains
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|executionPlanNode
argument_list|,
name|ExecutionPlan
operator|.
name|HAS_EXECUTION_NODE
argument_list|,
name|engineExecution
argument_list|)
argument_list|)
condition|)
block|{
name|extractEnhancementProperties
argument_list|(
name|engineExProps
argument_list|,
name|em
argument_list|,
name|engineExecution
argument_list|,
literal|"Engine Execution"
argument_list|)
expr_stmt|;
block|}
comment|//else engine execution of a different execution plan
block|}
block|}
catch|catch
parameter_list|(
name|NoSuchPartException
name|e
parameter_list|)
block|{
comment|//no execution metadata are present
name|log
operator|.
name|debug
argument_list|(
literal|"  - no ExecutionMetadata are present ..."
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|ci
operator|.
name|getLock
argument_list|()
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|//finally merge the chain-engine scoped properties into the chain scoped properties
name|chainExProps
operator|.
name|putAll
argument_list|(
name|engineExProps
argument_list|)
expr_stmt|;
return|return
name|chainExProps
return|;
block|}
comment|/**      * Extracts all EnhancementProperties from the parsed Node and adds them to      * the parsed map      * @param properties The Map to add the extracted properties. extracted values      * are appended to existing values.      * @param graph the RDF graph containing the data      * @param node the node to extract the properties from      * @param level the name of the level (only used for logging)      */
specifier|private
specifier|static
name|void
name|extractEnhancementProperties
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|properties
parameter_list|,
name|Graph
name|graph
parameter_list|,
name|BlankNodeOrIRI
name|node
parameter_list|,
name|String
name|level
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|" - extract {} properties from {}"
argument_list|,
name|level
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|props
init|=
name|graph
operator|.
name|filter
argument_list|(
name|node
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
while|while
condition|(
name|props
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Triple
name|t
init|=
name|props
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|propUri
init|=
name|t
operator|.
name|getPredicate
argument_list|()
operator|.
name|getUnicodeString
argument_list|()
decl_stmt|;
if|if
condition|(
name|propUri
operator|.
name|startsWith
argument_list|(
name|EHPROP_NS
argument_list|)
condition|)
block|{
name|String
name|prop
init|=
name|propUri
operator|.
name|substring
argument_list|(
name|EHPROP_NS_LENGTH
argument_list|)
decl_stmt|;
name|RDFTerm
name|resource
init|=
name|t
operator|.
name|getObject
argument_list|()
decl_stmt|;
name|Object
name|value
init|=
name|extractEnhancementPropertyValue
argument_list|(
name|resource
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
operator|!
name|prop
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Object
name|current
init|=
name|properties
operator|.
name|get
argument_list|(
name|prop
argument_list|)
decl_stmt|;
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|current
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|" ... append {} property '{}' to {}='{}'"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|level
block|,
name|value
block|,
name|prop
block|,
name|current
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|" ... add {} property {}='{}'"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|level
block|,
name|prop
block|,
name|value
block|}
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|current
operator|instanceof
name|Collection
argument_list|<
name|?
argument_list|>
condition|)
block|{
operator|(
operator|(
name|Collection
operator|)
name|current
operator|)
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current
operator|!=
literal|null
condition|)
block|{
name|Collection
argument_list|<
name|Object
argument_list|>
name|col
init|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|col
operator|.
name|add
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|col
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|properties
operator|.
name|put
argument_list|(
name|prop
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|properties
operator|.
name|put
argument_list|(
name|prop
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**      * Extracts the EnhancementProperty value from the parsed RDFTerm.<p>      * Currently this will return {@link IRI#getUnicodeString()} or      * {@link Literal#getLexicalForm()}. For {@link BlankNode}s<code>null</code>       * is returned.      * @param r the resource to parse the value form      * @return the parsed value      */
specifier|private
specifier|static
name|Object
name|extractEnhancementPropertyValue
parameter_list|(
name|RDFTerm
name|r
parameter_list|)
block|{
name|Object
name|value
decl_stmt|;
if|if
condition|(
name|r
operator|instanceof
name|IRI
condition|)
block|{
name|value
operator|=
operator|(
operator|(
name|IRI
operator|)
name|r
operator|)
operator|.
name|getUnicodeString
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|instanceof
name|Literal
condition|)
block|{
name|value
operator|=
operator|(
operator|(
name|Literal
operator|)
name|r
operator|)
operator|.
name|getLexicalForm
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
literal|null
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
comment|/**      * Getter for all configuration values for the parsed property.<p>      * This does support arrays and {@link Collection}s for multiple values.      * In any other case a single value collection will be returned.<code>NULL</code>      * value contained in the parsed value will be silently removed.      * @param config the OSGI component configuration.      * @param property the configuration property      * @param type the desired type of the configuration values. The parsed type      * MUST define a {@link Constructor} taking a {@link String} as only parameter.      * @return the configuration values for the parsed property or<code>null</code>      * if the property was not contained in the parsed configuration      * @throws NullPointerException if the parsed type is<code>null</code>      * @throws IllegalArgumentException if the parsed type does not have a      * {@link Constructor} that takes a {@link String} as only parameter; if the      * {@link Constructor} is not visible or can not be instantiated (e.g.      * because the parsed type is an Interface or an abstract class).      * @throws ConfigurationException if the parsed type can not be instantiated      * if one of the parsed values (e.g. if {@link Float} is used as type and      * one of the parsed values is not a valid float).      * @since 0.12.1      */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Collection
argument_list|<
name|T
argument_list|>
name|getConfigValues
parameter_list|(
name|Dictionary
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|config
parameter_list|,
name|String
name|property
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
throws|throws
name|ConfigurationException
block|{
if|if
condition|(
name|config
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"The parsed Dictionary with the configuration MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|property
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"The parsed configuration property MUST NOT be NULL!"
argument_list|)
throw|;
block|}
try|try
block|{
return|return
name|parseConfigValues
argument_list|(
name|config
operator|.
name|get
argument_list|(
name|property
argument_list|)
argument_list|,
name|type
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|property
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Getter for all configuration values for the parsed enhancement property.<p>      * This does support arrays and {@link Collection}s for multiple values.      * In any other case a single value collection will be returned.<code>NULL</code>      * value contained in the parsed value will be silently removed.      * @param ee the enhancement engine (only used to report errors      * @param ci the content item (only used to report errors)      * @param enhProps the enhancement properties as parsed the the engine with      * the parsed content item      * @param enhProp the enhancement property      * @param type the desired type of the configuration values. The parsed type      * MUST define a {@link Constructor} taking a {@link String} as only parameter.      * @return the configuration values for the parsed property or<code>null</code>      * if the property was not contained in the parsed enhancement properties      * @throws NullPointerException if the parsed type is<code>null</code>      * @throws IllegalArgumentException if the parsed type does not have a      * {@link Constructor} that takes a {@link String} as only parameter; if the      * {@link Constructor} is not visible or can not be instantiated (e.g.      * because the parsed type is an Interface or an abstract class).      * @throws EnhancementPropertyException if the parsed type can not be instantiated      * if one of the parsed values (e.g. if {@link Float} is used as type and      * one of the parsed values is not a valid float).      * @since 0.12.1      */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Collection
argument_list|<
name|T
argument_list|>
name|getConfigValues
parameter_list|(
name|EnhancementEngine
name|ee
parameter_list|,
name|ContentItem
name|ci
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|enhProps
parameter_list|,
name|String
name|enhProp
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
throws|throws
name|EnhancementPropertyException
block|{
if|if
condition|(
name|enhProp
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"The parsed EnhancementProperty MUST NOT be NULL"
argument_list|)
throw|;
block|}
if|if
condition|(
name|enhProps
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"The parsed Map with the EnhancementProperties MUST NOT be NULL"
argument_list|)
throw|;
block|}
try|try
block|{
return|return
name|parseConfigValues
argument_list|(
name|enhProps
operator|.
name|get
argument_list|(
name|enhProp
argument_list|)
argument_list|,
name|type
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|EnhancementPropertyException
argument_list|(
name|ee
argument_list|,
name|ci
argument_list|,
name|enhProp
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Extracts multiple Configuration values from the parsed Object value.      * This does support arrays and {@link Collection}s for multiple values.      * In any other case a single value collection will be returned.<code>NULL</code>      * value contained in the parsed value will be silently removed.      * @param value the value. {@link Collection}s and Arrays are supported for      * multiple values. If the parsed value is of an other type a single value      * is assumed.      * @param type the desired type of the configuration values. The parsed type      * MUST define a {@link Constructor} taking a {@link String} as only parameter.      * @return the configuration values as parsed from the parsed value      * @throws NullPointerException if the parsed type is<code>null</code>      * @throws IllegalArgumentException if the parsed type does not have a      * {@link Constructor} that takes a {@link String} as only parameter; if the      * {@link Constructor} is not visible or can not be instantiated (e.g.      * because the parsed type is an Interface or an abstract class).      * @throws IllegalStateException if the parsed type can not be instantiated      * if one of the parsed values (e.g. if {@link Float} is used as type and      * one of the parsed values is not a valid float.      * @since 0.12.1      */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Collection
argument_list|<
name|T
argument_list|>
name|parseConfigValues
parameter_list|(
name|Object
name|value
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
block|{
return|return
name|parseConfigValues
argument_list|(
name|value
argument_list|,
name|type
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Getter for all configuration values for the parsed property.<p>      * This does support arrays and {@link Collection}s for multiple values.      * In any other case a single value collection will be returned.      * @param config the OSGI component configuration.      * @param property the configuration property      * @param type the desired type of the configuration values. The parsed type      * MUST define a {@link Constructor} taking a {@link String} as only parameter.      * @param preseveNullValues if<code>null</code> values in the parsed      * value should be preserved or removed.      * @return the configuration values for the parsed property or<code>null</code>      * if the property was not contained in the parsed configuration      * @throws NullPointerException if the parsed type is<code>null</code>      * @throws IllegalArgumentException if the parsed type does not have a      * {@link Constructor} that takes a {@link String} as only parameter; if the      * {@link Constructor} is not visible or can not be instantiated (e.g.      * because the parsed type is an Interface or an abstract class).      * @throws ConfigurationException if the parsed type can not be instantiated      * if one of the parsed values (e.g. if {@link Float} is used as type and      * one of the parsed values is not a valid float).      * @since 0.12.1      */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Collection
argument_list|<
name|T
argument_list|>
name|getConfigValues
parameter_list|(
name|Dictionary
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|config
parameter_list|,
name|String
name|property
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
name|boolean
name|preserveNullValues
parameter_list|)
throws|throws
name|ConfigurationException
block|{
if|if
condition|(
name|config
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"The parsed Dictionary with the configuration MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|property
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"The parsed configuration property MUST NOT be NULL!"
argument_list|)
throw|;
block|}
try|try
block|{
return|return
name|parseConfigValues
argument_list|(
name|config
operator|.
name|get
argument_list|(
name|property
argument_list|)
argument_list|,
name|type
argument_list|,
name|preserveNullValues
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|property
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Getter for all configuration values for the parsed enhancement property.<p>      * This does support arrays and {@link Collection}s for multiple values.      * In any other case a single value collection will be returned.      * @param ee the enhancement engine (only used to report errors      * @param ci the content item (only used to report errors)      * @param enhProps the enhancement properties as parsed the the engine with      * the parsed content item      * @param enhProp the enhancement property      * @param type the desired type of the configuration values. The parsed type      * MUST define a {@link Constructor} taking a {@link String} as only parameter.      * @param preseveNullValues if<code>null</code> values in the parsed      * value should be preserved or removed.      * @return the configuration values for the parsed property or<code>null</code>      * if the property was not contained in the parsed enhancement properties.      * @throws NullPointerException if the parsed type is<code>null</code>      * @throws IllegalArgumentException if the parsed type does not have a      * {@link Constructor} that takes a {@link String} as only parameter; if the      * {@link Constructor} is not visible or can not be instantiated (e.g.      * because the parsed type is an Interface or an abstract class).      * @throws EnhancementPropertyException if the parsed type can not be instantiated      * if one of the parsed values (e.g. if {@link Float} is used as type and      * one of the parsed values is not a valid float).      * @since 0.12.1      */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Collection
argument_list|<
name|T
argument_list|>
name|getConfigValues
parameter_list|(
name|EnhancementEngine
name|ee
parameter_list|,
name|ContentItem
name|ci
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|enhProps
parameter_list|,
name|String
name|enhProp
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
name|boolean
name|preserveNullValues
parameter_list|)
throws|throws
name|EnhancementPropertyException
block|{
if|if
condition|(
name|enhProp
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"The parsed EnhancementProperty MUST NOT be NULL"
argument_list|)
throw|;
block|}
if|if
condition|(
name|enhProps
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"The parsed Map with the EnhancementProperties MUST NOT be NULL"
argument_list|)
throw|;
block|}
try|try
block|{
return|return
name|parseConfigValues
argument_list|(
name|enhProps
operator|.
name|get
argument_list|(
name|enhProp
argument_list|)
argument_list|,
name|type
argument_list|,
name|preserveNullValues
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|EnhancementPropertyException
argument_list|(
name|ee
argument_list|,
name|ci
argument_list|,
name|enhProp
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Extracts multiple Configuration values from the parsed Object value.      * This does support arrays and {@link Collection}s for multiple values.      * In any other case a single value collection will be returned.      * @param value the value. {@link Collection}s and Arrays are supported for      * multiple values. If the parsed value is of an other type a single value      * is assumed.      * @param type the desired type of the configuration values. The parsed type      * MUST define a {@link Constructor} taking a {@link String} as only parameter.      * @param preseveNullValues if<code>null</code> values in the parsed      * value should be preserved or removed.      * @return the configuration values as parsed from the parsed value      * @throws NullPointerException if the parsed type is<code>null</code>      * @throws IllegalArgumentException if the parsed type does not have a      * {@link Constructor} that takes a {@link String} as only parameter; if the      * {@link Constructor} is not visible or can not be instantiated (e.g.      * because the parsed type is an Interface or an abstract class).      * @throws IllegalStateException if the parsed type can not be instantiated      * if one of the parsed values (e.g. if {@link Float} is used as type and      * one of the parsed values is not a valid float.      * @since 0.12.1      */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Collection
argument_list|<
name|T
argument_list|>
name|parseConfigValues
parameter_list|(
name|Object
name|value
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
name|boolean
name|preseveNullValues
parameter_list|)
block|{
return|return
name|parseConfigValues
argument_list|(
name|value
argument_list|,
name|type
argument_list|,
literal|null
argument_list|,
name|preseveNullValues
argument_list|)
return|;
block|}
comment|/**      * Getter for all configuration values for the parsed property.<p>      * This does support arrays and {@link Collection}s for multiple values.      * In any other case a single value collection will be returned.<code>NULL</code>      * value contained in the parsed value will be silently removed.      * @param config the OSGI component configuration.      * @param property the configuration property      * @param type the desired type of the configuration values. The parsed type      * MUST define a {@link Constructor} taking a {@link String} as only parameter.      * @param configValues The collection to add the parsed configuration values      * to. If<code>null</code> an {@link ArrayList} will be used.      * @return the configuration values for the parsed property or<code>null</code>      * if the property was not contained in the parsed configuration      * @throws NullPointerException if the parsed type is<code>null</code>      * @throws IllegalArgumentException if the parsed type does not have a      * {@link Constructor} that takes a {@link String} as only parameter; if the      * {@link Constructor} is not visible or can not be instantiated (e.g.      * because the parsed type is an Interface or an abstract class).      * @throws ConfigurationException if the parsed type can not be instantiated      * if one of the parsed values (e.g. if {@link Float} is used as type and      * one of the parsed values is not a valid float).      * @since 0.12.1      */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Collection
argument_list|<
name|T
argument_list|>
name|getConfigValues
parameter_list|(
name|Dictionary
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|config
parameter_list|,
name|String
name|property
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
name|Collection
argument_list|<
name|T
argument_list|>
name|configValues
parameter_list|)
throws|throws
name|ConfigurationException
block|{
if|if
condition|(
name|config
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"The parsed Dictionary with the configuration MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|property
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"The parsed configuration property MUST NOT be NULL!"
argument_list|)
throw|;
block|}
try|try
block|{
return|return
name|parseConfigValues
argument_list|(
name|config
operator|.
name|get
argument_list|(
name|property
argument_list|)
argument_list|,
name|type
argument_list|,
name|configValues
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|property
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Getter for all configuration values for the parsed enhancement property.<p>      * This does support arrays and {@link Collection}s for multiple values.      * In any other case a single value collection will be returned.<code>NULL</code>      * value contained in the parsed value will be silently removed.      * @param ee the enhancement engine (only used to report errors      * @param ci the content item (only used to report errors)      * @param enhProps the enhancement properties as parsed the the engine with      * the parsed content item      * @param enhProp the enhancement property      * @param type the desired type of the configuration values. The parsed type      * MUST define a {@link Constructor} taking a {@link String} as only parameter.      * @param configValues The collection to add the parsed configuration values      * to. If<code>null</code> an {@link ArrayList} will be used.      * @return the configuration values for the parsed property or<code>null</code>      * if the property was not contained in the parsed enhancement properties      * @throws NullPointerException if the parsed type is<code>null</code>      * @throws IllegalArgumentException if the parsed type does not have a      * {@link Constructor} that takes a {@link String} as only parameter; if the      * {@link Constructor} is not visible or can not be instantiated (e.g.      * because the parsed type is an Interface or an abstract class).      * @throws EnhancementPropertyException if the parsed type can not be instantiated      * if one of the parsed values (e.g. if {@link Float} is used as type and      * one of the parsed values is not a valid float).      * @since 0.12.1      */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Collection
argument_list|<
name|T
argument_list|>
name|getConfigValues
parameter_list|(
name|EnhancementEngine
name|ee
parameter_list|,
name|ContentItem
name|ci
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|enhProps
parameter_list|,
name|String
name|enhProp
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
name|Collection
argument_list|<
name|T
argument_list|>
name|configValues
parameter_list|)
throws|throws
name|EnhancementPropertyException
block|{
if|if
condition|(
name|enhProp
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"The parsed EnhancementProperty MUST NOT be NULL"
argument_list|)
throw|;
block|}
if|if
condition|(
name|enhProps
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"The parsed Map with the EnhancementProperties MUST NOT be NULL"
argument_list|)
throw|;
block|}
try|try
block|{
return|return
name|parseConfigValues
argument_list|(
name|enhProps
operator|.
name|get
argument_list|(
name|enhProp
argument_list|)
argument_list|,
name|type
argument_list|,
name|configValues
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|EnhancementPropertyException
argument_list|(
name|ee
argument_list|,
name|ci
argument_list|,
name|enhProp
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Extracts multiple Configuration values from the parsed Object value.      * This does support arrays and {@link Collection}s for multiple values.      * In any other case a single value collection will be returned.      * @param value the value. {@link Collection}s and Arrays are supported for      * multiple values. If the parsed value is of an other type a single value      * is assumed.      * @param type the desired type of the configuration values. The parsed type      * MUST define a {@link Constructor} taking a {@link String} as only parameter.      * @param configValues The collection to add the parsed configuration values      * to. If<code>null</code> an {@link ArrayList} will be used.      * @return the configuration values as parsed from the parsed value.       *<code>null</code> if the parsed value was<code>null</code>.      * @throws NullPointerException if the parsed type is<code>null</code>      * @throws IllegalArgumentException if the parsed type does not have a      * {@link Constructor} that takes a {@link String} as only parameter; if the      * {@link Constructor} is not visible or can not be instantiated (e.g.      * because the parsed type is an Interface or an abstract class).      * @throws IllegalStateException if the parsed type can not be instantiated      * if one of the parsed values (e.g. if {@link Float} is used as type and      * one of the parsed values is not a valid float.      * @since 0.12.1      */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Collection
argument_list|<
name|T
argument_list|>
name|parseConfigValues
parameter_list|(
name|Object
name|value
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
name|Collection
argument_list|<
name|T
argument_list|>
name|configValues
parameter_list|)
block|{
return|return
name|parseConfigValues
argument_list|(
name|value
argument_list|,
name|type
argument_list|,
name|configValues
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Getter for all configuration values for the parsed property.<p>      * This does support arrays and {@link Collection}s for multiple values.      * In any other case a single value collection will be returned.      * @param config the OSGI component configuration.      * @param property the configuration property      * @param type the desired type of the configuration values. The parsed type      * MUST define a {@link Constructor} taking a {@link String} as only parameter.      * @param configValues The collection to add the parsed configuration values      * to. If<code>null</code> an {@link ArrayList} will be used.      * @param preseveNullValues if<code>null</code> values in the parsed      * value should be preserved or removed.      * @return the configuration values for the parsed property or<code>null</code>      * if the property was not contained in the parsed configuration      * @throws NullPointerException if the parsed type is<code>null</code>      * @throws IllegalArgumentException if the parsed type does not have a      * {@link Constructor} that takes a {@link String} as only parameter; if the      * {@link Constructor} is not visible or can not be instantiated (e.g.      * because the parsed type is an Interface or an abstract class).      * @throws ConfigurationException if the parsed type can not be instantiated      * if one of the parsed values (e.g. if {@link Float} is used as type and      * one of the parsed values is not a valid float).      * @since 0.12.1      */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Collection
argument_list|<
name|T
argument_list|>
name|getConfigValues
parameter_list|(
name|Dictionary
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|config
parameter_list|,
name|String
name|property
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
name|Collection
argument_list|<
name|T
argument_list|>
name|configValues
parameter_list|,
name|boolean
name|preserveNullValues
parameter_list|)
throws|throws
name|ConfigurationException
block|{
if|if
condition|(
name|config
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"The parsed Dictionary with the configuration MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|property
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"The parsed configuration property MUST NOT be NULL!"
argument_list|)
throw|;
block|}
try|try
block|{
return|return
name|parseConfigValues
argument_list|(
name|config
operator|.
name|get
argument_list|(
name|property
argument_list|)
argument_list|,
name|type
argument_list|,
name|configValues
argument_list|,
name|preserveNullValues
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|property
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Getter for all configuration values for the parsed enhancement property.<p>      * This does support arrays and {@link Collection}s for multiple values.      * In any other case a single value collection will be returned.      * @param ee the enhancement engine (only used to report errors      * @param ci the content item (only used to report errors)      * @param enhProps the enhancement properties as parsed the the engine with      * the parsed content item      * @param enhProp the enhancement property      * @param type the desired type of the configuration values. The parsed type      * MUST define a {@link Constructor} taking a {@link String} as only parameter.      * @param configValues The collection to add the parsed configuration values      * to. If<code>null</code> an {@link ArrayList} will be used.      * @param preseveNullValues if<code>null</code> values in the parsed      * value should be preserved or removed.      * @return the configuration values for the parsed property or<code>null</code>      * if the property was not contained in the parsed enhancement properties      * @throws NullPointerException if the parsed type is<code>null</code>      * @throws IllegalArgumentException if the parsed type does not have a      * {@link Constructor} that takes a {@link String} as only parameter; if the      * {@link Constructor} is not visible or can not be instantiated (e.g.      * because the parsed type is an Interface or an abstract class).      * @throws EnhancementPropertyException if the parsed type can not be instantiated      * if one of the parsed values (e.g. if {@link Float} is used as type and      * one of the parsed values is not a valid float).      * @since 0.12.1      */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Collection
argument_list|<
name|T
argument_list|>
name|getConfigValues
parameter_list|(
name|EnhancementEngine
name|ee
parameter_list|,
name|ContentItem
name|ci
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|enhProps
parameter_list|,
name|String
name|enhProp
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
name|Collection
argument_list|<
name|T
argument_list|>
name|configValues
parameter_list|,
name|boolean
name|preserveNullValues
parameter_list|)
throws|throws
name|EnhancementPropertyException
block|{
if|if
condition|(
name|enhProp
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"The parsed EnhancementProperty MUST NOT be NULL"
argument_list|)
throw|;
block|}
if|if
condition|(
name|enhProps
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"The parsed Map with the EnhancementProperties MUST NOT be NULL"
argument_list|)
throw|;
block|}
try|try
block|{
return|return
name|parseConfigValues
argument_list|(
name|enhProps
operator|.
name|get
argument_list|(
name|enhProp
argument_list|)
argument_list|,
name|type
argument_list|,
name|configValues
argument_list|,
name|preserveNullValues
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|EnhancementPropertyException
argument_list|(
name|ee
argument_list|,
name|ci
argument_list|,
name|enhProp
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Extracts multiple Configuration values from the parsed Object value.      * This does support arrays and {@link Collection}s for multiple values.      * In any other case a single value collection will be returned.      * @param value the value. {@link Collection}s and Arrays are supported for      * multiple values. If the parsed value is of an other type a single value      * is assumed.      * @param type the desired type of the configuration values. The parsed type      * MUST define a {@link Constructor} taking a {@link String} as only parameter.      * @param configValues The collection to add the parsed configuration values      * to. If<code>null</code> an {@link ArrayList} will be used.      * @param preseveNullValues if<code>null</code> values in the parsed      * value should be preserved or removed.      * @return the configuration values as parsed from the parsed value.       *<code>null</code> if the parsed value was<code>null</code>.      * @throws NullPointerException if the parsed type is<code>null</code>      * @throws IllegalArgumentException if the parsed type does not have a      * {@link Constructor} that takes a {@link String} as only parameter; if the      * {@link Constructor} is not visible or can not be instantiated (e.g.      * because the parsed type is an Interface or an abstract class).      * @throws IllegalStateException if the parsed type can not be instantiated      * if one of the parsed values (e.g. if {@link Float} is used as type and      * one of the parsed values is not a valid float.      * @since 0.12.1      */
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Collection
argument_list|<
name|T
argument_list|>
name|parseConfigValues
parameter_list|(
name|Object
name|value
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
name|Collection
argument_list|<
name|T
argument_list|>
name|configValues
parameter_list|,
name|boolean
name|preseveNullValues
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|Collection
argument_list|<
name|?
argument_list|>
name|values
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Collection
argument_list|<
name|?
argument_list|>
condition|)
block|{
name|values
operator|=
operator|(
name|Collection
argument_list|<
name|?
argument_list|>
operator|)
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|.
name|getClass
argument_list|()
operator|.
name|isArray
argument_list|()
condition|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|componentType
init|=
name|value
operator|.
name|getClass
argument_list|()
operator|.
name|getComponentType
argument_list|()
decl_stmt|;
if|if
condition|(
name|componentType
operator|.
name|isPrimitive
argument_list|()
condition|)
block|{
name|int
name|len
init|=
name|Array
operator|.
name|getLength
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|av
init|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|(
name|len
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|av
operator|.
name|add
argument_list|(
name|Array
operator|.
name|get
argument_list|(
name|value
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|values
operator|=
name|av
expr_stmt|;
block|}
else|else
block|{
name|values
operator|=
name|Arrays
operator|.
name|asList
argument_list|(
operator|(
name|Object
index|[]
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|values
operator|=
name|Collections
operator|.
name|singleton
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Constructor
argument_list|<
name|T
argument_list|>
name|constructor
init|=
name|getConfigTypeConstructor
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|configValues
operator|==
literal|null
condition|)
block|{
comment|//no idea why I have to cast to C ...
name|configValues
operator|=
operator|new
name|ArrayList
argument_list|<
name|T
argument_list|>
argument_list|(
name|values
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Object
name|o
range|:
name|values
control|)
block|{
if|if
condition|(
name|o
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|preseveNullValues
condition|)
block|{
name|configValues
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|//else skip
block|}
else|else
block|{
name|configValues
operator|.
name|add
argument_list|(
name|parseConfigValue
argument_list|(
name|o
argument_list|,
name|type
argument_list|,
name|constructor
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|configValues
return|;
block|}
comment|/**      * Getter for the first configuration value      * @param config the OSGI component configuration      * @param property the configuration property      * @param type the desired type of the configuration values. The parsed type      * MUST define a {@link Constructor} taking a {@link String} as only parameter.      * @param preseveNullValues if<code>null</code> values in the parsed      * value should be preserved or removed.      * @return the configuration value as parsed from the parsed value      * @throws ConfigurationException if the parsed type can not be instantiated      * if one of the parsed values (e.g. if {@link Float} is used as type and      * one of the parsed values is not a valid float.      * @throws NullPointerException if the parsed {@link Dictionary} with the component      * configuration, the configuration property or the type is<code>null</code>      * @throws IllegalArgumentException if the parsed type does not have a      * {@link Constructor} that takes a {@link String} as only parameter; if the      * {@link Constructor} is not visible or can not be instantiated (e.g.      * because the parsed type is an Interface or an abstract class).      * @since 0.12.1      */
specifier|public
specifier|static
specifier|final
parameter_list|<
name|T
parameter_list|>
name|T
name|getFirstConfigValue
parameter_list|(
name|Dictionary
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|config
parameter_list|,
name|String
name|property
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
throws|throws
name|ConfigurationException
block|{
if|if
condition|(
name|config
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"The parsed configuration MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|property
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"The pased configuration property MUST NOT be NULL!"
argument_list|)
throw|;
block|}
try|try
block|{
return|return
name|parseFirstConfigValue
argument_list|(
name|config
operator|.
name|get
argument_list|(
name|property
argument_list|)
argument_list|,
name|type
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|property
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Getter for the first value of an EnhancementProperty      * @param ee the enhancement engine (only used for reporting errors)      * @param ci the content item (only used for reporting errors)      * @param enhProps the map with the enhancement properties      * @param enhProp the enhancement property      * @param type the desired type of the configuration values. The parsed type      * MUST define a {@link Constructor} taking a {@link String} as only parameter.      * @param preseveNullValues if<code>null</code> values in the parsed      * value should be preserved or removed.      * @return the configuration value as parsed from the parsed value      * @throws EnhancementPropertyException if the parsed type can not be instantiated      * if one of the parsed values (e.g. if {@link Float} is used as type and      * one of the parsed values is not a valid float.      * @throws NullPointerException if the parsed {@link Map} with the enhancement      * properties, the enhancement property or the type is<code>null</code>      * @throws IllegalArgumentException if the parsed type does not have a      * {@link Constructor} that takes a {@link String} as only parameter; if the      * {@link Constructor} is not visible or can not be instantiated (e.g.      * because the parsed type is an Interface or an abstract class).      * @since 0.12.1      */
specifier|public
specifier|static
specifier|final
parameter_list|<
name|T
parameter_list|>
name|T
name|getFirstConfigValue
parameter_list|(
name|EnhancementEngine
name|ee
parameter_list|,
name|ContentItem
name|ci
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|enhProps
parameter_list|,
name|String
name|enhProp
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
throws|throws
name|EnhancementPropertyException
block|{
if|if
condition|(
name|enhProp
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"The parsed EnhancementProperty MUST NOT be NULL"
argument_list|)
throw|;
block|}
if|if
condition|(
name|enhProps
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"The parsed Map with the EnhancementProperties MUST NOT be NULL"
argument_list|)
throw|;
block|}
try|try
block|{
return|return
name|parseFirstConfigValue
argument_list|(
name|enhProps
operator|.
name|get
argument_list|(
name|enhProp
argument_list|)
argument_list|,
name|type
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|EnhancementPropertyException
argument_list|(
name|ee
argument_list|,
name|ci
argument_list|,
name|enhProp
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Extracts a single Configuration values from the parsed Object value.      * In case the parsed value is an Array or a Collection it will take the      * first non<code>null</code> value.      * @param value the value. In case of an Array or a Collection it will take      * the first non<code>null</code> value      * @param type the desired type of the configuration values. The parsed type      * MUST define a {@link Constructor} taking a {@link String} as only parameter.      * @param preseveNullValues if<code>null</code> values in the parsed      * value should be preserved or removed.      * @return the configuration value as parsed from the parsed value      * @throws NullPointerException if the parsed type is<code>null</code>      * @throws IllegalArgumentException if the parsed type does not have a      * {@link Constructor} that takes a {@link String} as only parameter; if the      * {@link Constructor} is not visible or can not be instantiated (e.g.      * because the parsed type is an Interface or an abstract class).      * @throws IllegalStateException if the parsed type can not be instantiated      * if one of the parsed values (e.g. if {@link Float} is used as type and      * one of the parsed values is not a valid float.      * @since 0.12.1      */
specifier|public
specifier|static
specifier|final
parameter_list|<
name|T
parameter_list|>
name|T
name|parseFirstConfigValue
parameter_list|(
name|Object
name|value
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Object
name|first
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Collection
argument_list|<
name|?
argument_list|>
condition|)
block|{
name|Collection
argument_list|<
name|?
argument_list|>
name|c
init|=
operator|(
name|Collection
argument_list|<
name|?
argument_list|>
operator|)
name|value
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|Iterator
argument_list|<
name|?
argument_list|>
name|it
init|=
name|c
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|first
operator|==
literal|null
operator|&&
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|first
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|value
operator|.
name|getClass
argument_list|()
operator|.
name|isArray
argument_list|()
condition|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|componentType
init|=
name|value
operator|.
name|getClass
argument_list|()
operator|.
name|getComponentType
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|Array
operator|.
name|getLength
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
if|if
condition|(
name|componentType
operator|.
name|isPrimitive
argument_list|()
condition|)
block|{
name|first
operator|=
name|Array
operator|.
name|get
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|first
operator|==
literal|null
operator|&&
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|first
operator|=
name|Array
operator|.
name|get
argument_list|(
name|value
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|first
operator|=
name|value
expr_stmt|;
block|}
return|return
name|parseConfigValue
argument_list|(
name|first
argument_list|,
name|type
argument_list|,
name|getConfigTypeConstructor
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
block|}
end_class

begin_comment
comment|/**      * Internally used to get the config value for the parsed value and type.      * @param value      * @param type      * @param constructor the constructor typically retrieved by calling      * {@link #getConfigTypeConstructor(Class)} for the type      * @return the value      */
end_comment

begin_function
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|parseConfigValue
parameter_list|(
name|Object
name|value
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|,
specifier|final
name|Constructor
argument_list|<
name|T
argument_list|>
name|constructor
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|T
name|configValue
decl_stmt|;
if|if
condition|(
name|constructor
operator|==
literal|null
condition|)
block|{
name|configValue
operator|=
name|type
operator|.
name|cast
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|configValue
operator|=
name|constructor
operator|.
name|newInstance
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InstantiationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unable to instantiate the "
operator|+
literal|"parsed value type '"
operator|+
name|type
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"'!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unable to access the "
operator|+
literal|"constructor of the parsed value type '"
operator|+
name|type
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"'!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to instantiate the "
operator|+
literal|"parsed value type '"
operator|+
name|type
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' with the String value '"
operator|+
name|value
operator|+
literal|"'!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|configValue
return|;
block|}
end_function

begin_comment
comment|/**      * Internally used to get the String parameter constructor for the parsed      * config value type      * @param type      * @return      */
end_comment

begin_function
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Constructor
argument_list|<
name|T
argument_list|>
name|getConfigTypeConstructor
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
block|{
specifier|final
name|Constructor
argument_list|<
name|T
argument_list|>
name|constructor
decl_stmt|;
if|if
condition|(
name|String
operator|.
name|class
operator|.
name|equals
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|constructor
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|constructor
operator|=
name|type
operator|.
name|getConstructor
argument_list|(
name|String
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Parsed config value type '"
operator|+
name|type
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"' does not define a Constructor "
operator|+
literal|"that takes a String as only parameter!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|constructor
return|;
block|}
end_function

unit|}
end_unit

