begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|EnhancementEngineHelper
operator|.
name|get
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|EnhancementEngineHelper
operator|.
name|getReference
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|ExecutionPlanHelper
operator|.
name|getEngine
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|ExecutionPlanHelper
operator|.
name|getExecutionNodes
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|ExecutionMetadata
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|ExecutionPlan
operator|.
name|CHAIN
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|RDF_TYPE
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|BNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Literal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|LiteralFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|MGraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|NonLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Triple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|TripleCollection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|UriRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|impl
operator|.
name|PlainLiteralImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|impl
operator|.
name|SimpleMGraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|impl
operator|.
name|TripleImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|Chain
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|ContentItem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|EnhancementJobManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|NoSuchPartException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|ExecutionMetadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|ExecutionPlan
import|;
end_import

begin_comment
comment|/**  * This class defines utility methods for writing and updating   * Execution Metadata. This will be usually needed by   * {@link EnhancementJobManager} implementations.  * @author Rupert Westenthaler  *  */
end_comment

begin_class
specifier|public
class|class
name|ExecutionMetadataHelper
block|{
specifier|private
specifier|static
specifier|final
name|LiteralFactory
name|lf
init|=
name|LiteralFactory
operator|.
name|getInstance
argument_list|()
decl_stmt|;
specifier|public
specifier|static
name|NonLiteral
name|createChainExecutionNode
parameter_list|(
name|MGraph
name|graph
parameter_list|,
name|NonLiteral
name|executionPlan
parameter_list|,
name|UriRef
name|ciUri
parameter_list|,
name|boolean
name|defaultChain
parameter_list|)
block|{
name|NonLiteral
name|node
init|=
operator|new
name|BNode
argument_list|()
decl_stmt|;
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|node
argument_list|,
name|RDF_TYPE
argument_list|,
name|EXECUTION
argument_list|)
argument_list|)
expr_stmt|;
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|node
argument_list|,
name|RDF_TYPE
argument_list|,
name|CHAIN_EXECUTION
argument_list|)
argument_list|)
expr_stmt|;
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|node
argument_list|,
name|ENHANCES
argument_list|,
name|ciUri
argument_list|)
argument_list|)
expr_stmt|;
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|ciUri
argument_list|,
name|ENHANCED_BY
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|node
argument_list|,
name|STATUS
argument_list|,
name|STATUS_SCHEDULED
argument_list|)
argument_list|)
expr_stmt|;
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|node
argument_list|,
name|EXECUTION_PLAN
argument_list|,
name|executionPlan
argument_list|)
argument_list|)
expr_stmt|;
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|node
argument_list|,
name|IS_DEFAULT_CHAIN
argument_list|,
name|lf
operator|.
name|createTypedLiteral
argument_list|(
name|defaultChain
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
specifier|public
specifier|static
name|NonLiteral
name|createEngineExecution
parameter_list|(
name|MGraph
name|graph
parameter_list|,
name|NonLiteral
name|chainExecution
parameter_list|,
name|NonLiteral
name|executionNode
parameter_list|)
block|{
name|NonLiteral
name|node
init|=
operator|new
name|BNode
argument_list|()
decl_stmt|;
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|node
argument_list|,
name|RDF_TYPE
argument_list|,
name|EXECUTION
argument_list|)
argument_list|)
expr_stmt|;
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|node
argument_list|,
name|RDF_TYPE
argument_list|,
name|ENGINE_EXECUTION
argument_list|)
argument_list|)
expr_stmt|;
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|node
argument_list|,
name|EXECUTION_PART
argument_list|,
name|chainExecution
argument_list|)
argument_list|)
expr_stmt|;
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|node
argument_list|,
name|EXECUTION_NODE
argument_list|,
name|executionNode
argument_list|)
argument_list|)
expr_stmt|;
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|node
argument_list|,
name|STATUS
argument_list|,
name|STATUS_SCHEDULED
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
comment|/**      * Sets the state of the ExecutionNode to completed      * @param graph      * @param execution      * @param message An optional message      */
specifier|public
specifier|static
name|void
name|setExecutionCompleted
parameter_list|(
name|MGraph
name|graph
parameter_list|,
name|NonLiteral
name|execution
parameter_list|,
name|String
name|message
parameter_list|)
block|{
name|Literal
name|dateTime
init|=
name|lf
operator|.
name|createTypedLiteral
argument_list|(
operator|new
name|Date
argument_list|()
argument_list|)
decl_stmt|;
name|setStatus
argument_list|(
name|graph
argument_list|,
name|execution
argument_list|,
name|STATUS_COMPLETED
argument_list|)
expr_stmt|;
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|execution
argument_list|,
name|COMPLETED
argument_list|,
name|dateTime
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
operator|!=
literal|null
condition|)
block|{
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|execution
argument_list|,
name|STATUS_MESSAGE
argument_list|,
operator|new
name|PlainLiteralImpl
argument_list|(
name|message
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Sets the state of the ExecutionNode to scheduled and deletes any started,      * completed times      * @param graph the graph holding the execution metadata      * @param execution the execution node      */
specifier|public
specifier|static
name|void
name|setExecutionScheduled
parameter_list|(
name|MGraph
name|graph
parameter_list|,
name|NonLiteral
name|execution
parameter_list|)
block|{
name|setStatus
argument_list|(
name|graph
argument_list|,
name|execution
argument_list|,
name|STATUS_SCHEDULED
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|it
init|=
name|graph
operator|.
name|filter
argument_list|(
name|execution
argument_list|,
name|STARTED
argument_list|,
literal|null
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
name|it
operator|=
name|graph
operator|.
name|filter
argument_list|(
name|execution
argument_list|,
name|COMPLETED
argument_list|,
literal|null
argument_list|)
expr_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Set the parsed execution node to failed.      * @param graph      * @param execution      * @param message An message describing why the execution failed      */
specifier|public
specifier|static
name|void
name|setExecutionFaild
parameter_list|(
name|MGraph
name|graph
parameter_list|,
name|NonLiteral
name|execution
parameter_list|,
name|String
name|message
parameter_list|)
block|{
name|Literal
name|dateTime
init|=
name|lf
operator|.
name|createTypedLiteral
argument_list|(
operator|new
name|Date
argument_list|()
argument_list|)
decl_stmt|;
name|setStatus
argument_list|(
name|graph
argument_list|,
name|execution
argument_list|,
name|STATUS_FAILED
argument_list|)
expr_stmt|;
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|execution
argument_list|,
name|COMPLETED
argument_list|,
name|dateTime
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
operator|!=
literal|null
condition|)
block|{
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|execution
argument_list|,
name|STATUS_MESSAGE
argument_list|,
operator|new
name|PlainLiteralImpl
argument_list|(
name|message
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"For faild Execution a STATUS message is required!"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Sets an execution node to skipped. This sets both the start and the completed      * time to the current time.      * @param graph      * @param execution      * @param message An optional message why this execution was skipped      */
specifier|public
specifier|static
name|void
name|setExecutionSkipped
parameter_list|(
name|MGraph
name|graph
parameter_list|,
name|NonLiteral
name|execution
parameter_list|,
name|String
name|message
parameter_list|)
block|{
name|Literal
name|dateTime
init|=
name|lf
operator|.
name|createTypedLiteral
argument_list|(
operator|new
name|Date
argument_list|()
argument_list|)
decl_stmt|;
name|setStatus
argument_list|(
name|graph
argument_list|,
name|execution
argument_list|,
name|STATUS_SKIPPED
argument_list|)
expr_stmt|;
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|execution
argument_list|,
name|STARTED
argument_list|,
name|dateTime
argument_list|)
argument_list|)
expr_stmt|;
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|execution
argument_list|,
name|COMPLETED
argument_list|,
name|dateTime
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
operator|!=
literal|null
condition|)
block|{
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|execution
argument_list|,
name|STATUS_MESSAGE
argument_list|,
operator|new
name|PlainLiteralImpl
argument_list|(
name|message
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Sets an execution node to in-progress. This also sets the start time to      * the current time      * @param graph      * @param execution      */
specifier|public
specifier|static
name|void
name|setExecutionInProgress
parameter_list|(
name|MGraph
name|graph
parameter_list|,
name|NonLiteral
name|execution
parameter_list|)
block|{
name|Literal
name|dateTime
init|=
name|lf
operator|.
name|createTypedLiteral
argument_list|(
operator|new
name|Date
argument_list|()
argument_list|)
decl_stmt|;
name|setStatus
argument_list|(
name|graph
argument_list|,
name|execution
argument_list|,
name|STATUS_IN_PROGRESS
argument_list|)
expr_stmt|;
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|execution
argument_list|,
name|STARTED
argument_list|,
name|dateTime
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Removes the current value of {@link ExecutionMetadata#STATUS} and set it      * to the parsed value.      * @param graph      * @param execution      */
specifier|private
specifier|static
name|void
name|setStatus
parameter_list|(
name|MGraph
name|graph
parameter_list|,
name|NonLiteral
name|execution
parameter_list|,
name|UriRef
name|status
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|it
init|=
name|graph
operator|.
name|filter
argument_list|(
name|execution
argument_list|,
name|STATUS
argument_list|,
literal|null
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
literal|null
condition|)
block|{
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|execution
argument_list|,
name|STATUS
argument_list|,
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Getter for the {@link ExecutionMetadata#CHAIN_EXECUTION} node of an       * graph containing ChainExecution metadata for the parsed {@link Chain#getName()}.      * If both the execution metadata and the execution plan are in the same      * graph one need to parse the same triple collection instance for both      * the execution metadata and the execution plan.      * @param em the triple collection containing execution metadata      * @param ep the triple collection containing the execution plan      * @param chainName the name of the executed chain      * @return the node or<code>null</code> if not found.      */
specifier|public
specifier|static
specifier|final
name|NonLiteral
name|getChainExecutionForChainName
parameter_list|(
name|TripleCollection
name|em
parameter_list|,
name|TripleCollection
name|ep
parameter_list|,
name|String
name|chainName
parameter_list|)
block|{
specifier|final
name|NonLiteral
name|executionPlanNode
init|=
name|ExecutionPlanHelper
operator|.
name|getExecutionPlan
argument_list|(
name|ep
argument_list|,
name|chainName
argument_list|)
decl_stmt|;
if|if
condition|(
name|executionPlanNode
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|getChainExecutionForExecutionPlan
argument_list|(
name|em
argument_list|,
name|executionPlanNode
argument_list|)
return|;
block|}
block|}
comment|/**      * Getter for the {@link ExecutionMetadata#CHAIN_EXECUTION} node of an       * graph containing ChainExecution metadata for the parsed       * {@link ExecutionPlan#EXECUTION_PLAN} node      * @param graph the graph containing the Execution Metadata      * @param executionPlanNode the {@link ExecutionPlan#EXECUTION_PLAN} node      * @return the {@link ExecutionMetadata#CHAIN_EXECUTION} node      */
specifier|public
specifier|static
name|NonLiteral
name|getChainExecutionForExecutionPlan
parameter_list|(
name|TripleCollection
name|graph
parameter_list|,
specifier|final
name|NonLiteral
name|executionPlanNode
parameter_list|)
block|{
if|if
condition|(
name|graph
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed graph with the execution metadata MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|executionPlanNode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed execution plan node MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|it
init|=
name|graph
operator|.
name|filter
argument_list|(
literal|null
argument_list|,
name|ExecutionMetadata
operator|.
name|EXECUTION_PLAN
argument_list|,
name|executionPlanNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
return|return
name|it
operator|.
name|next
argument_list|()
operator|.
name|getSubject
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Getter/Initialiser for the execution metadata content part of the parsed      * content item. This part is expected to be registered with the URI      * {@link ExecutionMetadata#CHAIN_EXECUTION}. If it does not already exist      * this method creates an empty graph and register it with the parsed      * content item otherwise it returns the existing part registered under that      * URI.<p>      * Typically users will also want to use       * {@link #initExecutionMetadata(MGraph, TripleCollection, UriRef, String, boolean)}      * to initialise the state based on the grpah returned by this method.      * NOTES:<ul>      *<li> If a content part is registered under the URI       * {@link ExecutionMetadata#CHAIN_EXECUTION} that is not of type      * {@link MGraph} this method will replace it with an empty {@link MGraph}.      *<li> This method acquires a write lock on the content item while checking      * for the content part.      *</ul>      * @param contentItem the contentItem      * @return the {@link MGraph} with the execution metadata as registered as      * content part with the URI {@link ExecutionMetadata#CHAIN_EXECUTION} to       * the {@link ContentItem}      * @throws IllegalArgumentException if the parsed content itme is<code>null</code>.      */
specifier|public
specifier|static
name|MGraph
name|initExecutionMetadataContentPart
parameter_list|(
name|ContentItem
name|contentItem
parameter_list|)
block|{
if|if
condition|(
name|contentItem
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed ContentItme MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|MGraph
name|executionMetadata
decl_stmt|;
name|contentItem
operator|.
name|getLock
argument_list|()
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
try|try
block|{
name|executionMetadata
operator|=
name|contentItem
operator|.
name|getPart
argument_list|(
name|CHAIN_EXECUTION
argument_list|,
name|MGraph
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchPartException
name|e
parameter_list|)
block|{
name|executionMetadata
operator|=
operator|new
name|SimpleMGraph
argument_list|()
expr_stmt|;
name|contentItem
operator|.
name|addPart
argument_list|(
name|CHAIN_EXECUTION
argument_list|,
name|executionMetadata
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|contentItem
operator|.
name|getLock
argument_list|()
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|executionMetadata
return|;
block|}
comment|/**      * Initialises execution metadata based on the parsed parameter. If the parsed      * graph with the execution metadata is empty it will initialise the metadata      * based on the execution plan. If there are already metadata in the graph      * it will initialise the returned map based on the existing data.<p>      * This method can be therefore used to both:<ul>      *<li> create a new set of execution metadata: as needed before a      * {@link EnhancementJobManager} implementation can start processing a       * {@link ContentItem} by using an {@link Chain}       *<li> read existing executionMetadata allowing to let an       * {@link EnhancementJobManager} to continue from an uncompleted enhancement.      *</ul><p>      * If both the execution metadata and the execution plan are stored within the      * same graph users need to base this graph as both the first and second      * parameter      * @param em The graph containing the execution metadata. MUST NOT be NULL      * @param ep The graph containing the execution plan. MUST NOT be NULL      * @param ciUri the URI of the content item. MUST NOT be NULL      * @param chainName the name of the chain to execute. May be NULL if      * initialising from existing metadata. MUST NOT be NULL if initialising from      * empty execution metadata      * @param isDefaultChain if the chain to execute is the default chain. Will be      * ignored if initialising from existing execution metadata. MUST NOT be NULL      * if initialising from empty execution metadata      * @return A map containing all em:Execution nodes as key and the according      * ep:ExecutionNode of the execution plan as values.      * @throws IllegalArgumentException if any of the requirements stated in the      * documentation for the parameters is not fulfilled.      */
specifier|public
specifier|static
specifier|final
name|Map
argument_list|<
name|NonLiteral
argument_list|,
name|NonLiteral
argument_list|>
name|initExecutionMetadata
parameter_list|(
name|MGraph
name|em
parameter_list|,
name|TripleCollection
name|ep
parameter_list|,
name|UriRef
name|ciUri
parameter_list|,
name|String
name|chainName
parameter_list|,
name|Boolean
name|isDefaultChain
parameter_list|)
block|{
if|if
condition|(
name|em
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed ExecutionMetadata graph MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|ciUri
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed URI of the contentItem MUST NOT be NULL!"
argument_list|)
throw|;
block|}
comment|//1. check for the ChainExecution node for the parsed content item
specifier|final
name|NonLiteral
name|executionPlanNode
decl_stmt|;
name|NonLiteral
name|chainExecutionNode
init|=
name|getChainExecutionForExecutionPlan
argument_list|(
name|em
argument_list|,
name|ciUri
argument_list|)
decl_stmt|;
if|if
condition|(
name|chainExecutionNode
operator|!=
literal|null
condition|)
block|{
comment|//init from existing executin metadata
comment|// -> chainName and isDefaultChain may be null
comment|//init from existing
name|executionPlanNode
operator|=
name|getExecutionPlanNode
argument_list|(
name|em
argument_list|,
name|chainExecutionNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|executionPlanNode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The em:ChainExecution '"
operator|+
name|chainExecutionNode
operator|+
literal|"'that enhances ContentItem '"
operator|+
name|ciUri
operator|+
literal|"' does not define a link to an valid ExecutionPlan"
argument_list|)
throw|;
block|}
name|isDefaultChain
operator|=
name|get
argument_list|(
name|em
argument_list|,
name|chainExecutionNode
argument_list|,
name|IS_DEFAULT_CHAIN
argument_list|,
name|Boolean
operator|.
name|class
argument_list|,
name|lf
argument_list|)
expr_stmt|;
name|String
name|extractedChainName
init|=
name|EnhancementEngineHelper
operator|.
name|getString
argument_list|(
name|ep
argument_list|,
name|executionPlanNode
argument_list|,
name|CHAIN
argument_list|)
decl_stmt|;
if|if
condition|(
name|extractedChainName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The em:ChainExecution '"
operator|+
name|chainExecutionNode
operator|+
literal|"'that enhances ContentItem '"
operator|+
name|ciUri
operator|+
literal|"' links to the ep:ExecutionPlan '"
operator|+
name|executionPlanNode
operator|+
literal|"' that does not define a ChainName (property: "
operator|+
name|CHAIN
operator|+
literal|")!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|chainName
operator|==
literal|null
condition|)
block|{
name|chainName
operator|=
name|extractedChainName
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|chainName
operator|.
name|equals
argument_list|(
name|extractedChainName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The em:ChainExecution '"
operator|+
name|chainExecutionNode
operator|+
literal|"'that enhances ContentItem '"
operator|+
name|ciUri
operator|+
literal|"' links to the ep:ExecutionPlan '"
operator|+
name|executionPlanNode
operator|+
literal|"' with the chain name '"
operator|+
name|extractedChainName
operator|+
literal|"' but '"
operator|+
name|chainName
operator|+
literal|"' was parsed "
operator|+
literal|"as expected chain name!"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|//create a new one
comment|// -> in that case chainName and isDefaultChain are required
name|executionPlanNode
operator|=
name|ExecutionPlanHelper
operator|.
name|getExecutionPlan
argument_list|(
name|ep
argument_list|,
name|chainName
argument_list|)
expr_stmt|;
if|if
condition|(
name|executionPlanNode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed ExectuonPlan graph does not contain an"
operator|+
literal|"ExecutionPlan for a Chain with the name '"
operator|+
name|chainName
operator|+
literal|"'!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|isDefaultChain
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The isDefaultChain parameter MUST NOT"
operator|+
literal|"be NULL if initialising from empty ExecutionMetadata!"
argument_list|)
throw|;
block|}
name|chainExecutionNode
operator|=
name|createChainExecutionNode
argument_list|(
name|em
argument_list|,
name|executionPlanNode
argument_list|,
name|ciUri
argument_list|,
name|isDefaultChain
argument_list|)
expr_stmt|;
block|}
comment|//2. check/init the EngineExecution nodes for for the ExecutionNodes of the ExecutionPlan
name|Map
argument_list|<
name|NonLiteral
argument_list|,
name|NonLiteral
argument_list|>
name|executionsMap
init|=
operator|new
name|HashMap
argument_list|<
name|NonLiteral
argument_list|,
name|NonLiteral
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|NonLiteral
argument_list|>
name|executionNodes
init|=
name|getExecutionNodes
argument_list|(
name|ep
argument_list|,
name|executionPlanNode
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|NonLiteral
argument_list|>
name|executions
init|=
name|getExecutions
argument_list|(
name|em
argument_list|,
name|chainExecutionNode
argument_list|)
decl_stmt|;
for|for
control|(
name|NonLiteral
name|en
range|:
name|executionNodes
control|)
block|{
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|it
init|=
name|em
operator|.
name|filter
argument_list|(
literal|null
argument_list|,
name|EXECUTION_NODE
argument_list|,
name|en
argument_list|)
decl_stmt|;
name|NonLiteral
name|execution
decl_stmt|;
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|execution
operator|=
name|it
operator|.
name|next
argument_list|()
operator|.
name|getSubject
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|executions
operator|.
name|contains
argument_list|(
name|execution
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Execution '"
operator|+
name|execution
operator|+
literal|"' for ExecutionNode '"
operator|+
name|en
operator|+
literal|"' (engine: '"
operator|+
name|getEngine
argument_list|(
name|ep
argument_list|,
name|en
argument_list|)
operator|+
literal|"') is not part of ChainExecution '"
operator|+
name|chainExecutionNode
operator|+
literal|"' (chain: '"
operator|+
name|chainName
operator|+
literal|")!"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|execution
operator|=
name|createEngineExecution
argument_list|(
name|em
argument_list|,
name|chainExecutionNode
argument_list|,
name|en
argument_list|)
expr_stmt|;
name|executions
operator|.
name|add
argument_list|(
name|execution
argument_list|)
expr_stmt|;
block|}
name|executionsMap
operator|.
name|put
argument_list|(
name|execution
argument_list|,
name|en
argument_list|)
expr_stmt|;
block|}
comment|//3. check that there are no executions that are not part of the
comment|//   parsed ExecutionPlan
for|for
control|(
name|NonLiteral
name|e
range|:
name|executions
control|)
block|{
if|if
condition|(
operator|!
name|executionsMap
operator|.
name|containsKey
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|NonLiteral
name|en
init|=
name|getExecutionNode
argument_list|(
name|em
argument_list|,
name|e
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"ChainExecution '"
operator|+
name|chainExecutionNode
operator|+
literal|"' (chain: '"
operator|+
name|chainName
operator|+
literal|") contains"
operator|+
literal|"Execution '"
operator|+
name|e
operator|+
literal|"' for ExecutionNode '"
operator|+
name|en
operator|+
literal|"' (engine: '"
operator|+
name|ExecutionPlanHelper
operator|.
name|getEngine
argument_list|(
name|ep
argument_list|,
name|en
argument_list|)
operator|+
literal|"') that is not part of the pased ExecutionPlan '"
operator|+
name|executionPlanNode
operator|+
literal|"'(chain; '"
operator|+
name|chainName
operator|+
literal|"')!"
argument_list|)
throw|;
block|}
block|}
return|return
name|executionsMap
return|;
block|}
comment|/**      * Getter for the ep:ExecutionNode for a given em:Execution.      * @param graph the graph containing the execution metadata      * @param execution the em:Execution node      * @return the ep:ExecutionNode node      */
specifier|public
specifier|static
name|NonLiteral
name|getExecutionNode
parameter_list|(
name|TripleCollection
name|graph
parameter_list|,
name|NonLiteral
name|execution
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|it
init|=
name|graph
operator|.
name|filter
argument_list|(
name|execution
argument_list|,
name|EXECUTION_NODE
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Triple
name|t
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|Resource
name|o
init|=
name|t
operator|.
name|getObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|o
operator|instanceof
name|NonLiteral
condition|)
block|{
return|return
operator|(
name|NonLiteral
operator|)
name|o
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Value of property "
operator|+
name|EXECUTION_NODE
operator|+
literal|"MUST BE of type NonLiteral (triple: '"
operator|+
name|t
operator|+
literal|"')!"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|//maybe an em:ChainExecution
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Get {@link ExecutionMetadata#EXECUTION} nodes that are       * {@link ExecutionMetadata#EXECUTION_PART} of the parsed       * {@link ExecutionMetadata#CHAIN_EXECUTION} node      * @param em the graph with the execution metadata      * @param chainExecutionNode the chain execution node      * @return the Set with all execution part of the chain execution      */
specifier|public
specifier|static
name|Set
argument_list|<
name|NonLiteral
argument_list|>
name|getExecutions
parameter_list|(
name|TripleCollection
name|em
parameter_list|,
name|NonLiteral
name|chainExecutionNode
parameter_list|)
block|{
if|if
condition|(
name|em
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed graph with the Execution metadata MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|chainExecutionNode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed chain execution plan node MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|Set
argument_list|<
name|NonLiteral
argument_list|>
name|executionNodes
init|=
operator|new
name|HashSet
argument_list|<
name|NonLiteral
argument_list|>
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|it
init|=
name|em
operator|.
name|filter
argument_list|(
literal|null
argument_list|,
name|ExecutionMetadata
operator|.
name|EXECUTION_PART
argument_list|,
name|chainExecutionNode
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|executionNodes
operator|.
name|add
argument_list|(
name|it
operator|.
name|next
argument_list|()
operator|.
name|getSubject
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|executionNodes
return|;
block|}
comment|/**      * Getter for the ep:ExecutionPlan node for the parsed em:ChainExecution node      * @param em the execution metadata      * @param chainExecutionNode the chain execution node      * @return the execution plan node      */
specifier|public
specifier|static
name|NonLiteral
name|getExecutionPlanNode
parameter_list|(
name|TripleCollection
name|em
parameter_list|,
name|NonLiteral
name|chainExecutionNode
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|it
init|=
name|em
operator|.
name|filter
argument_list|(
name|chainExecutionNode
argument_list|,
name|EXECUTION_PLAN
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Triple
name|t
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|Resource
name|r
init|=
name|t
operator|.
name|getObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|r
operator|instanceof
name|NonLiteral
condition|)
block|{
return|return
operator|(
name|NonLiteral
operator|)
name|r
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Value of the property "
operator|+
name|EXECUTION_PLAN
operator|+
literal|" MUST BE a NonLiteral (triple: '"
operator|+
name|t
operator|+
literal|"')!"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Getter for the ChainExecution used to enhance the content item      * @param em the graph with the execution metadata      * @param ciUri the ID of the content item      * @return the node that {@link ExecutionMetadata#ENHANCES} the {@link ContentItem}      */
specifier|public
specifier|static
name|NonLiteral
name|getChainExecution
parameter_list|(
name|TripleCollection
name|em
parameter_list|,
name|UriRef
name|ciUri
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|it
init|=
name|em
operator|.
name|filter
argument_list|(
literal|null
argument_list|,
name|ENHANCES
argument_list|,
name|ciUri
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
return|return
name|it
operator|.
name|next
argument_list|()
operator|.
name|getSubject
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Tests if the {@link ExecutionMetadata#STATUS status} if an       * {@link ExecutionMetadata#EXECUTION execution} is      * {@link ExecutionMetadata#STATUS_FAILED failed}.      * @param graph the graph with the execution metadata      * @param execution the execution node      * @return<code>true</code> if the status is faild. Otherwise<code>false</code>.      */
specifier|public
specifier|static
name|boolean
name|isExecutionFailed
parameter_list|(
name|TripleCollection
name|graph
parameter_list|,
name|NonLiteral
name|execution
parameter_list|)
block|{
return|return
name|STATUS_FAILED
operator|.
name|equals
argument_list|(
name|getReference
argument_list|(
name|graph
argument_list|,
name|execution
argument_list|,
name|STATUS
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Tests if the {@link ExecutionMetadata#STATUS status} if an       * {@link ExecutionMetadata#EXECUTION execution} has already finished. This      * includes the states {@link ExecutionMetadata#STATUS_COMPLETED completed}       * and {@link ExecutionMetadata#STATUS_FAILED failed}.      * @param graph the graph with the execution metadata      * @param execution the execution node      * @return<code>true</code> if the execution has already finished      */
specifier|public
specifier|static
name|boolean
name|isExecutionFinished
parameter_list|(
name|TripleCollection
name|graph
parameter_list|,
name|NonLiteral
name|execution
parameter_list|)
block|{
name|UriRef
name|status
init|=
name|getReference
argument_list|(
name|graph
argument_list|,
name|execution
argument_list|,
name|STATUS
argument_list|)
decl_stmt|;
return|return
name|STATUS_FAILED
operator|.
name|equals
argument_list|(
name|status
argument_list|)
operator|||
name|STATUS_COMPLETED
operator|.
name|equals
argument_list|(
name|status
argument_list|)
return|;
block|}
comment|/**      * Getter for the started dateTime of an 'em:Execution'      * @param graph the graph      * @param execution the execution instance      * @return the time or<code>null</code> if not present      */
specifier|public
specifier|static
name|Date
name|getStarted
parameter_list|(
name|TripleCollection
name|graph
parameter_list|,
name|NonLiteral
name|execution
parameter_list|)
block|{
return|return
name|get
argument_list|(
name|graph
argument_list|,
name|execution
argument_list|,
name|ExecutionMetadata
operator|.
name|STARTED
argument_list|,
name|Date
operator|.
name|class
argument_list|,
name|lf
argument_list|)
return|;
block|}
comment|/**      * Getter for the completed dateTime of an 'em:Execution'      * @param graph the graph      * @param execution the execution instance      * @return the time or<code>null</code> if not present      */
specifier|public
specifier|static
name|Date
name|getCompleted
parameter_list|(
name|TripleCollection
name|graph
parameter_list|,
name|NonLiteral
name|execution
parameter_list|)
block|{
return|return
name|get
argument_list|(
name|graph
argument_list|,
name|execution
argument_list|,
name|ExecutionMetadata
operator|.
name|COMPLETED
argument_list|,
name|Date
operator|.
name|class
argument_list|,
name|lf
argument_list|)
return|;
block|}
block|}
end_class

end_unit

