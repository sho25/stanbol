begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|utils
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|ENHANCER_CONFIDENCE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|RDF_TYPE
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStreamWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Writer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Language
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|LiteralFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|MGraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|UriRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|impl
operator|.
name|PlainLiteralImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|impl
operator|.
name|TripleImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|NlpAnnotations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|model
operator|.
name|AnalysedText
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|model
operator|.
name|Chunk
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|model
operator|.
name|Span
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|model
operator|.
name|Span
operator|.
name|SpanTypeEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|model
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|model
operator|.
name|annotation
operator|.
name|Annotated
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|model
operator|.
name|annotation
operator|.
name|Annotation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|model
operator|.
name|annotation
operator|.
name|Value
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|nif
operator|.
name|SsoOntology
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|nif
operator|.
name|StringOntology
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|phrase
operator|.
name|PhraseTag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|pos
operator|.
name|LexicalCategory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|pos
operator|.
name|Pos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|pos
operator|.
name|PosTag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|ContentItemHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
import|;
end_import

begin_class
specifier|public
specifier|final
class|class
name|NIFHelper
block|{
specifier|private
specifier|static
specifier|final
name|LiteralFactory
name|lf
init|=
name|LiteralFactory
operator|.
name|getInstance
argument_list|()
decl_stmt|;
specifier|private
name|NIFHelper
parameter_list|()
block|{}
specifier|public
specifier|static
specifier|final
name|Map
argument_list|<
name|SpanTypeEnum
argument_list|,
name|UriRef
argument_list|>
name|SPAN_TYPE_TO_SSO_TYPE
decl_stmt|;
static|static
block|{
name|Map
argument_list|<
name|SpanTypeEnum
argument_list|,
name|UriRef
argument_list|>
name|mapping
init|=
operator|new
name|EnumMap
argument_list|<
name|SpanTypeEnum
argument_list|,
name|UriRef
argument_list|>
argument_list|(
name|SpanTypeEnum
operator|.
name|class
argument_list|)
decl_stmt|;
comment|//mapping.put(SpanTypeEnum.Text, null);
comment|//mapping.put(SpanTypeEnum.TextSection, null);
name|mapping
operator|.
name|put
argument_list|(
name|SpanTypeEnum
operator|.
name|Sentence
argument_list|,
name|SsoOntology
operator|.
name|Sentence
operator|.
name|getUri
argument_list|()
argument_list|)
expr_stmt|;
name|mapping
operator|.
name|put
argument_list|(
name|SpanTypeEnum
operator|.
name|Chunk
argument_list|,
name|SsoOntology
operator|.
name|Phrase
operator|.
name|getUri
argument_list|()
argument_list|)
expr_stmt|;
name|mapping
operator|.
name|put
argument_list|(
name|SpanTypeEnum
operator|.
name|Token
argument_list|,
name|SsoOntology
operator|.
name|Word
operator|.
name|getUri
argument_list|()
argument_list|)
expr_stmt|;
name|SPAN_TYPE_TO_SSO_TYPE
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|mapping
argument_list|)
expr_stmt|;
block|}
comment|/**      * Read-only map that maps from the {@link LexicalCategory} to the OLIA      * Concept representing the Phrase (e.g. {@link LexicalCategory#Noun} maps      * to "<code>http://purl.org/olia/olia.owl#NounPhrase</code>").      */
specifier|public
specifier|static
specifier|final
name|Map
argument_list|<
name|LexicalCategory
argument_list|,
name|UriRef
argument_list|>
name|LEXICAL_TYPE_TO_PHRASE_TYPE
decl_stmt|;
static|static
block|{
name|String
name|olia
init|=
literal|"http://purl.org/olia/olia.owl#"
decl_stmt|;
name|Map
argument_list|<
name|LexicalCategory
argument_list|,
name|UriRef
argument_list|>
name|mapping
init|=
operator|new
name|EnumMap
argument_list|<
name|LexicalCategory
argument_list|,
name|UriRef
argument_list|>
argument_list|(
name|LexicalCategory
operator|.
name|class
argument_list|)
decl_stmt|;
name|mapping
operator|.
name|put
argument_list|(
name|LexicalCategory
operator|.
name|Noun
argument_list|,
operator|new
name|UriRef
argument_list|(
name|olia
operator|+
literal|"NounPhrase"
argument_list|)
argument_list|)
expr_stmt|;
name|mapping
operator|.
name|put
argument_list|(
name|LexicalCategory
operator|.
name|Verb
argument_list|,
operator|new
name|UriRef
argument_list|(
name|olia
operator|+
literal|"VerbPhrase"
argument_list|)
argument_list|)
expr_stmt|;
name|mapping
operator|.
name|put
argument_list|(
name|LexicalCategory
operator|.
name|Adjective
argument_list|,
operator|new
name|UriRef
argument_list|(
name|olia
operator|+
literal|"AdjectivePhrase"
argument_list|)
argument_list|)
expr_stmt|;
name|mapping
operator|.
name|put
argument_list|(
name|LexicalCategory
operator|.
name|Adverb
argument_list|,
operator|new
name|UriRef
argument_list|(
name|olia
operator|+
literal|"AdverbPhrase"
argument_list|)
argument_list|)
expr_stmt|;
name|mapping
operator|.
name|put
argument_list|(
name|LexicalCategory
operator|.
name|Conjuction
argument_list|,
operator|new
name|UriRef
argument_list|(
name|olia
operator|+
literal|"ConjuctionPhrase"
argument_list|)
argument_list|)
expr_stmt|;
name|LEXICAL_TYPE_TO_PHRASE_TYPE
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|mapping
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a NIF2.0 Fragment URI using the parsed base URI and the start/end      * indexes.      * @param base the base URI      * @param start the start position. If<code>&lt; 0</code> than zero is added.      * @param end the end position or values&lt; 1 when open ended.      * @return the NIF 2.0 Fragment URI      * @throws IllegalArgumentException if<code>null</code> is parsed as base      * {@link UriRef} or the end position is&gt;=0 but&lt= the parsed start      * position.      */
specifier|public
specifier|static
specifier|final
name|UriRef
name|getNifFragmentURI
parameter_list|(
name|UriRef
name|base
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
if|if
condition|(
name|base
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Base URI MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|base
operator|.
name|getUnicodeString
argument_list|()
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"#char="
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|start
operator|>=
literal|0
condition|?
name|start
else|:
literal|0
argument_list|)
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|end
operator|<
name|start
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"End index '"
operator|+
name|end
operator|+
literal|"'< start '"
operator|+
name|start
operator|+
literal|"'!"
argument_list|)
throw|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|end
argument_list|)
expr_stmt|;
block|}
comment|//else open ended ...
return|return
operator|new
name|UriRef
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
specifier|public
specifier|static
specifier|final
name|UriRef
name|getNifOffsetURI
parameter_list|(
name|UriRef
name|base
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
if|if
condition|(
name|base
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Base URI MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|base
operator|.
name|getUnicodeString
argument_list|()
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"#offset_"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|start
operator|>=
literal|0
condition|?
name|start
else|:
literal|0
argument_list|)
operator|.
name|append
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|end
operator|<
name|start
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"End index '"
operator|+
name|end
operator|+
literal|"'< start '"
operator|+
name|start
operator|+
literal|"'!"
argument_list|)
throw|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|end
argument_list|)
expr_stmt|;
block|}
comment|//else open ended ...
return|return
operator|new
name|UriRef
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
specifier|public
specifier|static
specifier|final
name|int
name|NIF_HASH_CONTEXT_LENGTH
init|=
literal|10
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|NIF_HASH_MAX_STRING_LENGTH
init|=
literal|20
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Charset
name|UTF8
init|=
name|Charset
operator|.
name|forName
argument_list|(
literal|"UTF8"
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|UriRef
name|getNifHashURI
parameter_list|(
name|UriRef
name|base
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|String
name|text
parameter_list|)
block|{
if|if
condition|(
name|base
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Base URI MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|start
operator|=
name|start
operator|<
literal|0
condition|?
literal|0
else|:
name|start
expr_stmt|;
name|end
operator|=
name|end
operator|<
literal|0
condition|?
name|start
else|:
name|end
expr_stmt|;
if|if
condition|(
name|end
operator|<
name|start
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"End index '"
operator|+
name|end
operator|+
literal|"'< start '"
operator|+
name|start
operator|+
literal|"'!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|end
operator|>=
name|text
operator|.
name|length
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The End index '"
operator|+
name|end
operator|+
literal|"' exeeds the "
operator|+
literal|"length of the text '"
operator|+
name|text
operator|.
name|length
argument_list|()
operator|+
literal|"'!"
argument_list|)
throw|;
block|}
name|int
name|contextStart
init|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|start
operator|-
name|NIF_HASH_CONTEXT_LENGTH
argument_list|)
decl_stmt|;
name|int
name|contextEnd
init|=
name|Math
operator|.
name|min
argument_list|(
name|text
operator|.
name|length
argument_list|()
argument_list|,
name|end
operator|+
name|NIF_HASH_CONTEXT_LENGTH
argument_list|)
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|base
operator|.
name|getUnicodeString
argument_list|()
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"#hash_"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|NIF_HASH_CONTEXT_LENGTH
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|getContextDigest
argument_list|(
name|text
argument_list|,
name|contextStart
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|contextEnd
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|text
operator|.
name|substring
argument_list|(
name|start
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|end
argument_list|,
name|start
operator|+
name|NIF_HASH_MAX_STRING_LENGTH
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|UriRef
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Creates the UTF8 byte representation for the '{prefix}({selected}){suffix}'      * calculated based on the parsed parameters      * @param text the text      * @param contextStart the start index of the prefix      * @param start the start index of the selected text part      * @param end the end index of the selecte text part      * @param contextEnd the end index of the suffix      * @return the HASH string representation of the MD5 over       *<code>'{prefix}({selected}){suffix}'</code> (NOTE the brackets that are      *  added at the start/end of the selected text)      */
specifier|private
specifier|static
name|String
name|getContextDigest
parameter_list|(
name|String
name|text
parameter_list|,
name|int
name|contextStart
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|int
name|contextEnd
parameter_list|)
block|{
name|ByteArrayOutputStream
name|contextOs
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|Writer
name|contextWriter
init|=
operator|new
name|OutputStreamWriter
argument_list|(
name|contextOs
argument_list|,
name|UTF8
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|contextStart
operator|<
name|start
condition|)
block|{
name|contextWriter
operator|.
name|append
argument_list|(
name|text
argument_list|,
name|contextStart
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
name|contextWriter
operator|.
name|append
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|<
name|end
condition|)
block|{
name|contextWriter
operator|.
name|append
argument_list|(
name|text
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
name|contextWriter
operator|.
name|append
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|<
name|contextEnd
condition|)
block|{
name|contextWriter
operator|.
name|append
argument_list|(
name|text
argument_list|,
name|end
argument_list|,
name|contextEnd
argument_list|)
expr_stmt|;
block|}
name|contextWriter
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|ContentItemHelper
operator|.
name|streamDigest
argument_list|(
operator|new
name|ByteArrayInputStream
argument_list|(
name|contextOs
operator|.
name|toByteArray
argument_list|()
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|"MD5"
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|//NO IOExceptions in in-memory stream implementations
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|contextOs
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Writes basic information of the parsed span by using NIF 1.0 including the      * {@link SsoOntology} Sentence/Phrase/Word type based on       * the {@link Span#getType()}<p>      * As {@link AnalysedText} is based on the plain text version of the ContentItem      * this uses the {@link StringOntology#OffsetBasedString} notation.<p>      *<i>NOTE:</i> This DOES NOT write string relations, lemma, pos ... information      * that might be stored as {@link Annotation} with the parsed {@link Span}.      * @param graph the graph to add the triples      * @param base the base URI      * @param text the {@link AnalysedText}      * @param language the {@link Language} or<code>null</code> if not known      * @param span the {@link Span} to write.      * @return the {@link UriRef} representing the parsed {@link Span} in the      * graph      */
specifier|public
specifier|static
name|UriRef
name|writeSpan
parameter_list|(
name|MGraph
name|graph
parameter_list|,
name|UriRef
name|base
parameter_list|,
name|AnalysedText
name|text
parameter_list|,
name|Language
name|language
parameter_list|,
name|Span
name|span
parameter_list|)
block|{
name|UriRef
name|segment
init|=
name|getNifOffsetURI
argument_list|(
name|base
argument_list|,
name|span
operator|.
name|getStart
argument_list|()
argument_list|,
name|span
operator|.
name|getEnd
argument_list|()
argument_list|)
decl_stmt|;
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|segment
argument_list|,
name|RDF_TYPE
argument_list|,
name|StringOntology
operator|.
name|OffsetBasedString
operator|.
name|getUri
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|segment
argument_list|,
name|StringOntology
operator|.
name|anchorOf
operator|.
name|getUri
argument_list|()
argument_list|,
operator|new
name|PlainLiteralImpl
argument_list|(
name|span
operator|.
name|getSpan
argument_list|()
argument_list|,
name|language
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|segment
argument_list|,
name|StringOntology
operator|.
name|beginIndex
operator|.
name|getUri
argument_list|()
argument_list|,
name|lf
operator|.
name|createTypedLiteral
argument_list|(
name|span
operator|.
name|getStart
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|segment
argument_list|,
name|StringOntology
operator|.
name|endIndex
operator|.
name|getUri
argument_list|()
argument_list|,
name|lf
operator|.
name|createTypedLiteral
argument_list|(
name|span
operator|.
name|getEnd
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|span
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|Token
case|:
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|segment
argument_list|,
name|RDF_TYPE
argument_list|,
name|SsoOntology
operator|.
name|Word
operator|.
name|getUri
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Chunk
case|:
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|segment
argument_list|,
name|RDF_TYPE
argument_list|,
name|SsoOntology
operator|.
name|Phrase
operator|.
name|getUri
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Sentence
case|:
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|segment
argument_list|,
name|RDF_TYPE
argument_list|,
name|SsoOntology
operator|.
name|Sentence
operator|.
name|getUri
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|//            case Text:
comment|//                graph.add(new TripleImpl(segment, RDF_TYPE, StringOntology.Document.getUri()));
comment|//no default:
block|}
return|return
name|segment
return|;
block|}
comment|/**      * Writes the {@link NlpAnnotations#POS_ANNOTATION} as NIF 1.0 to the parsed      * RDF graph by using the parsed segmentUri as subject      * @param graph the graph      * @param annotated the annotated element (e.g. a {@link Token})      * @param segmentUri the URI of the resource representing the parsed       * annotated element in the graph      */
specifier|public
specifier|static
name|void
name|writePos
parameter_list|(
name|MGraph
name|graph
parameter_list|,
name|Annotated
name|annotated
parameter_list|,
name|UriRef
name|segmentUri
parameter_list|)
block|{
name|Value
argument_list|<
name|PosTag
argument_list|>
name|posTag
init|=
name|annotated
operator|.
name|getAnnotation
argument_list|(
name|NlpAnnotations
operator|.
name|POS_ANNOTATION
argument_list|)
decl_stmt|;
if|if
condition|(
name|posTag
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|posTag
operator|.
name|value
argument_list|()
operator|.
name|isMapped
argument_list|()
condition|)
block|{
for|for
control|(
name|Pos
name|pos
range|:
name|posTag
operator|.
name|value
argument_list|()
operator|.
name|getPos
argument_list|()
control|)
block|{
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|segmentUri
argument_list|,
name|SsoOntology
operator|.
name|oliaLink
operator|.
name|getUri
argument_list|()
argument_list|,
name|pos
operator|.
name|getUri
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|LexicalCategory
name|cat
range|:
name|posTag
operator|.
name|value
argument_list|()
operator|.
name|getCategories
argument_list|()
control|)
block|{
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|segmentUri
argument_list|,
name|SsoOntology
operator|.
name|oliaLink
operator|.
name|getUri
argument_list|()
argument_list|,
name|cat
operator|.
name|getUri
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|segmentUri
argument_list|,
name|SsoOntology
operator|.
name|posTag
operator|.
name|getUri
argument_list|()
argument_list|,
name|lf
operator|.
name|createTypedLiteral
argument_list|(
name|posTag
operator|.
name|value
argument_list|()
operator|.
name|getTag
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|segmentUri
argument_list|,
name|ENHANCER_CONFIDENCE
argument_list|,
name|lf
operator|.
name|createTypedLiteral
argument_list|(
name|posTag
operator|.
name|probability
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Writes a {@link NlpAnnotations#PHRASE_ANNOTATION} as NIF 1.0 to the      * parsed RDF graph by using the segmentUri as subject      * @param graph the graph      * @param annotated the annotated element (e.g. a {@link Chunk})      * @param segmentUri the URI of the resource representing the parsed       * annotated element in the graph      */
specifier|public
specifier|static
name|void
name|writePhrase
parameter_list|(
name|MGraph
name|graph
parameter_list|,
name|Annotated
name|annotated
parameter_list|,
name|UriRef
name|segmentUri
parameter_list|)
block|{
name|Value
argument_list|<
name|PhraseTag
argument_list|>
name|phraseTag
init|=
name|annotated
operator|.
name|getAnnotation
argument_list|(
name|NlpAnnotations
operator|.
name|PHRASE_ANNOTATION
argument_list|)
decl_stmt|;
if|if
condition|(
name|phraseTag
operator|!=
literal|null
condition|)
block|{
name|UriRef
name|phraseTypeUri
init|=
name|LEXICAL_TYPE_TO_PHRASE_TYPE
operator|.
name|get
argument_list|(
name|phraseTag
operator|.
name|value
argument_list|()
operator|.
name|getCategory
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|phraseTypeUri
operator|!=
literal|null
condition|)
block|{
comment|//add the oliaLink for the Phrase
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|segmentUri
argument_list|,
name|SsoOntology
operator|.
name|oliaLink
operator|.
name|getUri
argument_list|()
argument_list|,
name|phraseTypeUri
argument_list|)
argument_list|)
expr_stmt|;
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|segmentUri
argument_list|,
name|ENHANCER_CONFIDENCE
argument_list|,
name|lf
operator|.
name|createTypedLiteral
argument_list|(
name|phraseTag
operator|.
name|probability
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

