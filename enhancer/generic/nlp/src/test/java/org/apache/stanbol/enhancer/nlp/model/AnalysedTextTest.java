begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|model
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|commons
operator|.
name|rdf
operator|.
name|IRI
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|collections
operator|.
name|CollectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|contentitem
operator|.
name|inmemory
operator|.
name|InMemoryContentItemFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|model
operator|.
name|annotation
operator|.
name|Annotation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|model
operator|.
name|annotation
operator|.
name|Value
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|utils
operator|.
name|NIFHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|utils
operator|.
name|NlpEngineHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|Blob
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|ContentItem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|ContentItemFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|ContentItemHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|impl
operator|.
name|StringSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|BeforeClass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * The Class added as ContentPart to the contentItem  * @author westei  *  */
end_comment

begin_class
specifier|public
class|class
name|AnalysedTextTest
block|{
specifier|private
specifier|static
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|AnalysedTextTest
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|text
init|=
literal|"The Stanbol enhancer can detect famous "
operator|+
literal|"cities such as Paris and people such as Bob Marley. With "
operator|+
literal|"disambiguation it would even be able to detect the Comedian "
operator|+
literal|"Bob Marley trafeling to Paris in Texas."
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Annotation
argument_list|<
name|Number
argument_list|>
name|testAnnotation
init|=
operator|new
name|Annotation
argument_list|<
name|Number
argument_list|>
argument_list|(
literal|"test"
argument_list|,
name|Number
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/* -----      * Test data creates within the BeforeClass      * -----      */
comment|/**      * AnalysedText instance filled in {@link #setup()} with test dats      */
specifier|private
specifier|static
name|AnalysedText
name|analysedTextWithData
decl_stmt|;
specifier|private
specifier|static
name|LinkedHashMap
argument_list|<
name|Sentence
argument_list|,
name|String
argument_list|>
name|expectedSentences
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Sentence
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|static
name|LinkedHashMap
argument_list|<
name|Chunk
argument_list|,
name|String
argument_list|>
name|expectedChunks
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Chunk
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|static
name|LinkedHashMap
argument_list|<
name|Token
argument_list|,
name|String
argument_list|>
name|expectedTokens
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Token
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|/* -----      * Test data creates before every single test      * -----      */
comment|/**      * Empty AnalysedText instance created before each test      */
specifier|private
specifier|static
name|AnalysedText
name|at
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|ContentItemFactory
name|ciFactory
init|=
name|InMemoryContentItemFactory
operator|.
name|getInstance
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|AnalysedTextFactory
name|atFactory
init|=
name|AnalysedTextFactory
operator|.
name|getDefaultInstance
argument_list|()
decl_stmt|;
specifier|private
specifier|static
name|ContentItem
name|ci
decl_stmt|;
annotation|@
name|BeforeClass
specifier|public
specifier|static
specifier|final
name|void
name|setup
parameter_list|()
throws|throws
name|IOException
block|{
name|analysedTextWithData
operator|=
name|createAnalysedText
argument_list|()
expr_stmt|;
name|int
name|sentence
init|=
name|text
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|)
operator|+
literal|1
decl_stmt|;
name|Sentence
name|sent1
init|=
name|analysedTextWithData
operator|.
name|addSentence
argument_list|(
literal|0
argument_list|,
name|sentence
argument_list|)
decl_stmt|;
name|expectedSentences
operator|.
name|put
argument_list|(
name|sent1
argument_list|,
literal|"The Stanbol enhancer can detect famous "
operator|+
literal|"cities such as Paris and people such as Bob Marley."
argument_list|)
expr_stmt|;
name|Sentence
name|sent2
init|=
name|analysedTextWithData
operator|.
name|addSentence
argument_list|(
name|sentence
operator|+
literal|1
argument_list|,
name|text
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|expectedSentences
operator|.
name|put
argument_list|(
name|sent2
argument_list|,
literal|"With disambiguation it would even be able "
operator|+
literal|"to detect the Comedian Bob Marley trafeling to Paris in Texas."
argument_list|)
expr_stmt|;
name|Token
name|the
init|=
name|sent1
operator|.
name|addToken
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|expectedTokens
operator|.
name|put
argument_list|(
name|the
argument_list|,
literal|"The"
argument_list|)
expr_stmt|;
name|Token
name|stanbol
init|=
name|sent1
operator|.
name|addToken
argument_list|(
literal|4
argument_list|,
literal|11
argument_list|)
decl_stmt|;
name|expectedTokens
operator|.
name|put
argument_list|(
name|stanbol
argument_list|,
literal|"Stanbol"
argument_list|)
expr_stmt|;
comment|//use index to create Tokens
name|int
name|enhancerStart
init|=
name|sent1
operator|.
name|getSpan
argument_list|()
operator|.
name|indexOf
argument_list|(
literal|"enhancer"
argument_list|)
decl_stmt|;
name|Token
name|enhancer
init|=
name|sent1
operator|.
name|addToken
argument_list|(
name|enhancerStart
argument_list|,
name|enhancerStart
operator|+
literal|"enhancer"
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|expectedTokens
operator|.
name|put
argument_list|(
name|enhancer
argument_list|,
literal|"enhancer"
argument_list|)
expr_stmt|;
comment|//create a chunk
name|Chunk
name|stanbolEnhancer
init|=
name|analysedTextWithData
operator|.
name|addChunk
argument_list|(
name|stanbol
operator|.
name|getStart
argument_list|()
argument_list|,
name|enhancer
operator|.
name|getEnd
argument_list|()
argument_list|)
decl_stmt|;
name|expectedChunks
operator|.
name|put
argument_list|(
name|stanbolEnhancer
argument_list|,
literal|"Stanbol enhancer"
argument_list|)
expr_stmt|;
name|int
name|parisStart
init|=
name|sent1
operator|.
name|getSpan
argument_list|()
operator|.
name|indexOf
argument_list|(
literal|"Paris"
argument_list|)
decl_stmt|;
name|Token
name|paris
init|=
name|sent1
operator|.
name|addToken
argument_list|(
name|parisStart
argument_list|,
name|parisStart
operator|+
literal|5
argument_list|)
decl_stmt|;
name|expectedTokens
operator|.
name|put
argument_list|(
name|paris
argument_list|,
literal|"Paris"
argument_list|)
expr_stmt|;
name|int
name|bobMarleyStart
init|=
name|sent1
operator|.
name|getSpan
argument_list|()
operator|.
name|indexOf
argument_list|(
literal|"Bob Marley"
argument_list|)
decl_stmt|;
name|Chunk
name|bobMarley
init|=
name|sent1
operator|.
name|addChunk
argument_list|(
name|bobMarleyStart
argument_list|,
name|bobMarleyStart
operator|+
literal|10
argument_list|)
decl_stmt|;
name|expectedChunks
operator|.
name|put
argument_list|(
name|bobMarley
argument_list|,
literal|"Bob Marley"
argument_list|)
expr_stmt|;
name|Token
name|bob
init|=
name|bobMarley
operator|.
name|addToken
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|expectedTokens
operator|.
name|put
argument_list|(
name|bob
argument_list|,
literal|"Bob"
argument_list|)
expr_stmt|;
name|Token
name|marley
init|=
name|bobMarley
operator|.
name|addToken
argument_list|(
literal|4
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|expectedTokens
operator|.
name|put
argument_list|(
name|marley
argument_list|,
literal|"Marley"
argument_list|)
expr_stmt|;
name|Token
name|with
init|=
name|sent2
operator|.
name|addToken
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|expectedTokens
operator|.
name|put
argument_list|(
name|with
argument_list|,
literal|"With"
argument_list|)
expr_stmt|;
name|Token
name|disambiguation
init|=
name|sent2
operator|.
name|addToken
argument_list|(
literal|5
argument_list|,
literal|5
operator|+
literal|"disambiguation"
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|expectedTokens
operator|.
name|put
argument_list|(
name|disambiguation
argument_list|,
literal|"disambiguation"
argument_list|)
expr_stmt|;
name|int
name|comedianBobMarleyIndex
init|=
name|sent2
operator|.
name|getSpan
argument_list|()
operator|.
name|indexOf
argument_list|(
literal|"Comedian"
argument_list|)
decl_stmt|;
name|Chunk
name|comedianBobMarley
init|=
name|sent2
operator|.
name|addChunk
argument_list|(
name|comedianBobMarleyIndex
argument_list|,
name|comedianBobMarleyIndex
operator|+
literal|"Comedian Bob Marley"
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|expectedChunks
operator|.
name|put
argument_list|(
name|comedianBobMarley
argument_list|,
literal|"Comedian Bob Marley"
argument_list|)
expr_stmt|;
name|Token
name|comedian
init|=
name|comedianBobMarley
operator|.
name|addToken
argument_list|(
literal|0
argument_list|,
literal|"Comedian"
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|expectedTokens
operator|.
name|put
argument_list|(
name|comedian
argument_list|,
literal|"Comedian"
argument_list|)
expr_stmt|;
name|Token
name|bobSent2
init|=
name|comedianBobMarley
operator|.
name|addToken
argument_list|(
literal|9
argument_list|,
literal|9
operator|+
literal|"Bob"
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|expectedTokens
operator|.
name|put
argument_list|(
name|bobSent2
argument_list|,
literal|"Bob"
argument_list|)
expr_stmt|;
name|Token
name|marleySent2
init|=
name|comedianBobMarley
operator|.
name|addToken
argument_list|(
literal|13
argument_list|,
literal|13
operator|+
literal|"Marley"
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|expectedTokens
operator|.
name|put
argument_list|(
name|marleySent2
argument_list|,
literal|"Marley"
argument_list|)
expr_stmt|;
name|int
name|parisIndex
init|=
name|sent2
operator|.
name|getSpan
argument_list|()
operator|.
name|indexOf
argument_list|(
literal|"Paris"
argument_list|)
decl_stmt|;
name|Chunk
name|parisInTexas
init|=
name|sent2
operator|.
name|addChunk
argument_list|(
name|parisIndex
argument_list|,
name|parisIndex
operator|+
literal|"Paris in Texas"
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|expectedChunks
operator|.
name|put
argument_list|(
name|parisInTexas
argument_list|,
literal|"Paris in Texas"
argument_list|)
expr_stmt|;
name|Token
name|parisSent2
init|=
name|parisInTexas
operator|.
name|addToken
argument_list|(
literal|0
argument_list|,
literal|"Paris"
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|expectedTokens
operator|.
name|put
argument_list|(
name|parisSent2
argument_list|,
literal|"Paris"
argument_list|)
expr_stmt|;
name|int
name|inIndex
init|=
name|parisInTexas
operator|.
name|getSpan
argument_list|()
operator|.
name|indexOf
argument_list|(
literal|"in"
argument_list|)
decl_stmt|;
name|Token
name|in
init|=
name|parisInTexas
operator|.
name|addToken
argument_list|(
name|inIndex
argument_list|,
name|inIndex
operator|+
literal|2
argument_list|)
decl_stmt|;
name|expectedTokens
operator|.
name|put
argument_list|(
name|in
argument_list|,
literal|"in"
argument_list|)
expr_stmt|;
name|Token
name|texasSent2
init|=
name|parisInTexas
operator|.
name|addToken
argument_list|(
name|parisInTexas
operator|.
name|getSpan
argument_list|()
operator|.
name|indexOf
argument_list|(
literal|"Texas"
argument_list|)
argument_list|,
name|parisInTexas
operator|.
name|getSpan
argument_list|()
operator|.
name|indexOf
argument_list|(
literal|"Texas"
argument_list|)
operator|+
literal|"Texas"
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|expectedTokens
operator|.
name|put
argument_list|(
name|texasSent2
argument_list|,
literal|"Texas"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Before
specifier|public
name|void
name|initAnalysedText
parameter_list|()
throws|throws
name|Exception
block|{
name|at
operator|=
name|createAnalysedText
argument_list|()
expr_stmt|;
block|}
comment|/**      * @throws IOException      */
specifier|private
specifier|static
name|AnalysedText
name|createAnalysedText
parameter_list|()
throws|throws
name|IOException
block|{
name|ci
operator|=
name|ciFactory
operator|.
name|createContentItem
argument_list|(
operator|new
name|StringSource
argument_list|(
name|text
argument_list|)
argument_list|)
expr_stmt|;
name|Entry
argument_list|<
name|IRI
argument_list|,
name|Blob
argument_list|>
name|textBlob
init|=
name|ContentItemHelper
operator|.
name|getBlob
argument_list|(
name|ci
argument_list|,
name|Collections
operator|.
name|singleton
argument_list|(
literal|"text/plain"
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|atFactory
operator|.
name|createAnalysedText
argument_list|(
name|ci
argument_list|,
name|textBlob
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSpanFilter
parameter_list|()
block|{
name|Iterator
argument_list|<
name|Sentence
argument_list|>
name|sentences
init|=
name|analysedTextWithData
operator|.
name|getSentences
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Chunk
argument_list|>
name|chunks
init|=
name|analysedTextWithData
operator|.
name|getChunks
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Token
argument_list|>
name|tokens
init|=
name|analysedTextWithData
operator|.
name|getTokens
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|Sentence
argument_list|,
name|String
argument_list|>
name|sentEntry
range|:
name|expectedSentences
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Sentence
name|sent
init|=
name|sentences
operator|.
name|next
argument_list|()
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|sentEntry
operator|.
name|getKey
argument_list|()
argument_list|,
name|sent
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|sentEntry
operator|.
name|getValue
argument_list|()
argument_list|,
name|sent
operator|.
name|getSpan
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Entry
argument_list|<
name|Chunk
argument_list|,
name|String
argument_list|>
name|chunkEntry
range|:
name|expectedChunks
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Chunk
name|chunk
init|=
name|chunks
operator|.
name|next
argument_list|()
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|chunkEntry
operator|.
name|getKey
argument_list|()
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|chunkEntry
operator|.
name|getValue
argument_list|()
argument_list|,
name|chunk
operator|.
name|getSpan
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Entry
argument_list|<
name|Token
argument_list|,
name|String
argument_list|>
name|tokenEntry
range|:
name|expectedTokens
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Token
name|token
init|=
name|tokens
operator|.
name|next
argument_list|()
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|tokenEntry
operator|.
name|getKey
argument_list|()
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|tokenEntry
operator|.
name|getValue
argument_list|()
argument_list|,
name|token
operator|.
name|getSpan
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAnalysedText
parameter_list|()
block|{
name|Assert
operator|.
name|assertEquals
argument_list|(
name|text
argument_list|,
name|at
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|text
argument_list|,
name|at
operator|.
name|getSpan
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|at
operator|.
name|getStart
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|text
operator|.
name|length
argument_list|()
argument_list|,
name|at
operator|.
name|getEnd
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Spans created relative to an other MUST NOT exceed the span of the       * other one      */
annotation|@
name|Test
argument_list|(
name|expected
operator|=
name|IllegalArgumentException
operator|.
name|class
argument_list|)
specifier|public
name|void
name|testExceedsRelativeSpan
parameter_list|()
block|{
name|Sentence
name|sent
init|=
name|at
operator|.
name|addSentence
argument_list|(
literal|0
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|sent
operator|.
name|addChunk
argument_list|(
literal|5
argument_list|,
literal|15
argument_list|)
expr_stmt|;
comment|//Invalid
block|}
annotation|@
name|Test
argument_list|(
name|expected
operator|=
name|IllegalArgumentException
operator|.
name|class
argument_list|)
specifier|public
name|void
name|testNegativeStart
parameter_list|()
block|{
name|at
operator|.
name|addSentence
argument_list|(
operator|-
literal|1
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
argument_list|(
name|expected
operator|=
name|IllegalArgumentException
operator|.
name|class
argument_list|)
specifier|public
name|void
name|testRelativeNegativeStart
parameter_list|()
block|{
name|Sentence
name|sent
init|=
name|at
operator|.
name|addSentence
argument_list|(
literal|0
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|sent
operator|.
name|addToken
argument_list|(
operator|-
literal|1
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAnalysedTextaddSpanMethods
parameter_list|()
block|{
name|Collection
argument_list|<
name|Span
argument_list|>
name|spans
init|=
operator|new
name|HashSet
argument_list|<
name|Span
argument_list|>
argument_list|()
decl_stmt|;
comment|//add some span of different types
name|spans
operator|.
name|add
argument_list|(
name|at
operator|.
name|addToken
argument_list|(
literal|4
argument_list|,
literal|11
argument_list|)
argument_list|)
expr_stmt|;
name|spans
operator|.
name|add
argument_list|(
name|at
operator|.
name|addChunk
argument_list|(
literal|4
argument_list|,
literal|19
argument_list|)
argument_list|)
expr_stmt|;
name|spans
operator|.
name|add
argument_list|(
name|at
operator|.
name|addSentence
argument_list|(
literal|0
argument_list|,
literal|91
argument_list|)
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|Span
argument_list|>
name|atSpans
init|=
name|AnalysedTextUtils
operator|.
name|asSet
argument_list|(
name|at
operator|.
name|getEnclosed
argument_list|(
name|EnumSet
operator|.
name|allOf
argument_list|(
name|SpanTypeEnum
operator|.
name|class
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|spans
operator|.
name|containsAll
argument_list|(
name|atSpans
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|atSpans
operator|.
name|containsAll
argument_list|(
name|spans
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Test relative additions (with relative indexes) as well as iterators      * over this hierarchy      */
annotation|@
name|Test
specifier|public
name|void
name|testSpanHierarchy
parameter_list|()
block|{
name|int
index|[]
name|startPos
init|=
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|}
decl_stmt|;
name|int
index|[]
name|endPos
init|=
operator|new
name|int
index|[]
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|}
decl_stmt|;
name|int
name|maxVal
init|=
name|endPos
index|[
name|endPos
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
name|int
name|tokenLength
init|=
literal|5
decl_stmt|;
name|int
name|chunkLength
init|=
name|tokenLength
operator|*
name|maxVal
decl_stmt|;
name|int
name|sentenceLength
init|=
name|tokenLength
operator|*
name|maxVal
operator|*
name|maxVal
decl_stmt|;
name|List
argument_list|<
name|Sentence
argument_list|>
name|sentences
init|=
operator|new
name|ArrayList
argument_list|<
name|Sentence
argument_list|>
argument_list|(
name|startPos
operator|.
name|length
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Chunk
argument_list|>
name|chunks
init|=
operator|new
name|ArrayList
argument_list|<
name|Chunk
argument_list|>
argument_list|(
name|startPos
operator|.
name|length
operator|*
literal|2
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Token
argument_list|>
name|tokens
init|=
operator|new
name|ArrayList
argument_list|<
name|Token
argument_list|>
argument_list|(
name|startPos
operator|.
name|length
operator|*
literal|3
argument_list|)
decl_stmt|;
name|int
name|start
decl_stmt|;
name|int
name|end
decl_stmt|;
comment|//1. test relative add and absolute start/end
name|log
operator|.
name|info
argument_list|(
literal|"--- adding Spans ---"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|startPos
operator|.
name|length
condition|;
name|s
operator|++
control|)
block|{
name|start
operator|=
name|startPos
index|[
name|s
index|]
operator|*
name|sentenceLength
expr_stmt|;
name|end
operator|=
name|endPos
index|[
name|s
index|]
operator|*
name|sentenceLength
expr_stmt|;
name|Sentence
name|sent
init|=
name|at
operator|.
name|addSentence
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"add {}"
argument_list|,
name|sent
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|start
argument_list|,
name|sent
operator|.
name|getStart
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|end
argument_list|,
name|sent
operator|.
name|getEnd
argument_list|()
argument_list|)
expr_stmt|;
name|sentences
operator|.
name|add
argument_list|(
name|sent
argument_list|)
expr_stmt|;
block|}
comment|//1.b iterate over the sentences while adding Chunks and Tokens to
comment|//    test that returned Iterators MUST NOT throw
comment|//    ConcurrentModificationExceptions when adding Spans to the AnalysedText
name|Iterator
argument_list|<
name|Sentence
argument_list|>
name|sentenceIt
init|=
name|at
operator|.
name|getSentences
argument_list|()
decl_stmt|;
while|while
condition|(
name|sentenceIt
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Sentence
name|sent
init|=
name|sentenceIt
operator|.
name|next
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|startPos
operator|.
name|length
condition|;
name|c
operator|++
control|)
block|{
name|start
operator|=
name|startPos
index|[
name|c
index|]
operator|*
name|chunkLength
expr_stmt|;
name|end
operator|=
name|endPos
index|[
name|c
index|]
operator|*
name|chunkLength
expr_stmt|;
name|Chunk
name|chunk
init|=
name|sent
operator|.
name|addChunk
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"  add {}"
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|start
operator|=
name|sent
operator|.
name|getStart
argument_list|()
operator|+
name|start
expr_stmt|;
name|end
operator|=
name|sent
operator|.
name|getStart
argument_list|()
operator|+
name|end
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|start
argument_list|,
name|chunk
operator|.
name|getStart
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|end
argument_list|,
name|chunk
operator|.
name|getEnd
argument_list|()
argument_list|)
expr_stmt|;
name|chunks
operator|.
name|add
argument_list|(
name|chunk
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|startPos
operator|.
name|length
condition|;
name|t
operator|++
control|)
block|{
name|start
operator|=
name|startPos
index|[
name|t
index|]
operator|*
name|tokenLength
expr_stmt|;
name|end
operator|=
name|endPos
index|[
name|t
index|]
operator|*
name|tokenLength
expr_stmt|;
name|Token
name|token
init|=
name|chunk
operator|.
name|addToken
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"    add {}"
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|start
operator|=
name|chunk
operator|.
name|getStart
argument_list|()
operator|+
name|start
expr_stmt|;
name|end
operator|=
name|chunk
operator|.
name|getStart
argument_list|()
operator|+
name|end
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|start
argument_list|,
name|token
operator|.
name|getStart
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|end
argument_list|,
name|token
operator|.
name|getEnd
argument_list|()
argument_list|)
expr_stmt|;
name|tokens
operator|.
name|add
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//2. test iterations of enclosed
name|int
name|chunksInSentence
init|=
name|startPos
operator|.
name|length
decl_stmt|;
name|int
name|tokensInChunk
init|=
name|chunksInSentence
decl_stmt|;
name|int
name|tokensInSentence
init|=
name|chunksInSentence
operator|*
name|tokensInChunk
decl_stmt|;
name|Iterator
argument_list|<
name|Sentence
argument_list|>
name|sentIt
init|=
name|at
operator|.
name|getSentences
argument_list|()
decl_stmt|;
name|int
name|s
init|=
literal|0
decl_stmt|;
name|int
name|c
init|=
literal|0
decl_stmt|;
name|int
name|t
init|=
literal|0
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"--- iterating over Spans ---"
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"{}"
argument_list|,
name|at
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|sentIt
operator|.
name|hasNext
argument_list|()
condition|;
name|s
operator|++
control|)
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
name|sentences
operator|.
name|size
argument_list|()
operator|+
literal|" Sentences Expected (found: "
operator|+
operator|(
name|s
operator|+
literal|1
operator|)
operator|+
literal|")"
argument_list|,
name|s
operator|<
name|sentences
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Sentence
name|sent
init|=
name|sentIt
operator|.
name|next
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"  {}"
argument_list|,
name|sent
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|sentences
operator|.
name|get
argument_list|(
name|s
argument_list|)
argument_list|,
name|sent
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|Chunk
argument_list|>
name|chunkIt
init|=
name|sent
operator|.
name|getChunks
argument_list|()
decl_stmt|;
name|int
name|foundChunks
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|chunkIt
operator|.
name|hasNext
argument_list|()
condition|;
name|c
operator|++
control|)
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
name|chunks
operator|.
name|size
argument_list|()
operator|+
literal|" Chunks Expected (found: "
operator|+
operator|(
name|c
operator|+
literal|1
operator|)
operator|+
literal|")"
argument_list|,
name|c
operator|<
name|chunks
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Chunk
name|chunk
init|=
name|chunkIt
operator|.
name|next
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"    {}"
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|chunks
operator|.
name|get
argument_list|(
name|c
argument_list|)
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|Token
argument_list|>
name|tokenIt
init|=
name|chunk
operator|.
name|getTokens
argument_list|()
decl_stmt|;
name|int
name|foundTokens
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|tokenIt
operator|.
name|hasNext
argument_list|()
condition|;
name|t
operator|++
control|)
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
name|tokens
operator|.
name|size
argument_list|()
operator|+
literal|" Tokens Expected (found: "
operator|+
operator|(
name|t
operator|+
literal|1
operator|)
operator|+
literal|")"
argument_list|,
name|t
operator|<
name|tokens
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Token
name|token
init|=
name|tokenIt
operator|.
name|next
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"      {}"
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|tokens
operator|.
name|get
argument_list|(
name|t
argument_list|)
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|foundTokens
operator|++
expr_stmt|;
block|}
name|Assert
operator|.
name|assertEquals
argument_list|(
name|tokensInChunk
operator|+
literal|" Tokens expected in Chunk"
argument_list|,
name|tokensInChunk
argument_list|,
name|foundTokens
argument_list|)
expr_stmt|;
name|foundChunks
operator|++
expr_stmt|;
block|}
name|Assert
operator|.
name|assertEquals
argument_list|(
name|chunksInSentence
operator|+
literal|" Chunks expected in Sentence"
argument_list|,
name|chunksInSentence
argument_list|,
name|foundChunks
argument_list|)
expr_stmt|;
comment|//also iterate over tokens within a sentence
name|log
operator|.
name|info
argument_list|(
literal|"  {}"
argument_list|,
name|sent
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|Token
argument_list|>
name|tokenIt
init|=
name|sent
operator|.
name|getTokens
argument_list|()
decl_stmt|;
name|int
name|foundTokens
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|tokenIt
operator|.
name|hasNext
argument_list|()
condition|;
name|foundTokens
operator|++
control|)
block|{
name|Token
name|token
init|=
name|tokenIt
operator|.
name|next
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"    {}"
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|tokens
operator|.
name|get
argument_list|(
name|s
operator|*
name|tokensInSentence
operator|+
name|foundTokens
argument_list|)
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
name|Assert
operator|.
name|assertEquals
argument_list|(
name|tokensInSentence
operator|+
literal|" Tokens expected in Sentence"
argument_list|,
name|tokensInSentence
argument_list|,
name|foundTokens
argument_list|)
expr_stmt|;
block|}
name|Assert
operator|.
name|assertEquals
argument_list|(
name|sentences
operator|.
name|size
argument_list|()
operator|+
literal|" Sentences Expected (found: "
operator|+
name|s
operator|+
literal|")"
argument_list|,
name|sentences
operator|.
name|size
argument_list|()
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|chunks
operator|.
name|size
argument_list|()
operator|+
literal|" Chunks Expected (found: "
operator|+
name|c
operator|+
literal|")"
argument_list|,
name|chunks
operator|.
name|size
argument_list|()
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|tokens
operator|.
name|size
argument_list|()
operator|+
literal|" Sentences Expected (found: "
operator|+
name|t
operator|+
literal|")"
argument_list|,
name|tokens
operator|.
name|size
argument_list|()
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|//also iterate over Chunks in AnalysedText
name|Iterator
argument_list|<
name|Chunk
argument_list|>
name|chunkIt
init|=
name|at
operator|.
name|getChunks
argument_list|()
decl_stmt|;
name|int
name|foundChunks
init|=
literal|0
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"{}"
argument_list|,
name|at
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|chunkIt
operator|.
name|hasNext
argument_list|()
condition|;
name|foundChunks
operator|++
control|)
block|{
name|Chunk
name|chunk
init|=
name|chunkIt
operator|.
name|next
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"  {}"
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|chunks
operator|.
name|get
argument_list|(
name|foundChunks
argument_list|)
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
block|}
name|Assert
operator|.
name|assertEquals
argument_list|(
name|chunks
operator|.
name|size
argument_list|()
operator|+
literal|" Chunks expected in AnalysedText"
argument_list|,
name|chunks
operator|.
name|size
argument_list|()
argument_list|,
name|foundChunks
argument_list|)
expr_stmt|;
comment|//also iterate over Tokens in AnalysedText
name|Iterator
argument_list|<
name|Token
argument_list|>
name|tokenIt
init|=
name|at
operator|.
name|getTokens
argument_list|()
decl_stmt|;
name|int
name|foundTokens
init|=
literal|0
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"{}"
argument_list|,
name|at
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|tokenIt
operator|.
name|hasNext
argument_list|()
condition|;
name|foundTokens
operator|++
control|)
block|{
name|Token
name|token
init|=
name|tokenIt
operator|.
name|next
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"  {}"
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|tokens
operator|.
name|get
argument_list|(
name|foundTokens
argument_list|)
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
name|Assert
operator|.
name|assertEquals
argument_list|(
name|tokens
operator|.
name|size
argument_list|()
operator|+
literal|" Tokens expected in AnalysedText"
argument_list|,
name|tokens
operator|.
name|size
argument_list|()
argument_list|,
name|foundTokens
argument_list|)
expr_stmt|;
comment|//Finally iterate over multiple token types
name|Iterator
argument_list|<
name|Span
argument_list|>
name|sentencesAndChunks
init|=
name|at
operator|.
name|getEnclosed
argument_list|(
name|EnumSet
operator|.
name|of
argument_list|(
name|SpanTypeEnum
operator|.
name|Sentence
argument_list|,
name|SpanTypeEnum
operator|.
name|Chunk
argument_list|)
argument_list|)
decl_stmt|;
name|s
operator|=
literal|0
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"{}>> Iterate over Sentences and Chunks"
argument_list|,
name|at
argument_list|)
expr_stmt|;
while|while
condition|(
name|sentencesAndChunks
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Span
name|span
init|=
name|sentencesAndChunks
operator|.
name|next
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"  {}"
argument_list|,
name|span
argument_list|)
expr_stmt|;
if|if
condition|(
name|span
operator|.
name|getType
argument_list|()
operator|==
name|SpanTypeEnum
operator|.
name|Chunk
condition|)
block|{
name|Assert
operator|.
name|assertEquals
argument_list|(
name|chunks
operator|.
name|get
argument_list|(
name|c
argument_list|)
argument_list|,
name|span
argument_list|)
expr_stmt|;
name|c
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|span
operator|.
name|getType
argument_list|()
operator|==
name|SpanTypeEnum
operator|.
name|Sentence
condition|)
block|{
name|Assert
operator|.
name|assertEquals
argument_list|(
name|sentences
operator|.
name|get
argument_list|(
name|s
argument_list|)
argument_list|,
name|span
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
else|else
block|{
name|Assert
operator|.
name|fail
argument_list|(
literal|"Unexpected SpanType '"
operator|+
name|span
operator|.
name|getType
argument_list|()
operator|+
literal|" (Span: "
operator|+
name|span
operator|.
name|getClass
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
name|Assert
operator|.
name|assertEquals
argument_list|(
name|sentences
operator|.
name|size
argument_list|()
operator|+
literal|" Sentences expected in AnalysedText"
argument_list|,
name|sentences
operator|.
name|size
argument_list|()
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
operator|(
name|sentences
operator|.
name|size
argument_list|()
operator|*
name|chunksInSentence
operator|)
operator|+
literal|" Chunks expected in AnalysedText"
argument_list|,
operator|(
name|sentences
operator|.
name|size
argument_list|()
operator|*
name|chunksInSentence
operator|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
comment|/**      * Tests the {@link Section#getEnclosed(Set, int, int)} method introduced      * with<code>0.12.1</code>      */
annotation|@
name|Test
specifier|public
name|void
name|testSubSectionIteration
parameter_list|()
block|{
name|log
operator|.
name|info
argument_list|(
literal|"testSubSectionIteration ..."
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Span
argument_list|>
name|expectedSpans
init|=
operator|new
name|ArrayList
argument_list|<
name|Span
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Sentence
argument_list|>
name|sentences
init|=
operator|new
name|ArrayList
argument_list|<
name|Sentence
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|SpanTypeEnum
argument_list|>
name|enabledTypes
init|=
name|EnumSet
operator|.
name|of
argument_list|(
name|SpanTypeEnum
operator|.
name|Sentence
argument_list|,
name|SpanTypeEnum
operator|.
name|Token
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|Span
argument_list|>
name|allIt
init|=
name|analysedTextWithData
operator|.
name|getEnclosed
argument_list|(
name|enabledTypes
argument_list|)
decl_stmt|;
while|while
condition|(
name|allIt
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Span
name|s
init|=
name|allIt
operator|.
name|next
argument_list|()
decl_stmt|;
name|expectedSpans
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|getType
argument_list|()
operator|==
name|SpanTypeEnum
operator|.
name|Sentence
condition|)
block|{
name|sentences
operator|.
name|add
argument_list|(
operator|(
name|Sentence
operator|)
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|//first test an section that exceeds the end of the text
name|int
index|[]
name|testSpan
init|=
operator|new
name|int
index|[]
block|{
literal|4
block|,
literal|90
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|assertSectionIterator
argument_list|(
name|analysedTextWithData
argument_list|,
name|expectedSpans
argument_list|,
name|testSpan
argument_list|,
name|enabledTypes
argument_list|)
argument_list|)
expr_stmt|;
comment|//second test a section relative to an sentence
name|Sentence
name|lastSent
init|=
name|sentences
operator|.
name|get
argument_list|(
name|sentences
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|int
index|[]
name|offsetSpan
init|=
operator|new
name|int
index|[]
block|{
literal|5
block|,
literal|25
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|assertSectionIterator
argument_list|(
name|lastSent
argument_list|,
name|expectedSpans
argument_list|,
name|offsetSpan
argument_list|,
name|enabledTypes
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * @param span      * @param testSpan      */
specifier|private
name|int
name|assertSectionIterator
parameter_list|(
name|Section
name|section
parameter_list|,
name|List
argument_list|<
name|Span
argument_list|>
name|span
parameter_list|,
name|int
index|[]
name|testSpan
parameter_list|,
name|Set
argument_list|<
name|SpanTypeEnum
argument_list|>
name|types
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"> assert span {} over {}"
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|testSpan
argument_list|)
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|Span
argument_list|>
name|sectionIt
init|=
name|section
operator|.
name|getEnclosed
argument_list|(
name|types
argument_list|,
name|testSpan
index|[
literal|0
index|]
argument_list|,
name|testSpan
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|int
name|startIdx
init|=
name|section
operator|.
name|getStart
argument_list|()
operator|+
name|testSpan
index|[
literal|0
index|]
decl_stmt|;
name|int
name|endIdx
init|=
name|section
operator|.
name|getStart
argument_list|()
operator|+
name|testSpan
index|[
literal|1
index|]
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Span
name|s
range|:
name|span
control|)
block|{
if|if
condition|(
name|s
operator|.
name|getStart
argument_list|()
operator|<
name|startIdx
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|" - asserted {} before section"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|.
name|getEnd
argument_list|()
operator|<
name|endIdx
condition|)
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
name|sectionIt
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|s
argument_list|,
name|sectionIt
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|" - asserted section token {}"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|" - asserted correct section end"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertFalse
argument_list|(
name|sectionIt
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|count
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAnnotation
parameter_list|()
block|{
name|List
argument_list|<
name|Value
argument_list|<
name|Number
argument_list|>
argument_list|>
name|values
init|=
operator|new
name|ArrayList
argument_list|<
name|Value
argument_list|<
name|Number
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|values
operator|.
name|add
argument_list|(
operator|new
name|Value
argument_list|<
name|Number
argument_list|>
argument_list|(
literal|26
argument_list|,
literal|0.6
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|add
argument_list|(
operator|new
name|Value
argument_list|<
name|Number
argument_list|>
argument_list|(
literal|27l
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|add
argument_list|(
operator|new
name|Value
argument_list|<
name|Number
argument_list|>
argument_list|(
literal|28.0f
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|add
argument_list|(
operator|new
name|Value
argument_list|<
name|Number
argument_list|>
argument_list|(
literal|25.0
argument_list|,
literal|0.8
argument_list|)
argument_list|)
expr_stmt|;
name|at
operator|.
name|addAnnotations
argument_list|(
name|testAnnotation
argument_list|,
name|values
argument_list|)
expr_stmt|;
name|Value
argument_list|<
name|Number
argument_list|>
name|value
init|=
name|at
operator|.
name|getAnnotation
argument_list|(
name|testAnnotation
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertNotNull
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|Double
operator|.
name|valueOf
argument_list|(
literal|25.0
argument_list|)
argument_list|,
name|value
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|0.8d
argument_list|,
name|value
operator|.
name|probability
argument_list|()
argument_list|,
literal|0.0d
argument_list|)
expr_stmt|;
name|Number
name|prev
init|=
name|Float
operator|.
name|valueOf
argument_list|(
literal|24f
argument_list|)
decl_stmt|;
for|for
control|(
name|Value
argument_list|<
name|Number
argument_list|>
name|v
range|:
name|at
operator|.
name|getAnnotations
argument_list|(
name|testAnnotation
argument_list|)
control|)
block|{
name|Assert
operator|.
name|assertNotNull
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|v
operator|.
name|value
argument_list|()
operator|.
name|doubleValue
argument_list|()
operator|>
name|prev
operator|.
name|doubleValue
argument_list|()
argument_list|)
expr_stmt|;
name|prev
operator|=
name|v
operator|.
name|value
argument_list|()
expr_stmt|;
block|}
comment|//check that the order of Annotations without probability is kept
name|at
operator|.
name|addAnnotation
argument_list|(
name|testAnnotation
argument_list|,
operator|new
name|Value
argument_list|<
name|Number
argument_list|>
argument_list|(
literal|29
argument_list|)
argument_list|)
expr_stmt|;
name|prev
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
literal|24
argument_list|)
expr_stmt|;
for|for
control|(
name|Value
argument_list|<
name|Number
argument_list|>
name|v
range|:
name|at
operator|.
name|getAnnotations
argument_list|(
name|testAnnotation
argument_list|)
control|)
block|{
name|Assert
operator|.
name|assertNotNull
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|v
operator|.
name|value
argument_list|()
operator|.
name|intValue
argument_list|()
operator|>
name|prev
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
name|prev
operator|=
name|v
operator|.
name|value
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

