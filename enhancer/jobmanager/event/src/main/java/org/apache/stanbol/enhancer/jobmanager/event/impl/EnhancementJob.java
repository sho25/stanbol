begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|jobmanager
operator|.
name|event
operator|.
name|impl
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|EnhancementEngineHelper
operator|.
name|getReference
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|EnhancementEngineHelper
operator|.
name|getString
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|ExecutionMetadataHelper
operator|.
name|getChainExecution
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|ExecutionMetadataHelper
operator|.
name|getExecutionPlanNode
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|ExecutionMetadataHelper
operator|.
name|initExecutionMetadata
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|ExecutionMetadataHelper
operator|.
name|initExecutionMetadataContentPart
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|ExecutionMetadataHelper
operator|.
name|isExecutionFailed
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|ExecutionMetadataHelper
operator|.
name|setExecutionCompleted
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|ExecutionMetadataHelper
operator|.
name|setExecutionFaild
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|ExecutionMetadataHelper
operator|.
name|setExecutionInProgress
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|ExecutionPlanHelper
operator|.
name|getDependend
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|ExecutionPlanHelper
operator|.
name|getEngine
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|ExecutionPlanHelper
operator|.
name|isOptional
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|ExecutionMetadata
operator|.
name|STATUS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|ExecutionMetadata
operator|.
name|STATUS_IN_PROGRESS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|ExecutionPlan
operator|.
name|CHAIN
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReadWriteLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Graph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|MGraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|NonLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|UriRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|collections
operator|.
name|BidiMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|collections
operator|.
name|bidimap
operator|.
name|DualHashBidiMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|Chain
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|ContentItem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|EnhancementEngine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|EnhancementJobManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|NoSuchPartException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|ExecutionMetadataHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|ExecutionPlanHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|ExecutionMetadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Represents the enhancement of a {@link ContentItem} by following the  * execution plan provided by a {@link Chain} as parsed to an  * {@link EnhancementJobManager}.<p>  * TODO: This might become part of the Stanbol Enhancer Services API.  *   * @author Rupert Westenthaler  */
end_comment

begin_class
specifier|public
class|class
name|EnhancementJob
block|{
comment|/*      * NOTE on debug level Loggings      *       *  ++ ... init some activity      *>> ... started some activity (thread has the requested lock)      *<< ... completed some activity (thread has released the lock)      *        *  n: ... no lock      *  r: ... read lock      *  w: ... write lock      */
specifier|private
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|EnhancementJob
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|Lock
name|readLock
decl_stmt|;
specifier|private
specifier|final
name|Lock
name|writeLock
decl_stmt|;
comment|/**      * The read only executionPlan      */
specifier|private
specifier|final
name|Graph
name|executionPlan
decl_stmt|;
comment|/**      * The read/write able execution metadata. Also accessible via      * {@link ContentItem#getPart(UriRef, Class)} with the URI      * {@link ExecutionMetadata#CHAIN_EXECUTION}      */
specifier|private
specifier|final
name|MGraph
name|executionMetadata
decl_stmt|;
comment|/**      * Map with the em:Execution nodes of the em:ChainExecution for this      * ContentItem. Values are are ep:ExecutionNodes of the ep:ExecutionPlan      */
specifier|private
specifier|final
name|BidiMap
name|executionsMap
decl_stmt|;
comment|/**      * The em:ChainExecution for this {@link ContentItem}      */
specifier|private
specifier|final
name|NonLiteral
name|chainExecutionNode
decl_stmt|;
comment|/**      * The ep:ExecutionPlan for this {@link ContentItem}      */
specifier|private
specifier|final
name|NonLiteral
name|executionPlanNode
decl_stmt|;
comment|/**      * The name of the {@link Chain} used to enhance this {@link ContentItem}.      */
specifier|private
specifier|final
name|String
name|chain
decl_stmt|;
comment|/**      * The ContentItem      */
specifier|private
specifier|final
name|ContentItem
name|contentItem
decl_stmt|;
comment|/**      * The completed ep:ExecutionPlan nodes.<p>      * NOTE: This contains ep:ExecutionNodes and NOT em:Exetution instances!      */
specifier|private
specifier|final
name|Set
argument_list|<
name|NonLiteral
argument_list|>
name|completed
init|=
operator|new
name|HashSet
argument_list|<
name|NonLiteral
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * Unmodifiable and final set of completed executables. Replaced by a new      * instance every time {@link #completed} changes      */
specifier|private
name|Set
argument_list|<
name|NonLiteral
argument_list|>
name|completedExec
init|=
name|Collections
operator|.
name|emptySet
argument_list|()
decl_stmt|;
comment|/**      * The running ep:ExecutionPlan nodes<p>      * NOTE: This contains ep:ExecutionNodes and NOT em:Exetution instances!      */
specifier|private
specifier|final
name|Set
argument_list|<
name|NonLiteral
argument_list|>
name|running
init|=
operator|new
name|HashSet
argument_list|<
name|NonLiteral
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * Unmodifiable and final set of running executables. Replaced by a new      * instance every time {@link #running} changes.      */
specifier|private
name|Set
argument_list|<
name|NonLiteral
argument_list|>
name|runningExec
init|=
name|Collections
operator|.
name|emptySet
argument_list|()
decl_stmt|;
comment|/**      * Unmodifiable and final set of executable em:Execution nodes.       * Replaced by a new instance every time {@link #running} or       * {@link #completed} changes.      */
specifier|private
name|Set
argument_list|<
name|NonLiteral
argument_list|>
name|executable
decl_stmt|;
comment|/**      * Used to store any {@link Exception} parsed with the call to      * {@link #setFailed(NonLiteral, EnhancementEngine, Exception)} causing the      * enhancement process to fail. This Exception is typically re-thrown by the      * {@link EnhancementJobManager#enhanceContent(ContentItem, Chain)} method.      * @see #getError()      */
specifier|private
name|Exception
name|error
init|=
literal|null
decl_stmt|;
comment|/**      * Constructor used to create and initialise a new enhancement job. This      * will create the initial set of ExecutionMetadata and add them as      * ContentPart with the URI {@link ExecutionMetadata#CHAIN_EXECUTION} to the      * ContentItem.      * @param contentItem      * @param chainName      * @param executionPlan      * @param isDefaultChain      */
specifier|public
name|EnhancementJob
parameter_list|(
name|ContentItem
name|contentItem
parameter_list|,
name|String
name|chainName
parameter_list|,
name|Graph
name|executionPlan
parameter_list|,
name|boolean
name|isDefaultChain
parameter_list|)
block|{
if|if
condition|(
name|contentItem
operator|==
literal|null
operator|||
name|chainName
operator|==
literal|null
operator|||
name|executionPlan
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed contentItem and executionPlan MUST NOT be NULL"
argument_list|)
throw|;
block|}
name|this
operator|.
name|readLock
operator|=
name|contentItem
operator|.
name|getLock
argument_list|()
operator|.
name|readLock
argument_list|()
expr_stmt|;
name|this
operator|.
name|writeLock
operator|=
name|contentItem
operator|.
name|getLock
argument_list|()
operator|.
name|writeLock
argument_list|()
expr_stmt|;
name|executionMetadata
operator|=
name|initExecutionMetadataContentPart
argument_list|(
name|contentItem
argument_list|)
expr_stmt|;
if|if
condition|(
name|executionMetadata
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//if we init from scratch
name|this
operator|.
name|executionsMap
operator|=
operator|new
name|DualHashBidiMap
argument_list|(
name|initExecutionMetadata
argument_list|(
name|executionMetadata
argument_list|,
name|executionPlan
argument_list|,
name|contentItem
operator|.
name|getUri
argument_list|()
argument_list|,
name|chainName
argument_list|,
name|isDefaultChain
argument_list|)
argument_list|)
expr_stmt|;
name|chainExecutionNode
operator|=
name|getChainExecution
argument_list|(
name|executionMetadata
argument_list|,
name|contentItem
operator|.
name|getUri
argument_list|()
argument_list|)
expr_stmt|;
name|executionPlanNode
operator|=
name|getExecutionPlanNode
argument_list|(
name|executionMetadata
argument_list|,
name|chainExecutionNode
argument_list|)
expr_stmt|;
name|executionMetadata
operator|.
name|addAll
argument_list|(
name|executionPlan
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unable to create EnhancementJob for "
operator|+
literal|"a parsed execution plan if the ContentItem already contains "
operator|+
literal|"some Execution Metadata!"
argument_list|)
throw|;
block|}
name|this
operator|.
name|contentItem
operator|=
name|contentItem
expr_stmt|;
name|this
operator|.
name|executionPlan
operator|=
name|executionPlan
expr_stmt|;
name|this
operator|.
name|chain
operator|=
name|chainName
expr_stmt|;
comment|//check the first engines to execute
name|checkExecutable
argument_list|()
expr_stmt|;
block|}
comment|/**      * Creates an EnhancemenJob based on already existing execution metadata present      * for a ContentItem.      * @param contentItem the ContentItem with an already existing content part      * containing an {@link MGraph} with all required execution metadata and the       * execution plan.      * @throws IllegalArgumentException if the parsed {@link ContentItem} does      * not provide the required data to (re)initialise the EnhancementJob.      */
specifier|public
name|EnhancementJob
parameter_list|(
name|ContentItem
name|contentItem
parameter_list|)
block|{
if|if
condition|(
name|contentItem
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed ContentItem MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|this
operator|.
name|contentItem
operator|=
name|contentItem
expr_stmt|;
name|this
operator|.
name|readLock
operator|=
name|contentItem
operator|.
name|getLock
argument_list|()
operator|.
name|readLock
argument_list|()
expr_stmt|;
name|this
operator|.
name|writeLock
operator|=
name|contentItem
operator|.
name|getLock
argument_list|()
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|contentItem
operator|.
name|getPart
argument_list|(
name|ExecutionMetadata
operator|.
name|CHAIN_EXECUTION
argument_list|,
name|MGraph
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchPartException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot (re)initialise an EnhancementJob"
operator|+
literal|"without existing execution metadata content part!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|executionMetadata
operator|=
name|initExecutionMetadataContentPart
argument_list|(
name|contentItem
argument_list|)
expr_stmt|;
name|this
operator|.
name|executionPlan
operator|=
name|executionMetadata
operator|.
name|getGraph
argument_list|()
expr_stmt|;
name|chainExecutionNode
operator|=
name|getChainExecution
argument_list|(
name|executionMetadata
argument_list|,
name|contentItem
operator|.
name|getUri
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|chainExecutionNode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot (re)initialise an EnhancementJob"
operator|+
literal|"because the ExecutionMetadata do not contain an em:ChainExecution"
operator|+
literal|"for the given ContentItem '"
operator|+
name|contentItem
operator|.
name|getUri
argument_list|()
operator|+
literal|"'!"
argument_list|)
throw|;
block|}
name|executionPlanNode
operator|=
name|getExecutionPlanNode
argument_list|(
name|executionMetadata
argument_list|,
name|chainExecutionNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|executionPlanNode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot (re)initialise an EnhancementJob"
operator|+
literal|"because the ExecutionMetadata do not contain an ep:ExecutionPlan"
operator|+
literal|"for the given ContentItem '"
operator|+
name|contentItem
operator|.
name|getUri
argument_list|()
operator|+
literal|"'!"
argument_list|)
throw|;
block|}
name|this
operator|.
name|chain
operator|=
name|getString
argument_list|(
name|executionPlan
argument_list|,
name|executionPlanNode
argument_list|,
name|CHAIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|==
literal|null
operator|||
name|chain
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot (re)initialise an EnhancementJob "
operator|+
literal|"because the ExecutionMetadata do not define a valid chain name for "
operator|+
literal|"the ep:ExecutionPlan node '"
operator|+
name|executionPlanNode
operator|+
literal|"' as used to "
operator|+
literal|"enhance  ContentItem '"
operator|+
name|contentItem
operator|.
name|getUri
argument_list|()
operator|+
literal|"'!"
argument_list|)
throw|;
block|}
comment|//the executionPlan is part of the execution metadata
name|Map
argument_list|<
name|NonLiteral
argument_list|,
name|NonLiteral
argument_list|>
name|executionsMap
init|=
name|initExecutionMetadata
argument_list|(
name|executionMetadata
argument_list|,
name|executionPlan
argument_list|,
name|contentItem
operator|.
name|getUri
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|NonLiteral
argument_list|,
name|NonLiteral
argument_list|>
name|executionEntry
range|:
name|executionsMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|UriRef
name|status
init|=
name|getReference
argument_list|(
name|executionMetadata
argument_list|,
name|executionEntry
operator|.
name|getKey
argument_list|()
argument_list|,
name|STATUS
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The ex:Execution '"
operator|+
name|executionEntry
operator|.
name|getKey
argument_list|()
operator|+
literal|"' of the ex:ChainExecution for ContentItme '"
operator|+
name|contentItem
operator|.
name|getUri
argument_list|()
operator|+
literal|"' is missing a required value for the property '"
operator|+
name|STATUS
operator|+
literal|"'!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|status
operator|.
name|equals
argument_list|(
name|STATUS_IN_PROGRESS
argument_list|)
condition|)
block|{
comment|//re-schedule unfinished enhancement jobs
name|ExecutionMetadataHelper
operator|.
name|setExecutionScheduled
argument_list|(
name|executionMetadata
argument_list|,
name|executionEntry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|.
name|equals
argument_list|(
name|ExecutionMetadata
operator|.
name|STATUS_COMPLETED
argument_list|)
operator|||
name|status
operator|.
name|equals
argument_list|(
name|ExecutionMetadata
operator|.
name|STATUS_FAILED
argument_list|)
condition|)
block|{
name|completed
operator|.
name|add
argument_list|(
name|executionEntry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|executionsMap
operator|=
operator|new
name|DualHashBidiMap
argument_list|(
name|executionsMap
argument_list|)
expr_stmt|;
comment|//check the first engines to execute after continuation
name|checkExecutable
argument_list|()
expr_stmt|;
block|}
comment|/**      * Getter for the ep:ExecutionNode linked to a em:Execution      * @return the ep:ExecutionNode instance      * @throws IllegalArgumentException if the parsed em:Execution is not      * part of the execution metadata of this enhancement job      */
specifier|public
name|NonLiteral
name|getExecutionNode
parameter_list|(
name|NonLiteral
name|execution
parameter_list|)
block|{
name|NonLiteral
name|node
init|=
operator|(
name|NonLiteral
operator|)
name|executionsMap
operator|.
name|get
argument_list|(
name|execution
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown sp:ExecutionNode instance "
operator|+
name|node
argument_list|)
throw|;
block|}
return|return
name|node
return|;
block|}
comment|/**      * Getter for the em:Execution linked to a ep:ExecutionNode      * @return the em:Execution instance       * @throws IllegalArgumentException if the parsed ep:ExecutionNode is not      * part of the execution plan of this enhancement job      */
specifier|public
name|NonLiteral
name|getExecution
parameter_list|(
name|NonLiteral
name|executionNode
parameter_list|)
block|{
name|NonLiteral
name|execution
init|=
operator|(
name|NonLiteral
operator|)
name|executionsMap
operator|.
name|getKey
argument_list|(
name|executionNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|execution
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown em:Execution instance "
operator|+
name|executionNode
argument_list|)
throw|;
block|}
return|return
name|execution
return|;
block|}
comment|/**      * The used execution plan for processing the {@link ContentItem}      *       * @return the executionPlan      */
specifier|public
specifier|final
name|Graph
name|getExecutionPlan
parameter_list|()
block|{
return|return
name|executionPlan
return|;
block|}
comment|/**      * The ContentItem enhanced by this job.      *       * @return      */
specifier|public
specifier|final
name|ContentItem
name|getContentItem
parameter_list|()
block|{
return|return
name|contentItem
return|;
block|}
comment|/**      * This returns the name of the Chain used to initialise the execution plan for this enhancement job.      *<p>      * NOTE that because chains can change (activate, change, deactivate) at any moment there is no guarantee      * that the a chain with that name is still available nor that calling {@link Chain#getExecutionPlan()}      * will be equals to the {@link #getExecutionPlan()} used by this enhancement job. This is the reason why      * this method just returns the name of the chain and not the {@link Chain} instance.      *       * @return      */
specifier|public
specifier|final
name|String
name|getChainName
parameter_list|()
block|{
return|return
name|chain
return|;
block|}
comment|/**      * Getter for the lock used to synchronise read/write to this enhancement job. This returns the lock      * provided by {@link ContentItem#getLock()}      *       * @return the read/write lock for this enhancement job      */
specifier|public
specifier|final
name|ReadWriteLock
name|getLock
parameter_list|()
block|{
return|return
name|contentItem
operator|.
name|getLock
argument_list|()
return|;
block|}
comment|/**      * Getter for a read only view over the currently running executions.      *       * @return the currently running executions.      */
specifier|public
name|Set
argument_list|<
name|NonLiteral
argument_list|>
name|getRunning
parameter_list|()
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"++ r: {}"
argument_list|,
literal|"getRunning"
argument_list|)
expr_stmt|;
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|log
operator|.
name|debug
argument_list|(
literal|">> r: {}"
argument_list|,
literal|"getRunning"
argument_list|)
expr_stmt|;
return|return
name|runningExec
return|;
block|}
finally|finally
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"<< r: {}"
argument_list|,
literal|"getRunning"
argument_list|)
expr_stmt|;
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Getter for a read only view over the completed execution.      *       * @return the completed execution nodes      */
specifier|public
name|Set
argument_list|<
name|NonLiteral
argument_list|>
name|getCompleted
parameter_list|()
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"++ r: {}"
argument_list|,
literal|"getCompleted"
argument_list|)
expr_stmt|;
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|log
operator|.
name|debug
argument_list|(
literal|">> r: {}"
argument_list|,
literal|"getCompleted"
argument_list|)
expr_stmt|;
return|return
name|completedExec
return|;
block|}
finally|finally
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"<< r: {}"
argument_list|,
literal|"getCompleted"
argument_list|)
expr_stmt|;
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Sets the state of the parsed executionNode to completed. This also validates if the new state      * confirms to the ExectionPlan (e.g. if all nodes the parsed node depends on are also marked as      * completed).      *       * @param execution      *            the exection to be marked as running      * @throws IllegalArgumentException      *             if<code>null</code> is parsed as execution node      * @throws IllegalStateException      *             if the parsed execution node can not be marked as completed because some of its      *             depended nodes are not yet marked as completed.      */
specifier|public
name|void
name|setCompleted
parameter_list|(
name|NonLiteral
name|execution
parameter_list|)
block|{
if|if
condition|(
name|execution
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed em:Execution instance MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|NonLiteral
name|executionNode
init|=
name|getExecutionNode
argument_list|(
name|execution
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"++ w: {}: {}"
argument_list|,
literal|"setCompleted"
argument_list|,
name|getEngine
argument_list|(
name|executionPlan
argument_list|,
name|executionNode
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|log
operator|.
name|debug
argument_list|(
literal|">> w: {}: {}"
argument_list|,
literal|"setCompleted"
argument_list|,
name|getEngine
argument_list|(
name|executionPlan
argument_list|,
name|executionNode
argument_list|)
argument_list|)
expr_stmt|;
name|setNodeCompleted
argument_list|(
name|executionNode
argument_list|)
expr_stmt|;
name|setExecutionCompleted
argument_list|(
name|executionMetadata
argument_list|,
name|execution
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"<< w: {}: {}"
argument_list|,
literal|"setCompleted"
argument_list|,
name|getEngine
argument_list|(
name|executionPlan
argument_list|,
name|executionNode
argument_list|)
argument_list|)
expr_stmt|;
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Internally used to update the state kept in {@link #completed} and      * {@link #running} and {@link #executable} after an execution was set to      * {@link #setCompleted(NonLiteral) completed} or       * {@link #setFailed(NonLiteral, EnhancementEngine, Exception) failed}.<p>      * This method expects to be called within an active {@link #writeLock}.      * @param executionNode the ep:ExecutionNode linked to the em:Execution that      * finished.       */
specifier|private
name|void
name|setNodeCompleted
parameter_list|(
name|NonLiteral
name|executionNode
parameter_list|)
block|{
name|String
name|engine
init|=
name|getEngine
argument_list|(
name|executionPlan
argument_list|,
name|executionNode
argument_list|)
decl_stmt|;
name|boolean
name|optional
init|=
name|isOptional
argument_list|(
name|executionPlan
argument_list|,
name|executionNode
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|NonLiteral
argument_list|>
name|dependsOn
init|=
name|getDependend
argument_list|(
name|executionPlan
argument_list|,
name|executionNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|completed
operator|.
name|contains
argument_list|(
name|executionNode
argument_list|)
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Execution of Engine '{}' for ContentItem {} already "
operator|+
literal|"marked as completed(chain: {}, node: {}, optional {})."
operator|+
literal|" -> call ignored"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|engine
block|,
name|contentItem
operator|.
name|getUri
argument_list|()
operator|.
name|getUnicodeString
argument_list|()
block|,
name|chain
block|,
name|executionNode
block|,
name|optional
block|}
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|completed
operator|.
name|containsAll
argument_list|(
name|dependsOn
argument_list|)
condition|)
block|{
comment|// TODO maybe define an own Exception for such cases
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unable to set state of ExectionNode '"
operator|+
name|executionNode
operator|+
literal|"' (chain '"
operator|+
name|chain
operator|+
literal|"' | contentItem '"
operator|+
name|contentItem
operator|.
name|getUri
argument_list|()
operator|+
literal|"') to completed, because some of its depended "
operator|+
literal|"nodes are not marked completed yet. This indicates an Bug in the "
operator|+
literal|"implementation of the JobManager used to execute the ExecutionPlan. "
operator|+
literal|"(this.dependsOn="
operator|+
name|dependsOn
operator|+
literal|"| chain.completed "
operator|+
name|completed
operator|+
literal|" | chain.running "
operator|+
name|running
operator|+
literal|")!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|running
operator|.
name|remove
argument_list|(
name|executionNode
argument_list|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Execution of '{}' for ContentItem {} completed "
operator|+
literal|"(chain: {}, node: {}, optional {})"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|engine
block|,
name|contentItem
operator|.
name|getUri
argument_list|()
operator|.
name|getUnicodeString
argument_list|()
block|,
name|chain
block|,
name|executionNode
block|,
name|optional
block|}
argument_list|)
expr_stmt|;
block|}
name|completed
operator|.
name|add
argument_list|(
name|executionNode
argument_list|)
expr_stmt|;
comment|//update the set with the completed and running executables
name|updateCompletedExec
argument_list|()
expr_stmt|;
name|updateRunningExec
argument_list|()
expr_stmt|;
comment|// update the executables ... this will also recognise if finished
name|checkExecutable
argument_list|()
expr_stmt|;
block|}
comment|/**      * Sets the state of the parsed execution to running. This also validates if the new state      * confirms to the ExectionPlan (e.g. if all nodes the parsed node depends on are already marked as      * completed).      *       * @param execution      *            the execution to be marked as running      * @throws IllegalArgumentException      *             if<code>null</code> is parsed as execution node      * @throws IllegalStateException      *             if the parsed execution node can not be marked as running because some of its depended      *             nodes are not yet marked as completed.      */
specifier|public
name|void
name|setRunning
parameter_list|(
name|NonLiteral
name|execution
parameter_list|)
block|{
if|if
condition|(
name|execution
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed em:Execution instance MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|NonLiteral
name|executionNode
init|=
name|getExecutionNode
argument_list|(
name|execution
argument_list|)
decl_stmt|;
name|String
name|engine
init|=
name|getEngine
argument_list|(
name|executionPlan
argument_list|,
name|executionNode
argument_list|)
decl_stmt|;
name|boolean
name|optional
init|=
name|isOptional
argument_list|(
name|executionPlan
argument_list|,
name|executionNode
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|NonLiteral
argument_list|>
name|dependsOn
init|=
name|getDependend
argument_list|(
name|executionPlan
argument_list|,
name|executionNode
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"++ w: {}: {}"
argument_list|,
literal|"setRunning"
argument_list|,
name|ExecutionPlanHelper
operator|.
name|getEngine
argument_list|(
name|executionPlan
argument_list|,
name|executionNode
argument_list|)
argument_list|)
expr_stmt|;
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|log
operator|.
name|debug
argument_list|(
literal|">> w: {}: {}"
argument_list|,
literal|"setRunning"
argument_list|,
name|ExecutionPlanHelper
operator|.
name|getEngine
argument_list|(
name|executionPlan
argument_list|,
name|executionNode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|completed
operator|.
name|contains
argument_list|(
name|executionNode
argument_list|)
condition|)
block|{
name|String
name|message
init|=
literal|"Unable to set state of ExectionNode '"
operator|+
name|executionNode
operator|+
literal|"'(chain '"
operator|+
name|chain
operator|+
literal|"' | contentItem '"
operator|+
name|contentItem
operator|.
name|getUri
argument_list|()
operator|+
literal|"') to running, because"
operator|+
literal|"it is already marked as completed. This indicates "
operator|+
literal|"an Bug in the implementation of the JobManager "
operator|+
literal|"used to execute the ExecutionPlan (chain state: "
operator|+
literal|"completed "
operator|+
name|completed
operator|+
literal|" | running "
operator|+
name|running
operator|+
literal|")!"
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|message
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|message
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|completed
operator|.
name|containsAll
argument_list|(
name|dependsOn
argument_list|)
condition|)
block|{
comment|// TODO maybe define an own Exception for such cases
name|String
name|message
init|=
literal|"Unable to set state of ExectionNode '"
operator|+
name|executionNode
operator|+
literal|"' (chain '"
operator|+
name|chain
operator|+
literal|"' | contentItem '"
operator|+
name|contentItem
operator|.
name|getUri
argument_list|()
operator|+
literal|"') to running, because "
operator|+
literal|"some of its depended nodes are not marked "
operator|+
literal|"completed yet. This indicates an Bug in the "
operator|+
literal|"implementation of the JobManager used to execute "
operator|+
literal|"the ExecutionPlan (this.dependsOn="
operator|+
name|dependsOn
operator|+
literal|"| chain.completed "
operator|+
name|completed
operator|+
literal|" | chain.running "
operator|+
name|running
operator|+
literal|")!"
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
name|message
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|message
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|running
operator|.
name|add
argument_list|(
name|executionNode
argument_list|)
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Execution of Engine '{}' for ContentItem {} already "
operator|+
literal|"marked as running(chain: {}, node: {}, optional {})."
operator|+
literal|" -> call ignored"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|engine
block|,
name|contentItem
operator|.
name|getUri
argument_list|()
operator|.
name|getUnicodeString
argument_list|()
block|,
name|chain
block|,
name|executionNode
block|,
name|optional
block|}
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|//added an engine to running
name|log
operator|.
name|info
argument_list|(
literal|"Started Execution of '{}' for ContentItem {} "
operator|+
literal|"(chain: {}, node: {}, optional {})"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|engine
block|,
name|contentItem
operator|.
name|getUri
argument_list|()
operator|.
name|getUnicodeString
argument_list|()
block|,
name|chain
block|,
name|executionNode
block|,
name|optional
block|}
argument_list|)
expr_stmt|;
comment|//set the status of the execution to be in progress
name|ExecutionMetadataHelper
operator|.
name|setExecutionInProgress
argument_list|(
name|executionMetadata
argument_list|,
name|execution
argument_list|)
expr_stmt|;
comment|// update the executables ... this will also recognise if finished
name|updateRunningExec
argument_list|()
expr_stmt|;
comment|//update executables
name|checkExecutable
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"<< w: {}: {}"
argument_list|,
literal|"setRunning"
argument_list|,
name|ExecutionPlanHelper
operator|.
name|getEngine
argument_list|(
name|executionPlan
argument_list|,
name|executionNode
argument_list|)
argument_list|)
expr_stmt|;
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * updates the {@link #runningExec} based on {@link #running}      */
specifier|private
name|void
name|updateRunningExec
parameter_list|()
block|{
name|Set
argument_list|<
name|NonLiteral
argument_list|>
name|runningExec
init|=
operator|new
name|HashSet
argument_list|<
name|NonLiteral
argument_list|>
argument_list|(
name|running
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|NonLiteral
name|node
range|:
name|running
control|)
block|{
name|runningExec
operator|.
name|add
argument_list|(
name|getExecution
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|runningExec
operator|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|runningExec
argument_list|)
expr_stmt|;
block|}
comment|/**      * updates the {@link #runningExec} based on {@link #running}      */
specifier|private
name|void
name|updateCompletedExec
parameter_list|()
block|{
name|Set
argument_list|<
name|NonLiteral
argument_list|>
name|completedExec
init|=
operator|new
name|HashSet
argument_list|<
name|NonLiteral
argument_list|>
argument_list|(
name|completed
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|NonLiteral
name|node
range|:
name|completed
control|)
block|{
name|completedExec
operator|.
name|add
argument_list|(
name|getExecution
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|completedExec
operator|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|completedExec
argument_list|)
expr_stmt|;
block|}
comment|/**      * updated the {@link #executable} and also checks for {@link #finished}<p>      * Assumed to be called within a write lock!      */
specifier|private
name|void
name|checkExecutable
parameter_list|()
block|{
name|Set
argument_list|<
name|NonLiteral
argument_list|>
name|executeableNodes
init|=
name|ExecutionPlanHelper
operator|.
name|getExecutable
argument_list|(
name|executionPlan
argument_list|,
name|completed
argument_list|)
decl_stmt|;
comment|//a Chain finishes if no engine is running and no more nodes are executable
if|if
condition|(
operator|!
name|ExecutionMetadata
operator|.
name|STATUS_FAILED
operator|.
name|equals
argument_list|(
name|getReference
argument_list|(
name|executionMetadata
argument_list|,
name|chainExecutionNode
argument_list|,
name|STATUS
argument_list|)
argument_list|)
condition|)
block|{
name|executeableNodes
operator|.
name|removeAll
argument_list|(
name|running
argument_list|)
expr_stmt|;
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|engines
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|executeableNodes
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|NonLiteral
name|node
range|:
name|executeableNodes
control|)
block|{
name|engines
operator|.
name|add
argument_list|(
name|getEngine
argument_list|(
name|executionPlan
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|debug
argument_list|(
literal|"MARK {} as executeable"
argument_list|,
name|engines
argument_list|)
expr_stmt|;
block|}
comment|//we need to get the em:Executables for the ep:ExecutionNodes ...
if|if
condition|(
name|executeableNodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|this
operator|.
name|executable
operator|=
name|Collections
operator|.
name|emptySet
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|executeableNodes
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|this
operator|.
name|executable
operator|=
name|Collections
operator|.
name|singleton
argument_list|(
name|getExecution
argument_list|(
name|executeableNodes
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Set
argument_list|<
name|NonLiteral
argument_list|>
name|executable
init|=
operator|new
name|HashSet
argument_list|<
name|NonLiteral
argument_list|>
argument_list|(
name|executeableNodes
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|NonLiteral
name|exeutableNode
range|:
name|executeableNodes
control|)
block|{
name|executable
operator|.
name|add
argument_list|(
name|getExecution
argument_list|(
name|exeutableNode
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|executable
operator|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|executable
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//do not mark engines as executeable if chain already failed
name|this
operator|.
name|executable
operator|=
name|Collections
operator|.
name|emptySet
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|isFinished
argument_list|()
operator|&&
operator|!
name|isFailed
argument_list|()
condition|)
block|{
comment|//mark the execution process as completed
name|setExecutionCompleted
argument_list|(
name|executionMetadata
argument_list|,
name|chainExecutionNode
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Getter for the executable nodes.      * @return the nodes that can be executed next based on the completed and      * currently running engines.      */
specifier|public
name|Set
argument_list|<
name|NonLiteral
argument_list|>
name|getExecutable
parameter_list|()
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"++ r: {}"
argument_list|,
literal|"getExecutable"
argument_list|)
expr_stmt|;
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|">> r: {}"
argument_list|,
literal|"getExecutable"
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|executable
return|;
block|}
finally|finally
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"<< r: {}:{}"
argument_list|,
literal|"getExecutable"
argument_list|,
name|executable
argument_list|)
expr_stmt|;
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Returns true if this chain has finished.      * @return if this enhancement job is finished.      */
specifier|public
name|boolean
name|isFinished
parameter_list|()
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"++ r: {}"
argument_list|,
literal|"isFinished"
argument_list|)
expr_stmt|;
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|log
operator|.
name|debug
argument_list|(
literal|">> r: {}"
argument_list|,
literal|"isFinished"
argument_list|)
expr_stmt|;
return|return
name|executable
operator|.
name|isEmpty
argument_list|()
operator|&&
name|running
operator|.
name|isEmpty
argument_list|()
return|;
block|}
finally|finally
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"<< r: {}"
argument_list|,
literal|"isFinished"
argument_list|)
expr_stmt|;
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|setFailed
parameter_list|(
name|NonLiteral
name|execution
parameter_list|,
name|EnhancementEngine
name|engine
parameter_list|,
name|Exception
name|exception
parameter_list|)
block|{
if|if
condition|(
name|execution
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed em:Execution instance MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|NonLiteral
name|executionNode
init|=
name|getExecutionNode
argument_list|(
name|execution
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|optional
init|=
name|isOptional
argument_list|(
name|executionPlan
argument_list|,
name|executionNode
argument_list|)
decl_stmt|;
specifier|final
name|String
name|engineName
init|=
name|getEngine
argument_list|(
name|executionPlan
argument_list|,
name|executionNode
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"++ w: {}: {}"
argument_list|,
literal|"setFailed"
argument_list|,
name|ExecutionPlanHelper
operator|.
name|getEngine
argument_list|(
name|executionPlan
argument_list|,
name|executionNode
argument_list|)
argument_list|)
expr_stmt|;
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|log
operator|.
name|debug
argument_list|(
literal|">> w: {}: {}"
argument_list|,
literal|"setFailed"
argument_list|,
name|ExecutionPlanHelper
operator|.
name|getEngine
argument_list|(
name|executionPlan
argument_list|,
name|executionNode
argument_list|)
argument_list|)
expr_stmt|;
name|StringBuilder
name|message
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|message
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unable to process ContentItem '%s' with "
operator|+
literal|"Enhancement Engine '%s' because the engine "
argument_list|,
name|contentItem
operator|.
name|getUri
argument_list|()
argument_list|,
name|engineName
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|engine
operator|==
literal|null
condition|)
block|{
name|message
operator|.
name|append
argument_list|(
literal|"is currently not active"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|message
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"was unable to process the content "
operator|+
literal|"(Engine class: %s)"
argument_list|,
name|engine
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exception
operator|!=
literal|null
condition|)
block|{
name|message
operator|.
name|append
argument_list|(
literal|"(Reason: "
argument_list|)
operator|.
name|append
argument_list|(
name|exception
operator|.
name|getMessage
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
name|message
operator|.
name|append
argument_list|(
literal|'!'
argument_list|)
expr_stmt|;
name|setNodeCompleted
argument_list|(
name|executionNode
argument_list|)
expr_stmt|;
comment|//update the internal state
comment|//set this execution to failed
name|setExecutionFaild
argument_list|(
name|executionMetadata
argument_list|,
name|execution
argument_list|,
name|message
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|//if not optional and the chain is not yet failed
if|if
condition|(
operator|!
name|optional
operator|&&
operator|!
name|isExecutionFailed
argument_list|(
name|executionMetadata
argument_list|,
name|chainExecutionNode
argument_list|)
condition|)
block|{
comment|//set also the whole chain to faild!
name|String
name|chainMessage
init|=
name|String
operator|.
name|format
argument_list|(
literal|"Enhancement Chain failed because of required Engine '%s' failed "
operator|+
literal|"with Message: %s"
argument_list|,
name|engineName
argument_list|,
name|message
argument_list|)
decl_stmt|;
name|setExecutionFaild
argument_list|(
name|executionMetadata
argument_list|,
name|chainExecutionNode
argument_list|,
name|chainMessage
argument_list|)
expr_stmt|;
name|error
operator|=
name|exception
expr_stmt|;
comment|//this member stores the exception to allow
comment|//re-throwing by the EnhancementJobManager.
block|}
block|}
finally|finally
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"<< w: {}: {}"
argument_list|,
literal|"setFailed"
argument_list|,
name|ExecutionPlanHelper
operator|.
name|getEngine
argument_list|(
name|executionPlan
argument_list|,
name|executionNode
argument_list|)
argument_list|)
expr_stmt|;
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Getter for the failed state. Note that EnhancementJobs might be already      * failed but not yet finished.      * @return if the EnhancementJob has failed or not.      */
specifier|public
name|boolean
name|isFailed
parameter_list|()
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"++ r: {}"
argument_list|,
literal|"isFailed"
argument_list|)
expr_stmt|;
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|log
operator|.
name|debug
argument_list|(
literal|">> r: {}"
argument_list|,
literal|"isFailed"
argument_list|)
expr_stmt|;
return|return
name|isExecutionFailed
argument_list|(
name|executionMetadata
argument_list|,
name|chainExecutionNode
argument_list|)
return|;
block|}
finally|finally
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"<< r: {}"
argument_list|,
literal|"isFailed"
argument_list|)
expr_stmt|;
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|contentItem
operator|.
name|getUri
argument_list|()
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|o
operator|instanceof
name|EnhancementJob
operator|&&
name|contentItem
operator|.
name|getUri
argument_list|()
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|EnhancementJob
operator|)
name|o
operator|)
operator|.
name|contentItem
operator|.
name|getUri
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"EnhancementJob for ContentItem "
operator|+
name|contentItem
operator|.
name|getUri
argument_list|()
return|;
block|}
comment|/**      * if {@link #isFailed()} this may contain the {@link Exception} that caused      * the enhancement job to fail.       * @return The Exception or<code>null</code> if no exception is available      */
specifier|public
name|Exception
name|getError
parameter_list|()
block|{
return|return
name|error
return|;
block|}
specifier|public
name|String
name|getErrorMessage
parameter_list|()
block|{
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|getString
argument_list|(
name|executionMetadata
argument_list|,
name|chainExecutionNode
argument_list|,
name|ExecutionMetadata
operator|.
name|STATUS_MESSAGE
argument_list|)
return|;
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Getter for the ExecutionMetadata.      * @return the execution metadata.      */
specifier|public
name|MGraph
name|getExecutionMetadata
parameter_list|()
block|{
return|return
name|executionMetadata
return|;
block|}
comment|/**      * Marks the execution of the enhancement process as started. In other      * words this sets the status of the 'em:ChainExecution' instance that      * 'em:enhances' the {@link ContentItem} to       * {@link ExecutionMetadata#STATUS_IN_PROGRESS}      */
specifier|public
name|void
name|startProcessing
parameter_list|()
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|setExecutionInProgress
argument_list|(
name|executionMetadata
argument_list|,
name|chainExecutionNode
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

