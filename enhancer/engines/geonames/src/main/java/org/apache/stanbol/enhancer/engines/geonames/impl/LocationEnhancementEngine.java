begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|geonames
operator|.
name|impl
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|NamespaceEnum
operator|.
name|dbpedia_ont
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|OntologicalClasses
operator|.
name|DBPEDIA_PLACE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|DC_RELATION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|DC_REQUIRES
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|DC_TYPE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|ENHANCER_CONFIDENCE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|ENHANCER_ENTITY_LABEL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|ENHANCER_ENTITY_REFERENCE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|ENHANCER_ENTITY_TYPE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|ENHANCER_SELECTED_TEXT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
operator|.
name|RDF_TYPE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|TechnicalClasses
operator|.
name|ENHANCER_TEXTANNOTATION
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Dictionary
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|LiteralFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|MGraph
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|NonLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|Triple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|UriRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|impl
operator|.
name|TripleImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Component
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Property
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Reference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|felix
operator|.
name|scr
operator|.
name|annotations
operator|.
name|Service
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|geonames
operator|.
name|impl
operator|.
name|GeonamesAPIWrapper
operator|.
name|SearchRequestPropertyEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|ContentItem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|EngineException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|EnhancementEngine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|ServiceProperties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|helper
operator|.
name|EnhancementEngineHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|impl
operator|.
name|AbstractEnhancementEngine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|NamespaceEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|stanboltools
operator|.
name|offline
operator|.
name|OnlineMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|framework
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|service
operator|.
name|cm
operator|.
name|ConfigurationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|service
operator|.
name|component
operator|.
name|ComponentContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_class
annotation|@
name|Component
argument_list|(
name|immediate
operator|=
literal|true
argument_list|,
name|metatype
operator|=
literal|true
argument_list|)
annotation|@
name|Service
annotation|@
name|Properties
argument_list|(
name|value
operator|=
block|{
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|EnhancementEngine
operator|.
name|PROPERTY_NAME
argument_list|,
name|value
operator|=
name|LocationEnhancementEngine
operator|.
name|DEFAULT_ENGINE_NAME
argument_list|)
block|,
annotation|@
name|Property
argument_list|(
name|name
operator|=
name|Constants
operator|.
name|SERVICE_RANKING
argument_list|,
name|intValue
operator|=
name|LocationEnhancementEngine
operator|.
name|DEFAULT_SERVICE_RANKING
argument_list|)
block|}
argument_list|)
specifier|public
class|class
name|LocationEnhancementEngine
extends|extends
name|AbstractEnhancementEngine
argument_list|<
name|IOException
argument_list|,
name|RuntimeException
argument_list|>
implements|implements
name|EnhancementEngine
implements|,
name|ServiceProperties
block|{
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_ENGINE_NAME
init|=
literal|"geonames"
decl_stmt|;
comment|/**      * Default value for the {@link Constants#SERVICE_RANKING} used by this engine.      * This is a negative value to allow easy replacement by this engine depending      * to a remote service with one that does not have this requirement      */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_SERVICE_RANKING
init|=
operator|-
literal|100
decl_stmt|;
comment|/**      * The default value for the Execution of this Engine. Currently set to      * {@link ServiceProperties#ORDERING_EXTRACTION_ENHANCEMENT}      */
specifier|public
specifier|static
specifier|final
name|Integer
name|defaultOrder
init|=
name|ORDERING_EXTRACTION_ENHANCEMENT
decl_stmt|;
comment|/**      * This maps geonames.org feature classes to dbpedia.org ontology classes      */
specifier|public
specifier|static
specifier|final
name|Map
argument_list|<
name|FeatureClass
argument_list|,
name|Collection
argument_list|<
name|UriRef
argument_list|>
argument_list|>
name|FEATURE_CLASS_CONCEPT_MAPPINGS
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Collection
argument_list|<
name|UriRef
argument_list|>
argument_list|>
name|FEATURE_TYPE_CONCEPT_MAPPINGS
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|LocationEnhancementEngine
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * Default value for minimum scores of search results are added to the      * metadata of the parsed ContentItem      */
specifier|private
specifier|static
specifier|final
name|double
name|DEFAULT_MIN_SCORE
init|=
literal|0.33
decl_stmt|;
annotation|@
name|Property
argument_list|(
name|doubleValue
operator|=
name|DEFAULT_MIN_SCORE
argument_list|)
specifier|public
specifier|static
specifier|final
name|String
name|MIN_SCORE
init|=
literal|"org.apache.stanbol.enhancer.engines.geonames.locationEnhancementEngine.min-score"
decl_stmt|;
comment|/**      * Default values for the number of results returned by search requests      * to the geonames.org web service      */
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_MAX_LOCATION_ENHANCEMENTS
init|=
literal|3
decl_stmt|;
annotation|@
name|Property
argument_list|(
name|intValue
operator|=
name|DEFAULT_MAX_LOCATION_ENHANCEMENTS
argument_list|)
specifier|public
specifier|static
specifier|final
name|String
name|MAX_LOCATION_ENHANCEMENTS
init|=
literal|"org.apache.stanbol.enhancer.engines.geonames.locationEnhancementEngine.max-location-enhancements"
decl_stmt|;
comment|/**      * Default value for the minimum score of search results used to also add      * the hierarchy      */
specifier|private
specifier|static
specifier|final
name|double
name|DEFAULT_MIN_HIERARCHY_SCORE
init|=
literal|0.70
decl_stmt|;
annotation|@
name|Property
argument_list|(
name|doubleValue
operator|=
name|DEFAULT_MIN_HIERARCHY_SCORE
argument_list|)
specifier|public
specifier|static
specifier|final
name|String
name|MIN_HIERARCHY_SCORE
init|=
literal|"org.apache.stanbol.enhancer.engines.geonames.locationEnhancementEngine.min-hierarchy-score"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|UriRef
name|CONCEPT_GEONAMES_FEATURE
init|=
operator|new
name|UriRef
argument_list|(
name|NamespaceEnum
operator|.
name|geonames
operator|.
name|toString
argument_list|()
operator|+
literal|"Feature"
argument_list|)
decl_stmt|;
annotation|@
name|Property
argument_list|(
name|value
operator|=
name|GeonamesAPIWrapper
operator|.
name|DEFAULT_GEONAMES_ORG_WEBSERVICE_URL
argument_list|)
specifier|public
specifier|static
specifier|final
name|String
name|GEONAMES_SERVER_URL
init|=
literal|"org.apache.stanbol.enhancer.engines.geonames.locationEnhancementEngine.serverURL"
decl_stmt|;
comment|/**      * The useage of the anonymous server is deactivated by default because it      * is often overloaded and therefore causes randomly errors.      */
annotation|@
name|Property
argument_list|(
name|boolValue
operator|=
literal|false
argument_list|)
specifier|public
specifier|static
specifier|final
name|String
name|GEONAMES_ANONYMOUS_SERVICE_STATE
init|=
literal|"org.apache.stanbol.enhancer.engines.geonames.locationEnhancementEngine.allow-anonymous-service"
decl_stmt|;
annotation|@
name|Property
specifier|public
specifier|static
specifier|final
name|String
name|GEONAMES_USERNAME
init|=
literal|"org.apache.stanbol.enhancer.engines.geonames.locationEnhancementEngine.username"
decl_stmt|;
annotation|@
name|Property
specifier|public
specifier|static
specifier|final
name|String
name|GEONAMES_TOKEN
init|=
literal|"org.apache.stanbol.enhancer.engines.geonames.locationEnhancementEngine.token"
decl_stmt|;
comment|/**      * Only activate this engine in online mode      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
annotation|@
name|Reference
specifier|private
name|OnlineMode
name|onlineMode
decl_stmt|;
comment|/**      * The geonames.org API wrapper used to make service requests      */
specifier|protected
name|GeonamesAPIWrapper
name|geonamesService
decl_stmt|;
static|static
block|{
name|Map
argument_list|<
name|FeatureClass
argument_list|,
name|Collection
argument_list|<
name|UriRef
argument_list|>
argument_list|>
name|mappings
init|=
operator|new
name|EnumMap
argument_list|<
name|FeatureClass
argument_list|,
name|Collection
argument_list|<
name|UriRef
argument_list|>
argument_list|>
argument_list|(
name|FeatureClass
operator|.
name|class
argument_list|)
decl_stmt|;
comment|//first add the concepts of the geonames ontology
for|for
control|(
name|FeatureClass
name|fc
range|:
name|FeatureClass
operator|.
name|values
argument_list|()
control|)
block|{
name|List
argument_list|<
name|UriRef
argument_list|>
name|conceptMappings
init|=
operator|new
name|ArrayList
argument_list|<
name|UriRef
argument_list|>
argument_list|()
decl_stmt|;
name|conceptMappings
operator|.
name|add
argument_list|(
name|CONCEPT_GEONAMES_FEATURE
argument_list|)
expr_stmt|;
comment|//all things are features
name|conceptMappings
operator|.
name|add
argument_list|(
name|DBPEDIA_PLACE
argument_list|)
expr_stmt|;
comment|//all things are dbpedia places
name|mappings
operator|.
name|put
argument_list|(
name|fc
argument_list|,
name|conceptMappings
argument_list|)
expr_stmt|;
block|}
comment|//now add additional mappings to the dbpedia Ontology
name|UriRef
name|populatedPlace
init|=
operator|new
name|UriRef
argument_list|(
name|dbpedia_ont
operator|+
literal|"PopulatedPlace"
argument_list|)
decl_stmt|;
name|mappings
operator|.
name|get
argument_list|(
name|FeatureClass
operator|.
name|P
argument_list|)
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|populatedPlace
argument_list|,
operator|new
name|UriRef
argument_list|(
name|dbpedia_ont
operator|+
literal|"Settlement"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|mappings
operator|.
name|get
argument_list|(
name|FeatureClass
operator|.
name|A
argument_list|)
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|populatedPlace
argument_list|,
operator|new
name|UriRef
argument_list|(
name|dbpedia_ont
operator|+
literal|"AdministrativeRegion"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|mappings
operator|.
name|get
argument_list|(
name|FeatureClass
operator|.
name|H
argument_list|)
operator|.
name|add
argument_list|(
operator|new
name|UriRef
argument_list|(
name|dbpedia_ont
operator|+
literal|"BodyOfWater"
argument_list|)
argument_list|)
expr_stmt|;
name|mappings
operator|.
name|get
argument_list|(
name|FeatureClass
operator|.
name|R
argument_list|)
operator|.
name|add
argument_list|(
operator|new
name|UriRef
argument_list|(
name|dbpedia_ont
operator|+
literal|"Infrastructure"
argument_list|)
argument_list|)
expr_stmt|;
name|mappings
operator|.
name|get
argument_list|(
name|FeatureClass
operator|.
name|S
argument_list|)
operator|.
name|add
argument_list|(
operator|new
name|UriRef
argument_list|(
name|dbpedia_ont
operator|+
literal|"Building"
argument_list|)
argument_list|)
expr_stmt|;
name|mappings
operator|.
name|get
argument_list|(
name|FeatureClass
operator|.
name|T
argument_list|)
operator|.
name|add
argument_list|(
operator|new
name|UriRef
argument_list|(
name|dbpedia_ont
operator|+
literal|"Mountain"
argument_list|)
argument_list|)
expr_stmt|;
comment|//now write the unmodifiable static final constant
name|FEATURE_CLASS_CONCEPT_MAPPINGS
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|mappings
argument_list|)
expr_stmt|;
comment|//Mappings for known FeatureTypes
name|Map
argument_list|<
name|String
argument_list|,
name|Collection
argument_list|<
name|UriRef
argument_list|>
argument_list|>
name|typeMappings
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Collection
argument_list|<
name|UriRef
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|UriRef
argument_list|>
name|lakeTypes
init|=
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|UriRef
argument_list|(
name|dbpedia_ont
operator|+
literal|"Lake"
argument_list|)
argument_list|)
decl_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.LK"
argument_list|,
name|lakeTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.LKS"
argument_list|,
name|lakeTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.LKI"
argument_list|,
name|lakeTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.LKN"
argument_list|,
name|lakeTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.LK"
argument_list|,
name|lakeTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.LKO"
argument_list|,
name|lakeTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.LKX"
argument_list|,
name|lakeTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.LKC"
argument_list|,
name|lakeTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.LKNI"
argument_list|,
name|lakeTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.LKSI"
argument_list|,
name|lakeTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.LKOI"
argument_list|,
name|lakeTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.LKSN"
argument_list|,
name|lakeTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.LKSC"
argument_list|,
name|lakeTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.LKSB"
argument_list|,
name|lakeTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.LKSNI"
argument_list|,
name|lakeTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.RSV"
argument_list|,
name|lakeTypes
argument_list|)
expr_stmt|;
name|UriRef
name|stream
init|=
operator|new
name|UriRef
argument_list|(
name|dbpedia_ont
operator|+
literal|" Stream"
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|UriRef
argument_list|>
name|canalTypes
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|stream
argument_list|,
operator|new
name|UriRef
argument_list|(
name|dbpedia_ont
operator|+
literal|"Canal"
argument_list|)
argument_list|)
decl_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.CNL"
argument_list|,
name|canalTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.CNLA"
argument_list|,
name|canalTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.CNLB"
argument_list|,
name|canalTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.CNLI"
argument_list|,
name|canalTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.CNLD"
argument_list|,
name|canalTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.CNLSB"
argument_list|,
name|canalTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.CNLN"
argument_list|,
name|canalTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.CNLQ"
argument_list|,
name|canalTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.CNLX"
argument_list|,
name|canalTypes
argument_list|)
expr_stmt|;
name|Collection
argument_list|<
name|UriRef
argument_list|>
name|riverTypes
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|stream
argument_list|,
operator|new
name|UriRef
argument_list|(
name|dbpedia_ont
operator|+
literal|"River"
argument_list|)
argument_list|)
decl_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.STM"
argument_list|,
name|riverTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.STMI"
argument_list|,
name|riverTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.STMB"
argument_list|,
name|riverTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.STMD"
argument_list|,
name|riverTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.STMM"
argument_list|,
name|riverTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.STMA"
argument_list|,
name|riverTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.STMC"
argument_list|,
name|riverTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.STMX"
argument_list|,
name|riverTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.STMIX"
argument_list|,
name|riverTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.STMH"
argument_list|,
name|riverTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.STMSB"
argument_list|,
name|riverTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.STMQ"
argument_list|,
name|riverTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.STMS"
argument_list|,
name|riverTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.STM"
argument_list|,
name|riverTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.STM"
argument_list|,
name|riverTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.STM"
argument_list|,
name|riverTypes
argument_list|)
expr_stmt|;
name|Collection
argument_list|<
name|UriRef
argument_list|>
name|caveTypes
init|=
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|UriRef
argument_list|(
name|dbpedia_ont
operator|+
literal|"Cave"
argument_list|)
argument_list|)
decl_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"H.LKSB"
argument_list|,
name|caveTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"R.TNLN"
argument_list|,
name|caveTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"S.CAVE"
argument_list|,
name|caveTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"S.BUR"
argument_list|,
name|caveTypes
argument_list|)
expr_stmt|;
name|Collection
argument_list|<
name|UriRef
argument_list|>
name|countryTypes
init|=
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|UriRef
argument_list|(
name|dbpedia_ont
operator|+
literal|"Country"
argument_list|)
argument_list|)
decl_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"A.PCLI"
argument_list|,
name|countryTypes
argument_list|)
expr_stmt|;
name|UriRef
name|settlement
init|=
operator|new
name|UriRef
argument_list|(
name|dbpedia_ont
operator|+
literal|"Settlement"
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|UriRef
argument_list|>
name|cityTypes
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|settlement
argument_list|,
operator|new
name|UriRef
argument_list|(
name|dbpedia_ont
operator|+
literal|"City"
argument_list|)
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|UriRef
argument_list|>
name|villageTypes
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|settlement
argument_list|,
operator|new
name|UriRef
argument_list|(
name|dbpedia_ont
operator|+
literal|"Village"
argument_list|)
argument_list|)
decl_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"P.PPLG"
argument_list|,
name|cityTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"P.PPLC"
argument_list|,
name|cityTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"P.PPLF"
argument_list|,
name|villageTypes
argument_list|)
expr_stmt|;
name|typeMappings
operator|.
name|put
argument_list|(
literal|"P.PPLA"
argument_list|,
name|cityTypes
argument_list|)
expr_stmt|;
comment|//write the mappings as unmodifiable map the the static final constant
name|FEATURE_TYPE_CONCEPT_MAPPINGS
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|typeMappings
argument_list|)
expr_stmt|;
block|}
specifier|private
name|Integer
name|maxLocationEnhancements
decl_stmt|;
specifier|private
name|Double
name|minScore
decl_stmt|;
specifier|private
name|Double
name|minHierarchyScore
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|protected
name|void
name|activate
parameter_list|(
name|ComponentContext
name|ce
parameter_list|)
throws|throws
name|IOException
throws|,
name|ConfigurationException
block|{
name|super
operator|.
name|activate
argument_list|(
name|ce
argument_list|)
expr_stmt|;
name|Dictionary
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|properties
init|=
name|ce
operator|.
name|getProperties
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"activating ..."
argument_list|)
expr_stmt|;
comment|//NOTE: The type of the values is ensured by the default values in the
comment|//      @Property annotations e.g. doubleValue -> Double
name|setMinScore
argument_list|(
operator|(
name|Double
operator|)
name|properties
operator|.
name|get
argument_list|(
name|MIN_SCORE
argument_list|)
argument_list|)
expr_stmt|;
name|setMaxLocationEnhancements
argument_list|(
operator|(
name|Integer
operator|)
name|properties
operator|.
name|get
argument_list|(
name|MAX_LOCATION_ENHANCEMENTS
argument_list|)
argument_list|)
expr_stmt|;
name|setMinHierarchyScore
argument_list|(
operator|(
name|Double
operator|)
name|properties
operator|.
name|get
argument_list|(
name|MIN_HIERARCHY_SCORE
argument_list|)
argument_list|)
expr_stmt|;
comment|//parse geonames.org service specific configuration
name|Object
name|value
init|=
name|properties
operator|.
name|get
argument_list|(
name|GEONAMES_ANONYMOUS_SERVICE_STATE
argument_list|)
decl_stmt|;
name|boolean
name|allowAnonymous
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Boolean
condition|)
block|{
name|allowAnonymous
operator|=
operator|(
operator|(
name|Boolean
operator|)
name|value
operator|)
operator|.
name|booleanValue
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|allowAnonymous
operator|=
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|allowAnonymous
operator|=
literal|false
expr_stmt|;
block|}
name|String
name|serverUrl
init|=
operator|(
name|String
operator|)
name|properties
operator|.
name|get
argument_list|(
name|GEONAMES_SERVER_URL
argument_list|)
decl_stmt|;
name|String
name|userName
init|=
operator|(
name|String
operator|)
name|properties
operator|.
name|get
argument_list|(
name|GEONAMES_USERNAME
argument_list|)
decl_stmt|;
name|String
name|token
init|=
operator|(
name|String
operator|)
name|properties
operator|.
name|get
argument_list|(
name|GEONAMES_TOKEN
argument_list|)
decl_stmt|;
if|if
condition|(
name|userName
operator|==
literal|null
operator|||
name|userName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|allowAnonymous
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Anonymous Access is enabled and no User-Name is configured."
operator|+
literal|"Ignore configred server URL {} and will use the anonymous server {}"
argument_list|,
name|serverUrl
argument_list|,
name|GeonamesAPIWrapper
operator|.
name|ANONYMOUS_GEONAMES_ORG_WEBSERVICE_URL
argument_list|)
expr_stmt|;
name|serverUrl
operator|=
name|GeonamesAPIWrapper
operator|.
name|ANONYMOUS_GEONAMES_ORG_WEBSERVICE_URL
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|GEONAMES_USERNAME
argument_list|,
literal|"A User-Name MUST be configured if anonymous access to 'http://ws.geonames.org' is deactivated"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|token
operator|==
literal|null
operator|||
name|token
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|GEONAMES_TOKEN
argument_list|,
literal|"The Token MUST NOT be NULL nor empty if a User-Name is defined!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|serverUrl
operator|==
literal|null
operator|||
name|serverUrl
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"No ServerUrl is configured. Will use the default {}"
argument_list|,
name|GeonamesAPIWrapper
operator|.
name|DEFAULT_GEONAMES_ORG_WEBSERVICE_URL
argument_list|)
expr_stmt|;
name|serverUrl
operator|=
name|GeonamesAPIWrapper
operator|.
name|DEFAULT_GEONAMES_ORG_WEBSERVICE_URL
expr_stmt|;
block|}
block|}
name|log
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"create Geonames Client for server: %s and user: %s (token not logged)"
argument_list|,
name|serverUrl
argument_list|,
name|userName
argument_list|)
argument_list|)
expr_stmt|;
name|geonamesService
operator|=
operator|new
name|GeonamesAPIWrapper
argument_list|(
name|serverUrl
argument_list|,
name|userName
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|deactivate
parameter_list|(
name|ComponentContext
name|ce
parameter_list|)
block|{
name|super
operator|.
name|deactivate
argument_list|(
name|ce
argument_list|)
expr_stmt|;
name|setMinScore
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|setMaxLocationEnhancements
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|setMinHierarchyScore
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|geonamesService
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|canEnhance
parameter_list|(
name|ContentItem
name|ci
parameter_list|)
throws|throws
name|EngineException
block|{
return|return
name|ENHANCE_SYNCHRONOUS
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|computeEnhancements
parameter_list|(
name|ContentItem
name|ci
parameter_list|)
throws|throws
name|EngineException
block|{
name|UriRef
name|contentItemId
init|=
name|ci
operator|.
name|getUri
argument_list|()
decl_stmt|;
name|MGraph
name|graph
init|=
name|ci
operator|.
name|getMetadata
argument_list|()
decl_stmt|;
name|LiteralFactory
name|literalFactory
init|=
name|LiteralFactory
operator|.
name|getInstance
argument_list|()
decl_stmt|;
comment|//get all the textAnnotations
comment|/*          * this Map holds the name as key and all the text annotations of          * dc:type dbpedia:Place that select this name as value          * this map is used to avoid multiple lookups for text annotations          * selecting the same name.          */
name|Map
argument_list|<
name|String
argument_list|,
name|Collection
argument_list|<
name|NonLiteral
argument_list|>
argument_list|>
name|name2placeEnhancementMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Collection
argument_list|<
name|NonLiteral
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Triple
argument_list|>
name|iterator
init|=
name|graph
operator|.
name|filter
argument_list|(
literal|null
argument_list|,
name|DC_TYPE
argument_list|,
name|DBPEDIA_PLACE
argument_list|)
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|NonLiteral
name|placeEnhancement
init|=
name|iterator
operator|.
name|next
argument_list|()
operator|.
name|getSubject
argument_list|()
decl_stmt|;
comment|//the enhancement annotating an place
comment|//this can still be an TextAnnotation of an EntityAnnotation
comment|//so we need to filter TextAnnotation
name|Triple
name|isTextAnnotation
init|=
operator|new
name|TripleImpl
argument_list|(
name|placeEnhancement
argument_list|,
name|RDF_TYPE
argument_list|,
name|ENHANCER_TEXTANNOTATION
argument_list|)
decl_stmt|;
if|if
condition|(
name|graph
operator|.
name|contains
argument_list|(
name|isTextAnnotation
argument_list|)
condition|)
block|{
comment|//now get the name
name|String
name|name
init|=
name|EnhancementEngineHelper
operator|.
name|getString
argument_list|(
name|graph
argument_list|,
name|placeEnhancement
argument_list|,
name|ENHANCER_SELECTED_TEXT
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to process TextAnnotation "
operator|+
name|placeEnhancement
operator|+
literal|" because property"
operator|+
name|ENHANCER_SELECTED_TEXT
operator|+
literal|" is not present"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Collection
argument_list|<
name|NonLiteral
argument_list|>
name|placeEnhancements
init|=
name|name2placeEnhancementMap
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|placeEnhancements
operator|==
literal|null
condition|)
block|{
name|placeEnhancements
operator|=
operator|new
name|ArrayList
argument_list|<
name|NonLiteral
argument_list|>
argument_list|()
expr_stmt|;
name|name2placeEnhancementMap
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|placeEnhancements
argument_list|)
expr_stmt|;
block|}
name|placeEnhancements
operator|.
name|add
argument_list|(
name|placeEnhancement
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//TODO: if we also ant to process EntityAnnotations with the dc:type dbpedia:Place
comment|//      than we need to parse the name based on the enhancer:entity-name property
block|}
block|}
comment|//Now we do have all the names we need to lookup
name|Map
argument_list|<
name|SearchRequestPropertyEnum
argument_list|,
name|Collection
argument_list|<
name|String
argument_list|>
argument_list|>
name|requestParams
init|=
operator|new
name|EnumMap
argument_list|<
name|SearchRequestPropertyEnum
argument_list|,
name|Collection
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|(
name|SearchRequestPropertyEnum
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|getMaxLocationEnhancements
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|requestParams
operator|.
name|put
argument_list|(
name|SearchRequestPropertyEnum
operator|.
name|maxRows
argument_list|,
name|Collections
operator|.
name|singleton
argument_list|(
name|getMaxLocationEnhancements
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Collection
argument_list|<
name|NonLiteral
argument_list|>
argument_list|>
name|entry
range|:
name|name2placeEnhancementMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|List
argument_list|<
name|Toponym
argument_list|>
name|results
decl_stmt|;
try|try
block|{
name|requestParams
operator|.
name|put
argument_list|(
name|SearchRequestPropertyEnum
operator|.
name|name
argument_list|,
name|Collections
operator|.
name|singleton
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|results
operator|=
name|geonamesService
operator|.
name|searchToponyms
argument_list|(
name|requestParams
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|/*                      * TODO: Review if it makes sense to catch here for each name, or                      * to catch the whole loop.                      * This depends if single requests can result in Exceptions                      * (e.g. because of encoding problems) or if usually Exceptions                      * are thrown because of general things like connection issues                      * or service unavailability.                      */
throw|throw
operator|new
name|EngineException
argument_list|(
name|this
argument_list|,
name|ci
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|results
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Toponym
name|result
range|:
name|results
control|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"process result {} {}"
argument_list|,
name|result
operator|.
name|getGeoNameId
argument_list|()
argument_list|,
name|result
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|Double
name|score
init|=
name|getToponymScore
argument_list|(
name|result
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"> score {}"
argument_list|,
name|score
argument_list|)
expr_stmt|;
if|if
condition|(
name|score
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|score
operator|<
name|minScore
condition|)
block|{
comment|//if score is lower than the under bound, than stop
break|break;
block|}
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"NULL returned as Score for "
operator|+
name|result
operator|.
name|getGeoNameId
argument_list|()
operator|+
literal|" "
operator|+
name|result
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
comment|/*                          * NOTE: If score is not present all suggestions are                          * added as enhancements to the metadata of the content                          * item.                          */
block|}
comment|//write the enhancement!
name|NonLiteral
name|locationEnhancement
init|=
name|writeEntityEnhancement
argument_list|(
name|contentItemId
argument_list|,
name|graph
argument_list|,
name|literalFactory
argument_list|,
name|result
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"> {}>= {}"
argument_list|,
name|score
argument_list|,
name|minHierarchyScore
argument_list|)
expr_stmt|;
if|if
condition|(
name|score
operator|!=
literal|null
operator|&&
name|score
operator|>=
name|minHierarchyScore
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"> getHierarchy for {} {}"
argument_list|,
name|result
operator|.
name|getGeoNameId
argument_list|()
argument_list|,
name|result
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
comment|//get the hierarchy
try|try
block|{
name|Iterator
argument_list|<
name|Toponym
argument_list|>
name|hierarchy
init|=
name|getHierarchy
argument_list|(
name|result
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|hierarchy
operator|.
name|hasNext
argument_list|()
condition|;
name|level
operator|++
control|)
block|{
name|Toponym
name|hierarchyEntry
init|=
name|hierarchy
operator|.
name|next
argument_list|()
decl_stmt|;
comment|//TODO: filter the interesting entries
comment|//  maybe add an configuration
if|if
condition|(
name|level
operator|==
literal|0
condition|)
block|{
comment|//Mother earth -> ignore
continue|continue;
block|}
comment|//write it as dependent to the locationEnhancement
if|if
condition|(
name|result
operator|.
name|getGeoNameId
argument_list|()
operator|!=
name|hierarchyEntry
operator|.
name|getGeoNameId
argument_list|()
condition|)
block|{
comment|//TODO: add additional checks based on possible
comment|//      configuration here!
name|log
operator|.
name|debug
argument_list|(
literal|"    - write hierarchy {} {}"
argument_list|,
name|hierarchyEntry
operator|.
name|getGeoNameId
argument_list|()
argument_list|,
name|hierarchyEntry
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
comment|/*                                      * The hierarchy service dose not provide a score, because it would be 1.0                                      * so we need to set the score to this value.                                      * Currently is is set to the value of the suggested entry                                      */
name|writeEntityEnhancement
argument_list|(
name|contentItemId
argument_list|,
name|graph
argument_list|,
name|literalFactory
argument_list|,
name|hierarchyEntry
argument_list|,
literal|null
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|locationEnhancement
argument_list|)
argument_list|,
name|score
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to get Hierarchy for "
operator|+
name|result
operator|.
name|getGeoNameId
argument_list|()
operator|+
literal|" "
operator|+
name|result
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
comment|/**      * Getter for the socre in a range from [0..1]<p>      * NOTE (2010.11.16, rw): GeoNames previously returned the score in the      * range from [0..1]. It looks like that up from now they use the      * range [0..100]. Therefore I created this method to make the necessary      * adaptation.      * see also http://code.google.com/p/iks-project/issues/detail?id=89      *      * @param toponym the toponym      *      * @return the score in a range [0..1]      */
specifier|private
name|Double
name|getToponymScore
parameter_list|(
name|Toponym
name|toponym
parameter_list|)
block|{
return|return
name|toponym
operator|.
name|getScore
argument_list|()
operator|==
literal|null
condition|?
literal|null
else|:
name|toponym
operator|.
name|getScore
argument_list|()
operator|/
literal|100
return|;
block|}
comment|/**      * Returns the hierarchy for the parsed toponym. The planet Earth will be      * at the first position of the list and the parsed toponum represents the      * last element of the list.      *      * @param toponym the toponym      *      * @return The list containing the hierarchy      *      * @throws Exception on any error while accessing the webservice      */
specifier|protected
name|Collection
argument_list|<
name|Toponym
argument_list|>
name|getHierarchy
parameter_list|(
name|Toponym
name|toponym
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|geonamesService
operator|.
name|getHierarchy
argument_list|(
name|toponym
operator|.
name|getGeoNameId
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Writes an entity enhancement for the content item in the parsed graph      * based on the parsed toponym.      *      * @param contentItemId The id of the contentItem      * @param graph The graph used to write the triples      * @param literalFactory the literal factory used to create literals      * @param toponym the toponym      * @param relatedEnhancements related enhancements      * @param requiresEnhancements required enhancements      * @param defaultScore the score used as default id not present. This is      * used to parse the score of the Toponym if this method is used to add a      * parent Toponym.      *      * @return The UriRef of the created entity enhancement      */
specifier|private
name|UriRef
name|writeEntityEnhancement
parameter_list|(
name|UriRef
name|contentItemId
parameter_list|,
name|MGraph
name|graph
parameter_list|,
name|LiteralFactory
name|literalFactory
parameter_list|,
name|Toponym
name|toponym
parameter_list|,
name|Collection
argument_list|<
name|NonLiteral
argument_list|>
name|relatedEnhancements
parameter_list|,
name|Collection
argument_list|<
name|NonLiteral
argument_list|>
name|requiresEnhancements
parameter_list|,
name|Double
name|defaultScore
parameter_list|)
block|{
name|UriRef
name|entityRef
init|=
operator|new
name|UriRef
argument_list|(
literal|"http://sws.geonames.org/"
operator|+
name|toponym
operator|.
name|getGeoNameId
argument_list|()
operator|+
literal|'/'
argument_list|)
decl_stmt|;
name|FeatureClass
name|featureClass
init|=
name|toponym
operator|.
name|getFeatureClass
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"> featureClass "
operator|+
name|featureClass
argument_list|)
expr_stmt|;
name|UriRef
name|entityAnnotation
init|=
name|EnhancementEngineHelper
operator|.
name|createEntityEnhancement
argument_list|(
name|graph
argument_list|,
name|this
argument_list|,
name|contentItemId
argument_list|)
decl_stmt|;
comment|// first relate this entity annotation to the text annotation(s)
if|if
condition|(
name|relatedEnhancements
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|NonLiteral
name|related
range|:
name|relatedEnhancements
control|)
block|{
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|entityAnnotation
argument_list|,
name|DC_RELATION
argument_list|,
name|related
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|requiresEnhancements
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|NonLiteral
name|requires
range|:
name|requiresEnhancements
control|)
block|{
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|entityAnnotation
argument_list|,
name|DC_REQUIRES
argument_list|,
name|requires
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|entityAnnotation
argument_list|,
name|ENHANCER_ENTITY_REFERENCE
argument_list|,
name|entityRef
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"> name "
operator|+
name|toponym
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|entityAnnotation
argument_list|,
name|ENHANCER_ENTITY_LABEL
argument_list|,
name|literalFactory
operator|.
name|createTypedLiteral
argument_list|(
name|toponym
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Double
name|score
init|=
name|getToponymScore
argument_list|(
name|toponym
argument_list|)
decl_stmt|;
if|if
condition|(
name|score
operator|==
literal|null
condition|)
block|{
comment|//use the default score as fallback
name|score
operator|=
name|defaultScore
expr_stmt|;
block|}
if|if
condition|(
name|score
operator|!=
literal|null
condition|)
block|{
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|entityAnnotation
argument_list|,
name|ENHANCER_CONFIDENCE
argument_list|,
name|literalFactory
operator|.
name|createTypedLiteral
argument_list|(
name|score
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//now get all the entity types for the results
name|Set
argument_list|<
name|UriRef
argument_list|>
name|entityTypes
init|=
operator|new
name|HashSet
argument_list|<
name|UriRef
argument_list|>
argument_list|()
decl_stmt|;
comment|//first based on the feature class
name|Collection
argument_list|<
name|UriRef
argument_list|>
name|featureClassTypes
init|=
name|FEATURE_CLASS_CONCEPT_MAPPINGS
operator|.
name|get
argument_list|(
name|featureClass
argument_list|)
decl_stmt|;
if|if
condition|(
name|featureClassTypes
operator|!=
literal|null
condition|)
block|{
name|entityTypes
operator|.
name|addAll
argument_list|(
name|featureClassTypes
argument_list|)
expr_stmt|;
block|}
comment|//second for the feature Code
name|String
name|featureCode
init|=
name|toponym
operator|.
name|getFeatureCode
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|UriRef
argument_list|>
name|featureCodeTypes
init|=
name|FEATURE_TYPE_CONCEPT_MAPPINGS
operator|.
name|get
argument_list|(
name|featureCode
argument_list|)
decl_stmt|;
if|if
condition|(
name|featureCodeTypes
operator|!=
literal|null
condition|)
block|{
name|entityTypes
operator|.
name|addAll
argument_list|(
name|featureCodeTypes
argument_list|)
expr_stmt|;
block|}
comment|//third add the feature Code as additional type
name|entityTypes
operator|.
name|add
argument_list|(
operator|new
name|UriRef
argument_list|(
name|NamespaceEnum
operator|.
name|geonames
operator|+
name|featureClass
operator|.
name|name
argument_list|()
operator|+
literal|'.'
operator|+
name|featureCode
argument_list|)
argument_list|)
expr_stmt|;
comment|//finally add the type triples to the enhancement
for|for
control|(
name|UriRef
name|entityType
range|:
name|entityTypes
control|)
block|{
name|graph
operator|.
name|add
argument_list|(
operator|new
name|TripleImpl
argument_list|(
name|entityAnnotation
argument_list|,
name|ENHANCER_ENTITY_TYPE
argument_list|,
name|entityType
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|entityAnnotation
return|;
block|}
comment|/**      * Getter for the maximum number of enhancements added for a single      * TextAnnotation.      *      * @return The maximum number of location enhancements added for a single      *         text annotation      */
specifier|public
specifier|final
name|Integer
name|getMaxLocationEnhancements
parameter_list|()
block|{
return|return
name|maxLocationEnhancements
return|;
block|}
comment|/**      * Setter for the maximum number of enhancements added for a single      * TextAnnotation. If the parsed value is<code>null</code> or< 1, than the      * value is set to {@link LocationEnhancementEngine#DEFAULT_MAX_LOCATION_ENHANCEMENTS}.      *      * @param maxNumber the maximum number of enhancements added to a singel      * text annotation      */
specifier|public
specifier|final
name|void
name|setMaxLocationEnhancements
parameter_list|(
name|Integer
name|maxNumber
parameter_list|)
block|{
if|if
condition|(
name|maxNumber
operator|==
literal|null
condition|)
block|{
name|maxNumber
operator|=
name|DEFAULT_MAX_LOCATION_ENHANCEMENTS
expr_stmt|;
block|}
if|if
condition|(
name|maxNumber
operator|<
literal|1
condition|)
block|{
name|maxNumber
operator|=
name|DEFAULT_MAX_LOCATION_ENHANCEMENTS
expr_stmt|;
block|}
name|this
operator|.
name|maxLocationEnhancements
operator|=
name|maxNumber
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|getServiceProperties
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|Collections
operator|.
name|singletonMap
argument_list|(
name|ENHANCEMENT_ENGINE_ORDERING
argument_list|,
operator|(
name|Object
operator|)
name|defaultOrder
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Setter for the minimum score used to decide if results of geoname.org      * search results are added as EntityEnhancements to the ContentItem.      * If<code>null</code> is parsed the value is set to      * {@link LocationEnhancementEngine#DEFAULT_MIN_SCORE}. For values> 1 the      * value is set to 1 and for values< 0 the value is set to 0.      *      * @param minScore the minScore to set      */
specifier|public
name|void
name|setMinScore
parameter_list|(
name|Double
name|minScore
parameter_list|)
block|{
if|if
condition|(
name|minScore
operator|==
literal|null
condition|)
block|{
name|minScore
operator|=
name|DEFAULT_MIN_SCORE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|minScore
operator|>
literal|1
condition|)
block|{
name|minScore
operator|=
name|Double
operator|.
name|valueOf
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|minScore
operator|<
literal|0
condition|)
block|{
name|minScore
operator|=
name|Double
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|minScore
operator|=
name|minScore
expr_stmt|;
block|}
comment|/**      * Getter for the minimum score used to decide if results of geoname.org      * search results are added as EntityEnhancements to the ContentItem      *      * @return the minScore      */
specifier|public
name|Double
name|getMinScore
parameter_list|()
block|{
return|return
name|minScore
return|;
block|}
comment|/**      * Setter for the minimum value used to decide based on the score of      * locations returned by the geonames.org web service if also the hierarchy      * of that point should be added as enhancements to the analysed      * content item.<br>      * If<code>null</code> is parsed the value is set to      * {@link LocationEnhancementEngine#DEFAULT_MIN_HIERARCHY_SCORE}.      * For values> 1 the value is set to 1 and for values< 0 the value      * is set to 0.      *      * @param minHierarchyScore the minHierarchyScore to set      */
specifier|public
name|void
name|setMinHierarchyScore
parameter_list|(
name|Double
name|minHierarchyScore
parameter_list|)
block|{
if|if
condition|(
name|minHierarchyScore
operator|==
literal|null
condition|)
block|{
name|minHierarchyScore
operator|=
name|DEFAULT_MIN_HIERARCHY_SCORE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|minHierarchyScore
operator|>
literal|1
condition|)
block|{
name|minHierarchyScore
operator|=
name|Double
operator|.
name|valueOf
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|minScore
operator|<
literal|0
condition|)
block|{
name|minHierarchyScore
operator|=
name|Double
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|minHierarchyScore
operator|=
name|minHierarchyScore
expr_stmt|;
block|}
comment|/**      * Setter for the minimum value used to decide based on the score of      * locations returned by the geonames.org web service if also the hierarchy      * of that point should be added as enhancements to the analysed      * content item.      *      * @return the minHierarchyScore      */
specifier|public
name|Double
name|getMinHierarchyScore
parameter_list|()
block|{
return|return
name|minHierarchyScore
return|;
block|}
block|}
end_class

end_unit

