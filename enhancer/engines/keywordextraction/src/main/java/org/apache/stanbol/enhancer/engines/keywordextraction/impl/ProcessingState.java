begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *   */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|keywordextraction
operator|.
name|impl
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|opennlp
operator|.
name|TextAnalyzer
operator|.
name|AnalysedText
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|opennlp
operator|.
name|TextAnalyzer
operator|.
name|AnalysedText
operator|.
name|Chunk
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|opennlp
operator|.
name|TextAnalyzer
operator|.
name|AnalysedText
operator|.
name|Token
import|;
end_import

begin_class
specifier|public
class|class
name|ProcessingState
block|{
specifier|private
specifier|final
name|Iterator
argument_list|<
name|AnalysedText
argument_list|>
name|sentences
decl_stmt|;
comment|/**      * The sentence currently processed      */
specifier|private
name|AnalysedText
name|sentence
decl_stmt|;
comment|/**      * The index of the current token needed to be linked      */
specifier|private
name|int
name|tokenIndex
init|=
operator|-
literal|1
decl_stmt|;
comment|/**      * The current token      */
specifier|private
name|Token
name|token
decl_stmt|;
comment|/**      * The iterator over the chunks of the current {@link #sentence}        * or<code>null</code> if no {@link Chunk}s are available.      */
specifier|private
name|Iterator
argument_list|<
name|Chunk
argument_list|>
name|chunks
decl_stmt|;
comment|/**      * The current {@link Chunk}      */
specifier|private
name|Chunk
name|chunk
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|MAX_TEXT_CACHE_SIZE
init|=
literal|32
decl_stmt|;
comment|/**      * This is a cache over the last {@link #MAX_TEXT_CACHE_SIZE} token texts      * requested by {@link #getTokenText(int, int)}      */
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|textCache
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|(
name|MAX_TEXT_CACHE_SIZE
argument_list|,
literal|0.75f
argument_list|,
literal|true
argument_list|)
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
specifier|protected
name|boolean
name|removeEldestEntry
parameter_list|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|eldest
parameter_list|)
block|{
return|return
name|size
argument_list|()
operator|>
name|MAX_TEXT_CACHE_SIZE
return|;
block|}
empty_stmt|;
block|}
decl_stmt|;
comment|/**      * The position for the next token      */
specifier|private
name|int
name|nextToken
init|=
operator|-
literal|1
decl_stmt|;
comment|/**      * The position of the last consumed position      */
specifier|private
name|int
name|consumedIndex
init|=
operator|-
literal|1
decl_stmt|;
specifier|public
name|ProcessingState
parameter_list|(
name|Iterator
argument_list|<
name|AnalysedText
argument_list|>
name|sentences
parameter_list|)
block|{
name|this
operator|.
name|sentences
operator|=
name|sentences
expr_stmt|;
if|if
condition|(
operator|!
name|sentences
operator|.
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed AnalysedContent MUST NOT have an empty AnalysedText iterator!"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Getter for the current Sentence      * @return the sentence      */
specifier|public
specifier|final
name|AnalysedText
name|getSentence
parameter_list|()
block|{
return|return
name|sentence
return|;
block|}
comment|/**      * Getter for the index of the current active token within the current      * active {@link #getSentence() sentence}      * @return the tokenPos the index of the token      */
specifier|public
specifier|final
name|int
name|getTokenIndex
parameter_list|()
block|{
return|return
name|tokenIndex
return|;
block|}
comment|/**      * Getter for the last consumed index      * @return the index of the last consumed token      */
specifier|public
specifier|final
name|int
name|getConsumedIndex
parameter_list|()
block|{
return|return
name|consumedIndex
return|;
block|}
comment|/**      * The currently active token      * @return the token      */
specifier|public
specifier|final
name|Token
name|getToken
parameter_list|()
block|{
return|return
name|token
return|;
block|}
comment|/**      * Getter for the language of the current Token (based on the current      * sentence)      * @return the language      */
specifier|public
specifier|final
name|String
name|getLanguage
parameter_list|()
block|{
return|return
name|sentence
operator|.
name|getLanguage
argument_list|()
return|;
block|}
comment|/**      * The currently active chunk or<code>null</code> if no chunks are      * available. If chunks are present this can not be<code>null</code>      * because {@link Token}s outside of chunks are skiped.      * @return the chunk the current {@link Chunk} or<code>null</code> if      * no chunks are present.      */
specifier|public
specifier|final
name|Chunk
name|getChunk
parameter_list|()
block|{
return|return
name|chunk
return|;
block|}
comment|/**      * Getter for the next {@link Token} to be processed. Calling {@link #next()}      * is guaranteed to skip all tokens in between {@link #getTokenIndex()}      * and {@link #getNextToken()}, but it might even skip more tokens (e.g.      * in case that the token referenced by {@link #getNextToken()} is not      * within a {@link Chunk}      * @return the nextToken      */
specifier|public
specifier|final
name|int
name|getNextToken
parameter_list|()
block|{
return|return
name|nextToken
return|;
block|}
comment|//    /**
comment|//     * Allows to manually set to position of the next token to process.
comment|//     * This can be used to skip some tokens within (e.g. if a Concept
comment|//     * matching multiple Tokens where found.<p>
comment|//     * The set token may be greater than the number of tokens in
comment|//     * {@link #sentence}. This will simple cause the next sentence to be
comment|//     * activated on the next call to {@link #next()}
comment|//     * @param pos the position of the next token to process.
comment|//     */
comment|//    public void setNextToken(int pos){
comment|//        if(pos> tokenIndex){
comment|//            this.nextToken = pos;
comment|//        } else {
comment|//            throw new IllegalArgumentException("The nextTokenPos "+pos+
comment|//                " MUST BE greater than the current "+tokenIndex);
comment|//        }
comment|//    }
comment|/**      * The index of an consumed Token. The consumed index MUST BE equals or      * greater as {@link #getTokenIndex()}. If the consumed index is set to a      * value greater that {@link #getTokenIndex()} than consumed tokens are      * skipped on the next call to {@link #next()}      * @param pos the position of the last consumed token.      */
specifier|public
name|void
name|setConsumed
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
if|if
condition|(
name|pos
operator|>=
name|tokenIndex
condition|)
block|{
name|this
operator|.
name|consumedIndex
operator|=
name|pos
expr_stmt|;
name|this
operator|.
name|nextToken
operator|=
name|pos
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The lastConsumedPos "
operator|+
name|pos
operator|+
literal|" MUST BE equals or gerater than the current Pos "
operator|+
name|tokenIndex
argument_list|)
throw|;
block|}
block|}
comment|/**      * Moves the state to #nextToken this may switch to the next Chunk or      * sentence.      * @return<code>true</code> if there are further elements to process or      *<code>false</code> if there are no further elements to process.      */
specifier|public
name|boolean
name|next
parameter_list|()
block|{
comment|//switch to the next token
if|if
condition|(
name|nextToken
operator|>
name|tokenIndex
condition|)
block|{
name|tokenIndex
operator|=
name|nextToken
expr_stmt|;
block|}
else|else
block|{
name|tokenIndex
operator|++
expr_stmt|;
name|nextToken
operator|=
name|tokenIndex
expr_stmt|;
block|}
comment|//now init the next element
specifier|final
name|boolean
name|hasNext
decl_stmt|;
if|if
condition|(
name|chunk
operator|!=
literal|null
condition|)
block|{
comment|//if chunks are present
comment|//get next chunk (may be the current if chunk.getEnd()> tokenPos
for|for
control|(
init|;
name|tokenIndex
operator|>
name|chunk
operator|.
name|getEnd
argument_list|()
operator|&&
name|chunks
operator|.
name|hasNext
argument_list|()
condition|;
name|chunk
operator|=
name|chunks
operator|.
name|next
argument_list|()
control|)
empty_stmt|;
if|if
condition|(
name|tokenIndex
operator|<=
name|chunk
operator|.
name|getEnd
argument_list|()
condition|)
block|{
comment|//found valid chunk
if|if
condition|(
name|chunk
operator|.
name|getStart
argument_list|()
operator|>
name|tokenIndex
condition|)
block|{
comment|//skip tokens outside chunks
name|tokenIndex
operator|=
name|chunk
operator|.
name|getStart
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|chunk
operator|.
name|getStart
argument_list|()
operator|>
name|consumedIndex
condition|)
block|{
name|consumedIndex
operator|=
name|chunk
operator|.
name|getStart
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
name|hasNext
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|//no more valid chunks in this sentence
name|hasNext
operator|=
name|initNextSentence
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//no chunks ... use tokens only
if|if
condition|(
name|sentence
operator|==
literal|null
condition|)
block|{
comment|//first sentence
name|hasNext
operator|=
name|initNextSentence
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tokenIndex
operator|>=
name|sentence
operator|.
name|getTokens
argument_list|()
operator|.
name|size
argument_list|()
condition|)
block|{
name|hasNext
operator|=
name|initNextSentence
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|//more tokens in the sentence
comment|//set the token
name|hasNext
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hasNext
condition|)
block|{
comment|//set the Token
name|token
operator|=
name|sentence
operator|.
name|getTokens
argument_list|()
operator|.
name|get
argument_list|(
name|tokenIndex
argument_list|)
expr_stmt|;
block|}
return|return
name|hasNext
return|;
block|}
comment|/**      * Correctly initialise {@link #sentence}, {@link #chunks}, {@link #chunk}      * and {@link #tokenIndex} for the next element of {@link #sentences}. If      * no further sentences are to process it simple sets {@link #sentence},       * {@link #chunks}, {@link #chunk} and {@link #tokenIndex} to<code>null</code>      */
specifier|private
name|boolean
name|initNextSentence
parameter_list|()
block|{
name|textCache
operator|.
name|clear
argument_list|()
expr_stmt|;
name|sentence
operator|=
literal|null
expr_stmt|;
while|while
condition|(
name|sentence
operator|==
literal|null
operator|&&
name|sentences
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|sentence
operator|=
name|sentences
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|sentence
operator|.
name|getChunks
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|chunks
operator|=
name|sentence
operator|.
name|getChunks
argument_list|()
operator|.
name|iterator
argument_list|()
expr_stmt|;
if|if
condition|(
name|chunks
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|chunk
operator|=
name|chunks
operator|.
name|next
argument_list|()
expr_stmt|;
name|tokenIndex
operator|=
name|chunk
operator|.
name|getStart
argument_list|()
expr_stmt|;
name|consumedIndex
operator|=
name|tokenIndex
operator|-
literal|1
expr_stmt|;
name|nextToken
operator|=
name|tokenIndex
expr_stmt|;
block|}
else|else
block|{
comment|//no chunks in this sentence
name|sentence
operator|=
literal|null
expr_stmt|;
comment|//skip this sentence
block|}
block|}
else|else
block|{
if|if
condition|(
name|sentence
operator|.
name|getTokens
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//no tokens in this sentence
name|sentence
operator|=
literal|null
expr_stmt|;
comment|//skip this one
block|}
else|else
block|{
name|chunks
operator|=
literal|null
expr_stmt|;
name|chunk
operator|=
literal|null
expr_stmt|;
name|tokenIndex
operator|=
literal|0
expr_stmt|;
name|consumedIndex
operator|=
operator|-
literal|1
expr_stmt|;
name|nextToken
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
return|return
name|sentence
operator|!=
literal|null
return|;
block|}
comment|/**      * Getter for the text covered by the next tokenCount tokens relative to      * {@link #token}. It uses the {@link #textCache} to lookup/store such texts.      * Given the Tokens      *<pre>      *    [This, is, an, Example]      *</pre>      * and the parameter<code>3</code> this method will return      *<pre>      *     This is an      *</pre>      * @param tokenCount the number of tokens to be included relative to       * {@link #tokenIndex}      * @return the text covered by the span start of {@link #token} to end of      * token at<code>{@link #tokenIndex}+tokenCount</code>.      */
specifier|public
name|String
name|getTokenText
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|tokenCount
parameter_list|)
block|{
name|String
name|pos
init|=
name|start
operator|+
literal|","
operator|+
name|tokenCount
decl_stmt|;
name|String
name|text
init|=
name|textCache
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|text
operator|==
literal|null
condition|)
block|{
name|text
operator|=
name|sentence
operator|.
name|getText
argument_list|()
operator|.
name|substring
argument_list|(
name|sentence
operator|.
name|getTokens
argument_list|()
operator|.
name|get
argument_list|(
name|start
argument_list|)
operator|.
name|getStart
argument_list|()
argument_list|,
name|sentence
operator|.
name|getTokens
argument_list|()
operator|.
name|get
argument_list|(
name|start
operator|+
name|tokenCount
operator|-
literal|1
argument_list|)
operator|.
name|getEnd
argument_list|()
argument_list|)
expr_stmt|;
name|textCache
operator|.
name|put
argument_list|(
name|pos
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
return|return
name|text
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"["
operator|+
name|tokenIndex
operator|+
literal|","
operator|+
name|token
operator|+
literal|"] chunk: "
operator|+
operator|(
name|chunk
operator|==
literal|null
condition|?
literal|null
else|:
name|chunk
operator|.
name|getText
argument_list|()
operator|)
operator|+
literal|"| sentence: "
operator|+
operator|(
name|sentence
operator|==
literal|null
condition|?
literal|null
else|:
name|sentence
operator|.
name|getText
argument_list|()
operator|)
return|;
block|}
block|}
end_class

end_unit

