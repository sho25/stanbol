begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|keywordextraction
operator|.
name|linking
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|opennlp
operator|.
name|tools
operator|.
name|chunker
operator|.
name|Chunker
import|;
end_import

begin_import
import|import
name|opennlp
operator|.
name|tools
operator|.
name|postag
operator|.
name|POSTagger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|UriRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|opennlp
operator|.
name|TextAnalyzer
operator|.
name|AnalysedText
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|opennlp
operator|.
name|TextAnalyzer
operator|.
name|AnalysedText
operator|.
name|Chunk
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|opennlp
operator|.
name|TextAnalyzer
operator|.
name|AnalysedText
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|keywordextraction
operator|.
name|linking
operator|.
name|Suggestion
operator|.
name|MATCH
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|OntologicalClasses
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|defaults
operator|.
name|NamespaceEnum
import|;
end_import

begin_comment
comment|/**  * The configuration for the {@link EntityLinker}. Typically this  * configuration does not change often. Therefore it will be used for  * several {@link EntityLinker} instances processing different   * contents.  * @author Rupert Westenthaler  *  */
end_comment

begin_class
specifier|public
class|class
name|EntityLinkerConfig
block|{
comment|/**      * The minimum length of Token to be used for searches in case no      * POS (Part of Speech) tags are available.      */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MIN_SEARCH_TOKEN_LENGTH
init|=
literal|3
decl_stmt|;
comment|/**      * The default number for the maximum number of terms suggested for a word      */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_SUGGESTIONS
init|=
literal|3
decl_stmt|;
comment|/**      * Default value for the number of tokens that must be contained in      * suggested terms.      */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MIN_FOUND_TOKENS
init|=
literal|2
decl_stmt|;
comment|/**      * Multiple Tokens can be sent to the {@link EntitySearcher} service. The      * service uses this as optional parameters for the search. Therefore      * returned Concepts MUST contain at least a single of the parsed       * tokens.<p>      * The default value of<code>2</code> should be enough for nearly all      * Taxonomies to sufficiently reduce the number of results.<p>      * NOTE that the labels (nameField) of the results are compared as a      * whole. So even if only 2 Tokens are used for the search there may be      * more mapped to the actual label of an result.      */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MAX_SEARCH_TOKENS
init|=
literal|2
decl_stmt|;
comment|/**      * Default value for {@link #getNameField()} (rdfs:label)      */
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_NAME_FIELD
init|=
literal|"rdfs:label"
decl_stmt|;
comment|/**      * Default value for {@link #getTypeField()} (rdf:type)      */
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_TYPE_FIELD
init|=
literal|"rdf:type"
decl_stmt|;
comment|/**      * Default value for {@link #getRedirectField()} (rdf:seeAlso)      */
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_REDIRECT_FIELD
init|=
literal|"rdfs:seeAlso"
decl_stmt|;
comment|/**      * The default language used to search for labels regardless of the language      * of the text. The default value is<code>null</code> causing to include      * labels that do not have a language assigned.      */
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_LANGUAGE
init|=
literal|null
decl_stmt|;
comment|/**      * The default for case sensitive matching is set to<code>false</code>      */
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_CASE_SENSITIVE_MATCHING_STATE
init|=
literal|false
decl_stmt|;
comment|/**      * Default mapping for Concept types to dc:type values added for      * TextAnnotations.      */
specifier|public
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|UriRef
argument_list|>
name|DEFAULT_ENTITY_TYPE_MAPPINGS
decl_stmt|;
static|static
block|{
comment|//the default mappings for the three types used by the Stanbol Enhancement Structure
name|Map
argument_list|<
name|String
argument_list|,
name|UriRef
argument_list|>
name|mappings
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|UriRef
argument_list|>
argument_list|()
decl_stmt|;
name|mappings
operator|.
name|put
argument_list|(
name|OntologicalClasses
operator|.
name|DBPEDIA_ORGANISATION
operator|.
name|getUnicodeString
argument_list|()
argument_list|,
name|OntologicalClasses
operator|.
name|DBPEDIA_ORGANISATION
argument_list|)
expr_stmt|;
name|mappings
operator|.
name|put
argument_list|(
name|NamespaceEnum
operator|.
name|dbpediaOnt
operator|+
literal|"Newspaper"
argument_list|,
name|OntologicalClasses
operator|.
name|DBPEDIA_ORGANISATION
argument_list|)
expr_stmt|;
name|mappings
operator|.
name|put
argument_list|(
name|NamespaceEnum
operator|.
name|schema
operator|+
literal|"Organization"
argument_list|,
name|OntologicalClasses
operator|.
name|DBPEDIA_ORGANISATION
argument_list|)
expr_stmt|;
comment|//        mappings.put(NamespaceEnum.dailymed+"organization",OntologicalClasses.DBPEDIA_ORGANISATION);
name|mappings
operator|.
name|put
argument_list|(
name|OntologicalClasses
operator|.
name|DBPEDIA_PERSON
operator|.
name|getUnicodeString
argument_list|()
argument_list|,
name|OntologicalClasses
operator|.
name|DBPEDIA_PERSON
argument_list|)
expr_stmt|;
name|mappings
operator|.
name|put
argument_list|(
name|NamespaceEnum
operator|.
name|foaf
operator|+
literal|"Person"
argument_list|,
name|OntologicalClasses
operator|.
name|DBPEDIA_PERSON
argument_list|)
expr_stmt|;
name|mappings
operator|.
name|put
argument_list|(
name|NamespaceEnum
operator|.
name|schema
operator|+
literal|"Person"
argument_list|,
name|OntologicalClasses
operator|.
name|DBPEDIA_PERSON
argument_list|)
expr_stmt|;
name|mappings
operator|.
name|put
argument_list|(
name|OntologicalClasses
operator|.
name|DBPEDIA_PLACE
operator|.
name|getUnicodeString
argument_list|()
argument_list|,
name|OntologicalClasses
operator|.
name|DBPEDIA_PLACE
argument_list|)
expr_stmt|;
name|mappings
operator|.
name|put
argument_list|(
name|NamespaceEnum
operator|.
name|schema
operator|+
literal|"Place"
argument_list|,
name|OntologicalClasses
operator|.
name|DBPEDIA_PLACE
argument_list|)
expr_stmt|;
name|mappings
operator|.
name|put
argument_list|(
name|NamespaceEnum
operator|.
name|gml
operator|+
literal|"_Feature"
argument_list|,
name|OntologicalClasses
operator|.
name|DBPEDIA_PLACE
argument_list|)
expr_stmt|;
name|mappings
operator|.
name|put
argument_list|(
name|OntologicalClasses
operator|.
name|SKOS_CONCEPT
operator|.
name|getUnicodeString
argument_list|()
argument_list|,
name|OntologicalClasses
operator|.
name|SKOS_CONCEPT
argument_list|)
expr_stmt|;
comment|//        UriRef DRUG = new UriRef(NamespaceEnum.drugbank+"drugs");
comment|//        mappings.put(DRUG.getUnicodeString(), DRUG);
comment|//        mappings.put(NamespaceEnum.dbpediaOnt+"Drug", DRUG);
comment|//        mappings.put(NamespaceEnum.dailymed+"drugs", DRUG);
comment|//        mappings.put(NamespaceEnum.sider+"drugs", DRUG);
comment|//        mappings.put(NamespaceEnum.tcm+"Medicine", DRUG);
comment|//
comment|//        UriRef DISEASE = new UriRef(NamespaceEnum.diseasome+"diseases");
comment|//        mappings.put(DISEASE.getUnicodeString(), DISEASE);
comment|//        mappings.put(NamespaceEnum.linkedct+"condition", DISEASE);
comment|//        mappings.put(NamespaceEnum.tcm+"Disease", DISEASE);
comment|//
comment|//        UriRef SIDE_EFFECT = new UriRef(NamespaceEnum.sider+"side_effects");
comment|//        mappings.put(SIDE_EFFECT.getUnicodeString(), SIDE_EFFECT);
comment|//
comment|//        UriRef INGREDIENT = new UriRef(NamespaceEnum.dailymed+"ingredients");
comment|//        mappings.put(INGREDIENT.getUnicodeString(), INGREDIENT);
name|DEFAULT_ENTITY_TYPE_MAPPINGS
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|mappings
argument_list|)
expr_stmt|;
block|}
comment|/**      * Enumeration over the different possibilities on how to deal with      * redirects (similar to Browsers following HTTP status 303 and RDF defining      * the "rdf:seeAlso" relation.       * @author Rupert Westenthaler      */
specifier|public
specifier|static
enum|enum
name|RedirectProcessingMode
block|{
comment|/**          * Ignore redirects          */
name|IGNORE
block|,
comment|/**          * Follow redirects, but only add the values (e.g. labels, types) such          * entities to the original one.          */
name|ADD_VALUES
block|,
comment|/**          * Follow the redirect.          */
name|FOLLOW
block|}
comment|/**      * The default value for how to process redirect is set to      * {@link RedirectProcessingMode#IGNORE}      */
specifier|public
specifier|static
name|RedirectProcessingMode
name|DEFAULT_REDIRECT_PROCESSING_MODE
init|=
name|RedirectProcessingMode
operator|.
name|IGNORE
decl_stmt|;
comment|/**      * The minimum length of labels that are looked-up in the directory      */
specifier|private
name|int
name|minSearchTokenLength
init|=
name|DEFAULT_MIN_SEARCH_TOKEN_LENGTH
decl_stmt|;
comment|/**      * The the maximum number of terms suggested for a word      */
specifier|private
name|int
name|maxSuggestions
init|=
name|DEFAULT_SUGGESTIONS
decl_stmt|;
comment|/**      * If several words are selected from the text to search for an Entity in the      * Dictionary (e.g. if a {@link Chunker} is used or if the {@link POSTagger}      * detects several connected nouns) that entities found for the such chunks      * MUST define a label (with no or the correct lanugage) that contains at      * least this number of tokens to be accepted.<p>      * TODO: make configurable      */
specifier|private
name|int
name|minFoundTokens
init|=
name|DEFAULT_MIN_FOUND_TOKENS
decl_stmt|;
comment|/**      * The maximum numbers of Tokens sent to the {@link EntitySearcher} to search      * for concepts.<p>      * NOTE that the labels (nameField) of the results are compared as a      * whole. So even if only e.g. 2 tokens are used for the search there may be      * more mapped to the actual label of an result.      */
specifier|private
name|int
name|maxSearchTokens
init|=
name|DEFAULT_MAX_SEARCH_TOKENS
decl_stmt|;
specifier|private
name|boolean
name|caseSensitiveMatchingState
init|=
name|DEFAULT_CASE_SENSITIVE_MATCHING_STATE
decl_stmt|;
comment|/**      * Holds the mappings of rdf:type used by concepts to dc:type values used      * by TextAnnotations.       */
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|UriRef
argument_list|>
name|typeMappings
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|UriRef
argument_list|>
name|unmodTypeMappings
decl_stmt|;
comment|/**      * The mode on how to process redirect for Entities.       */
specifier|private
name|RedirectProcessingMode
name|redirectProcessingMode
decl_stmt|;
comment|/**      * the default DC Type      */
specifier|private
name|UriRef
name|defaultDcType
decl_stmt|;
specifier|private
name|String
name|nameField
decl_stmt|;
specifier|private
name|String
name|redirectField
decl_stmt|;
specifier|private
name|String
name|typeField
decl_stmt|;
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|selectedFields
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * The language always included in searches (regardless of the language      * detected for the text.      */
specifier|private
name|String
name|defaultLanguage
init|=
name|DEFAULT_LANGUAGE
decl_stmt|;
comment|/**      * Default for the maximum number of non-processable tokens that are       * allowed to not match before no further tokens are matched against a label       * of an Entity.<p>      * This allows e.g. to match "Dr. Richard Dogles" with "Dr Richard Dogles"      * as '.' is a non-processable token in the text that is missing in the      * label.<p>      * The default is set to<code>1</code>      */
specifier|public
specifier|final
specifier|static
name|int
name|DEFAULT_MAX_NOT_FOUND
init|=
literal|1
decl_stmt|;
comment|/**      * Value of the maximum number of non-processable tokens that are       * allowed to not match before no further tokens are matched against a label       * of an Entity.<p>      * This allows e.g. to match "Dr. Richard Dogles" with "Dr Richard Dogles"      * as '.' is a non-processable token in the text that is missing in the      * label.     */
specifier|private
name|int
name|maxNotFound
decl_stmt|;
comment|/**      * Default value for the minimum token match factor.      * If Tokens match is determined by comparing them using some algorithm.      * Results need to be in the range [0..1]. This factor defines the minimum      * similarity value so that a match is assumed. Not that this factor only      * is used for filtering out non-matching tokens. The similarity value will      * still used for calculating the confidence.<p>      * The default is set to<code>0.7</code>.      */
specifier|public
specifier|final
specifier|static
name|float
name|DEFAULT_MIN_TOKEN_MATCH_FACTOR
init|=
literal|0.7f
decl_stmt|;
comment|/**      * If Tokens match is determined by comparing them using some algorithm.      * Results need to be in the range [0..1]. This factor defines the minimum      * similarity value so that a match is assumed. Not that this factor only      * is used for filtering out non-matching tokens. The similarity value will      * still used for calculating the confidence      */
specifier|private
name|float
name|minTokenMatchFactor
decl_stmt|;
comment|/**      * Default constructor the initialises the configuration with the       * default values      */
specifier|public
name|EntityLinkerConfig
parameter_list|()
block|{
name|setMinSearchTokenLength
argument_list|(
name|DEFAULT_MIN_SEARCH_TOKEN_LENGTH
argument_list|)
expr_stmt|;
name|setMaxSuggestions
argument_list|(
name|DEFAULT_SUGGESTIONS
argument_list|)
expr_stmt|;
name|setMaxSearchTokens
argument_list|(
name|DEFAULT_MAX_SEARCH_TOKENS
argument_list|)
expr_stmt|;
name|setRedirectProcessingMode
argument_list|(
name|DEFAULT_REDIRECT_PROCESSING_MODE
argument_list|)
expr_stmt|;
name|typeMappings
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|UriRef
argument_list|>
argument_list|(
name|DEFAULT_ENTITY_TYPE_MAPPINGS
argument_list|)
expr_stmt|;
name|unmodTypeMappings
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|typeMappings
argument_list|)
expr_stmt|;
name|setDefaultDcType
argument_list|(
name|typeMappings
operator|.
name|remove
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|setNameField
argument_list|(
name|DEFAULT_NAME_FIELD
argument_list|)
expr_stmt|;
name|setRedirectField
argument_list|(
name|DEFAULT_REDIRECT_FIELD
argument_list|)
expr_stmt|;
name|setTypeField
argument_list|(
name|DEFAULT_TYPE_FIELD
argument_list|)
expr_stmt|;
name|setMaxNotFound
argument_list|(
name|DEFAULT_MAX_NOT_FOUND
argument_list|)
expr_stmt|;
name|setMinTokenMatchFactor
argument_list|(
name|DEFAULT_MIN_TOKEN_MATCH_FACTOR
argument_list|)
expr_stmt|;
block|}
comment|/**      * Getter for the uri of the field used for the names in the taxonomy      * (e.g. rdfs:label, skos:prefLabel). Needs to return the full URI      * @return the field used for the names of in the Taxonomy.      */
specifier|public
specifier|final
name|String
name|getNameField
parameter_list|()
block|{
return|return
name|nameField
return|;
block|}
comment|/**      * Setter for the uri of the field used for the names in the taxonomy      * (e.g. rdfs:label, skos:prefLabel).       * Converts short to full URIy by using the prefixes as registered in the      * {@link NamespaceEnum}.      * @param nameField the nameField to set      */
specifier|public
specifier|final
name|void
name|setNameField
parameter_list|(
name|String
name|nameField
parameter_list|)
block|{
name|this
operator|.
name|nameField
operator|=
name|NamespaceEnum
operator|.
name|getFullName
argument_list|(
name|nameField
argument_list|)
expr_stmt|;
name|updateSelectedFields
argument_list|()
expr_stmt|;
block|}
comment|/**      * internally used to update the selected fields on changes to      * {@link #setNameField(String)}, {@link #setRedirectField(String)} or      * {@link #setTypeField(String)}      */
specifier|private
name|void
name|updateSelectedFields
parameter_list|()
block|{
name|selectedFields
operator|.
name|clear
argument_list|()
expr_stmt|;
name|selectedFields
operator|.
name|add
argument_list|(
name|nameField
argument_list|)
expr_stmt|;
name|selectedFields
operator|.
name|add
argument_list|(
name|redirectField
argument_list|)
expr_stmt|;
name|selectedFields
operator|.
name|add
argument_list|(
name|typeField
argument_list|)
expr_stmt|;
block|}
comment|/**      * Getter for the selected fields. A set that includes the current      * {@link #getNameField()}, {@link #getTypeField()} and {@link #getRedirectField()}.      * @return the selectedFields      */
specifier|public
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|getSelectedFields
parameter_list|()
block|{
return|return
name|selectedFields
return|;
block|}
comment|/**      * The field used to follow redirects (typically rdf:seeAlso)      * @return the redirect field      */
specifier|public
specifier|final
name|String
name|getRedirectField
parameter_list|()
block|{
return|return
name|redirectField
return|;
block|}
comment|/**      * The field used to follow redirects (typically rdf:seeAlso)      * Converts short to full URIy by using the prefixes as registered in the      * {@link NamespaceEnum}.      * @param redirectField the redirectField to set      */
specifier|public
specifier|final
name|void
name|setRedirectField
parameter_list|(
name|String
name|redirectField
parameter_list|)
block|{
name|this
operator|.
name|redirectField
operator|=
name|NamespaceEnum
operator|.
name|getFullName
argument_list|(
name|redirectField
argument_list|)
expr_stmt|;
name|updateSelectedFields
argument_list|()
expr_stmt|;
block|}
comment|/**      * The field used to lookup the types (typically rdf:type)      * @return the field name used to lookup types      */
specifier|public
specifier|final
name|String
name|getTypeField
parameter_list|()
block|{
return|return
name|typeField
return|;
block|}
comment|/**      * The field used to lookup the types (typically rdf:type)      * Converts short to full URIy by using the prefixes as registered in the      * {@link NamespaceEnum}.      * @param typeField the typeField to set      */
specifier|public
specifier|final
name|void
name|setTypeField
parameter_list|(
name|String
name|typeField
parameter_list|)
block|{
name|this
operator|.
name|typeField
operator|=
name|NamespaceEnum
operator|.
name|getFullName
argument_list|(
name|typeField
argument_list|)
expr_stmt|;
name|updateSelectedFields
argument_list|()
expr_stmt|;
block|}
comment|/**      * The minimum number of character a {@link Token} (word) must have to be      * used {@link EntitySearcher#lookup(java.util.List, String...) lookup} concepts      * in the taxonomy. Note that this parameter is only used of no POS (Part-      * of-speech) tags are available in the {@link AnalysedText}.      * @param minSearchTokenLength the minSearchTokenLength to set      */
specifier|public
name|void
name|setMinSearchTokenLength
parameter_list|(
name|int
name|minSearchTokenLength
parameter_list|)
block|{
name|this
operator|.
name|minSearchTokenLength
operator|=
name|minSearchTokenLength
expr_stmt|;
block|}
comment|/**      * The minimum number of character a {@link Token} (word) must have to be      * used {@link EntitySearcher#lookup(java.util.List, String...) lookup} concepts      * in the taxonomy. Note that this parameter is only used of no POS (Part-      * of-speech) tags are available in the {@link AnalysedText}.      * @return the minSearchTokenLength      */
specifier|public
name|int
name|getMinSearchTokenLength
parameter_list|()
block|{
return|return
name|minSearchTokenLength
return|;
block|}
comment|/**      * Setter for the maximum number of suggestion returned.       * @param maxSuggestions the maxSuggestions to set      */
specifier|public
name|void
name|setMaxSuggestions
parameter_list|(
name|int
name|maxSuggestions
parameter_list|)
block|{
name|this
operator|.
name|maxSuggestions
operator|=
name|maxSuggestions
expr_stmt|;
block|}
comment|/**      * Getter for the maximum number of suggestion returned.       * @return the maxSuggestions      */
specifier|public
name|int
name|getMaxSuggestions
parameter_list|()
block|{
return|return
name|maxSuggestions
return|;
block|}
comment|/**      * Setter for the minimum number of Tokens (of the content) that MUST match      * with a {@link EntitySearcher#getNameField() label} of a       * {@link EntitySearcher#lookup(java.util.List, String...) concept of the taxonomy}      * so that it is {@link Suggestion suggested} even if the match is only      * {@link MATCH#PARTIAL}. Entities that match less than that are only included      * if a label is an {@link MATCH#EXACT EXACT} match with the current position      * in the text.       * @param minFoundTokens the minFoundTokens to set      */
specifier|public
name|void
name|setMinFoundTokens
parameter_list|(
name|int
name|minFoundTokens
parameter_list|)
block|{
name|this
operator|.
name|minFoundTokens
operator|=
name|minFoundTokens
expr_stmt|;
block|}
comment|/**      * Getter for the minimum number of Tokens (of the content) that MUST match      * with a {@link EntitySearcher#getNameField() label} of a       * {@link EntitySearcher#lookup(java.util.List, String...) concept of the taxonomy}      * so that it is {@link Suggestion suggested} even if the match is only      * {@link MATCH#PARTIAL}. Entities that match less than that are only included      * if a label is an {@link MATCH#EXACT EXACT} match with the current position      * in the text.       * @return the minFoundTokens      */
specifier|public
name|int
name|getMinFoundTokens
parameter_list|()
block|{
return|return
name|minFoundTokens
return|;
block|}
comment|/**      * Getter for the  maximum number of tokens parsed to       * {@link EntitySearcher#lookup(java.util.List, String...)}      * @return the maxSearchTokens      */
specifier|public
specifier|final
name|int
name|getMaxSearchTokens
parameter_list|()
block|{
return|return
name|maxSearchTokens
return|;
block|}
comment|/**      * The maximum number of tokens parsed to       * {@link EntitySearcher#lookup(java.util.List, String...)}. This is NOT the      * maximum number of Tokens mapped for Entities returned by such queries.<p>      * In case {@link Chunk}s are available in the parsed {@link AnalysedText}      * searches can be scoped by such chunks. However if no chunks are available,      * than this value is used to collect this number of words in the text.<p>      * The {@link #DEFAULT_MAX_SEARCH_TOKENS default value} of<code>2</code>      * should be ok in most cases.        * @param maxSearchTokens the maxSearchTokens to set      */
specifier|public
specifier|final
name|void
name|setMaxSearchTokens
parameter_list|(
name|int
name|maxSearchTokens
parameter_list|)
block|{
name|this
operator|.
name|maxSearchTokens
operator|=
name|maxSearchTokens
expr_stmt|;
block|}
comment|/**      * Getter for the case sensitive matching state      * @return the state      */
specifier|public
name|boolean
name|isCaseSensitiveMatching
parameter_list|()
block|{
return|return
name|caseSensitiveMatchingState
return|;
block|}
comment|/**      * Setter for the case sensitive matching state      * @param caseSensitiveMatchingState the state      */
specifier|public
name|void
name|setCaseSensitiveMatchingState
parameter_list|(
name|boolean
name|state
parameter_list|)
block|{
name|this
operator|.
name|caseSensitiveMatchingState
operator|=
name|state
expr_stmt|;
block|}
comment|/**      * Removes the mapping for the parsed concept type      * @param conceptType the concept type to remove the mapping      * @return the previously mapped dc:type value or<code>null</code> if      * no mapping for the parsed concept type was present      */
specifier|public
name|UriRef
name|removeTypeMapping
parameter_list|(
name|String
name|conceptType
parameter_list|)
block|{
return|return
name|typeMappings
operator|.
name|remove
argument_list|(
name|conceptType
argument_list|)
return|;
block|}
comment|/**      *       * @param conceptType the type of the concept or<code>null</code> to      * add the default dc:type mapping. See also {@link #setDefaultDcType(UriRef)}      * @param dcType the dc:type for the parsed concept type      * @return the previously mapped dc:type value if an existing mapping      * was updated or<code>null</code> if a new mapping was added.      */
specifier|public
name|UriRef
name|setTypeMapping
parameter_list|(
name|String
name|conceptType
parameter_list|,
name|UriRef
name|dcType
parameter_list|)
block|{
if|if
condition|(
name|dcType
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed dc:type URI MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|conceptType
operator|==
literal|null
condition|)
block|{
comment|//handle setting of the default dc:type value
name|UriRef
name|oldDefault
init|=
name|getDefaultDcType
argument_list|()
decl_stmt|;
name|setDefaultDcType
argument_list|(
name|dcType
argument_list|)
expr_stmt|;
return|return
name|oldDefault
return|;
block|}
return|return
name|typeMappings
operator|.
name|put
argument_list|(
name|conceptType
argument_list|,
name|dcType
argument_list|)
return|;
block|}
comment|/**      * Setter for the default dc:type of linked entities if for none of the      * types of the suggestions a {@link #getTypeMappings()} exists. Set this      * to<code>null</code> to specify that no dc:type should be set in such      * cases.      * @param defaultDcType the defaultDcType to set      */
specifier|public
name|void
name|setDefaultDcType
parameter_list|(
name|UriRef
name|defaultDcType
parameter_list|)
block|{
name|this
operator|.
name|defaultDcType
operator|=
name|defaultDcType
expr_stmt|;
block|}
comment|/**      * The default type for Entities if no {@link #getTypeMappings() type mapping}      * is present.<code>null</code> means that no type should be set if no      * explicit mapping exists      * @return the defaultDcType      */
specifier|public
name|UriRef
name|getDefaultDcType
parameter_list|()
block|{
return|return
name|defaultDcType
return|;
block|}
comment|/**      * Setter for the mode on how to deal with redirects      * @param redirectProcessingMode the redirectProcessingMode to set      */
specifier|public
name|void
name|setRedirectProcessingMode
parameter_list|(
name|RedirectProcessingMode
name|redirectProcessingMode
parameter_list|)
block|{
name|this
operator|.
name|redirectProcessingMode
operator|=
name|redirectProcessingMode
expr_stmt|;
block|}
comment|/**      * Getter for the mode how to deal with redirects      * @return the redirectProcessingMode      */
specifier|public
name|RedirectProcessingMode
name|getRedirectProcessingMode
parameter_list|()
block|{
return|return
name|redirectProcessingMode
return|;
block|}
comment|/**      * Getter for the read only mappings of type mappings      * @return the type mappings (read only)      */
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|UriRef
argument_list|>
name|getTypeMappings
parameter_list|()
block|{
return|return
name|unmodTypeMappings
return|;
block|}
comment|/**      * Setter for the language of labels searched in addition to the current      * language of the text. Setting this to<code>null</code> (also the default)      * will cause to search labels without any defined language.<p>      * Changing this makes only sense if a dataset (such as dbpedia.org) adds      * language tags to labels even if they are typically used in any language.      * @param defaultLanguage the default language      */
specifier|public
name|void
name|setDefaultLanguage
parameter_list|(
name|String
name|defaultLanguage
parameter_list|)
block|{
name|this
operator|.
name|defaultLanguage
operator|=
name|defaultLanguage
expr_stmt|;
block|}
comment|/**      * Getter for the language of labels searched in addition to the current      * language of the text.      * @return the default language       */
specifier|public
name|String
name|getDefaultLanguage
parameter_list|()
block|{
return|return
name|defaultLanguage
return|;
block|}
comment|/**      * Getter for the maximum number of non-processable tokens that are       * allowed to not match before no further tokens are matched against a label       * of an Entity.<p>      * This allows e.g. to match "Dr. Richard Dogles" with "Dr Richard Dogles"      * as '.' is a non-processable token in the text that is missing in the      * label.      * @return the maxNotFound      */
specifier|public
name|int
name|getMaxNotFound
parameter_list|()
block|{
return|return
name|maxNotFound
return|;
block|}
comment|/**      * Setter for the maximum number of non-processable tokens that are       * allowed to not match before no further tokens are matched against a label       * of an Entity.<p>      * This allows e.g. to match "Dr. Richard Dogles" with "Dr Richard Dogles"      * as '.' is a non-processable token in the text that is missing in the      * label.      * @param maxNotFound the maxNotFound to set      */
specifier|public
name|void
name|setMaxNotFound
parameter_list|(
name|int
name|maxNotFound
parameter_list|)
block|{
if|if
condition|(
name|maxNotFound
operator|<
literal|0
condition|)
block|{
name|this
operator|.
name|maxNotFound
operator|=
name|DEFAULT_MAX_NOT_FOUND
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|maxNotFound
operator|=
name|maxNotFound
expr_stmt|;
block|}
block|}
comment|/**      * Getter for the minimum token match Factor.      * If Tokens match is determined by comparing them using some algorithm.      * Results need to be in the range [0..1]. This factor defines the minimum      * similarity value so that a match is assumed. Not that this factor only      * is used for filtering out non-matching tokens. The similarity value will      * still used for calculating the confidence      * @return the minTokenMatchFactor      */
specifier|public
name|float
name|getMinTokenMatchFactor
parameter_list|()
block|{
return|return
name|minTokenMatchFactor
return|;
block|}
comment|/**      * Setter for the minimum token match Factor.      * If Tokens match is determined by comparing them using some algorithm.      * Results need to be in the range [0..1]. This factor defines the minimum      * similarity value so that a match is assumed. Not that this factor only      * is used for filtering out non-matching tokens. The similarity value will      * still used for calculating the confidence      * @param minTokenMatchFactor the minTokenMatchFactor to set      */
specifier|public
name|void
name|setMinTokenMatchFactor
parameter_list|(
name|float
name|minTokenMatchFactor
parameter_list|)
block|{
if|if
condition|(
name|minTokenMatchFactor
operator|<
literal|0
condition|)
block|{
name|this
operator|.
name|minTokenMatchFactor
operator|=
name|DEFAULT_MIN_TOKEN_MATCH_FACTOR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|minTokenMatchFactor
operator|==
literal|0
operator|||
name|minTokenMatchFactor
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"minimum Token Match Facter MUST be> 0<= 1 (parsed: "
operator|+
name|minTokenMatchFactor
operator|+
literal|")!"
argument_list|)
throw|;
block|}
else|else
block|{
name|this
operator|.
name|minTokenMatchFactor
operator|=
name|minTokenMatchFactor
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

