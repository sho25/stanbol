begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *   */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|keywordextraction
operator|.
name|linking
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Representation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|rdf
operator|.
name|RdfResourceEnum
import|;
end_import

begin_comment
comment|/**  * A suggestion of an entity in the {@link EntitySearcher} for a part of the  * text. This class does not include the actual position within the Text,   * because it is intended to be used in combination with {@link LinkedEntity}.<p>  * This class also manages redirected entities and a state if redirects where  * already processed for this suggestion.<p>  * In addition this class also defines a set of {@link Comparator}s that are   * used to sort suggestions base on how well the fit the text.  * @author Rupert Westenthaler  *  */
end_comment

begin_class
specifier|public
class|class
name|Suggestion
implements|implements
name|Comparable
argument_list|<
name|Suggestion
argument_list|>
block|{
specifier|private
name|MATCH
name|match
init|=
name|MATCH
operator|.
name|NONE
decl_stmt|;
specifier|private
name|int
name|span
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|matchCount
init|=
literal|0
decl_stmt|;
specifier|private
name|Text
name|label
decl_stmt|;
specifier|private
name|int
name|labelTokenCount
init|=
literal|0
decl_stmt|;
specifier|private
specifier|final
name|Representation
name|result
decl_stmt|;
specifier|private
name|Representation
name|redirectsTo
decl_stmt|;
specifier|private
name|boolean
name|redirectProcessed
decl_stmt|;
specifier|private
name|double
name|score
decl_stmt|;
specifier|public
specifier|static
enum|enum
name|MATCH
block|{
comment|/**          * No match (to less tokens, wrong oder ...)          */
name|NONE
block|,
comment|/**          * Not all tokens but sufficient to suggest (with lower score)          */
name|PARTIAL
block|,
comment|/**          * All requested Tokens match, but it is no exact match e.g. because          * the label defines some additional tokens          */
name|FULL
block|,
comment|/**          * The label of the suggested Entity is exactly the requested string          */
name|EXACT
block|,     }
specifier|protected
name|Suggestion
parameter_list|(
name|Representation
name|result
parameter_list|)
block|{
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Result MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|this
operator|.
name|result
operator|=
name|result
expr_stmt|;
comment|//TODO Do no longer use the resultScore as the score. We need to provide an
comment|//own algorithm to calculate scores!
comment|//        this.resultScore = result.getFirst(RdfResourceEnum.resultScore.getUri(), Float.class);
block|}
comment|/**      * Updates this suggestion       * @param match the math type      * @param span the number of token this suggestion spans      * @param count the number of token that match with the suggestion within the span      * @param label the label that matches the tokens      * @param labelTokenCount the number of tokens of the label      */
specifier|protected
name|void
name|updateMatch
parameter_list|(
name|MATCH
name|match
parameter_list|,
name|int
name|span
parameter_list|,
name|int
name|count
parameter_list|,
name|Text
name|label
parameter_list|,
name|int
name|labelTokenCount
parameter_list|)
block|{
name|this
operator|.
name|match
operator|=
name|match
expr_stmt|;
comment|//check the validity of the parameters to avoid later errors that are
comment|//than hard to debug
if|if
condition|(
name|match
operator|==
name|MATCH
operator|.
name|NONE
condition|)
block|{
name|this
operator|.
name|span
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|matchCount
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|label
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|span
operator|<
literal|1
operator|||
name|count
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"For "
operator|+
name|match
operator|+
literal|" matches the token span and count MUST BE> 0"
argument_list|)
throw|;
block|}
if|if
condition|(
name|match
operator|==
name|MATCH
operator|.
name|PARTIAL
condition|)
block|{
if|if
condition|(
name|span
operator|<=
name|count
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"For "
operator|+
name|match
operator|+
literal|" matches the token span MUST BE> than the token count!"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|span
operator|!=
name|count
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"For "
operator|+
name|match
operator|+
literal|" matches the token span MUST BE equals to the token count!"
argument_list|)
throw|;
block|}
block|}
block|}
name|this
operator|.
name|span
operator|=
name|span
expr_stmt|;
name|this
operator|.
name|matchCount
operator|=
name|count
expr_stmt|;
name|this
operator|.
name|label
operator|=
name|label
expr_stmt|;
name|this
operator|.
name|labelTokenCount
operator|=
name|labelTokenCount
expr_stmt|;
block|}
comment|/**      * Getter for the number of Tokens of the label. Usually needed to calculate      * the score (how good the label matches)      * @return the labelTokenCount      */
specifier|public
specifier|final
name|int
name|getLabelTokenCount
parameter_list|()
block|{
return|return
name|labelTokenCount
return|;
block|}
comment|/**      * Setter for the {@link MATCH} type of this suggestion      * @param match the match type      */
specifier|protected
name|void
name|setMatch
parameter_list|(
name|MATCH
name|match
parameter_list|)
block|{
name|this
operator|.
name|match
operator|=
name|match
expr_stmt|;
block|}
comment|/**      * Getter for the the type of the match      * @return The type of the match      */
specifier|public
specifier|final
name|MATCH
name|getMatch
parameter_list|()
block|{
return|return
name|match
return|;
block|}
comment|/**      * Getter for the number of the token matched by this suggestion      * @return The number of the token matched by this suggestion      */
specifier|public
specifier|final
name|int
name|getSpan
parameter_list|()
block|{
return|return
name|span
return|;
block|}
comment|/**      * Getter for the he number of matching tokens.      * @return The number of matching tokens.      */
specifier|public
specifier|final
name|int
name|getMatchCount
parameter_list|()
block|{
return|return
name|matchCount
return|;
block|}
comment|/**      * The actual label of the {@link #getResult() result} that produced the      * based match for the given search tokens.      * @return the label      */
specifier|public
specifier|final
name|Text
name|getMatchedLabel
parameter_list|()
block|{
return|return
name|label
return|;
block|}
specifier|protected
specifier|final
name|void
name|setMatchedLabel
parameter_list|(
name|Text
name|label
parameter_list|)
block|{
name|this
operator|.
name|label
operator|=
name|label
expr_stmt|;
block|}
comment|/**      * Getter for the best label in the given language      * @param suggestion the suggestion      * @param nameField the field used to search for labels      * @param language the language      * @return the best match or {@link Suggestion#getMatchedLabel()} if non is found      */
specifier|public
name|Text
name|getBestLabel
parameter_list|(
name|String
name|nameField
parameter_list|,
name|String
name|language
parameter_list|)
block|{
name|Representation
name|rep
init|=
name|getRepresentation
argument_list|()
decl_stmt|;
comment|// 1. check if the returned Entity does has a label -> if not return null
comment|// add labels (set only a single label. Use "en" if available!
name|Text
name|label
init|=
literal|null
decl_stmt|;
name|Iterator
argument_list|<
name|Text
argument_list|>
name|labels
init|=
name|rep
operator|.
name|getText
argument_list|(
name|nameField
argument_list|)
decl_stmt|;
name|boolean
name|matchFound
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|labels
operator|.
name|hasNext
argument_list|()
operator|&&
operator|!
name|matchFound
condition|)
block|{
name|Text
name|actLabel
init|=
name|labels
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|label
operator|==
literal|null
condition|)
block|{
comment|//take any label at first
name|label
operator|=
name|actLabel
expr_stmt|;
block|}
comment|//now we have already a label check the language
name|String
name|actLang
init|=
name|actLabel
operator|.
name|getLanguage
argument_list|()
decl_stmt|;
comment|//use startWith to match also en-GB and en-US ...
if|if
condition|(
name|actLang
operator|!=
literal|null
operator|&&
name|actLang
operator|.
name|startsWith
argument_list|(
name|language
argument_list|)
condition|)
block|{
comment|//prefer labels with the correct language
name|label
operator|=
name|actLabel
expr_stmt|;
if|if
condition|(
name|label
operator|.
name|getText
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|label
operator|.
name|getText
argument_list|()
argument_list|)
condition|)
block|{
comment|//found label in that language that exactly matches the
comment|//label used to match the text
name|matchFound
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|label
operator|==
literal|null
condition|)
block|{
comment|//if no label was found ... return the one used for the match
name|label
operator|=
name|getMatchedLabel
argument_list|()
expr_stmt|;
block|}
return|return
name|label
return|;
block|}
specifier|public
specifier|final
name|Representation
name|getResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|label
operator|+
literal|"[m="
operator|+
name|match
operator|+
operator|(
name|match
operator|!=
name|MATCH
operator|.
name|NONE
condition|?
literal|",c="
operator|+
name|matchCount
operator|+
literal|",s="
operator|+
name|span
operator|+
literal|']'
else|:
literal|"]"
operator|)
return|;
block|}
comment|/**      * The {@link RdfResourceEnum#entityRank entity rank} of the {@link #getResult() result}.      * The entity rank is the relative importance of an entity within an      * Collection of Entities (ReferencedSite, Thesaurus, Taxonomy ...).<p>      * This method returns the rank of the entity returned by      * {@link #getRepresentation()}. Therefore if an redirect is active it will      * be the rank of the redirected entity and not of the suggested result.      * @return the rank of the entity or<code>null</code> if not available      */
specifier|public
name|Float
name|getEntityRank
parameter_list|()
block|{
return|return
name|getRepresentation
argument_list|()
operator|.
name|getFirst
argument_list|(
name|RdfResourceEnum
operator|.
name|entityRank
operator|.
name|getUri
argument_list|()
argument_list|,
name|Float
operator|.
name|class
argument_list|)
return|;
block|}
comment|/**      * @param score the score to set      */
specifier|public
name|void
name|setScore
parameter_list|(
name|double
name|score
parameter_list|)
block|{
name|this
operator|.
name|score
operator|=
name|score
expr_stmt|;
block|}
comment|/**      * @return the score      */
specifier|public
name|double
name|getScore
parameter_list|()
block|{
return|return
name|score
return|;
block|}
comment|/**      * Returns<code>true</code> if the result has a registered redirect      * @return<code>true</code> if a redirect is present. Otherwise<code>false</code>      */
specifier|public
name|boolean
name|isRedirect
parameter_list|()
block|{
return|return
name|redirectsTo
operator|!=
literal|null
return|;
block|}
comment|/**      * Setter for Entity the {@link #getResult() result} of this match redirects      * to. Also sets {@link #setRedirectProcessed(boolean)} to<code>true</code>      * @param redirect the redirected entity or<code>null</code> if no redirect      * is present      */
specifier|protected
name|void
name|setRedirect
parameter_list|(
name|Representation
name|redirect
parameter_list|)
block|{
name|this
operator|.
name|redirectsTo
operator|=
name|redirect
expr_stmt|;
name|setRedirectProcessed
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**      * Setter for the state if the redirects for this resultMatch where already      * processed. Calling {@link #setRedirect(Representation)} will set this      * automatically to<code>true</code>      * @param state the state.      */
specifier|protected
name|void
name|setRedirectProcessed
parameter_list|(
name|boolean
name|state
parameter_list|)
block|{
name|this
operator|.
name|redirectProcessed
operator|=
name|state
expr_stmt|;
block|}
comment|/**      * Getter for the state if the redirect was processed for this ResultMatch      * @return the state      */
specifier|protected
name|boolean
name|isRedirectedProcessed
parameter_list|()
block|{
return|return
name|redirectProcessed
return|;
block|}
comment|/**      * Getter for the Entity the {@link #getResult()} of this Entity redirects      * to. Returns<code>null</code> if there is no redirect.       * @return the entity the {@link #getResult()} redirects to or<code>null</code>      * if there is no redirect      */
specifier|public
name|Representation
name|getRedirect
parameter_list|()
block|{
return|return
name|redirectsTo
return|;
block|}
comment|/**      * getter for the Representation of this result. In case of       *<code>{@link #isRedirect()} == true</code> it returns the the       * {@link #getRedirect()} otherwise it returns the {@link #getResult()}.<p>      * To check explicitly for the result of the redirect one needs to use      * {@link #getRedirect()} and {@link #getRedirect()} instead.      * @return The representation for this match. might be directly the       * {@link #getResult() result} or if present the       * {@link #getRedirect() redirected} resource.       */
specifier|public
specifier|final
name|Representation
name|getRepresentation
parameter_list|()
block|{
return|return
name|redirectsTo
operator|==
literal|null
condition|?
name|result
else|:
name|redirectsTo
return|;
block|}
comment|/**      * Compares {@link Suggestion} first based on the {@link Suggestion#getMatch()} value      * and secondly based on the {@link RdfResourceEnum#entityRank}.      */
specifier|public
specifier|static
specifier|final
name|Comparator
argument_list|<
name|Suggestion
argument_list|>
name|MATCH_TYPE_SUGGESTION_COMPARATOR
init|=
operator|new
name|Comparator
argument_list|<
name|Suggestion
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Suggestion
name|arg0
parameter_list|,
name|Suggestion
name|arg1
parameter_list|)
block|{
if|if
condition|(
name|arg0
operator|.
name|match
operator|!=
name|arg1
operator|.
name|match
condition|)
block|{
return|return
name|arg1
operator|.
name|match
operator|.
name|ordinal
argument_list|()
operator|-
name|arg0
operator|.
name|match
operator|.
name|ordinal
argument_list|()
return|;
comment|//higher ordinal first
block|}
elseif|else
if|if
condition|(
name|arg0
operator|.
name|match
operator|==
name|MATCH
operator|.
name|NONE
condition|)
block|{
return|return
literal|0
return|;
comment|//do not further sort entries that do not match
block|}
else|else
block|{
name|Float
name|arg0Rank
init|=
name|arg0
operator|.
name|getEntityRank
argument_list|()
decl_stmt|;
if|if
condition|(
name|arg0Rank
operator|==
literal|null
condition|)
block|{
name|arg0Rank
operator|=
name|Float
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|Float
name|arg1Rank
init|=
name|arg1
operator|.
name|getEntityRank
argument_list|()
decl_stmt|;
if|if
condition|(
name|arg1Rank
operator|==
literal|null
condition|)
block|{
name|arg1Rank
operator|=
name|Float
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|arg1Rank
operator|.
name|compareTo
argument_list|(
name|arg0Rank
argument_list|)
return|;
comment|//higher ranks first
block|}
block|}
block|}
decl_stmt|;
comment|/**      * Compares {@link Suggestion}s based on the {@link Suggestion#getScore()}.      * In case the scores are equals the call is forwarded to the      * {@link Suggestion#DEFAULT_SUGGESTION_COMPARATOR}.<p>      * This is NOT the default {@link Comparator} because score values are      * usually only calculated relative to the best matching suggestions and      * therefore only available later.      */
specifier|public
specifier|static
specifier|final
name|Comparator
argument_list|<
name|Suggestion
argument_list|>
name|SCORE_COMPARATOR
init|=
operator|new
name|Comparator
argument_list|<
name|Suggestion
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Suggestion
name|arg0
parameter_list|,
name|Suggestion
name|arg1
parameter_list|)
block|{
return|return
name|arg0
operator|.
name|getScore
argument_list|()
operator|>
name|arg1
operator|.
name|getScore
argument_list|()
condition|?
operator|-
literal|1
else|:
comment|//bigger score first
name|arg0
operator|.
name|getScore
argument_list|()
operator|<
name|arg1
operator|.
name|getScore
argument_list|()
condition|?
literal|1
else|:
name|DEFAULT_SUGGESTION_COMPARATOR
operator|.
name|compare
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/**      * Compares {@link Suggestion} first based on the {@link Suggestion#getMatchCount()}       * number of matched tokens. If the number of the matched tokens is equals or      * any of the parsed {@link Suggestion} instances has {@link MATCH#NONE} it      * forwards the request to the {@link #MATCH_TYPE_SUGGESTION_COMPARATOR}.      */
specifier|public
specifier|static
specifier|final
name|Comparator
argument_list|<
name|Suggestion
argument_list|>
name|DEFAULT_SUGGESTION_COMPARATOR
init|=
operator|new
name|Comparator
argument_list|<
name|Suggestion
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Suggestion
name|arg0
parameter_list|,
name|Suggestion
name|arg1
parameter_list|)
block|{
if|if
condition|(
name|arg0
operator|.
name|match
operator|==
name|MATCH
operator|.
name|NONE
operator|||
name|arg1
operator|.
name|match
operator|==
name|MATCH
operator|.
name|NONE
operator|||
name|arg0
operator|.
name|matchCount
operator|==
name|arg1
operator|.
name|matchCount
condition|)
block|{
return|return
name|MATCH_TYPE_SUGGESTION_COMPARATOR
operator|.
name|compare
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|arg1
operator|.
name|matchCount
operator|-
name|arg0
operator|.
name|matchCount
return|;
comment|//bigger should be first
block|}
block|}
block|}
decl_stmt|;
comment|/**      * Implementation of the {@link Comparable} interface using      * {@link #MATCH_TYPE_SUGGESTION_COMPARATOR}.      */
annotation|@
name|Override
specifier|public
name|int
name|compareTo
parameter_list|(
name|Suggestion
name|other
parameter_list|)
block|{
return|return
name|DEFAULT_SUGGESTION_COMPARATOR
operator|.
name|compare
argument_list|(
name|this
argument_list|,
name|other
argument_list|)
return|;
block|}
block|}
end_class

end_unit

