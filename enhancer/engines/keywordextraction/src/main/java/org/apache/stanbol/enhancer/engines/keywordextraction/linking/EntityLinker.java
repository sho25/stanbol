begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|keywordextraction
operator|.
name|linking
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|UriRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|opennlp
operator|.
name|TextAnalyzer
operator|.
name|AnalysedText
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|keywordextraction
operator|.
name|impl
operator|.
name|ProcessingState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|keywordextraction
operator|.
name|linking
operator|.
name|EntityLinkerConfig
operator|.
name|RedirectProcessingMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|keywordextraction
operator|.
name|linking
operator|.
name|Suggestion
operator|.
name|MATCH
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|defaults
operator|.
name|NamespaceEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Reference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Representation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|rdf
operator|.
name|RdfResourceEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_class
specifier|public
class|class
name|EntityLinker
block|{
specifier|private
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|EntityLinker
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|EntityLinkerConfig
name|config
decl_stmt|;
specifier|private
specifier|final
name|AnalysedContent
name|content
decl_stmt|;
specifier|private
specifier|final
name|EntitySearcher
name|entitySearcher
decl_stmt|;
comment|/**      * The state of the current processing      */
specifier|private
specifier|final
name|ProcessingState
name|state
decl_stmt|;
comment|/**      * The map holding the results of the linking process      */
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|LinkedEntity
argument_list|>
name|linkedEntities
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|LinkedEntity
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * After {@link #process()}ing this returns the entities linked for the      * parsed {@link AnalysedContent}.      * @return the linked entities      */
specifier|public
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|LinkedEntity
argument_list|>
name|getLinkedEntities
parameter_list|()
block|{
return|return
name|linkedEntities
return|;
block|}
specifier|public
name|EntityLinker
parameter_list|(
name|AnalysedContent
name|content
parameter_list|,
name|EntitySearcher
name|taxonomy
parameter_list|,
name|EntityLinkerConfig
name|config
parameter_list|)
block|{
if|if
condition|(
name|config
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed TaxonomyLinkerConfig MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|taxonomy
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Taxonomy MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|content
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed AnalysedContent MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|this
operator|.
name|content
operator|=
name|content
expr_stmt|;
name|this
operator|.
name|entitySearcher
operator|=
name|taxonomy
expr_stmt|;
name|this
operator|.
name|config
operator|=
name|config
expr_stmt|;
name|this
operator|.
name|state
operator|=
operator|new
name|ProcessingState
argument_list|(
name|content
operator|.
name|getAnalysedText
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Steps over the sentences, chunks, tokens of the {@link #sentences}      */
specifier|public
name|void
name|process
parameter_list|()
block|{
while|while
condition|(
name|state
operator|.
name|next
argument_list|()
condition|)
block|{
if|if
condition|(
name|isProcessableToken
argument_list|(
name|state
operator|.
name|getToken
argument_list|()
argument_list|)
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|searchStrings
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|config
operator|.
name|getMaxSearchTokens
argument_list|()
argument_list|)
decl_stmt|;
name|searchStrings
operator|.
name|add
argument_list|(
name|state
operator|.
name|getToken
argument_list|()
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
comment|//get the list of all tokens that can possible be matched
name|int
name|includeTokenIndex
init|=
name|state
operator|.
name|getTokenIndex
argument_list|()
decl_stmt|;
name|includeTokenIndex
operator|++
expr_stmt|;
while|while
condition|(
name|searchStrings
operator|.
name|size
argument_list|()
operator|<
name|config
operator|.
name|getMaxSearchTokens
argument_list|()
operator|&&
comment|//more search strings
operator|(
name|includeTokenIndex
operator|<=
operator|(
name|state
operator|.
name|getChunk
argument_list|()
operator|!=
literal|null
condition|?
comment|//still within
name|state
operator|.
name|getChunk
argument_list|()
operator|.
name|getEnd
argument_list|()
else|:
comment|//the chunk
name|state
operator|.
name|getSentence
argument_list|()
operator|.
name|getTokens
argument_list|()
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|//or sentence
name|Token
name|included
init|=
name|state
operator|.
name|getSentence
argument_list|()
operator|.
name|getTokens
argument_list|()
operator|.
name|get
argument_list|(
name|includeTokenIndex
argument_list|)
decl_stmt|;
name|includeTokenIndex
operator|++
expr_stmt|;
if|if
condition|(
name|isProcessableToken
argument_list|(
name|included
argument_list|)
condition|)
block|{
name|searchStrings
operator|.
name|add
argument_list|(
name|included
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|//search for Entities
name|List
argument_list|<
name|Suggestion
argument_list|>
name|suggestions
init|=
name|lookupEntities
argument_list|(
name|searchStrings
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|suggestions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//update the suggestions based on the best match
name|int
name|bestMatchCount
init|=
name|suggestions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getMatchCount
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Suggestion
argument_list|>
name|it
init|=
name|suggestions
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Suggestion
name|suggestion
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
comment|//suggestions that match less tokens as the best match
comment|//need to be updated to PARTIAL
if|if
condition|(
name|suggestion
operator|.
name|getMatchCount
argument_list|()
operator|<
name|bestMatchCount
condition|)
block|{
name|suggestion
operator|.
name|setMatch
argument_list|(
name|MATCH
operator|.
name|PARTIAL
argument_list|)
expr_stmt|;
block|}
comment|//Filter matches with less than config.getMinFoundTokens()
comment|//if matchcount is less than of the best match
if|if
condition|(
name|suggestion
operator|.
name|getMatchCount
argument_list|()
operator|<
name|bestMatchCount
operator|&&
name|suggestion
operator|.
name|getMatchCount
argument_list|()
operator|<
name|config
operator|.
name|getMinFoundTokens
argument_list|()
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|//calculate the score
name|double
name|suggestionMatchScore
init|=
name|suggestion
operator|.
name|getMatchCount
argument_list|()
operator|*
name|suggestion
operator|.
name|getMatchScore
argument_list|()
decl_stmt|;
comment|//how good is the current match in relation to the best one
name|double
name|spanScore
init|=
name|suggestion
operator|.
name|getMatchCount
argument_list|()
operator|/
name|bestMatchCount
decl_stmt|;
comment|//how good is the match to the span selected by this suggestion
name|double
name|textScore
init|=
name|suggestionMatchScore
operator|/
name|suggestion
operator|.
name|getSpan
argument_list|()
decl_stmt|;
comment|//how good is the match in relation to the tokens of the suggested label
name|double
name|labelScore
init|=
name|suggestionMatchScore
operator|/
name|suggestion
operator|.
name|getLabelTokenCount
argument_list|()
decl_stmt|;
name|suggestion
operator|.
name|setScore
argument_list|(
name|spanScore
operator|*
name|spanScore
operator|*
name|textScore
operator|*
name|labelScore
argument_list|)
expr_stmt|;
block|}
block|}
name|Suggestion
name|oldBestRanked
init|=
name|suggestions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|//for debugging
comment|//resort by score
name|Collections
operator|.
name|sort
argument_list|(
name|suggestions
argument_list|,
name|Suggestion
operator|.
name|SCORE_COMPARATOR
argument_list|)
expr_stmt|;
comment|//this should never happen ... but the
comment|//matchcount of the best match MUST NOT change
comment|//after the sort by score!
if|if
condition|(
name|bestMatchCount
operator|!=
name|suggestions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getMatchCount
argument_list|()
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"The match count for the top Ranked Suggestion for {} "
operator|+
literal|"changed after resorting based on Scores!"
argument_list|,
name|state
operator|.
name|getTokenText
argument_list|(
name|suggestions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getStart
argument_list|()
argument_list|,
name|bestMatchCount
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|warn
argument_list|(
literal|"  originalbest   : {}"
argument_list|,
name|oldBestRanked
argument_list|)
expr_stmt|;
name|log
operator|.
name|warn
argument_list|(
literal|" currnet ranking : {}"
argument_list|,
name|suggestions
argument_list|)
expr_stmt|;
name|log
operator|.
name|warn
argument_list|(
literal|"  ... this will result in worng confidence values relative to the best match"
argument_list|)
expr_stmt|;
block|}
comment|//remove all suggestions> config.maxSuggestions
if|if
condition|(
name|suggestions
operator|.
name|size
argument_list|()
operator|>
name|config
operator|.
name|getMaxSuggestions
argument_list|()
condition|)
block|{
name|suggestions
operator|.
name|subList
argument_list|(
name|config
operator|.
name|getMaxSuggestions
argument_list|()
argument_list|,
name|suggestions
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|//process redirects
if|if
condition|(
name|config
operator|.
name|getRedirectProcessingMode
argument_list|()
operator|!=
name|RedirectProcessingMode
operator|.
name|IGNORE
condition|)
block|{
for|for
control|(
name|Suggestion
name|suggestion
range|:
name|suggestions
control|)
block|{
name|processRedirects
argument_list|(
name|suggestion
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|start
init|=
name|suggestions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getStart
argument_list|()
decl_stmt|;
name|int
name|span
init|=
name|suggestions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getSpan
argument_list|()
decl_stmt|;
comment|//Store the linking results
name|String
name|selectedText
init|=
name|state
operator|.
name|getTokenText
argument_list|(
name|start
argument_list|,
name|span
argument_list|)
decl_stmt|;
comment|//float score;
name|LinkedEntity
name|linkedEntity
init|=
name|linkedEntities
operator|.
name|get
argument_list|(
name|selectedText
argument_list|)
decl_stmt|;
if|if
condition|(
name|linkedEntity
operator|==
literal|null
condition|)
block|{
name|linkedEntity
operator|=
operator|new
name|LinkedEntity
argument_list|(
name|selectedText
argument_list|,
name|suggestions
argument_list|,
name|getLinkedEntityTypes
argument_list|(
name|suggestions
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|linkedEntities
operator|.
name|put
argument_list|(
name|selectedText
argument_list|,
name|linkedEntity
argument_list|)
expr_stmt|;
block|}
name|linkedEntity
operator|.
name|addOccurrence
argument_list|(
name|state
operator|.
name|getSentence
argument_list|()
argument_list|,
name|start
argument_list|,
name|span
argument_list|)
expr_stmt|;
comment|//set the next token to process to the next word after the
comment|//currently found suggestion
name|state
operator|.
name|setConsumed
argument_list|(
name|start
operator|+
name|span
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|//else do not process this token
block|}
block|}
comment|/**      * Retrieves all {@link EntitySearcher#getTypeField()} values of the parsed      * {@link Suggestion}s and than lookup the {@link NamespaceEnum#dcTerms dc}:type      * values for the {@link LinkedEntity#getTypes()} by using the configured      * {@link EntityLinkerConfig#getTypeMappings() types mappings} (and if      * no mapping is found the {@link EntityLinkerConfig#getDefaultDcType()       * default} type.      * @param conceptTypes The list of suggestions      * @return the types values for the {@link LinkedEntity}      */
specifier|private
name|Set
argument_list|<
name|UriRef
argument_list|>
name|getLinkedEntityTypes
parameter_list|(
name|Collection
argument_list|<
name|Suggestion
argument_list|>
name|suggestions
parameter_list|)
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|conceptTypes
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Suggestion
name|suggestion
range|:
name|suggestions
control|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|Reference
argument_list|>
name|types
init|=
name|suggestion
operator|.
name|getRepresentation
argument_list|()
operator|.
name|getReferences
argument_list|(
name|config
operator|.
name|getTypeField
argument_list|()
argument_list|)
init|;
name|types
operator|.
name|hasNext
argument_list|()
condition|;
name|conceptTypes
operator|.
name|add
argument_list|(
name|types
operator|.
name|next
argument_list|()
operator|.
name|getReference
argument_list|()
argument_list|)
control|)
empty_stmt|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|UriRef
argument_list|>
name|typeMappings
init|=
name|config
operator|.
name|getTypeMappings
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|UriRef
argument_list|>
name|dcTypes
init|=
operator|new
name|HashSet
argument_list|<
name|UriRef
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|conceptType
range|:
name|conceptTypes
control|)
block|{
name|UriRef
name|dcType
init|=
name|typeMappings
operator|.
name|get
argument_list|(
name|conceptType
argument_list|)
decl_stmt|;
if|if
condition|(
name|dcType
operator|!=
literal|null
condition|)
block|{
name|dcTypes
operator|.
name|add
argument_list|(
name|dcType
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dcTypes
operator|.
name|isEmpty
argument_list|()
operator|&&
name|config
operator|.
name|getDefaultDcType
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|dcTypes
operator|.
name|add
argument_list|(
name|config
operator|.
name|getDefaultDcType
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|dcTypes
return|;
block|}
comment|/**      * Processes {@link EntitySearcher#getRedirectField() redirect field} values for      * the parsed suggestions based on the {@link RedirectProcessingMode}      * as configured in the {@link #config}.<p>      * The results of this method are stored within the parsed {@link Suggestion}s      * @param suggestion The suggestion to process.      */
specifier|private
name|void
name|processRedirects
parameter_list|(
name|Suggestion
name|suggestion
parameter_list|)
block|{
comment|//if mode is IGNORE -> nothing to do
if|if
condition|(
name|config
operator|.
name|getRedirectProcessingMode
argument_list|()
operator|==
name|RedirectProcessingMode
operator|.
name|IGNORE
condition|)
block|{
return|return;
block|}
comment|//in case results for queries are locally cached it might be the case
comment|//that some/all of the results do already redirects processed.
comment|//therefore there is a small internal state that stores this information
if|if
condition|(
name|suggestion
operator|.
name|isRedirectedProcessed
argument_list|()
condition|)
block|{
return|return;
comment|//Redirects for ResultMatch are already processed ... ignore
block|}
name|Representation
name|result
init|=
name|suggestion
operator|.
name|getResult
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Reference
argument_list|>
name|redirects
init|=
name|result
operator|.
name|getReferences
argument_list|(
name|config
operator|.
name|getRedirectField
argument_list|()
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|config
operator|.
name|getRedirectProcessingMode
argument_list|()
condition|)
block|{
case|case
name|ADD_VALUES
case|:
while|while
condition|(
name|redirects
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Reference
name|redirect
init|=
name|redirects
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|redirect
operator|!=
literal|null
condition|)
block|{
name|Representation
name|redirectedEntity
init|=
name|entitySearcher
operator|.
name|get
argument_list|(
name|redirect
operator|.
name|getReference
argument_list|()
argument_list|,
name|config
operator|.
name|getSelectedFields
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|redirectedEntity
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|String
argument_list|>
name|fields
init|=
name|redirectedEntity
operator|.
name|getFieldNames
argument_list|()
init|;
name|fields
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|String
name|field
init|=
name|fields
operator|.
name|next
argument_list|()
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
name|field
argument_list|,
name|redirectedEntity
operator|.
name|get
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|//set that the redirects where searched for this result
name|suggestion
operator|.
name|setRedirectProcessed
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
case|case
name|FOLLOW
case|:
while|while
condition|(
name|redirects
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Reference
name|redirect
init|=
name|redirects
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|redirect
operator|!=
literal|null
condition|)
block|{
name|Representation
name|redirectedEntity
init|=
name|entitySearcher
operator|.
name|get
argument_list|(
name|redirect
operator|.
name|getReference
argument_list|()
argument_list|,
name|config
operator|.
name|getSelectedFields
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|redirectedEntity
operator|!=
literal|null
condition|)
block|{
comment|//copy the original result score
name|redirectedEntity
operator|.
name|set
argument_list|(
name|RdfResourceEnum
operator|.
name|resultScore
operator|.
name|getUri
argument_list|()
argument_list|,
name|result
operator|.
name|get
argument_list|(
name|RdfResourceEnum
operator|.
name|resultScore
operator|.
name|getUri
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|//set the redirect
name|suggestion
operator|.
name|setRedirect
argument_list|(
name|redirectedEntity
argument_list|)
expr_stmt|;
block|}
block|}
block|}
default|default:
comment|//nothing to do
block|}
block|}
comment|/**      * Searches for Entities in the {@link #entitySearcher} corresponding to the      * {@link Token#getText() words} of the current {@link #state position} in      * the text.      * @param searchStrings the list of {@link Token#getText() words} to search      * entities for.      * @return The sorted list with the suggestions.      * If there are no suggestions an empty list will be returned.      */
specifier|private
name|List
argument_list|<
name|Suggestion
argument_list|>
name|lookupEntities
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|searchStrings
parameter_list|)
block|{
name|Collection
argument_list|<
name|?
extends|extends
name|Representation
argument_list|>
name|results
init|=
name|entitySearcher
operator|.
name|lookup
argument_list|(
name|config
operator|.
name|getNameField
argument_list|()
argument_list|,
name|config
operator|.
name|getSelectedFields
argument_list|()
argument_list|,
name|searchStrings
argument_list|,
name|state
operator|.
name|getSentence
argument_list|()
operator|.
name|getLanguage
argument_list|()
argument_list|,
name|config
operator|.
name|getDefaultLanguage
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Suggestion
argument_list|>
name|suggestions
init|=
operator|new
name|ArrayList
argument_list|<
name|Suggestion
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Representation
name|result
range|:
name|results
control|)
block|{
name|Suggestion
name|match
init|=
name|matchLabels
argument_list|(
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
name|match
operator|.
name|getMatch
argument_list|()
operator|!=
name|MATCH
operator|.
name|NONE
condition|)
block|{
name|suggestions
operator|.
name|add
argument_list|(
name|match
argument_list|)
expr_stmt|;
block|}
block|}
comment|//sort the suggestions
if|if
condition|(
name|suggestions
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|suggestions
argument_list|,
name|Suggestion
operator|.
name|DEFAULT_SUGGESTION_COMPARATOR
argument_list|)
expr_stmt|;
block|}
comment|//remove all elements> config.getMaxSuggestions()
return|return
name|suggestions
return|;
block|}
comment|/**      * Matches the labels of the parsed {@link Representation} with the Tokens of      * the texts (beginning with the currently active       * {@link ProcessingState#getToken() token}).<p>      * The field used to get the labels is retrieved from       * {@link EntitySearcher#getNameField()}. Only labels with no language or the      * language of the current sentence are considered. If less than       * {@link EntityLinkerConfig#getMinFoundTokens()} tokens match with an      * label the Concept is only considered to match if the label is      * {@link String#equalsIgnoreCase(String)} to the text covered by the      * matched token(s). Otherwise also {@link MATCH#FULL} and {@link MATCH#PARTIAL}      * results are allowed.      * @param rep The representation including at least the data for the      * {@link EntitySearcher#getNameField()} property.      * @return The result of the matching.      */
specifier|private
name|Suggestion
name|matchLabels
parameter_list|(
name|Representation
name|rep
parameter_list|)
block|{
name|String
name|curLang
init|=
name|state
operator|.
name|getLanguage
argument_list|()
decl_stmt|;
comment|//language of the current sentence
name|String
name|defLang
init|=
name|config
operator|.
name|getDefaultLanguage
argument_list|()
decl_stmt|;
comment|//configured default language
comment|//        Iterator<Text> labels = rep.get(config.getNameField(), //get all labels
comment|//            state.getLanguage(), //in the current language
comment|//            config.getDefaultLanguage()); //and the default language
name|Iterator
argument_list|<
name|Text
argument_list|>
name|labels
init|=
name|rep
operator|.
name|getText
argument_list|(
name|config
operator|.
name|getNameField
argument_list|()
argument_list|)
decl_stmt|;
name|Suggestion
name|match
init|=
operator|new
name|Suggestion
argument_list|(
name|rep
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|Text
argument_list|>
name|defaultLabels
init|=
operator|new
name|ArrayList
argument_list|<
name|Text
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|matchedCurLangLabel
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|labels
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Text
name|label
init|=
name|labels
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|lang
init|=
name|label
operator|.
name|getLanguage
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|lang
operator|==
literal|null
operator|&&
name|curLang
operator|==
literal|null
operator|)
operator|||
operator|(
name|lang
operator|!=
literal|null
operator|&&
name|curLang
operator|!=
literal|null
operator|&&
name|lang
operator|.
name|startsWith
argument_list|(
name|curLang
argument_list|)
operator|)
condition|)
block|{
name|matchLabel
argument_list|(
name|match
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|matchedCurLangLabel
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|lang
operator|==
literal|null
operator|&&
name|defLang
operator|==
literal|null
operator|)
operator|||
operator|(
name|lang
operator|!=
literal|null
operator|&&
name|defLang
operator|!=
literal|null
operator|&&
name|lang
operator|.
name|startsWith
argument_list|(
name|defLang
argument_list|)
operator|)
condition|)
block|{
name|defaultLabels
operator|.
name|add
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
block|}
comment|//use only labels in the default language if there is
comment|// * no label in the current language or
if|if
condition|(
operator|!
name|matchedCurLangLabel
condition|)
block|{
comment|// || match.getMatch() == MATCH.NONE){
for|for
control|(
name|Text
name|defaultLangLabel
range|:
name|defaultLabels
control|)
block|{
name|matchLabel
argument_list|(
name|match
argument_list|,
name|defaultLangLabel
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|match
return|;
block|}
comment|/**      * The default value for the maximum number or non-processable tokens      * allowed to be not matching with a label of an entity before the matching      * is stopped.      */
specifier|private
specifier|static
name|int
name|DEFAULT_MAX_NOT_FOUND
init|=
literal|1
decl_stmt|;
comment|/**     * The value for the maximum number or non-processable tokens     * allowed to be not matching with a label of an entity before the matching     * is stopped.      * TODO: make configurable!     */
specifier|private
name|int
name|maxNotFound
init|=
name|DEFAULT_MAX_NOT_FOUND
decl_stmt|;
comment|/**      * @param match      * @param label      */
specifier|private
name|void
name|matchLabel
parameter_list|(
name|Suggestion
name|match
parameter_list|,
name|Text
name|label
parameter_list|)
block|{
name|String
name|text
init|=
name|label
operator|.
name|getText
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|config
operator|.
name|isCaseSensitiveMatching
argument_list|()
condition|)
block|{
name|text
operator|=
name|text
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
comment|//TODO use language of label for Locale
block|}
comment|//Tokenize the label and remove remove tokens without alpha numerical chars
name|String
index|[]
name|unprocessedLabelTokens
init|=
name|content
operator|.
name|tokenize
argument_list|(
name|text
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|unprocessedLabelTokens
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|boolean
name|hasAlpha
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
operator|!
name|hasAlpha
operator|&&
name|j
operator|<
name|unprocessedLabelTokens
index|[
name|i
index|]
operator|.
name|length
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|hasAlpha
operator|=
name|Character
operator|.
name|isLetterOrDigit
argument_list|(
name|unprocessedLabelTokens
index|[
name|i
index|]
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hasAlpha
condition|)
block|{
name|offset
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|>
literal|0
condition|)
block|{
name|unprocessedLabelTokens
index|[
name|i
operator|-
name|offset
index|]
operator|=
name|unprocessedLabelTokens
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|String
index|[]
name|labelTokens
decl_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
name|labelTokens
operator|=
name|unprocessedLabelTokens
expr_stmt|;
block|}
else|else
block|{
name|labelTokens
operator|=
operator|new
name|String
index|[
name|unprocessedLabelTokens
operator|.
name|length
operator|-
name|offset
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|unprocessedLabelTokens
argument_list|,
literal|0
argument_list|,
name|labelTokens
argument_list|,
literal|0
argument_list|,
name|labelTokens
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|labelTokenSet
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|labelTokens
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|foundProcessableTokens
init|=
literal|0
decl_stmt|;
name|int
name|foundTokens
init|=
literal|0
decl_stmt|;
name|float
name|foundTokenMatch
init|=
literal|0
decl_stmt|;
comment|//ensure the correct order of the tokens in the suggested entity
name|boolean
name|search
init|=
literal|true
decl_stmt|;
name|int
name|firstFoundIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|lastFoundIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|firstFoundLabelIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|lastfoundLabelIndex
init|=
operator|-
literal|1
decl_stmt|;
name|Token
name|currentToken
decl_stmt|;
name|String
name|currentTokenText
decl_stmt|;
name|int
name|currentTokenLength
decl_stmt|;
name|int
name|notFound
init|=
literal|0
decl_stmt|;
comment|//search for matches within the correct order
for|for
control|(
name|int
name|currentIndex
init|=
name|state
operator|.
name|getTokenIndex
argument_list|()
init|;
name|currentIndex
operator|<
name|state
operator|.
name|getSentence
argument_list|()
operator|.
name|getTokens
argument_list|()
operator|.
name|size
argument_list|()
operator|&&
name|search
condition|;
name|currentIndex
operator|++
control|)
block|{
name|currentToken
operator|=
name|state
operator|.
name|getSentence
argument_list|()
operator|.
name|getTokens
argument_list|()
operator|.
name|get
argument_list|(
name|currentIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentToken
operator|.
name|hasAplhaNumericChar
argument_list|()
condition|)
block|{
name|currentTokenText
operator|=
name|currentToken
operator|.
name|getText
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|config
operator|.
name|isCaseSensitiveMatching
argument_list|()
condition|)
block|{
name|currentTokenText
operator|=
name|currentTokenText
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
block|}
name|currentTokenLength
operator|=
name|currentTokenText
operator|.
name|length
argument_list|()
expr_stmt|;
name|boolean
name|isProcessable
init|=
name|isProcessableToken
argument_list|(
name|currentToken
argument_list|)
decl_stmt|;
name|boolean
name|found
init|=
literal|false
decl_stmt|;
name|float
name|matchFactor
init|=
literal|0f
decl_stmt|;
comment|//iteration starts at the next token after the last matched one
comment|//so it is OK to skip tokens in the label, but not within the text
for|for
control|(
name|int
name|i
init|=
name|lastfoundLabelIndex
operator|+
literal|1
init|;
operator|!
name|found
operator|&&
name|i
operator|<
name|labelTokens
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|labelTokenText
init|=
name|labelTokens
index|[
name|i
index|]
decl_stmt|;
name|int
name|labelTokenLength
init|=
name|labelTokenText
operator|.
name|length
argument_list|()
decl_stmt|;
name|float
name|maxLength
init|=
name|currentTokenLength
operator|>
name|labelTokenLength
condition|?
name|currentTokenLength
else|:
name|labelTokenLength
decl_stmt|;
name|float
name|lengthDif
init|=
name|Math
operator|.
name|abs
argument_list|(
name|currentTokenLength
operator|-
name|labelTokenLength
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|lengthDif
operator|/
name|maxLength
operator|)
operator|<=
literal|0.3f
condition|)
block|{
comment|//this prevents unnecessary string comparison
name|int
name|matchCount
init|=
name|compairTokens
argument_list|(
name|currentTokenText
argument_list|,
name|labelTokenText
argument_list|)
decl_stmt|;
if|if
condition|(
name|matchCount
operator|/
name|maxLength
operator|>=
literal|0.7f
condition|)
block|{
name|lastfoundLabelIndex
operator|=
name|i
expr_stmt|;
comment|//set the last found index to the current position
name|found
operator|=
literal|true
expr_stmt|;
comment|//set found to true -> stops iteration
name|matchFactor
operator|=
name|matchCount
operator|/
name|maxLength
expr_stmt|;
comment|//how good is the match
comment|//remove matched labels from the set to disable them for
comment|//a later random oder search
name|labelTokenSet
operator|.
name|remove
argument_list|(
name|labelTokenText
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
comment|//search for a match in the wrong order
comment|//currently only exact matches (for testing)
if|if
condition|(
name|found
operator|=
name|labelTokenSet
operator|.
name|remove
argument_list|(
name|currentTokenText
argument_list|)
condition|)
block|{
name|matchFactor
operator|=
literal|0.7f
expr_stmt|;
block|}
block|}
comment|//int found = text.indexOf(currentToken.getText().toLowerCase());
if|if
condition|(
name|found
condition|)
block|{
comment|//found
if|if
condition|(
name|isProcessable
condition|)
block|{
name|foundProcessableTokens
operator|++
expr_stmt|;
comment|//only count processable Tokens
block|}
name|foundTokens
operator|++
expr_stmt|;
name|foundTokenMatch
operator|=
name|foundTokenMatch
operator|+
name|matchFactor
expr_stmt|;
comment|//sum up the matches
if|if
condition|(
name|firstFoundIndex
operator|<
literal|0
condition|)
block|{
name|firstFoundIndex
operator|=
name|currentIndex
expr_stmt|;
name|firstFoundLabelIndex
operator|=
name|lastfoundLabelIndex
expr_stmt|;
block|}
name|lastFoundIndex
operator|=
name|currentIndex
expr_stmt|;
block|}
else|else
block|{
comment|//not found
name|notFound
operator|++
expr_stmt|;
if|if
condition|(
name|isProcessable
operator|||
name|notFound
operator|>
name|maxNotFound
condition|)
block|{
comment|//stop as soon as a token that needs to be processed is
comment|//not found in the label or the maximum number of tokens
comment|//that are not processable are not found
name|search
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
comment|// else token without alpha or numeric characters are not processed
block|}
comment|//search backwards for label tokens until firstFoundLabelIndex if there
comment|//are unconsumed Tokens in the sentence before state.getTokenIndex
name|int
name|currentIndex
init|=
name|state
operator|.
name|getTokenIndex
argument_list|()
operator|-
literal|1
decl_stmt|;
name|int
name|labelIndex
init|=
name|firstFoundLabelIndex
operator|-
literal|1
decl_stmt|;
name|notFound
operator|=
literal|0
expr_stmt|;
name|search
operator|=
literal|true
expr_stmt|;
while|while
condition|(
name|search
operator|&&
name|labelIndex
operator|>=
literal|0
operator|&&
name|currentIndex
operator|>
name|state
operator|.
name|getConsumedIndex
argument_list|()
condition|)
block|{
name|String
name|labelTokenText
init|=
name|labelTokens
index|[
name|labelIndex
index|]
decl_stmt|;
if|if
condition|(
name|labelTokenSet
operator|.
name|remove
argument_list|(
name|labelTokenText
argument_list|)
condition|)
block|{
comment|//still not matched
name|currentToken
operator|=
name|state
operator|.
name|getSentence
argument_list|()
operator|.
name|getTokens
argument_list|()
operator|.
name|get
argument_list|(
name|currentIndex
argument_list|)
expr_stmt|;
name|currentTokenText
operator|=
name|currentToken
operator|.
name|getText
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|config
operator|.
name|isCaseSensitiveMatching
argument_list|()
condition|)
block|{
name|currentTokenText
operator|=
name|currentTokenText
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
block|}
name|currentTokenLength
operator|=
name|currentTokenText
operator|.
name|length
argument_list|()
expr_stmt|;
name|boolean
name|found
init|=
literal|false
decl_stmt|;
name|float
name|matchFactor
init|=
literal|0f
decl_stmt|;
name|int
name|labelTokenLength
init|=
name|labelTokenText
operator|.
name|length
argument_list|()
decl_stmt|;
name|float
name|maxLength
init|=
name|currentTokenLength
operator|>
name|labelTokenLength
condition|?
name|currentTokenLength
else|:
name|labelTokenLength
decl_stmt|;
name|float
name|lengthDif
init|=
name|Math
operator|.
name|abs
argument_list|(
name|currentTokenLength
operator|-
name|labelTokenLength
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|lengthDif
operator|/
name|maxLength
operator|)
operator|<=
literal|0.3f
condition|)
block|{
comment|//this prevents unnecessary string comparison
name|int
name|matchCount
init|=
name|compairTokens
argument_list|(
name|currentTokenText
argument_list|,
name|labelTokenText
argument_list|)
decl_stmt|;
if|if
condition|(
name|matchCount
operator|/
name|maxLength
operator|>=
literal|0.7f
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
comment|//set found to true -> stops iteration
name|matchFactor
operator|=
name|matchCount
operator|/
name|maxLength
expr_stmt|;
comment|//how good is the match
block|}
block|}
if|if
condition|(
name|found
condition|)
block|{
comment|//found
name|foundTokens
operator|++
expr_stmt|;
name|foundTokenMatch
operator|=
name|foundTokenMatch
operator|+
name|matchFactor
expr_stmt|;
comment|//sum up the matches
name|firstFoundIndex
operator|=
name|currentIndex
expr_stmt|;
name|currentIndex
operator|--
expr_stmt|;
block|}
else|else
block|{
name|notFound
operator|++
expr_stmt|;
if|if
condition|(
name|notFound
operator|>
name|maxNotFound
condition|)
block|{
comment|//stop as soon as a token that needs to be processed is
comment|//not found in the label or the maximum number of tokens
comment|//that are not processable are not found
name|search
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
name|labelIndex
operator|--
expr_stmt|;
block|}
comment|//Now we make a second round to search tokens that match in the wrong order
comment|//e.g. if given and family name of persons are switched
name|MATCH
name|labelMatch
decl_stmt|;
name|int
name|coveredTokens
init|=
name|lastFoundIndex
operator|-
name|firstFoundIndex
operator|+
literal|1
decl_stmt|;
name|float
name|labelMatchScore
init|=
operator|(
name|foundTokenMatch
operator|/
operator|(
name|float
operator|)
name|labelTokens
operator|.
name|length
operator|)
decl_stmt|;
comment|//Matching rules
comment|// - if less than config#minTokenFound() than accept only EXACT
comment|// - override PARTIAL matches with FULL/EXACT matches only if
comment|//   foundTokens of the PARTIAL match is> than of the FULL/EXACT
comment|//   match (this will be very rare
if|if
condition|(
name|foundProcessableTokens
operator|>
literal|0
operator|&&
name|match
operator|.
name|getMatchCount
argument_list|()
operator|<=
name|foundProcessableTokens
condition|)
block|{
name|String
name|currentText
init|=
name|state
operator|.
name|getTokenText
argument_list|(
name|firstFoundIndex
argument_list|,
name|coveredTokens
argument_list|)
decl_stmt|;
if|if
condition|(
name|config
operator|.
name|isCaseSensitiveMatching
argument_list|()
condition|?
name|currentText
operator|.
name|equals
argument_list|(
name|text
argument_list|)
else|:
name|currentText
operator|.
name|equalsIgnoreCase
argument_list|(
name|text
argument_list|)
condition|)
block|{
name|labelMatch
operator|=
name|MATCH
operator|.
name|EXACT
expr_stmt|;
comment|//set found to covered: May be lower because only
comment|//processable tokens are counted, but Exact also checks
comment|//of non-processable!
name|foundTokens
operator|=
name|coveredTokens
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|foundProcessableTokens
operator|>=
name|config
operator|.
name|getMinFoundTokens
argument_list|()
operator|||
name|foundTokens
operator|==
name|coveredTokens
operator|)
operator|&&
name|labelMatchScore
operator|>=
literal|0.6f
condition|)
block|{
if|if
condition|(
name|foundTokens
operator|==
name|coveredTokens
condition|)
block|{
name|labelMatch
operator|=
name|MATCH
operator|.
name|FULL
expr_stmt|;
block|}
else|else
block|{
name|labelMatch
operator|=
name|MATCH
operator|.
name|PARTIAL
expr_stmt|;
block|}
block|}
else|else
block|{
name|labelMatch
operator|=
name|MATCH
operator|.
name|NONE
expr_stmt|;
block|}
if|if
condition|(
name|labelMatch
operator|!=
name|MATCH
operator|.
name|NONE
condition|)
block|{
if|if
condition|(
name|match
operator|.
name|getMatchCount
argument_list|()
operator|<
name|foundProcessableTokens
operator|||
name|match
operator|.
name|getMatchCount
argument_list|()
operator|==
name|foundProcessableTokens
operator|&&
name|labelMatch
operator|.
name|ordinal
argument_list|()
operator|>
name|match
operator|.
name|getMatch
argument_list|()
operator|.
name|ordinal
argument_list|()
condition|)
block|{
name|match
operator|.
name|updateMatch
argument_list|(
name|labelMatch
argument_list|,
name|firstFoundIndex
argument_list|,
name|coveredTokens
argument_list|,
name|foundTokens
argument_list|,
name|foundTokenMatch
operator|/
name|foundTokens
argument_list|,
name|label
argument_list|,
name|labelTokens
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|//else this match is not better as the existing one
block|}
comment|//else ignore labels with MATCH.NONE
block|}
comment|//else NO tokens found -> nothing to do
block|}
comment|/**      * Compares to token with each other and returns the longest match. The       * tokens are compared from the beginning and from the end.      * @param token1 the first token      * @param token2 the second token      * @return the number of matching chars      */
specifier|private
name|int
name|compairTokens
parameter_list|(
name|String
name|token1
parameter_list|,
name|String
name|token2
parameter_list|)
block|{
name|int
name|l1
init|=
name|token1
operator|.
name|length
argument_list|()
decl_stmt|;
comment|//length of the first token
name|int
name|l2
init|=
name|token2
operator|.
name|length
argument_list|()
decl_stmt|;
comment|//length of the second token
comment|//in case of same length check for equals first
if|if
condition|(
name|l1
operator|==
name|l2
operator|&&
name|token1
operator|.
name|equals
argument_list|(
name|token2
argument_list|)
condition|)
block|{
return|return
name|l1
return|;
block|}
name|int
name|ml
init|=
name|l1
operator|>
name|l2
condition|?
name|l2
else|:
name|l1
decl_stmt|;
comment|//minimum length of a token
if|if
condition|(
name|ml
operator|==
literal|0
condition|)
block|{
return|return
name|ml
return|;
block|}
name|int
name|f
init|=
literal|0
decl_stmt|;
comment|//forward match count + 1
name|int
name|b
init|=
literal|0
decl_stmt|;
comment|//backward match count + 1
name|boolean
name|match
init|=
literal|true
decl_stmt|;
comment|//still matches
while|while
condition|(
name|match
operator|&&
name|f
operator|<
name|ml
condition|)
block|{
name|match
operator|=
name|token1
operator|.
name|charAt
argument_list|(
name|f
argument_list|)
operator|==
name|token2
operator|.
name|charAt
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|f
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|match
condition|)
block|{
name|f
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|<
name|ml
condition|)
block|{
name|match
operator|=
literal|true
expr_stmt|;
while|while
condition|(
name|match
operator|&&
name|b
operator|<
name|ml
condition|)
block|{
name|b
operator|++
expr_stmt|;
name|match
operator|=
name|token1
operator|.
name|charAt
argument_list|(
name|l1
operator|-
name|b
argument_list|)
operator|==
name|token2
operator|.
name|charAt
argument_list|(
name|l2
operator|-
name|b
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|match
condition|)
block|{
name|b
operator|--
expr_stmt|;
block|}
block|}
return|return
name|f
operator|>
name|b
condition|?
name|f
else|:
name|b
return|;
block|}
comment|/**      * Checks if the current token of {@link #state} is processable.       * @param token the {@link Token} to check.      * @return<code>true</code> if the parsed token needs to be processed.      * Otherwise<code>false</code>      */
specifier|private
name|boolean
name|isProcessableToken
parameter_list|(
name|Token
name|token
parameter_list|)
block|{
name|Boolean
name|processToken
init|=
literal|null
decl_stmt|;
name|String
index|[]
name|posTags
init|=
name|token
operator|.
name|getPosTags
argument_list|()
decl_stmt|;
name|double
index|[]
name|posProb
init|=
name|token
operator|.
name|getPosProbabilities
argument_list|()
decl_stmt|;
if|if
condition|(
name|posTags
operator|!=
literal|null
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
do|do
block|{
name|processToken
operator|=
name|content
operator|.
name|processPOS
argument_list|(
name|posTags
index|[
name|i
index|]
argument_list|,
name|posProb
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|processToken
operator|!=
literal|null
operator|&&
name|processToken
operator|.
name|equals
argument_list|(
name|Boolean
operator|.
name|FALSE
argument_list|)
operator|&&
name|i
operator|<
name|posTags
operator|.
name|length
condition|)
do|;
block|}
if|if
condition|(
name|processToken
operator|==
literal|null
condition|)
block|{
name|processToken
operator|=
name|token
operator|.
name|getText
argument_list|()
operator|.
name|length
argument_list|()
operator|>=
name|config
operator|.
name|getMinSearchTokenLength
argument_list|()
expr_stmt|;
block|}
return|return
name|processToken
return|;
block|}
block|}
end_class

end_unit

