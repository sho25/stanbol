begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|keywordextraction
operator|.
name|linking
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|opennlp
operator|.
name|tools
operator|.
name|util
operator|.
name|Span
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|UriRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|commons
operator|.
name|opennlp
operator|.
name|TextAnalyzer
operator|.
name|AnalysedText
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|keywordextraction
operator|.
name|impl
operator|.
name|ProcessingState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|keywordextraction
operator|.
name|linking
operator|.
name|EntityLinkerConfig
operator|.
name|RedirectProcessingMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|keywordextraction
operator|.
name|linking
operator|.
name|Suggestion
operator|.
name|MATCH
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|defaults
operator|.
name|NamespaceEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Reference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Representation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|rdf
operator|.
name|RdfResourceEnum
import|;
end_import

begin_class
specifier|public
class|class
name|EntityLinker
block|{
specifier|private
specifier|final
name|EntityLinkerConfig
name|config
decl_stmt|;
specifier|private
specifier|final
name|AnalysedContent
name|content
decl_stmt|;
specifier|private
specifier|final
name|EntitySearcher
name|entitySearcher
decl_stmt|;
comment|/**      * The state of the current processing      */
specifier|private
specifier|final
name|ProcessingState
name|state
decl_stmt|;
comment|/**      * The map holding the results of the linking process      */
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|LinkedEntity
argument_list|>
name|linkedEntities
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|LinkedEntity
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * After {@link #process()}ing this returns the entities linked for the      * parsed {@link AnalysedContent}.      * @return the linked entities      */
specifier|public
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|LinkedEntity
argument_list|>
name|getLinkedEntities
parameter_list|()
block|{
return|return
name|linkedEntities
return|;
block|}
specifier|public
name|EntityLinker
parameter_list|(
name|AnalysedContent
name|content
parameter_list|,
name|EntitySearcher
name|taxonomy
parameter_list|,
name|EntityLinkerConfig
name|config
parameter_list|)
block|{
if|if
condition|(
name|config
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed TaxonomyLinkerConfig MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|taxonomy
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed Taxonomy MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|content
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed AnalysedContent MUST NOT be NULL!"
argument_list|)
throw|;
block|}
name|this
operator|.
name|content
operator|=
name|content
expr_stmt|;
name|this
operator|.
name|entitySearcher
operator|=
name|taxonomy
expr_stmt|;
name|this
operator|.
name|config
operator|=
name|config
expr_stmt|;
name|this
operator|.
name|state
operator|=
operator|new
name|ProcessingState
argument_list|(
name|content
operator|.
name|getAnalysedText
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Steps over the sentences, chunks, tokens of the {@link #sentences}      */
specifier|public
name|void
name|process
parameter_list|()
block|{
while|while
condition|(
name|state
operator|.
name|next
argument_list|()
condition|)
block|{
if|if
condition|(
name|isProcessableToken
argument_list|(
name|state
operator|.
name|getToken
argument_list|()
argument_list|)
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|searchStrings
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|config
operator|.
name|getMaxSearchTokens
argument_list|()
argument_list|)
decl_stmt|;
name|searchStrings
operator|.
name|add
argument_list|(
name|state
operator|.
name|getToken
argument_list|()
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
comment|//get the list of all tokens that can possible be matched
name|int
name|includeTokenIndex
init|=
name|state
operator|.
name|getTokenIndex
argument_list|()
decl_stmt|;
name|includeTokenIndex
operator|++
expr_stmt|;
while|while
condition|(
name|searchStrings
operator|.
name|size
argument_list|()
operator|<
name|config
operator|.
name|getMaxSearchTokens
argument_list|()
operator|&&
comment|//more search strings
operator|(
name|includeTokenIndex
operator|<=
operator|(
name|state
operator|.
name|getChunk
argument_list|()
operator|!=
literal|null
condition|?
comment|//still within
name|state
operator|.
name|getChunk
argument_list|()
operator|.
name|getEnd
argument_list|()
else|:
comment|//the chunk
name|state
operator|.
name|getSentence
argument_list|()
operator|.
name|getTokens
argument_list|()
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|//or sentence
name|Token
name|included
init|=
name|state
operator|.
name|getSentence
argument_list|()
operator|.
name|getTokens
argument_list|()
operator|.
name|get
argument_list|(
name|includeTokenIndex
argument_list|)
decl_stmt|;
name|includeTokenIndex
operator|++
expr_stmt|;
if|if
condition|(
name|isProcessableToken
argument_list|(
name|included
argument_list|)
condition|)
block|{
name|searchStrings
operator|.
name|add
argument_list|(
name|included
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|//search for Entities
name|List
argument_list|<
name|Suggestion
argument_list|>
name|suggestions
init|=
name|lookupEntities
argument_list|(
name|searchStrings
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|suggestions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//update the suggestions based on the best match
name|int
name|bestMatchCount
init|=
name|suggestions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getMatchCount
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Suggestion
argument_list|>
name|it
init|=
name|suggestions
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Suggestion
name|suggestion
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
comment|//suggestions that match less tokens as the best match
comment|//need to be updated to PARTIAL
if|if
condition|(
name|suggestion
operator|.
name|getMatchCount
argument_list|()
operator|<
name|bestMatchCount
condition|)
block|{
name|suggestion
operator|.
name|setMatch
argument_list|(
name|MATCH
operator|.
name|PARTIAL
argument_list|)
expr_stmt|;
block|}
comment|//Filter matches with less than config.getMinFoundTokens()
comment|//if matchcount is less than of the best match
if|if
condition|(
name|suggestion
operator|.
name|getMatchCount
argument_list|()
operator|<
name|bestMatchCount
operator|&&
name|suggestion
operator|.
name|getMatchCount
argument_list|()
operator|<
name|config
operator|.
name|getMinFoundTokens
argument_list|()
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|//calculate the score
comment|//how good is the current match in relation to the best one
name|double
name|spanScore
init|=
operator|(
operator|(
name|double
operator|)
name|suggestion
operator|.
name|getMatchCount
argument_list|()
operator|)
operator|/
name|bestMatchCount
decl_stmt|;
comment|//how good is the match to the span selected by this suggestion
name|double
name|textScore
init|=
operator|(
operator|(
name|double
operator|)
name|suggestion
operator|.
name|getMatchCount
argument_list|()
operator|)
operator|/
name|suggestion
operator|.
name|getSpan
argument_list|()
decl_stmt|;
comment|//how good is the match in relation to the tokens of the suggested label
name|double
name|labelScore
init|=
operator|(
operator|(
name|double
operator|)
name|suggestion
operator|.
name|getMatchCount
argument_list|()
operator|/
name|suggestion
operator|.
name|getLabelTokenCount
argument_list|()
operator|)
decl_stmt|;
name|suggestion
operator|.
name|setScore
argument_list|(
name|spanScore
operator|*
name|spanScore
operator|*
name|textScore
operator|*
name|labelScore
argument_list|)
expr_stmt|;
block|}
block|}
name|Suggestion
name|oldBestRanked
init|=
name|suggestions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|//for debugging
comment|//resort by score
name|Collections
operator|.
name|sort
argument_list|(
name|suggestions
argument_list|,
name|Suggestion
operator|.
name|SCORE_COMPARATOR
argument_list|)
expr_stmt|;
comment|//this should never happen ... but the
comment|//matchcount of the best match MUST NOT change
comment|//after the sort by score!
if|if
condition|(
name|bestMatchCount
operator|!=
name|suggestions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getMatchCount
argument_list|()
condition|)
block|{
comment|//TODO: change this to a warning (like to have exceptions during debugging)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"The match count for the top Ranked Suggestion for %s changed after resorting based on Scores! (original: %s, currnet %s)"
argument_list|,
name|state
operator|.
name|getTokenText
argument_list|(
name|bestMatchCount
argument_list|)
argument_list|,
name|oldBestRanked
argument_list|,
name|suggestions
argument_list|)
argument_list|)
throw|;
block|}
comment|//remove all suggestions> config.maxSuggestions
if|if
condition|(
name|suggestions
operator|.
name|size
argument_list|()
operator|>
name|config
operator|.
name|getMaxSuggestions
argument_list|()
condition|)
block|{
name|suggestions
operator|.
name|subList
argument_list|(
name|config
operator|.
name|getMaxSuggestions
argument_list|()
argument_list|,
name|suggestions
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|//process redirects
if|if
condition|(
name|config
operator|.
name|getRedirectProcessingMode
argument_list|()
operator|!=
name|RedirectProcessingMode
operator|.
name|IGNORE
condition|)
block|{
for|for
control|(
name|Suggestion
name|suggestion
range|:
name|suggestions
control|)
block|{
name|processRedirects
argument_list|(
name|suggestion
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|span
init|=
name|suggestions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getSpan
argument_list|()
decl_stmt|;
comment|//Store the linking results
name|String
name|selectedText
init|=
name|state
operator|.
name|getTokenText
argument_list|(
name|span
argument_list|)
decl_stmt|;
comment|//float score;
name|LinkedEntity
name|linkedEntity
init|=
name|linkedEntities
operator|.
name|get
argument_list|(
name|selectedText
argument_list|)
decl_stmt|;
if|if
condition|(
name|linkedEntity
operator|==
literal|null
condition|)
block|{
name|linkedEntity
operator|=
operator|new
name|LinkedEntity
argument_list|(
name|selectedText
argument_list|,
name|suggestions
argument_list|,
name|getLinkedEntityTypes
argument_list|(
name|suggestions
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|linkedEntities
operator|.
name|put
argument_list|(
name|selectedText
argument_list|,
name|linkedEntity
argument_list|)
expr_stmt|;
block|}
name|linkedEntity
operator|.
name|addOccurrence
argument_list|(
name|state
operator|.
name|getSentence
argument_list|()
argument_list|,
name|state
operator|.
name|getTokenIndex
argument_list|()
argument_list|,
name|span
argument_list|)
expr_stmt|;
comment|//set the next token to process to the next word after the
comment|//currently found suggestion
name|state
operator|.
name|setNextToken
argument_list|(
name|state
operator|.
name|getTokenIndex
argument_list|()
operator|+
name|span
argument_list|)
expr_stmt|;
block|}
block|}
comment|//else do not process this token
block|}
block|}
comment|/**      * Retrieves all {@link EntitySearcher#getTypeField()} values of the parsed      * {@link Suggestion}s and than lookup the {@link NamespaceEnum#dcTerms dc}:type      * values for the {@link LinkedEntity#getTypes()} by using the configured      * {@link EntityLinkerConfig#getTypeMappings() types mappings} (and if      * no mapping is found the {@link EntityLinkerConfig#getDefaultDcType()       * default} type.      * @param conceptTypes The list of suggestions      * @return the types values for the {@link LinkedEntity}      */
specifier|private
name|Set
argument_list|<
name|UriRef
argument_list|>
name|getLinkedEntityTypes
parameter_list|(
name|Collection
argument_list|<
name|Suggestion
argument_list|>
name|suggestions
parameter_list|)
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|conceptTypes
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Suggestion
name|suggestion
range|:
name|suggestions
control|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|Reference
argument_list|>
name|types
init|=
name|suggestion
operator|.
name|getRepresentation
argument_list|()
operator|.
name|getReferences
argument_list|(
name|config
operator|.
name|getTypeField
argument_list|()
argument_list|)
init|;
name|types
operator|.
name|hasNext
argument_list|()
condition|;
name|conceptTypes
operator|.
name|add
argument_list|(
name|types
operator|.
name|next
argument_list|()
operator|.
name|getReference
argument_list|()
argument_list|)
control|)
empty_stmt|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|UriRef
argument_list|>
name|typeMappings
init|=
name|config
operator|.
name|getTypeMappings
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|UriRef
argument_list|>
name|dcTypes
init|=
operator|new
name|HashSet
argument_list|<
name|UriRef
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|conceptType
range|:
name|conceptTypes
control|)
block|{
name|UriRef
name|dcType
init|=
name|typeMappings
operator|.
name|get
argument_list|(
name|conceptType
argument_list|)
decl_stmt|;
if|if
condition|(
name|dcType
operator|!=
literal|null
condition|)
block|{
name|dcTypes
operator|.
name|add
argument_list|(
name|dcType
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dcTypes
operator|.
name|isEmpty
argument_list|()
operator|&&
name|config
operator|.
name|getDefaultDcType
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|dcTypes
operator|.
name|add
argument_list|(
name|config
operator|.
name|getDefaultDcType
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|dcTypes
return|;
block|}
comment|/**      * Processes {@link EntitySearcher#getRedirectField() redirect field} values for      * the parsed suggestions based on the {@link RedirectProcessingMode}      * as configured in the {@link #config}.<p>      * The results of this method are stored within the parsed {@link Suggestion}s      * @param suggestion The suggestion to process.      */
specifier|private
name|void
name|processRedirects
parameter_list|(
name|Suggestion
name|suggestion
parameter_list|)
block|{
comment|//if mode is IGNORE -> nothing to do
if|if
condition|(
name|config
operator|.
name|getRedirectProcessingMode
argument_list|()
operator|==
name|RedirectProcessingMode
operator|.
name|IGNORE
condition|)
block|{
return|return;
block|}
comment|//in case results for queries are locally cached it might be the case
comment|//that some/all of the results do already redirects processed.
comment|//therefore there is a small internal state that stores this information
if|if
condition|(
name|suggestion
operator|.
name|isRedirectedProcessed
argument_list|()
condition|)
block|{
return|return;
comment|//Redirects for ResultMatch are already processed ... ignore
block|}
name|Representation
name|result
init|=
name|suggestion
operator|.
name|getResult
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Reference
argument_list|>
name|redirects
init|=
name|result
operator|.
name|getReferences
argument_list|(
name|config
operator|.
name|getRedirectField
argument_list|()
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|config
operator|.
name|getRedirectProcessingMode
argument_list|()
condition|)
block|{
case|case
name|ADD_VALUES
case|:
while|while
condition|(
name|redirects
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Reference
name|redirect
init|=
name|redirects
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|redirect
operator|!=
literal|null
condition|)
block|{
name|Representation
name|redirectedEntity
init|=
name|entitySearcher
operator|.
name|get
argument_list|(
name|redirect
operator|.
name|getReference
argument_list|()
argument_list|,
name|config
operator|.
name|getSelectedFields
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|redirectedEntity
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|String
argument_list|>
name|fields
init|=
name|redirectedEntity
operator|.
name|getFieldNames
argument_list|()
init|;
name|fields
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|String
name|field
init|=
name|fields
operator|.
name|next
argument_list|()
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
name|field
argument_list|,
name|redirectedEntity
operator|.
name|get
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|//set that the redirects where searched for this result
name|suggestion
operator|.
name|setRedirectProcessed
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
case|case
name|FOLLOW
case|:
while|while
condition|(
name|redirects
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Reference
name|redirect
init|=
name|redirects
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|redirect
operator|!=
literal|null
condition|)
block|{
name|Representation
name|redirectedEntity
init|=
name|entitySearcher
operator|.
name|get
argument_list|(
name|redirect
operator|.
name|getReference
argument_list|()
argument_list|,
name|config
operator|.
name|getSelectedFields
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|redirectedEntity
operator|!=
literal|null
condition|)
block|{
comment|//copy the original result score
name|redirectedEntity
operator|.
name|set
argument_list|(
name|RdfResourceEnum
operator|.
name|resultScore
operator|.
name|getUri
argument_list|()
argument_list|,
name|result
operator|.
name|get
argument_list|(
name|RdfResourceEnum
operator|.
name|resultScore
operator|.
name|getUri
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|//set the redirect
name|suggestion
operator|.
name|setRedirect
argument_list|(
name|redirectedEntity
argument_list|)
expr_stmt|;
block|}
block|}
block|}
default|default:
comment|//nothing to do
block|}
block|}
comment|/**      * Searches for Entities in the {@link #entitySearcher} corresponding to the      * {@link Token#getText() words} of the current {@link #state position} in      * the text.      * @param searchStrings the list of {@link Token#getText() words} to search      * entities for.      * @return The sorted list with the suggestions.      * If there are no suggestions an empty list will be returned.      */
specifier|private
name|List
argument_list|<
name|Suggestion
argument_list|>
name|lookupEntities
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|searchStrings
parameter_list|)
block|{
name|Collection
argument_list|<
name|?
extends|extends
name|Representation
argument_list|>
name|results
init|=
name|entitySearcher
operator|.
name|lookup
argument_list|(
name|config
operator|.
name|getNameField
argument_list|()
argument_list|,
name|config
operator|.
name|getSelectedFields
argument_list|()
argument_list|,
name|searchStrings
argument_list|,
name|state
operator|.
name|getSentence
argument_list|()
operator|.
name|getLanguage
argument_list|()
argument_list|,
name|config
operator|.
name|getDefaultLanguage
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Suggestion
argument_list|>
name|suggestions
init|=
operator|new
name|ArrayList
argument_list|<
name|Suggestion
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Representation
name|result
range|:
name|results
control|)
block|{
name|Suggestion
name|match
init|=
name|matchLabels
argument_list|(
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
name|match
operator|.
name|getMatch
argument_list|()
operator|!=
name|MATCH
operator|.
name|NONE
condition|)
block|{
name|suggestions
operator|.
name|add
argument_list|(
name|match
argument_list|)
expr_stmt|;
block|}
block|}
comment|//sort the suggestions
if|if
condition|(
name|suggestions
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|suggestions
argument_list|,
name|Suggestion
operator|.
name|DEFAULT_SUGGESTION_COMPARATOR
argument_list|)
expr_stmt|;
block|}
comment|//remove all elements> config.getMaxSuggestions()
return|return
name|suggestions
return|;
block|}
comment|/**      * Matches the labels of the parsed {@link Representation} with the Tokens of      * the texts (beginning with the currently active       * {@link ProcessingState#getToken() token}).<p>      * The field used to get the labels is retrieved from       * {@link EntitySearcher#getNameField()}. Only labels with no language or the      * language of the current sentence are considered. If less than       * {@link EntityLinkerConfig#getMinFoundTokens()} tokens match with an      * label the Concept is only considered to match if the label is      * {@link String#equalsIgnoreCase(String)} to the text covered by the      * matched token(s). Otherwise also {@link MATCH#FULL} and {@link MATCH#PARTIAL}      * results are allowed.      * @param rep The representation including at least the data for the      * {@link EntitySearcher#getNameField()} property.      * @return The result of the matching.      */
specifier|private
name|Suggestion
name|matchLabels
parameter_list|(
name|Representation
name|rep
parameter_list|)
block|{
name|String
name|curLang
init|=
name|state
operator|.
name|getLanguage
argument_list|()
decl_stmt|;
comment|//language of the current sentence
name|String
name|defLang
init|=
name|config
operator|.
name|getDefaultLanguage
argument_list|()
decl_stmt|;
comment|//configured default language
comment|//        Iterator<Text> labels = rep.get(config.getNameField(), //get all labels
comment|//            state.getLanguage(), //in the current language
comment|//            config.getDefaultLanguage()); //and the default language
name|Iterator
argument_list|<
name|Text
argument_list|>
name|labels
init|=
name|rep
operator|.
name|getText
argument_list|(
name|config
operator|.
name|getNameField
argument_list|()
argument_list|)
decl_stmt|;
name|Suggestion
name|match
init|=
operator|new
name|Suggestion
argument_list|(
name|rep
argument_list|)
decl_stmt|;
while|while
condition|(
name|labels
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Text
name|label
init|=
name|labels
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|lang
init|=
name|label
operator|.
name|getLanguage
argument_list|()
decl_stmt|;
comment|//check the language of the current label
comment|//NOTE: Stirng.startWith is used to match'en-GB' with 'en'
if|if
condition|(
operator|(
name|lang
operator|==
literal|null
operator|&&
operator|(
comment|//if lang is null
name|defLang
operator|==
literal|null
operator|||
comment|//default lang is null
name|curLang
operator|==
literal|null
operator|)
operator|)
comment|//or current lang is null
operator|||
operator|(
name|lang
operator|!=
literal|null
operator|&&
operator|(
comment|//if lang is not null
comment|//NOTE: starsWith does not like parsing NULL
name|curLang
operator|!=
literal|null
operator|&&
name|lang
operator|.
name|startsWith
argument_list|(
name|curLang
argument_list|)
operator|||
comment|//match with default
name|defLang
operator|!=
literal|null
operator|&&
name|lang
operator|.
name|startsWith
argument_list|(
name|defLang
argument_list|)
operator|)
comment|//or match with current
operator|)
comment|//end or
condition|)
block|{
comment|//end if
name|String
name|text
init|=
name|label
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|labelTokens
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|content
operator|.
name|tokenize
argument_list|(
name|text
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|foundTokens
init|=
literal|0
decl_stmt|;
comment|//ensure the correct order of the tokens in the suggested entity
name|int
name|foundInLabelIndex
init|=
literal|0
decl_stmt|;
name|boolean
name|search
init|=
literal|true
decl_stmt|;
name|int
name|lastFoundIndex
init|=
operator|-
literal|1
decl_stmt|;
name|Token
name|currentToken
decl_stmt|;
name|int
name|maxNotFound
init|=
literal|1
decl_stmt|;
comment|//TODO make configureable
name|int
name|notFound
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|currentIndex
init|=
name|state
operator|.
name|getTokenIndex
argument_list|()
init|;
name|currentIndex
operator|<
name|state
operator|.
name|getSentence
argument_list|()
operator|.
name|getTokens
argument_list|()
operator|.
name|size
argument_list|()
operator|&&
name|search
condition|;
name|currentIndex
operator|++
control|)
block|{
name|currentToken
operator|=
name|state
operator|.
name|getSentence
argument_list|()
operator|.
name|getTokens
argument_list|()
operator|.
name|get
argument_list|(
name|currentIndex
argument_list|)
expr_stmt|;
name|boolean
name|isProcessable
init|=
name|isProcessableToken
argument_list|(
name|currentToken
argument_list|)
decl_stmt|;
name|int
name|found
init|=
name|text
operator|.
name|indexOf
argument_list|(
name|currentToken
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|found
operator|>=
name|foundInLabelIndex
condition|)
block|{
comment|//found
if|if
condition|(
name|isProcessable
condition|)
block|{
name|foundTokens
operator|++
expr_stmt|;
comment|//only count processable Tokens
block|}
comment|//TODO: maybe move this also in the "isProcessable" ...
name|foundInLabelIndex
operator|=
name|found
operator|+
name|currentToken
operator|.
name|getText
argument_list|()
operator|.
name|length
argument_list|()
expr_stmt|;
name|lastFoundIndex
operator|=
name|currentIndex
expr_stmt|;
block|}
else|else
block|{
comment|//not found
name|notFound
operator|++
expr_stmt|;
if|if
condition|(
name|isProcessable
operator|||
name|notFound
operator|>
name|maxNotFound
condition|)
block|{
comment|//stop as soon as a token that needs to be processed is
comment|//not found in the label or the maximum number of tokens
comment|//that are not processable are not found
name|search
operator|=
literal|false
expr_stmt|;
block|}
block|}
comment|//else it is OK if non processable tokens are not found
block|}
name|MATCH
name|labelMatch
decl_stmt|;
name|int
name|coveredTokens
init|=
name|lastFoundIndex
operator|-
name|state
operator|.
name|getTokenIndex
argument_list|()
operator|+
literal|1
decl_stmt|;
comment|//Matching rules
comment|// - if less than config#minTokenFound() than accept only EXACT
comment|// - override PARTIAL matches with FULL/EXACT matches only if
comment|//   foundTokens of the PARTIAL match is> than of the FULL/EXACT
comment|//   match (this will be very rare
if|if
condition|(
name|foundTokens
operator|>
literal|0
operator|&&
name|match
operator|.
name|getMatchCount
argument_list|()
operator|<=
name|foundTokens
condition|)
block|{
name|String
name|currentText
init|=
name|state
operator|.
name|getTokenText
argument_list|(
name|coveredTokens
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentText
operator|.
name|equalsIgnoreCase
argument_list|(
name|label
operator|.
name|getText
argument_list|()
argument_list|)
condition|)
block|{
name|labelMatch
operator|=
name|MATCH
operator|.
name|EXACT
expr_stmt|;
comment|//set found to covered: May be lower because only
comment|//processable tokens are counted, but Exact also checks
comment|//of non-processable!
name|foundTokens
operator|=
name|coveredTokens
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|foundTokens
operator|>=
name|config
operator|.
name|getMinFoundTokens
argument_list|()
condition|)
block|{
if|if
condition|(
name|foundTokens
operator|==
name|coveredTokens
condition|)
block|{
name|labelMatch
operator|=
name|MATCH
operator|.
name|FULL
expr_stmt|;
block|}
else|else
block|{
name|labelMatch
operator|=
name|MATCH
operator|.
name|PARTIAL
expr_stmt|;
block|}
block|}
else|else
block|{
name|labelMatch
operator|=
name|MATCH
operator|.
name|NONE
expr_stmt|;
block|}
if|if
condition|(
name|labelMatch
operator|!=
name|MATCH
operator|.
name|NONE
condition|)
block|{
if|if
condition|(
name|match
operator|.
name|getMatchCount
argument_list|()
operator|<
name|foundTokens
operator|||
name|match
operator|.
name|getMatchCount
argument_list|()
operator|<
name|foundTokens
operator|&&
name|labelMatch
operator|.
name|ordinal
argument_list|()
operator|>
name|match
operator|.
name|getMatch
argument_list|()
operator|.
name|ordinal
argument_list|()
condition|)
block|{
name|match
operator|.
name|updateMatch
argument_list|(
name|labelMatch
argument_list|,
name|coveredTokens
argument_list|,
name|foundTokens
argument_list|,
name|label
argument_list|,
name|labelTokens
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//else this match is not better as the existing one
block|}
comment|//else ignore labels with MATCH.NONE
block|}
comment|//else NO tokens found -> nothing to do
block|}
comment|// else worng language
block|}
return|return
name|match
return|;
block|}
comment|/**      * Checks if the current token of {@link #state} is processable.       * @param token the {@link Token} to check.      * @return<code>true</code> if the parsed token needs to be processed.      * Otherwise<code>false</code>      */
specifier|private
name|boolean
name|isProcessableToken
parameter_list|(
name|Token
name|token
parameter_list|)
block|{
name|Boolean
name|processToken
init|=
literal|null
decl_stmt|;
name|String
index|[]
name|posTags
init|=
name|token
operator|.
name|getPosTags
argument_list|()
decl_stmt|;
name|double
index|[]
name|posProb
init|=
name|token
operator|.
name|getPosProbabilities
argument_list|()
decl_stmt|;
if|if
condition|(
name|posTags
operator|!=
literal|null
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
do|do
block|{
name|processToken
operator|=
name|content
operator|.
name|processPOS
argument_list|(
name|posTags
index|[
name|i
index|]
argument_list|,
name|posProb
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|processToken
operator|!=
literal|null
operator|&&
name|processToken
operator|.
name|equals
argument_list|(
name|Boolean
operator|.
name|FALSE
argument_list|)
operator|&&
name|i
operator|<
name|posTags
operator|.
name|length
condition|)
do|;
block|}
if|if
condition|(
name|processToken
operator|==
literal|null
condition|)
block|{
name|processToken
operator|=
name|token
operator|.
name|getText
argument_list|()
operator|.
name|length
argument_list|()
operator|>=
name|config
operator|.
name|getMinSearchTokenLength
argument_list|()
expr_stmt|;
block|}
return|return
name|processToken
return|;
block|}
block|}
end_class

end_unit

