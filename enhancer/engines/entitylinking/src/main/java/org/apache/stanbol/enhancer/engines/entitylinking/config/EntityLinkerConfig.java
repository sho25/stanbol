begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|config
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|defaults
operator|.
name|NamespaceEnum
operator|.
name|getFullName
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Dictionary
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|UriRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|EntitySearcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|impl
operator|.
name|EntityLinker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|impl
operator|.
name|Suggestion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|entitylinking
operator|.
name|impl
operator|.
name|Suggestion
operator|.
name|MATCH
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|NlpAnnotations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|model
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|morpho
operator|.
name|MorphoFeatures
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|pos
operator|.
name|Pos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|nlp
operator|.
name|pos
operator|.
name|PosTag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|OntologicalClasses
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|defaults
operator|.
name|NamespaceEnum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|osgi
operator|.
name|service
operator|.
name|cm
operator|.
name|ConfigurationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * The configuration for the {@link EntityLinker}. Typically this  * configuration does not change often. Therefore it will be used for  * several {@link EntityLinker} instances processing different   * contents.  * @author Rupert Westenthaler  *  */
end_comment

begin_class
specifier|public
class|class
name|EntityLinkerConfig
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|EntityLinkerConfig
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * The field used to search for labels in the vocabulary linked against      */
specifier|public
specifier|static
specifier|final
name|String
name|NAME_FIELD
init|=
literal|"enhancer.engines.linking.labelField"
decl_stmt|;
comment|/**      * The field used as types for entities. While the type does not influence the      * suggestions it is used for the<code>fise:entity-type</code> value of       *<code>fise:EntityAnnotation</code>s and also to determine the      *<code>dc:type</code> value of<code>fise:TextAnnotation</code>s via the      * configured {@link #TYPE_MAPPINGS}.      */
specifier|public
specifier|static
specifier|final
name|String
name|TYPE_FIELD
init|=
literal|"enhancer.engines.linking.typeField"
decl_stmt|;
comment|/**      * Allows to enable/disable case sensitive matching      */
specifier|public
specifier|static
specifier|final
name|String
name|CASE_SENSITIVE
init|=
literal|"enhancer.engines.linking.caseSensitive"
decl_stmt|;
comment|/**      * The field used to lookup redirects      */
specifier|public
specifier|static
specifier|final
name|String
name|REDIRECT_FIELD
init|=
literal|"enhancer.engines.linking.redirectField"
decl_stmt|;
comment|/**      * If/how redirects (provided by the {@link #REDIRECT_FIELD}) are processed.      */
specifier|public
specifier|static
specifier|final
name|String
name|REDIRECT_MODE
init|=
literal|"enhancer.engines.linking.redirectMode"
decl_stmt|;
comment|/**      * The maximum number of fise:EntityAnnotations created as suggestion for a fise:TextAnnotation      */
specifier|public
specifier|static
specifier|final
name|String
name|SUGGESTIONS
init|=
literal|"enhancer.engines.linking.suggestions"
decl_stmt|;
comment|/**      * If enabled {@link MorphoFeatures#getLemma()} values are used instead of the {@link Token#getSpan()} to      * search/match Entities within the Vocabulary linked against.      * @see EntityLinkerConfig#isLemmaMatching()      * @see EntityLinkerConfig#DEFAULT_LEMMA_MATCHING_STATE      */
specifier|public
specifier|static
specifier|final
name|String
name|LEMMA_MATCHING_STATE
init|=
literal|"enhancer.engines.linking.lemmaMatching"
decl_stmt|;
comment|/**      * Can be used to that the "default language" from<code>null</code>      * (labels without language tag) to an other value (e.g. "en").<p>      * The "default language" is used in addition to the language of the      * processed text to search for labels.      */
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_MATCHING_LANGUAGE
init|=
literal|"enhancer.engines.linking.defaultMatchingLanguage"
decl_stmt|;
comment|/**      * Allows to configure entity type -> dc:type mappings as used for created      * fise:TextAnnotations      */
specifier|public
specifier|static
specifier|final
name|String
name|TYPE_MAPPINGS
init|=
literal|"enhancer.engines.linking.typeMappings"
decl_stmt|;
comment|/**      * How well single tokens of the Label needs to match a token of the Text so that they      * are considered to match. Matching does only allow differences at the end of the      * token (e.g. "London" -> "Londons major")      */
specifier|public
specifier|static
specifier|final
name|String
name|MIN_TOKEN_SCORE
init|=
literal|"enhancer.engines.linking.minTokenScore"
decl_stmt|;
comment|/**      * The minimum number of matching tokens. Only "matchable" tokens are counted.      * For full matches (where all tokens of the Label do match tokens in the text)      * this parameter is ignored.<p>      * This parameter is strongly related with the {@link #MIN_LABEL_SCORE}.      * Typical setting are<ul>      *<li><code>{@link #MIN_FOUND_TOKENS}=1</code> and<code>{@link #MIN_LABEL_SCORE}> 0.5</code> (e.g. 0.75)      *<li><code>{@link #MIN_FOUND_TOKENS}=2</code> and<code>{@link #MIN_LABEL_SCORE}<= 0.5</code> (e.g. 0.5)      *</ul>      * as both settings will ensures that Labels with two tokens where only a single one      * does match with the text are not suggested.<p>      * If used in combination with an disambiguation Engine one might want to consider      * Entities where their labels do match only a single token is such cases a      *<code>{@link #MIN_FOUND_TOKENS}=1</code> and<code>{@link #MIN_LABEL_SCORE}<= 0.5</code>      * might be also a meaningful configuration. In such cases users will also want to set the      *<code>{@link #SUGGESTIONS}> 10</code>.      */
specifier|public
specifier|static
specifier|final
name|String
name|MIN_FOUND_TOKENS
init|=
literal|"enhancer.engines.linking.minFoundTokens"
decl_stmt|;
comment|/**      * The "Label Score" [0..1] represents how much of the      * Label of an Entity matches with the Text. It compares the number      * of Tokens of the Label with the number of Tokens matched to the      * Text. Not exact matches for Tokens, or if the Tokens within the       * label do appear in an other order than in the text do also       * reduce this score.<p>      * The default is {@link EntityLinkerConfig#DEFAULT_MIN_LABEL_SCORE}      * (value: {@value EntityLinkerConfig#DEFAULT_MIN_LABEL_SCORE})      */
specifier|public
specifier|static
specifier|final
name|String
name|MIN_LABEL_SCORE
init|=
literal|"enhancer.engines.linking.minLabelScore"
decl_stmt|;
comment|/**      * The "Text Score" [0..1] represents how well the      * Label of an Entity matches to the selected Span in the Text.      * It compares the number of matched {@link Token} from      * the label with the number of Tokens enclosed by the Span      * in the Text an Entity is suggested for. Not exact matches       * for Tokens, or if the Tokens within the label do appear in      * an other order than in the text do also reduce this score.<p>      * The default is {@link EntityLinkerConfig#DEFAULT_MIN_TEXT_SCORE}      * (value: {@value EntityLinkerConfig#DEFAULT_MIN_TEXT_SCORE})      */
specifier|public
specifier|static
specifier|final
name|String
name|MIN_TEXT_SCORE
init|=
literal|"enhancer.engines.linking.minTextScore"
decl_stmt|;
comment|/**      * Defined as the product of the "Text Score" with the      * "Label Score" - meaning that this value represents      * both how well the label matches the text and how much of the      * label is matched with the text.<p>      * The default is {@link EntityLinkerConfig#DEFAULT_MIN_MATCH_SCORE}      * (value: {@value EntityLinkerConfig#DEFAULT_MIN_MATCH_SCORE})      * @see #MIN_TEXT_SCORE      * @see #MIN_LABEL_SCORE      */
specifier|public
specifier|static
specifier|final
name|String
name|MIN_MATCH_FACTOR
init|=
literal|"enhancer.engines.linking.minMatchScore"
decl_stmt|;
comment|/**      * Used as fallback in case a {@link Token} does not have a {@link PosTag} or       * {@link NlpAnnotations#POS_ANNOTATION POS annotations} do have a low confidence.      * In such cases only words that are longer than  this value will be considerd for      * linking      */
specifier|public
specifier|static
specifier|final
name|String
name|MIN_SEARCH_TOKEN_LENGTH
init|=
literal|"enhancer.engines.linking.minSearchTokenLength"
decl_stmt|;
comment|/**      * The maximum number of {@link Token} used as search terms with the       * {@link EntitySearcher#lookup(String, Set, java.util.List, String[], Integer)}      * method      */
specifier|public
specifier|static
specifier|final
name|String
name|MAX_SEARCH_TOKENS
init|=
literal|"enhancer.engines.linking.maxSearchTokens"
decl_stmt|;
comment|/**      * The maximum number of {@link Token} searched around a linkable Token for      * additional search tokens.<p>      * As an Example in the text section "at the University of Munich a new procedure to"      * only "Munich" would be classified as {@link Pos#ProperNoun} and considered as      * linkable. However for searching it makes sence to use additional Tokens to      * reduce (or correctly rank) the expected high number of results for "Munich".      * Because of that "matchable" words surrounding the linkable are considered as      * included for searches.<p>      * This parameter allows to configure the maximum distance surounding the current      * linkable Token other linkable tokens can be included in searches.      */
specifier|public
specifier|static
specifier|final
name|String
name|MAX_SEARCH_TOKEN_DISTANCE
init|=
literal|"enhancer.engines.linking.maxSearchTokenDistance"
decl_stmt|;
comment|/**      * Adds the dereference feature (STANBOL-333) also to this engine.      * This will be replaced by STANBOL-336.       */
specifier|public
specifier|static
specifier|final
name|String
name|DEREFERENCE_ENTITIES
init|=
literal|"enhancer.engines.linking.dereference"
decl_stmt|;
comment|/**      * Allows to add a list of fields that are included when dereferencing Entities      */
specifier|public
specifier|static
specifier|final
name|String
name|DEREFERENCE_ENTITIES_FIELDS
init|=
literal|"enhancer.engines.linking.dereferenceFields"
decl_stmt|;
comment|/**      * Additional fields added for dereferenced entities      */
specifier|private
specifier|static
specifier|final
name|Collection
argument_list|<
name|String
argument_list|>
name|DEFAULT_DEREFERENCED_FIELDS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|getFullName
argument_list|(
literal|"rdfs:comment"
argument_list|)
argument_list|,
name|getFullName
argument_list|(
literal|"geo:lat"
argument_list|)
argument_list|,
name|getFullName
argument_list|(
literal|"geo:long"
argument_list|)
argument_list|,
name|getFullName
argument_list|(
literal|"foaf:depiction"
argument_list|)
argument_list|,
name|getFullName
argument_list|(
literal|"dbp-ont:thumbnail"
argument_list|)
argument_list|)
decl_stmt|;
comment|/**      * The minimum length of Token to be used for searches in case no      * POS (Part of Speech) tags are available.      */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MIN_SEARCH_TOKEN_LENGTH
init|=
literal|3
decl_stmt|;
comment|/**      * The default number for the maximum number of terms suggested for a word      */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_SUGGESTIONS
init|=
literal|3
decl_stmt|;
comment|/**      * Default value for the number of tokens that must be contained in      * suggested terms. The default is<code>1</code>      */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MIN_FOUND_TOKENS
init|=
literal|1
decl_stmt|;
comment|/**      * Multiple Tokens can be sent to the {@link EntitySearcher} service. The      * service uses this as optional parameters for the search. Therefore      * returned Concepts MUST contain at least a single of the parsed       * tokens.<p>      * The default value of<code>2</code> should be enough for nearly all      * Taxonomies to sufficiently reduce the number of results.<p>      * NOTE that the labels (nameField) of the results are compared as a      * whole. So even if only 2 Tokens are used for the search there may be      * more mapped to the actual label of an result.      */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MAX_SEARCH_TOKENS
init|=
literal|2
decl_stmt|;
comment|/**      * Default value for the maximum distance tokens are      * considered to be used (in addition to the currently processed on)      * for searches of Entities.<p>      * The default is set to<code>3</code>       */
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MAX_SEARCH_DISTANCE
init|=
literal|3
decl_stmt|;
comment|/**      * Default value for {@link #getNameField()} (rdfs:label)      */
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_NAME_FIELD
init|=
literal|"rdfs:label"
decl_stmt|;
comment|/**      * Default value for {@link #getTypeField()} (rdf:type)      */
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_TYPE_FIELD
init|=
literal|"rdf:type"
decl_stmt|;
comment|/**      * Default value for {@link #getRedirectField()} (rdf:seeAlso)      */
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_REDIRECT_FIELD
init|=
literal|"rdfs:seeAlso"
decl_stmt|;
comment|/**      * The default language used to search for labels regardless of the language      * of the text. The default value is<code>null</code> causing to include      * labels that do not have a language assigned.      */
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_LANGUAGE
init|=
literal|null
decl_stmt|;
comment|/**      * The default for case sensitive matching is set to<code>false</code>      */
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_CASE_SENSITIVE_MATCHING_STATE
init|=
literal|false
decl_stmt|;
comment|/**      * By default Lemma based matching is deactivated.      */
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_LEMMA_MATCHING_STATE
init|=
literal|false
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|double
name|DEFAULT_MIN_LABEL_SCORE
init|=
literal|0.75
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|double
name|DEFAULT_MIN_TEXT_SCORE
init|=
literal|0.4
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|double
name|DEFAULT_MIN_MATCH_SCORE
init|=
literal|0.3
decl_stmt|;
comment|/**      * Default mapping for Concept types to dc:type values added for      * TextAnnotations.      */
specifier|public
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|UriRef
argument_list|>
name|DEFAULT_ENTITY_TYPE_MAPPINGS
decl_stmt|;
static|static
block|{
comment|//the default mappings for the three types used by the Stanbol Enhancement Structure
name|Map
argument_list|<
name|String
argument_list|,
name|UriRef
argument_list|>
name|mappings
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|UriRef
argument_list|>
argument_list|()
decl_stmt|;
name|mappings
operator|.
name|put
argument_list|(
name|OntologicalClasses
operator|.
name|DBPEDIA_ORGANISATION
operator|.
name|getUnicodeString
argument_list|()
argument_list|,
name|OntologicalClasses
operator|.
name|DBPEDIA_ORGANISATION
argument_list|)
expr_stmt|;
name|mappings
operator|.
name|put
argument_list|(
name|NamespaceEnum
operator|.
name|dbpediaOnt
operator|+
literal|"Newspaper"
argument_list|,
name|OntologicalClasses
operator|.
name|DBPEDIA_ORGANISATION
argument_list|)
expr_stmt|;
name|mappings
operator|.
name|put
argument_list|(
name|NamespaceEnum
operator|.
name|schema
operator|+
literal|"Organization"
argument_list|,
name|OntologicalClasses
operator|.
name|DBPEDIA_ORGANISATION
argument_list|)
expr_stmt|;
comment|//        mappings.put(NamespaceEnum.dailymed+"organization",OntologicalClasses.DBPEDIA_ORGANISATION);
name|mappings
operator|.
name|put
argument_list|(
name|OntologicalClasses
operator|.
name|DBPEDIA_PERSON
operator|.
name|getUnicodeString
argument_list|()
argument_list|,
name|OntologicalClasses
operator|.
name|DBPEDIA_PERSON
argument_list|)
expr_stmt|;
name|mappings
operator|.
name|put
argument_list|(
name|NamespaceEnum
operator|.
name|foaf
operator|+
literal|"Person"
argument_list|,
name|OntologicalClasses
operator|.
name|DBPEDIA_PERSON
argument_list|)
expr_stmt|;
name|mappings
operator|.
name|put
argument_list|(
name|NamespaceEnum
operator|.
name|schema
operator|+
literal|"Person"
argument_list|,
name|OntologicalClasses
operator|.
name|DBPEDIA_PERSON
argument_list|)
expr_stmt|;
name|mappings
operator|.
name|put
argument_list|(
name|OntologicalClasses
operator|.
name|DBPEDIA_PLACE
operator|.
name|getUnicodeString
argument_list|()
argument_list|,
name|OntologicalClasses
operator|.
name|DBPEDIA_PLACE
argument_list|)
expr_stmt|;
name|mappings
operator|.
name|put
argument_list|(
name|NamespaceEnum
operator|.
name|schema
operator|+
literal|"Place"
argument_list|,
name|OntologicalClasses
operator|.
name|DBPEDIA_PLACE
argument_list|)
expr_stmt|;
name|mappings
operator|.
name|put
argument_list|(
name|NamespaceEnum
operator|.
name|gml
operator|+
literal|"_Feature"
argument_list|,
name|OntologicalClasses
operator|.
name|DBPEDIA_PLACE
argument_list|)
expr_stmt|;
name|mappings
operator|.
name|put
argument_list|(
name|OntologicalClasses
operator|.
name|SKOS_CONCEPT
operator|.
name|getUnicodeString
argument_list|()
argument_list|,
name|OntologicalClasses
operator|.
name|SKOS_CONCEPT
argument_list|)
expr_stmt|;
comment|//        UriRef DRUG = new UriRef(NamespaceEnum.drugbank+"drugs");
comment|//        mappings.put(DRUG.getUnicodeString(), DRUG);
comment|//        mappings.put(NamespaceEnum.dbpediaOnt+"Drug", DRUG);
comment|//        mappings.put(NamespaceEnum.dailymed+"drugs", DRUG);
comment|//        mappings.put(NamespaceEnum.sider+"drugs", DRUG);
comment|//        mappings.put(NamespaceEnum.tcm+"Medicine", DRUG);
comment|//
comment|//        UriRef DISEASE = new UriRef(NamespaceEnum.diseasome+"diseases");
comment|//        mappings.put(DISEASE.getUnicodeString(), DISEASE);
comment|//        mappings.put(NamespaceEnum.linkedct+"condition", DISEASE);
comment|//        mappings.put(NamespaceEnum.tcm+"Disease", DISEASE);
comment|//
comment|//        UriRef SIDE_EFFECT = new UriRef(NamespaceEnum.sider+"side_effects");
comment|//        mappings.put(SIDE_EFFECT.getUnicodeString(), SIDE_EFFECT);
comment|//
comment|//        UriRef INGREDIENT = new UriRef(NamespaceEnum.dailymed+"ingredients");
comment|//        mappings.put(INGREDIENT.getUnicodeString(), INGREDIENT);
name|DEFAULT_ENTITY_TYPE_MAPPINGS
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|mappings
argument_list|)
expr_stmt|;
block|}
comment|/**      * Enumeration over the different possibilities on how to deal with      * redirects (similar to Browsers following HTTP status 303 and RDF defining      * the "rdf:seeAlso" relation.       * @author Rupert Westenthaler      */
specifier|public
specifier|static
enum|enum
name|RedirectProcessingMode
block|{
comment|/**          * Ignore redirects          */
name|IGNORE
block|,
comment|/**          * Follow redirects, but only add the values (e.g. labels, types) such          * entities to the original one.          */
name|ADD_VALUES
block|,
comment|/**          * Follow the redirect.          */
name|FOLLOW
block|}
comment|/**      * The default value for how to process redirect is set to      * {@link RedirectProcessingMode#IGNORE}      */
specifier|public
specifier|static
name|RedirectProcessingMode
name|DEFAULT_REDIRECT_PROCESSING_MODE
init|=
name|RedirectProcessingMode
operator|.
name|IGNORE
decl_stmt|;
comment|/**      * The dereferenceEntitiesState as set in {@link #activateEntityDereference(Dictionary)}      */
specifier|private
name|boolean
name|dereferenceEntitiesState
decl_stmt|;
comment|/**      * The minimum length of labels that are looked-up in the directory      */
specifier|private
name|int
name|minSearchTokenLength
init|=
name|DEFAULT_MIN_SEARCH_TOKEN_LENGTH
decl_stmt|;
comment|/**      * The the maximum number of terms suggested for a word      */
specifier|private
name|int
name|maxSuggestions
init|=
name|DEFAULT_SUGGESTIONS
decl_stmt|;
comment|/**      * The minimum number of Tokens in the text that must match with       * a label of the Entity so that also non-exact matches are      * used for suggestions      */
specifier|private
name|int
name|minFoundTokens
init|=
name|DEFAULT_MIN_FOUND_TOKENS
decl_stmt|;
comment|/**      * The maximum numbers of Tokens sent to the {@link EntitySearcher} to search      * for concepts.<p>      * NOTE that the labels (nameField) of the results are compared as a      * whole. So even if only e.g. 2 tokens are used for the search there may be      * more mapped to the actual label of an result.      */
specifier|private
name|int
name|maxSearchTokens
init|=
name|DEFAULT_MAX_SEARCH_TOKENS
decl_stmt|;
comment|/**      * Defines the maximum distance tokens are      * considered to be used (in addition to the currently processed on)      * for searches of Entities.<p>      */
specifier|private
name|int
name|maxSearchDistance
init|=
name|DEFAULT_MAX_SEARCH_DISTANCE
decl_stmt|;
specifier|private
name|boolean
name|caseSensitiveMatchingState
init|=
name|DEFAULT_CASE_SENSITIVE_MATCHING_STATE
decl_stmt|;
comment|/**      * Holds the mappings of rdf:type used by concepts to dc:type values used      * by TextAnnotations.       */
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|UriRef
argument_list|>
name|typeMappings
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|UriRef
argument_list|>
name|unmodTypeMappings
decl_stmt|;
comment|/**      * The mode on how to process redirect for Entities.       */
specifier|private
name|RedirectProcessingMode
name|redirectProcessingMode
decl_stmt|;
comment|/**      * the default DC Type      */
specifier|private
name|UriRef
name|defaultDcType
decl_stmt|;
specifier|private
name|String
name|nameField
decl_stmt|;
specifier|private
name|String
name|redirectField
decl_stmt|;
specifier|private
name|String
name|typeField
decl_stmt|;
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|dereferencedFields
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|__selectedFields
decl_stmt|;
comment|/**      * The language always included in searches (regardless of the language      * detected for the text.      */
specifier|private
name|String
name|defaultLanguage
init|=
name|DEFAULT_LANGUAGE
decl_stmt|;
comment|/**      * Default for the maximum number of non-processable tokens that are       * allowed to not match before no further tokens are matched against a label       * of an Entity.<p>      * This allows e.g. to match "Dr. Richard Dogles" with "Dr Richard Dogles"      * as '.' is a non-processable token in the text that is missing in the      * label.<p>      * The default is set to<code>1</code>      */
specifier|public
specifier|final
specifier|static
name|int
name|DEFAULT_MAX_NOT_FOUND
init|=
literal|1
decl_stmt|;
comment|/**      * Value of the maximum number of non-processable tokens that are       * allowed to not match before no further tokens are matched against a label       * of an Entity.<p>      * This allows e.g. to match "Dr. Richard Dogles" with "Dr Richard Dogles"      * as '.' is a non-processable token in the text that is missing in the      * label.     */
specifier|private
name|int
name|maxNotFound
decl_stmt|;
comment|/**      * Default value for the minimum token match factor.      * If Tokens match is determined by comparing them using some algorithm.      * Results need to be in the range [0..1]. This factor defines the minimum      * similarity value so that a match is assumed. Not that this factor only      * is used for filtering out non-matching tokens. The similarity value will      * still used for calculating the confidence.<p>      * The default is set to<code>0.7</code>.      */
specifier|public
specifier|final
specifier|static
name|float
name|DEFAULT_MIN_TOKEN_SCORE
init|=
literal|0.7f
decl_stmt|;
comment|/**      * By default Entities are dereferenced      */
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_DEREFERENCE_ENTITIES_STATE
init|=
literal|true
decl_stmt|;
comment|/**      * If Tokens match is determined by comparing them using some algorithm.      * Results need to be in the range [0..1]. This factor defines the minimum      * similarity value so that a match is assumed. Not that this factor only      * is used for filtering out non-matching tokens. The similarity value will      * still used for calculating the confidence      */
specifier|private
name|float
name|minTokenMatchFactor
decl_stmt|;
comment|/**      * If lemmas are used instead of the Tokens as present in the text to search      * and match Entities within the linked vocabulary      */
specifier|private
name|boolean
name|lemmaMatchingState
init|=
name|DEFAULT_LEMMA_MATCHING_STATE
decl_stmt|;
specifier|private
name|double
name|minLabelScore
init|=
name|DEFAULT_MIN_LABEL_SCORE
decl_stmt|;
specifier|private
name|double
name|minTextScore
init|=
name|DEFAULT_MIN_TEXT_SCORE
decl_stmt|;
specifier|private
name|double
name|minMatchScore
init|=
name|DEFAULT_MIN_MATCH_SCORE
decl_stmt|;
comment|/**      * Default constructor the initializes the configuration with the       * default values      */
specifier|public
name|EntityLinkerConfig
parameter_list|()
block|{
name|setMinSearchTokenLength
argument_list|(
name|DEFAULT_MIN_SEARCH_TOKEN_LENGTH
argument_list|)
expr_stmt|;
name|setMaxSuggestions
argument_list|(
name|DEFAULT_SUGGESTIONS
argument_list|)
expr_stmt|;
name|setMaxSearchTokens
argument_list|(
name|DEFAULT_MAX_SEARCH_TOKENS
argument_list|)
expr_stmt|;
name|setRedirectProcessingMode
argument_list|(
name|DEFAULT_REDIRECT_PROCESSING_MODE
argument_list|)
expr_stmt|;
name|typeMappings
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|UriRef
argument_list|>
argument_list|(
name|DEFAULT_ENTITY_TYPE_MAPPINGS
argument_list|)
expr_stmt|;
name|unmodTypeMappings
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|typeMappings
argument_list|)
expr_stmt|;
name|setDefaultDcType
argument_list|(
name|typeMappings
operator|.
name|remove
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|setNameField
argument_list|(
name|DEFAULT_NAME_FIELD
argument_list|)
expr_stmt|;
name|setRedirectField
argument_list|(
name|DEFAULT_REDIRECT_FIELD
argument_list|)
expr_stmt|;
name|setTypeField
argument_list|(
name|DEFAULT_TYPE_FIELD
argument_list|)
expr_stmt|;
name|setMaxNotFound
argument_list|(
name|DEFAULT_MAX_NOT_FOUND
argument_list|)
expr_stmt|;
name|setMinTokenMatchFactor
argument_list|(
name|DEFAULT_MIN_TOKEN_SCORE
argument_list|)
expr_stmt|;
name|setDereferenceEntitiesState
argument_list|(
name|DEFAULT_DEREFERENCE_ENTITIES_STATE
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a new {@link EntityLinkerConfig} based on the properties      * in the parsed {@link Dictionary}      * @param configuration the configuration      * @return the configured {@link EntityLinkerConfig}      * @throws ConfigurationException if the parsed configuration is not valid      */
specifier|public
specifier|static
name|EntityLinkerConfig
name|createInstance
parameter_list|(
name|Dictionary
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|configuration
parameter_list|)
throws|throws
name|ConfigurationException
block|{
name|EntityLinkerConfig
name|elc
init|=
operator|new
name|EntityLinkerConfig
argument_list|()
decl_stmt|;
name|setConfiguration
argument_list|(
name|elc
argument_list|,
name|configuration
argument_list|)
expr_stmt|;
return|return
name|elc
return|;
block|}
comment|/**      * Sets the configuration as parsed by the {@link Dictionary} to the      * parsed {@link EntityLinkerConfig}.      * @param linkerConfig the instance to apply the configuration to      * @param configuration the configuration      * @throws ConfigurationException in case the configuration is invalid      */
specifier|public
specifier|static
name|void
name|setConfiguration
parameter_list|(
name|EntityLinkerConfig
name|linkerConfig
parameter_list|,
name|Dictionary
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|configuration
parameter_list|)
throws|throws
name|ConfigurationException
block|{
name|Object
name|value
decl_stmt|;
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|NAME_FIELD
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|value
operator|.
name|toString
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|NAME_FIELD
argument_list|,
literal|"The configured name field MUST NOT be empty"
argument_list|)
throw|;
block|}
name|linkerConfig
operator|.
name|setNameField
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//init case sensitivity
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|CASE_SENSITIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Boolean
condition|)
block|{
name|linkerConfig
operator|.
name|setCaseSensitiveMatchingState
argument_list|(
operator|(
name|Boolean
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
operator|!
name|value
operator|.
name|toString
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|linkerConfig
operator|.
name|setCaseSensitiveMatchingState
argument_list|(
name|Boolean
operator|.
name|valueOf
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//if NULL or empty use default
comment|//init TYPE_FIELD
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|TYPE_FIELD
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|value
operator|.
name|toString
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|TYPE_FIELD
argument_list|,
literal|"The configured name field MUST NOT be empty"
argument_list|)
throw|;
block|}
name|linkerConfig
operator|.
name|setTypeField
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//init REDIRECT_FIELD
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|REDIRECT_FIELD
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|value
operator|.
name|toString
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|NAME_FIELD
argument_list|,
literal|"The configured name field MUST NOT be empty"
argument_list|)
throw|;
block|}
name|linkerConfig
operator|.
name|setRedirectField
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//init MAX_SUGGESTIONS
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|SUGGESTIONS
argument_list|)
expr_stmt|;
name|Integer
name|maxSuggestions
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Integer
condition|)
block|{
name|maxSuggestions
operator|=
operator|(
name|Integer
operator|)
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|maxSuggestions
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|SUGGESTIONS
argument_list|,
literal|"Values MUST be valid Integer values> 0"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|maxSuggestions
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|maxSuggestions
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|maxSuggestions
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|SUGGESTIONS
argument_list|,
literal|"Values MUST be valid Integer values> 0"
argument_list|)
throw|;
block|}
name|linkerConfig
operator|.
name|setMaxSuggestions
argument_list|(
name|maxSuggestions
argument_list|)
expr_stmt|;
block|}
comment|//init MIN_FOUND_TOKENS
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|MIN_FOUND_TOKENS
argument_list|)
expr_stmt|;
name|Integer
name|minFoundTokens
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Integer
condition|)
block|{
name|minFoundTokens
operator|=
operator|(
name|Integer
operator|)
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|minFoundTokens
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|MIN_FOUND_TOKENS
argument_list|,
literal|"Values MUST be valid Integer values> 0"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|minFoundTokens
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|minFoundTokens
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|minFoundTokens
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|MIN_FOUND_TOKENS
argument_list|,
literal|"Values MUST be valid Integer values> 0"
argument_list|)
throw|;
block|}
name|linkerConfig
operator|.
name|setMinFoundTokens
argument_list|(
name|minFoundTokens
argument_list|)
expr_stmt|;
block|}
comment|//init Label Score parameters
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|MIN_LABEL_SCORE
argument_list|)
expr_stmt|;
name|Double
name|minLabelMatchFactor
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Number
condition|)
block|{
name|minLabelMatchFactor
operator|=
name|Double
operator|.
name|valueOf
argument_list|(
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|doubleValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|minLabelMatchFactor
operator|=
name|Double
operator|.
name|valueOf
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|MIN_LABEL_SCORE
argument_list|,
literal|"Parsed value '"
operator|+
name|value
operator|+
literal|"' is not an valid double!"
argument_list|)
throw|;
block|}
block|}
try|try
block|{
name|linkerConfig
operator|.
name|setMinLabelScore
argument_list|(
name|minLabelMatchFactor
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|MIN_LABEL_SCORE
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|MIN_TEXT_SCORE
argument_list|)
expr_stmt|;
name|Double
name|minTextMatchFactor
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Number
condition|)
block|{
name|minTextMatchFactor
operator|=
name|Double
operator|.
name|valueOf
argument_list|(
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|doubleValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|minTextMatchFactor
operator|=
name|Double
operator|.
name|valueOf
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|MIN_TEXT_SCORE
argument_list|,
literal|"Parsed value '"
operator|+
name|value
operator|+
literal|"' is not an valid double!"
argument_list|)
throw|;
block|}
block|}
try|try
block|{
name|linkerConfig
operator|.
name|setMinTextScore
argument_list|(
name|minTextMatchFactor
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|MIN_TEXT_SCORE
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|MIN_MATCH_FACTOR
argument_list|)
expr_stmt|;
name|Double
name|minMatchFactor
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Number
condition|)
block|{
name|minMatchFactor
operator|=
name|Double
operator|.
name|valueOf
argument_list|(
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|doubleValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|minMatchFactor
operator|=
name|Double
operator|.
name|valueOf
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|MIN_MATCH_FACTOR
argument_list|,
literal|"Parsed value '"
operator|+
name|value
operator|+
literal|"' is not an valid double!"
argument_list|)
throw|;
block|}
block|}
try|try
block|{
name|linkerConfig
operator|.
name|setMinMatchScore
argument_list|(
name|minMatchFactor
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|MIN_MATCH_FACTOR
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
comment|// init MIN_SEARCH_TOKEN_LENGTH
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|MIN_SEARCH_TOKEN_LENGTH
argument_list|)
expr_stmt|;
name|Integer
name|minSearchTokenLength
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Integer
condition|)
block|{
name|minSearchTokenLength
operator|=
operator|(
name|Integer
operator|)
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|minSearchTokenLength
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|MIN_SEARCH_TOKEN_LENGTH
argument_list|,
literal|"Values MUST be valid Integer values> 0"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|minSearchTokenLength
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|minSearchTokenLength
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|minSearchTokenLength
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|MIN_SEARCH_TOKEN_LENGTH
argument_list|,
literal|"Values MUST be valid Integer values> 0"
argument_list|)
throw|;
block|}
name|linkerConfig
operator|.
name|setMinSearchTokenLength
argument_list|(
name|minSearchTokenLength
argument_list|)
expr_stmt|;
block|}
comment|//init LEMMA_MATCHING_STATE
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|LEMMA_MATCHING_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Boolean
condition|)
block|{
name|linkerConfig
operator|.
name|setLemmaMatchingState
argument_list|(
operator|(
name|Boolean
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|linkerConfig
operator|.
name|setLemmaMatchingState
argument_list|(
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//init MAX_SEARCH_TOKENS
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|MAX_SEARCH_TOKENS
argument_list|)
expr_stmt|;
name|Integer
name|maxSearchTokens
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Integer
condition|)
block|{
name|maxSearchTokens
operator|=
operator|(
name|Integer
operator|)
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|maxSearchTokens
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|MAX_SEARCH_TOKENS
argument_list|,
literal|"Values MUST be valid Integer values> 0"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|maxSearchTokens
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|maxSearchTokens
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|maxSearchTokens
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|MAX_SEARCH_TOKENS
argument_list|,
literal|"Values MUST be valid Integer values> 0"
argument_list|)
throw|;
block|}
name|linkerConfig
operator|.
name|setMaxSearchTokens
argument_list|(
name|maxSearchTokens
argument_list|)
expr_stmt|;
block|}
comment|//init the MAX_SEARCH_TOKEN_DISTANCE
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|MAX_SEARCH_TOKEN_DISTANCE
argument_list|)
expr_stmt|;
name|Integer
name|maxSearchDistance
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Integer
condition|)
block|{
name|maxSearchDistance
operator|=
operator|(
name|Integer
operator|)
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|maxSearchDistance
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|MAX_SEARCH_TOKEN_DISTANCE
argument_list|,
literal|"Values MUST be valid Integer values> 0"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|maxSearchDistance
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|maxSearchDistance
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|maxSearchDistance
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|MAX_SEARCH_TOKEN_DISTANCE
argument_list|,
literal|"Values MUST be valid Integer values> 0"
argument_list|)
throw|;
block|}
name|linkerConfig
operator|.
name|setMaxSearchDistance
argument_list|(
name|maxSearchDistance
argument_list|)
expr_stmt|;
block|}
comment|//init the REDIRECT_PROCESSING_MODE
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|REDIRECT_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|linkerConfig
operator|.
name|setRedirectProcessingMode
argument_list|(
name|RedirectProcessingMode
operator|.
name|valueOf
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|REDIRECT_MODE
argument_list|,
literal|"Values MUST be one of "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|RedirectProcessingMode
operator|.
name|values
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|//init the DEFAULT_LANGUAGE
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|DEFAULT_MATCHING_LANGUAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|String
name|defaultLang
init|=
name|value
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
name|defaultLang
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|linkerConfig
operator|.
name|setDefaultLanguage
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|defaultLang
operator|.
name|length
argument_list|()
operator|==
literal|1
condition|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|DEFAULT_MATCHING_LANGUAGE
argument_list|,
literal|"Illegal language code '"
operator|+
name|defaultLang
operator|+
literal|"'! Language Codes MUST BE at least 2 chars long."
argument_list|)
throw|;
block|}
else|else
block|{
name|linkerConfig
operator|.
name|setDefaultLanguage
argument_list|(
name|defaultLang
argument_list|)
expr_stmt|;
block|}
block|}
comment|// init MIN_TOKEN_MATCH_FACTOR
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|MIN_TOKEN_SCORE
argument_list|)
expr_stmt|;
name|float
name|minTokenMatchFactor
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Number
condition|)
block|{
name|minTokenMatchFactor
operator|=
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|floatValue
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|minTokenMatchFactor
operator|=
name|Float
operator|.
name|valueOf
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|MIN_TOKEN_SCORE
argument_list|,
literal|"Unable to parse the minimum token match factor from the parsed value "
operator|+
name|value
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|minTokenMatchFactor
operator|<
literal|0
condition|)
block|{
name|minTokenMatchFactor
operator|=
name|EntityLinkerConfig
operator|.
name|DEFAULT_MIN_TOKEN_SCORE
expr_stmt|;
block|}
block|}
else|else
block|{
name|minTokenMatchFactor
operator|=
name|EntityLinkerConfig
operator|.
name|DEFAULT_MIN_TOKEN_SCORE
expr_stmt|;
block|}
if|if
condition|(
name|minTokenMatchFactor
operator|==
literal|0
operator|||
name|minTokenMatchFactor
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|MIN_TOKEN_SCORE
argument_list|,
literal|"The minimum token match factor MUST be> 0 and<= 1 (negative values for the default)"
argument_list|)
throw|;
block|}
name|linkerConfig
operator|.
name|setMinTokenMatchFactor
argument_list|(
name|minTokenMatchFactor
argument_list|)
expr_stmt|;
comment|//init type mappings
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|TYPE_MAPPINGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|String
index|[]
condition|)
block|{
comment|//support array
name|value
operator|=
name|Arrays
operator|.
name|asList
argument_list|(
operator|(
name|String
index|[]
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|String
condition|)
block|{
comment|//single value
name|value
operator|=
name|Collections
operator|.
name|singleton
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|instanceof
name|Collection
argument_list|<
name|?
argument_list|>
condition|)
block|{
comment|//and collection
name|log
operator|.
name|info
argument_list|(
literal|"Init Type Mappings"
argument_list|)
expr_stmt|;
name|configs
label|:
for|for
control|(
name|Object
name|o
operator|:
operator|(
name|Iterable
argument_list|<
name|?
argument_list|>
operator|)
name|value
control|)
block|{
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
name|StringBuilder
name|usage
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"useages: "
argument_list|)
decl_stmt|;
name|usage
operator|.
name|append
argument_list|(
literal|"a: '{uri}' short for {uri}> {uri} | "
argument_list|)
expr_stmt|;
name|usage
operator|.
name|append
argument_list|(
literal|"b: '{source1};{source2};..;{sourceN}> {target}'"
argument_list|)
expr_stmt|;
name|String
index|[]
name|config
init|=
name|o
operator|.
name|toString
argument_list|()
operator|.
name|split
argument_list|(
literal|">"
argument_list|)
decl_stmt|;
if|if
condition|(
name|config
index|[
literal|0
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Invalid Type Mapping Config '{}': Missing Source Type ({}) -> ignore this config"
argument_list|,
name|o
argument_list|,
name|usage
argument_list|)
expr_stmt|;
continue|continue
name|configs
continue|;
block|}
name|String
index|[]
name|sourceTypes
init|=
name|config
index|[
literal|0
index|]
operator|.
name|split
argument_list|(
literal|";"
argument_list|)
decl_stmt|;
if|if
condition|(
name|sourceTypes
operator|.
name|length
operator|>
literal|1
operator|&&
operator|(
name|config
operator|.
name|length
operator|<
literal|2
operator|||
name|config
index|[
literal|1
index|]
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Invalid Type Mapping Config '{}': Missing Target Type '{}' ({}) -> ignore this config"
argument_list|,
name|o
argument_list|,
name|usage
argument_list|)
expr_stmt|;
continue|continue
name|configs
continue|;
block|}
name|String
name|targetType
init|=
name|config
operator|.
name|length
operator|<
literal|2
condition|?
name|sourceTypes
index|[
literal|0
index|]
else|:
name|config
index|[
literal|1
index|]
decl_stmt|;
name|targetType
operator|=
name|getFullName
argument_list|(
name|targetType
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
comment|//support for ns:localName
try|try
block|{
comment|//validate
operator|new
name|URI
argument_list|(
name|targetType
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Invalid URI '{}' in Type Mapping Config '{}' -> ignore this config"
argument_list|,
name|sourceTypes
index|[
literal|0
index|]
argument_list|,
name|o
argument_list|)
expr_stmt|;
continue|continue
name|configs
continue|;
block|}
name|UriRef
name|targetUri
init|=
operator|new
name|UriRef
argument_list|(
name|targetType
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|sourceType
range|:
name|sourceTypes
control|)
block|{
if|if
condition|(
operator|!
name|sourceType
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|sourceType
operator|=
name|getFullName
argument_list|(
name|sourceType
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
comment|//support for ns:localName
try|try
block|{
comment|//validate
operator|new
name|URI
argument_list|(
name|sourceType
argument_list|)
expr_stmt|;
name|UriRef
name|old
init|=
name|linkerConfig
operator|.
name|setTypeMapping
argument_list|(
name|sourceType
argument_list|,
name|targetUri
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"> add type mapping {}> {}"
argument_list|,
name|sourceType
argument_list|,
name|targetType
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"> set type mapping {}> {} (old: {})"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|sourceType
block|,
name|targetType
block|,
name|old
operator|.
name|getUnicodeString
argument_list|()
block|}
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Invalid URI '{}' in Type Mapping Config '{}' -> ignore this source type"
argument_list|,
name|sourceTypes
index|[
literal|0
index|]
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"No Type mappings configured"
argument_list|)
expr_stmt|;
block|}
comment|//dereference entities
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|DEREFERENCE_ENTITIES
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Boolean
condition|)
block|{
name|linkerConfig
operator|.
name|setDereferenceEntitiesState
argument_list|(
operator|(
operator|(
name|Boolean
operator|)
name|value
operator|)
operator|.
name|booleanValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
operator|!
name|value
operator|.
name|toString
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|linkerConfig
operator|.
name|setDereferenceEntitiesState
argument_list|(
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|linkerConfig
operator|.
name|isDereferenceEntitiesEnabled
argument_list|()
condition|)
block|{
name|value
operator|=
name|configuration
operator|.
name|get
argument_list|(
name|DEREFERENCE_ENTITIES_FIELDS
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|String
index|[]
condition|)
block|{
for|for
control|(
name|String
name|field
range|:
operator|(
name|String
index|[]
operator|)
name|value
control|)
block|{
if|if
condition|(
name|field
operator|!=
literal|null
operator|&&
operator|!
name|field
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|linkerConfig
operator|.
name|getDereferencedFields
argument_list|()
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Collection
argument_list|<
name|?
argument_list|>
condition|)
block|{
for|for
control|(
name|Object
name|field
else|:
operator|(
name|Collection
argument_list|<
name|?
argument_list|>
operator|)
name|value
block|)
block|{
if|if
condition|(
name|field
operator|!=
literal|null
operator|&&
operator|!
name|field
operator|.
name|toString
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|linkerConfig
operator|.
name|getDereferencedFields
argument_list|()
operator|.
name|add
argument_list|(
name|field
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_class

begin_if
unit|} else
if|if
condition|(
name|value
operator|instanceof
name|String
condition|)
block|{
if|if
condition|(
operator|!
name|value
operator|.
name|toString
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|linkerConfig
operator|.
name|getDereferencedFields
argument_list|()
operator|.
name|add
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|DEREFERENCE_ENTITIES_FIELDS
argument_list|,
literal|"Dereference Entities_Fields MUST BE parsed as String[], Collection<String> or "
operator|+
literal|"String (single value). The actual value '"
operator|+
name|value
operator|+
literal|"'(type: '"
operator|+
name|value
operator|.
name|getClass
argument_list|()
operator|+
literal|"') is NOT supported"
argument_list|)
throw|;
block|}
else|else
block|{
comment|//value == null -> add the default fields
name|linkerConfig
operator|.
name|getDereferencedFields
argument_list|()
operator|.
name|addAll
argument_list|(
name|DEFAULT_DEREFERENCED_FIELDS
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
unit|}               }
comment|/**      * Getter for the uri of the field used for the names in the taxonomy      * (e.g. rdfs:label, skos:prefLabel). Needs to return the full URI      * @return the field used for the names of in the Taxonomy.      */
end_comment

begin_function
specifier|public
specifier|final
name|String
name|getNameField
parameter_list|()
block|{
return|return
name|nameField
return|;
block|}
end_function

begin_comment
comment|/**      * Setter for the uri of the field used for the names in the taxonomy      * (e.g. rdfs:label, skos:prefLabel).       * Converts short to full URIy by using the prefixes as registered in the      * {@link NamespaceEnum}.      * @param nameField the nameField to set      */
end_comment

begin_function
specifier|public
specifier|final
name|void
name|setNameField
parameter_list|(
name|String
name|nameField
parameter_list|)
block|{
name|this
operator|.
name|nameField
operator|=
name|NamespaceEnum
operator|.
name|getFullName
argument_list|(
name|nameField
argument_list|)
expr_stmt|;
name|__selectedFields
operator|=
literal|null
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * Getter for the dereferencedFields. This is a read- and write-able      * set that allows to configure the fields that should be dereferenced      * @return      */
end_comment

begin_function
specifier|public
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|getDereferencedFields
parameter_list|()
block|{
return|return
name|dereferencedFields
return|;
block|}
end_function

begin_comment
comment|/**      * The field used to follow redirects (typically rdf:seeAlso)      * @return the redirect field      */
end_comment

begin_function
specifier|public
specifier|final
name|String
name|getRedirectField
parameter_list|()
block|{
return|return
name|redirectField
return|;
block|}
end_function

begin_comment
comment|/**      * The field used to follow redirects (typically rdf:seeAlso)      * Converts short to full URIy by using the prefixes as registered in the      * {@link NamespaceEnum}.      * @param redirectField the redirectField to set      */
end_comment

begin_function
specifier|public
specifier|final
name|void
name|setRedirectField
parameter_list|(
name|String
name|redirectField
parameter_list|)
block|{
name|this
operator|.
name|redirectField
operator|=
name|NamespaceEnum
operator|.
name|getFullName
argument_list|(
name|redirectField
argument_list|)
expr_stmt|;
name|__selectedFields
operator|=
literal|null
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * The field used to lookup the types (typically rdf:type)      * @return the field name used to lookup types      */
end_comment

begin_function
specifier|public
specifier|final
name|String
name|getTypeField
parameter_list|()
block|{
return|return
name|typeField
return|;
block|}
end_function

begin_comment
comment|/**      * The field used to lookup the types (typically rdf:type)      * Converts short to full URIy by using the prefixes as registered in the      * {@link NamespaceEnum}.      * @param typeField the typeField to set      */
end_comment

begin_function
specifier|public
specifier|final
name|void
name|setTypeField
parameter_list|(
name|String
name|typeField
parameter_list|)
block|{
name|this
operator|.
name|typeField
operator|=
name|NamespaceEnum
operator|.
name|getFullName
argument_list|(
name|typeField
argument_list|)
expr_stmt|;
name|__selectedFields
operator|=
literal|null
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * The minimum number of character a {@link Token} (word) must have to be      * used {@link EntitySearcher#lookup(java.util.List, String...) lookup} concepts      * in the taxonomy. Note that this parameter is only used of no POS (Part-      * of-speech) tags are available in the {@link AnalysedText}.      * @param minSearchTokenLength the minSearchTokenLength to set      */
end_comment

begin_function
specifier|public
name|void
name|setMinSearchTokenLength
parameter_list|(
name|int
name|minSearchTokenLength
parameter_list|)
block|{
name|this
operator|.
name|minSearchTokenLength
operator|=
name|minSearchTokenLength
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * The minimum number of character a {@link Token} (word) must have to be      * used {@link EntitySearcher#lookup(java.util.List, String...) lookup} concepts      * in the taxonomy. Note that this parameter is only used of no POS (Part-      * of-speech) tags are available in the {@link AnalysedText}.      * @return the minSearchTokenLength      */
end_comment

begin_function
specifier|public
name|int
name|getMinSearchTokenLength
parameter_list|()
block|{
return|return
name|minSearchTokenLength
return|;
block|}
end_function

begin_comment
comment|/**      * Setter for the maximum number of suggestion returned.       * @param maxSuggestions the maxSuggestions to set      */
end_comment

begin_function
specifier|public
name|void
name|setMaxSuggestions
parameter_list|(
name|int
name|maxSuggestions
parameter_list|)
block|{
name|this
operator|.
name|maxSuggestions
operator|=
name|maxSuggestions
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * Getter for the maximum number of suggestion returned.       * @return the maxSuggestions      */
end_comment

begin_function
specifier|public
name|int
name|getMaxSuggestions
parameter_list|()
block|{
return|return
name|maxSuggestions
return|;
block|}
end_function

begin_comment
comment|/**      * Setter for the minimum number of Tokens (of the content) that MUST match      * with a {@link EntitySearcher#getNameField() label} of a       * {@link EntitySearcher#lookup(java.util.List, String...) concept of the taxonomy}      * so that it is {@link Suggestion suggested} even if the match is only      * {@link MATCH#PARTIAL}. Entities that match less than that are only included      * if a label is an {@link MATCH#EXACT EXACT} match with the current position      * in the text.       * @param minFoundTokens the minFoundTokens to set      */
end_comment

begin_function
specifier|public
name|void
name|setMinFoundTokens
parameter_list|(
name|int
name|minFoundTokens
parameter_list|)
block|{
name|this
operator|.
name|minFoundTokens
operator|=
name|minFoundTokens
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * Getter for the minimum number of Tokens (of the content) that MUST match      * with a {@link EntitySearcher#getNameField() label} of a       * {@link EntitySearcher#lookup(java.util.List, String...) concept of the taxonomy}      * so that it is {@link Suggestion suggested} even if the match is only      * {@link MATCH#PARTIAL}. Entities that match less than that are only included      * if a label is an {@link MATCH#EXACT EXACT} match with the current position      * in the text.       * @return the minFoundTokens      */
end_comment

begin_function
specifier|public
name|int
name|getMinFoundTokens
parameter_list|()
block|{
return|return
name|minFoundTokens
return|;
block|}
end_function

begin_comment
comment|/**      * Getter for the  maximum number of tokens parsed to       * {@link EntitySearcher#lookup(java.util.List, String...)}      * @return the maxSearchTokens      */
end_comment

begin_function
specifier|public
specifier|final
name|int
name|getMaxSearchTokens
parameter_list|()
block|{
return|return
name|maxSearchTokens
return|;
block|}
end_function

begin_comment
comment|/**      * The maximum number of tokens parsed to       * {@link EntitySearcher#lookup(java.util.List, String...)}. This is NOT the      * maximum number of Tokens mapped for Entities returned by such queries.<p>      * In case {@link Chunk}s are available in the parsed {@link AnalysedText}      * searches can be scoped by such chunks. However if no chunks are available,      * than this value is used to collect this number of words in the text.<p>      * The {@link #DEFAULT_MAX_SEARCH_TOKENS default value} of<code>2</code>      * should be ok in most cases.        * @param maxSearchTokens the maxSearchTokens to set      */
end_comment

begin_function
specifier|public
specifier|final
name|void
name|setMaxSearchTokens
parameter_list|(
name|int
name|maxSearchTokens
parameter_list|)
block|{
if|if
condition|(
name|maxSearchTokens
operator|==
literal|0
condition|)
block|{
name|this
operator|.
name|maxSearchTokens
operator|=
name|DEFAULT_MAX_SEARCH_TOKENS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|maxSearchTokens
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The maxSearchToken value MUST BE>= 0 (0 for setting the default)"
argument_list|)
throw|;
block|}
else|else
block|{
name|this
operator|.
name|maxSearchTokens
operator|=
name|maxSearchTokens
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**      * Getter for the case sensitive matching state      * @return the state      */
end_comment

begin_function
specifier|public
name|boolean
name|isCaseSensitiveMatching
parameter_list|()
block|{
return|return
name|caseSensitiveMatchingState
return|;
block|}
end_function

begin_comment
comment|/**      * Setter for the case sensitive matching state      * @param caseSensitiveMatchingState the state      */
end_comment

begin_function
specifier|public
name|void
name|setCaseSensitiveMatchingState
parameter_list|(
name|boolean
name|state
parameter_list|)
block|{
name|this
operator|.
name|caseSensitiveMatchingState
operator|=
name|state
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * Removes the mapping for the parsed concept type      * @param conceptType the concept type to remove the mapping      * @return the previously mapped dc:type value or<code>null</code> if      * no mapping for the parsed concept type was present      */
end_comment

begin_function
specifier|public
name|UriRef
name|removeTypeMapping
parameter_list|(
name|String
name|conceptType
parameter_list|)
block|{
return|return
name|typeMappings
operator|.
name|remove
argument_list|(
name|conceptType
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**      *       * @param conceptType the type of the concept or<code>null</code> to      * add the default dc:type mapping. See also {@link #setDefaultDcType(UriRef)}      * @param dcType the dc:type for the parsed concept type      * @return the previously mapped dc:type value if an existing mapping      * was updated or<code>null</code> if a new mapping was added.      */
end_comment

begin_function
specifier|public
name|UriRef
name|setTypeMapping
parameter_list|(
name|String
name|conceptType
parameter_list|,
name|UriRef
name|dcType
parameter_list|)
block|{
if|if
condition|(
name|dcType
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed dc:type URI MUST NOT be NULL!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|conceptType
operator|==
literal|null
condition|)
block|{
comment|//handle setting of the default dc:type value
name|UriRef
name|oldDefault
init|=
name|getDefaultDcType
argument_list|()
decl_stmt|;
name|setDefaultDcType
argument_list|(
name|dcType
argument_list|)
expr_stmt|;
return|return
name|oldDefault
return|;
block|}
return|return
name|typeMappings
operator|.
name|put
argument_list|(
name|conceptType
argument_list|,
name|dcType
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**      * Setter for the default dc:type of linked entities if for none of the      * types of the suggestions a {@link #getTypeMappings()} exists. Set this      * to<code>null</code> to specify that no dc:type should be set in such      * cases.      * @param defaultDcType the defaultDcType to set      */
end_comment

begin_function
specifier|public
name|void
name|setDefaultDcType
parameter_list|(
name|UriRef
name|defaultDcType
parameter_list|)
block|{
name|this
operator|.
name|defaultDcType
operator|=
name|defaultDcType
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * The default type for Entities if no {@link #getTypeMappings() type mapping}      * is present.<code>null</code> means that no type should be set if no      * explicit mapping exists      * @return the defaultDcType      */
end_comment

begin_function
specifier|public
name|UriRef
name|getDefaultDcType
parameter_list|()
block|{
return|return
name|defaultDcType
return|;
block|}
end_function

begin_comment
comment|/**      * Setter for the mode on how to deal with redirects      * @param redirectProcessingMode the redirectProcessingMode to set      */
end_comment

begin_function
specifier|public
name|void
name|setRedirectProcessingMode
parameter_list|(
name|RedirectProcessingMode
name|redirectProcessingMode
parameter_list|)
block|{
name|this
operator|.
name|redirectProcessingMode
operator|=
name|redirectProcessingMode
expr_stmt|;
name|__selectedFields
operator|=
literal|null
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * Getter for the mode how to deal with redirects      * @return the redirectProcessingMode      */
end_comment

begin_function
specifier|public
name|RedirectProcessingMode
name|getRedirectProcessingMode
parameter_list|()
block|{
return|return
name|redirectProcessingMode
return|;
block|}
end_function

begin_comment
comment|/**      * Getter for the read only mappings of type mappings      * @return the type mappings (read only)      */
end_comment

begin_function
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|UriRef
argument_list|>
name|getTypeMappings
parameter_list|()
block|{
return|return
name|unmodTypeMappings
return|;
block|}
end_function

begin_comment
comment|/**      * Setter for the language of labels searched in addition to the current      * language of the text. Setting this to<code>null</code> (also the default)      * will cause to search labels without any defined language.<p>      * Changing this makes only sense if a dataset (such as dbpedia.org) adds      * language tags to labels even if they are typically used in any language.      * @param defaultLanguage the default language      */
end_comment

begin_function
specifier|public
name|void
name|setDefaultLanguage
parameter_list|(
name|String
name|defaultLanguage
parameter_list|)
block|{
name|this
operator|.
name|defaultLanguage
operator|=
name|defaultLanguage
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * Getter for the language of labels searched in addition to the current      * language of the text.      * @return the default language       */
end_comment

begin_function
specifier|public
name|String
name|getDefaultLanguage
parameter_list|()
block|{
return|return
name|defaultLanguage
return|;
block|}
end_function

begin_comment
comment|/**      * Getter for the maximum number of non-processable tokens that are       * allowed to not match before no further tokens are matched against a label       * of an Entity.<p>      * This allows e.g. to match "Dr. Richard Dogles" with "Dr Richard Dogles"      * as '.' is a non-processable token in the text that is missing in the      * label.      * @return the maxNotFound      */
end_comment

begin_function
specifier|public
name|int
name|getMaxNotFound
parameter_list|()
block|{
return|return
name|maxNotFound
return|;
block|}
end_function

begin_comment
comment|/**      * Setter for the maximum number of non-processable tokens that are       * allowed to not match before no further tokens are matched against a label       * of an Entity.<p>      * This allows e.g. to match "Dr. Richard Dogles" with "Dr Richard Dogles"      * as '.' is a non-processable token in the text that is missing in the      * label.      * @param maxNotFound the maxNotFound to set      */
end_comment

begin_function
specifier|public
name|void
name|setMaxNotFound
parameter_list|(
name|int
name|maxNotFound
parameter_list|)
block|{
if|if
condition|(
name|maxNotFound
operator|<
literal|0
condition|)
block|{
name|this
operator|.
name|maxNotFound
operator|=
name|DEFAULT_MAX_NOT_FOUND
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|maxNotFound
operator|=
name|maxNotFound
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**      * Getter for the minimum token match Factor.      * If Tokens match is determined by comparing them using some algorithm.      * Results need to be in the range [0..1]. This factor defines the minimum      * similarity value so that a match is assumed. Not that this factor only      * is used for filtering out non-matching tokens. The similarity value will      * still used for calculating the confidence      * @return the minTokenMatchFactor      */
end_comment

begin_function
specifier|public
name|float
name|getMinTokenMatchFactor
parameter_list|()
block|{
return|return
name|minTokenMatchFactor
return|;
block|}
end_function

begin_comment
comment|/**      * Setter for the minimum token match Factor.      * If Tokens match is determined by comparing them using some algorithm.      * Results need to be in the range [0..1]. This factor defines the minimum      * similarity value so that a match is assumed. Not that this factor only      * is used for filtering out non-matching tokens. The similarity value will      * still used for calculating the confidence      * @param minTokenMatchFactor the minTokenMatchFactor to set      */
end_comment

begin_function
specifier|public
name|void
name|setMinTokenMatchFactor
parameter_list|(
name|float
name|minTokenMatchFactor
parameter_list|)
block|{
if|if
condition|(
name|minTokenMatchFactor
operator|<
literal|0
condition|)
block|{
name|this
operator|.
name|minTokenMatchFactor
operator|=
name|DEFAULT_MIN_TOKEN_SCORE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|minTokenMatchFactor
operator|==
literal|0
operator|||
name|minTokenMatchFactor
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"minimum Token Match Facter MUST be> 0<= 1 (parsed: "
operator|+
name|minTokenMatchFactor
operator|+
literal|")!"
argument_list|)
throw|;
block|}
else|else
block|{
name|this
operator|.
name|minTokenMatchFactor
operator|=
name|minTokenMatchFactor
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**      * Getter for the maximum distance tokens are      * considered to be used (in addition to the currently processed on)      * for searches of Entities.      * @return the maximum search token distance      */
end_comment

begin_function
specifier|public
name|int
name|getMaxSearchDistance
parameter_list|()
block|{
return|return
name|maxSearchDistance
return|;
block|}
end_function

begin_comment
comment|/**     /**      * Getter for the maximum distance tokens are      * considered to be used (in addition to the currently processed on)      * for searches of Entities.      * @param maxSearchDistance the maximum search token distance. If      * values&lt;= 0 are parsed the value is set to      *  {@link #DEFAULT_MAX_SEARCH_DISTANCE}      */
end_comment

begin_function
specifier|public
name|void
name|setMaxSearchDistance
parameter_list|(
name|int
name|maxSearchDistance
parameter_list|)
block|{
if|if
condition|(
name|maxSearchDistance
operator|<=
literal|0
condition|)
block|{
name|maxSearchDistance
operator|=
name|DEFAULT_MAX_SEARCH_DISTANCE
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|maxSearchDistance
operator|=
name|maxSearchDistance
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|public
name|boolean
name|isLemmaMatching
parameter_list|()
block|{
return|return
name|lemmaMatchingState
return|;
block|}
end_function

begin_function
specifier|public
name|void
name|setLemmaMatchingState
parameter_list|(
name|Boolean
name|lemmaMatchingState
parameter_list|)
block|{
if|if
condition|(
name|lemmaMatchingState
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|lemmaMatchingState
operator|=
name|DEFAULT_LEMMA_MATCHING_STATE
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|lemmaMatchingState
operator|=
name|lemmaMatchingState
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**      * The minimum LabelScore required to suggest an Entity.<p>      * The "Label Score" [0..1] represents how much of the      * Label of an Entity matches with the Text. It compares the number      * of Tokens of the Label with the number of Tokens matched to the      * Text. Not exact matches for Tokens, or if the Tokens within the       * label do appear in an other order than in the text do also       * reduce this score.      * @return the minimum required LabelScore      */
end_comment

begin_function
specifier|public
name|double
name|getMinLabelScore
parameter_list|()
block|{
return|return
name|minLabelScore
return|;
block|}
end_function

begin_comment
comment|/**      * Setter for the minimum label score for suggested entities      * @param score the score [0..1] or<code>null</code> to reset      * to the default.      */
end_comment

begin_function
specifier|public
name|void
name|setMinLabelScore
parameter_list|(
name|Double
name|score
parameter_list|)
block|{
if|if
condition|(
name|score
operator|==
literal|null
condition|)
block|{
name|minLabelScore
operator|=
name|DEFAULT_MIN_LABEL_SCORE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|score
operator|>
literal|1
operator|||
name|score
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed MinLabelScore '"
operator|+
name|score
operator|+
literal|"' MUST BE in the range [0..1]!"
argument_list|)
throw|;
block|}
else|else
block|{
name|minLabelScore
operator|=
name|score
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**      * The minimum Text Score required to suggest an Entity.<p>      * The "Text Score" [0..1] represents how well the      * Label of an Entity matches to the selected Span in the Text.      * It compares the number of matched {@link Token} from      * the label with the number of Tokens enclosed by the Span      * in the Text an Entity is suggested for. Not exact matches       * for Tokens, or if the Tokens within the label do appear in      * an other order than in the text do also reduce this score      * @return the minimum required Text Score for labels of suggested      * Entities      */
end_comment

begin_function
specifier|public
name|double
name|getMinTextScore
parameter_list|()
block|{
return|return
name|minTextScore
return|;
block|}
end_function

begin_comment
comment|/**      * Setter for the minimum text score for suggested entities      * @param score the score [0..1] or<code>null</code> to reset      * to the default.      */
end_comment

begin_function
specifier|public
name|void
name|setMinTextScore
parameter_list|(
name|Double
name|score
parameter_list|)
block|{
if|if
condition|(
name|score
operator|==
literal|null
condition|)
block|{
name|minTextScore
operator|=
name|DEFAULT_MIN_TEXT_SCORE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|score
operator|>
literal|1
operator|||
name|score
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed MinTextScore '"
operator|+
name|score
operator|+
literal|"' MUST BE in the range [0..1]!"
argument_list|)
throw|;
block|}
else|else
block|{
name|minTextScore
operator|=
name|score
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**      * Getter for the minimum match Score of Entity labels against the      * Text.<p>      * This is the product of the {@link #getMinLabelScore()} with the      * {@link #getMinTextScore()} - meaning that this value represents      * both how well the label matches the text and how much of the      * label is matched with the text.      * @return      */
end_comment

begin_function
specifier|public
name|double
name|getMinMatchScore
parameter_list|()
block|{
return|return
name|minMatchScore
return|;
block|}
end_function

begin_comment
comment|/**      * Setter for the minimum text score for suggested entities      * @param score the score [0..1] or<code>null</code> to reset      * to the default.      */
end_comment

begin_function
specifier|public
name|void
name|setMinMatchScore
parameter_list|(
name|Double
name|score
parameter_list|)
block|{
if|if
condition|(
name|score
operator|==
literal|null
condition|)
block|{
name|minMatchScore
operator|=
name|DEFAULT_MIN_MATCH_SCORE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|score
operator|>
literal|1
operator|||
name|score
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed MinMatchScore '"
operator|+
name|score
operator|+
literal|"' MUST BE in the range [0..1]!"
argument_list|)
throw|;
block|}
else|else
block|{
name|minMatchScore
operator|=
name|score
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**      * Setter for the dereference entities state.      * @param state the state or<code>null</code> to set the      * default.      */
end_comment

begin_function
specifier|public
name|void
name|setDereferenceEntitiesState
parameter_list|(
name|Boolean
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|dereferenceEntitiesState
operator|=
name|DEFAULT_DEREFERENCE_ENTITIES_STATE
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|dereferenceEntitiesState
operator|=
name|state
expr_stmt|;
block|}
name|__selectedFields
operator|=
literal|null
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * Getter for the dereference entities state      * @return<code>true</code> if enabled otherwise<code>false</code>      */
end_comment

begin_function
specifier|public
name|boolean
name|isDereferenceEntitiesEnabled
parameter_list|()
block|{
return|return
name|dereferenceEntitiesState
return|;
block|}
end_function

begin_comment
comment|/**      * Getter for all fields that need to be selected based on the      * current EntityLinker configuration. This includes<ul>      *<li> {@link #getNameField()}      *<li> {@link #getTypeField()}      *<li> {@link #getRedirectField()} if {@link #getRedirectProcessingMode()}       * != {@link RedirectProcessingMode#IGNORE}      *<li> {@link #getDereferencedFields()} if {@link #isDereferenceEntitiesEnabled()}      *</ul>      * @return the selected fields for queries against the linked vocabulary.      */
end_comment

begin_function
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getSelectedFields
parameter_list|()
block|{
if|if
condition|(
name|__selectedFields
operator|==
literal|null
condition|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|fields
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|fields
operator|.
name|add
argument_list|(
name|nameField
argument_list|)
expr_stmt|;
name|fields
operator|.
name|add
argument_list|(
name|typeField
argument_list|)
expr_stmt|;
if|if
condition|(
name|redirectProcessingMode
operator|!=
name|RedirectProcessingMode
operator|.
name|IGNORE
condition|)
block|{
name|fields
operator|.
name|add
argument_list|(
name|redirectField
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dereferenceEntitiesState
condition|)
block|{
name|fields
operator|.
name|addAll
argument_list|(
name|dereferencedFields
argument_list|)
expr_stmt|;
block|}
name|__selectedFields
operator|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|fields
argument_list|)
expr_stmt|;
return|return
name|__selectedFields
return|;
block|}
else|else
block|{
return|return
name|__selectedFields
return|;
block|}
block|}
end_function

unit|}
end_unit

