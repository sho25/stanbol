begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|engines
operator|.
name|taxonomy
operator|.
name|impl
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|clerezza
operator|.
name|rdf
operator|.
name|core
operator|.
name|UriRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|OntologicalClasses
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|enhancer
operator|.
name|servicesapi
operator|.
name|rdf
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|model
operator|.
name|Representation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|stanbol
operator|.
name|entityhub
operator|.
name|servicesapi
operator|.
name|site
operator|.
name|ReferencedSite
import|;
end_import

begin_comment
comment|/**  * Holds information about suggestions created by the {@link TaxonomyLinkingEngine}.  * used to perform local lookups for queries that would be normally executed  * on the {@link ReferencedSite}  * @author Rupert Westenthaler  *  */
end_comment

begin_class
class|class
name|Suggestion
implements|implements
name|Comparable
argument_list|<
name|Suggestion
argument_list|>
block|{
specifier|private
specifier|final
name|UriRef
name|textAnnotation
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|UriRef
argument_list|>
name|textAnnotationTypes
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|UriRef
argument_list|>
name|linkedTextAnnotations
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|UriRef
argument_list|>
name|unmodLinked
decl_stmt|;
specifier|private
specifier|final
name|String
name|searchString
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|Representation
argument_list|>
name|suggestions
decl_stmt|;
specifier|public
name|Suggestion
parameter_list|(
name|String
name|searchString
parameter_list|,
name|UriRef
name|textAnnotation
parameter_list|,
name|List
argument_list|<
name|Representation
argument_list|>
name|suggestions
parameter_list|,
name|Set
argument_list|<
name|UriRef
argument_list|>
name|textAnnotationTypes
parameter_list|)
block|{
if|if
condition|(
name|searchString
operator|==
literal|null
operator|||
name|searchString
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The search string MUST NOT be NULL nor emtpy"
argument_list|)
throw|;
block|}
if|if
condition|(
name|textAnnotation
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed UriRef of the textAnnotation MUST NOT be NULL nor empty"
argument_list|)
throw|;
block|}
if|if
condition|(
name|suggestions
operator|==
literal|null
operator|||
name|suggestions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed list of suggestions MUST NOT be NULL nor empty"
argument_list|)
throw|;
block|}
if|if
condition|(
name|suggestions
operator|.
name|contains
argument_list|(
literal|null
argument_list|)
condition|)
block|{
comment|//test for NULL element, because this will cause NPE later on that would
comment|//be hard to debug!
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parsed list of suggestions MUST NOT contain the NULL element"
argument_list|)
throw|;
block|}
name|this
operator|.
name|searchString
operator|=
name|searchString
expr_stmt|;
name|this
operator|.
name|textAnnotation
operator|=
name|textAnnotation
expr_stmt|;
name|this
operator|.
name|suggestions
operator|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|Representation
argument_list|>
argument_list|(
name|suggestions
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|linkedTextAnnotations
operator|=
operator|new
name|HashSet
argument_list|<
name|UriRef
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|unmodLinked
operator|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|linkedTextAnnotations
argument_list|)
expr_stmt|;
if|if
condition|(
name|textAnnotationTypes
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|textAnnotationTypes
operator|=
name|Collections
operator|.
name|emptySet
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|textAnnotationTypes
operator|=
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
operator|new
name|HashSet
argument_list|<
name|UriRef
argument_list|>
argument_list|(
name|textAnnotationTypes
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
specifier|final
name|UriRef
name|getTextAnnotation
parameter_list|()
block|{
return|return
name|textAnnotation
return|;
block|}
comment|/**      * Returns an unmodifiable set containing all the other Text annotations      * for the same {@link #getSearchString() search string}.      * @return the linked text annotations (read only)      */
specifier|public
specifier|final
name|Set
argument_list|<
name|UriRef
argument_list|>
name|getLinkedTextAnnotations
parameter_list|()
block|{
return|return
name|unmodLinked
return|;
block|}
specifier|public
specifier|final
name|boolean
name|addLinked
parameter_list|(
name|UriRef
name|textAnnotation
parameter_list|)
block|{
if|if
condition|(
name|textAnnotation
operator|!=
literal|null
condition|)
block|{
return|return
name|linkedTextAnnotations
operator|.
name|add
argument_list|(
name|textAnnotation
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
specifier|public
specifier|final
name|boolean
name|removeLinked
parameter_list|(
name|UriRef
name|textAnnotation
parameter_list|)
block|{
return|return
name|linkedTextAnnotations
operator|.
name|remove
argument_list|(
name|textAnnotation
argument_list|)
return|;
block|}
comment|/**      * Getter for the search string used to calculate the suggestions      * @return the search string      */
specifier|public
specifier|final
name|String
name|getSearchString
parameter_list|()
block|{
return|return
name|searchString
return|;
block|}
comment|/**      * Getter for the Representations suggested for the       * {@link #getSearchString() search string}      * @return the suggestions (read only)      */
specifier|public
specifier|final
name|List
argument_list|<
name|Representation
argument_list|>
name|getSuggestions
parameter_list|()
block|{
return|return
name|suggestions
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|searchString
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|o
operator|instanceof
name|Suggestion
operator|&&
operator|(
operator|(
name|Suggestion
operator|)
name|o
operator|)
operator|.
name|searchString
operator|.
name|equals
argument_list|(
name|searchString
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|compareTo
parameter_list|(
name|Suggestion
name|o
parameter_list|)
block|{
return|return
name|searchString
operator|.
name|compareTo
argument_list|(
name|o
operator|.
name|searchString
argument_list|)
return|;
block|}
comment|/**      * Getter for the values of the {@link Properties#DC_TYPE dc:type}  property of the      * TextAnnotation. This types need to be used      * for additional TextAnnotations linked to the one returned by      * {@link #getTextAnnotation()}      * @return the @link Properties#DC_TYPE dc:type} values of the      * {@link #getTextAnnotation() TextAnnotation}.      */
specifier|public
name|Set
argument_list|<
name|UriRef
argument_list|>
name|getTextAnnotationTypes
parameter_list|()
block|{
return|return
name|textAnnotationTypes
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|suggestedIds
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|suggestions
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Representation
name|rep
range|:
name|suggestions
control|)
block|{
name|suggestedIds
operator|.
name|add
argument_list|(
name|rep
operator|==
literal|null
condition|?
literal|null
else|:
name|rep
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|String
operator|.
name|format
argument_list|(
literal|"Suggestion: %s -> %s"
argument_list|,
name|searchString
argument_list|,
name|suggestedIds
argument_list|)
return|;
block|}
block|}
end_class

end_unit

